"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_real-pdf-parser_ts"],{

/***/ "(app-pages-browser)/./lib/real-pdf-parser.ts":
/*!********************************!*\
  !*** ./lib/real-pdf-parser.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractCoursesFromText: function() { return /* binding */ extractCoursesFromText; },\n/* harmony export */   extractTextFromPDF: function() { return /* binding */ extractTextFromPDF; }\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n// Real PDF parsing implementation\n// This would use actual PDF parsing libraries to extract text from uploaded PDFs\n// Real PDF text extraction using pdf-parse library\nasync function extractTextFromPDF(file) {\n    try {\n        console.log(\"\\uD83D\\uDCC4 Extracting text from PDF: \".concat(file.name));\n        // REAL PDF PARSING - Extract actual content from uploaded PDF\n        console.log(\"\\uD83D\\uDCC4 Parsing actual PDF content from: \".concat(file.name));\n        console.log(\"\\uD83D\\uDCC4 File size: \".concat(file.size, \" bytes\"));\n        // Use a more reliable PDF parsing approach\n        try {\n            const arrayBuffer = await file.arrayBuffer();\n            console.log(\"\\uD83D\\uDCC4 PDF file size: \".concat(arrayBuffer.byteLength, \" bytes\"));\n            // Try multiple PDF parsing approaches\n            let extractedText = \"\";\n            let pageCount = 1;\n            // Approach 1: Try pdfjs-dist with optimized settings\n            try {\n                const pdfjsLib = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pdfjs-dist_build_pdf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! pdfjs-dist */ \"(app-pages-browser)/./node_modules/pdfjs-dist/build/pdf.mjs\"));\n                // Use a more reliable worker source\n                pdfjsLib.GlobalWorkerOptions.workerSrc = \"https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js\";\n                const pdf = await pdfjsLib.getDocument({\n                    data: arrayBuffer,\n                    useWorkerFetch: false,\n                    isEvalSupported: false,\n                    useSystemFonts: true,\n                    disableFontFace: true,\n                    disableRange: true,\n                    disableStream: true\n                }).promise;\n                console.log(\"\\uD83D\\uDCC4 PDF loaded: \".concat(pdf.numPages, \" pages\"));\n                pageCount = pdf.numPages;\n                // Extract text from all pages with enhanced table format support\n                for(let pageNum = 1; pageNum <= pdf.numPages; pageNum++){\n                    try {\n                        const page = await pdf.getPage(pageNum);\n                        const textContent = await page.getTextContent();\n                        // Enhanced text extraction for table formats\n                        const pageText = textContent.items.map((item)=>{\n                            // Preserve line breaks and spacing for table formats\n                            if (item.hasEOL) {\n                                return item.str + \"\\n\";\n                            }\n                            return item.str + \" \";\n                        }).join(\"\").replace(/\\s+/g, \" \") // Normalize whitespace\n                        .replace(/\\n\\s+/g, \"\\n\") // Clean up line breaks\n                        ;\n                        extractedText += pageText + \"\\n\";\n                    } catch (pageError) {\n                        console.warn(\"⚠️ Could not extract text from page \".concat(pageNum, \":\"), pageError);\n                    }\n                }\n                console.log(\"✅ Successfully extracted text from \".concat(pdf.numPages, \" pages\"));\n            } catch (pdfjsError) {\n                console.warn(\"⚠️ pdfjs-dist failed, trying alternative approach:\", pdfjsError);\n                // Approach 2: Try using a different PDF parsing library\n                try {\n                    // Use pdf-parse as a fallback (if available)\n                    const pdfParse = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pdf-parse_index_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! pdf-parse */ \"(app-pages-browser)/./node_modules/pdf-parse/index.js\", 23));\n                    const buffer = Buffer.from(arrayBuffer);\n                    const data = await pdfParse.default(buffer);\n                    extractedText = data.text;\n                    pageCount = data.numpages;\n                    console.log(\"✅ Successfully extracted text using pdf-parse\");\n                } catch (pdfParseError) {\n                    console.warn(\"⚠️ pdf-parse failed, trying basic text extraction:\", pdfParseError);\n                    // Approach 3: Basic text extraction as last resort\n                    const text = await new Promise((resolve, reject)=>{\n                        const reader = new FileReader();\n                        reader.onload = (e)=>{\n                            var _e_target;\n                            const result = (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.result;\n                            resolve(result || \"\");\n                        };\n                        reader.onerror = ()=>reject(new Error(\"Failed to read PDF file\"));\n                        reader.readAsText(file);\n                    });\n                    extractedText = text;\n                    console.log(\"✅ Using basic text extraction\");\n                }\n            }\n            console.log(\"\\uD83D\\uDCC4 Extracted text length: \".concat(extractedText.length, \" characters\"));\n            console.log(\"\\uD83D\\uDCC4 Text preview: \".concat(extractedText.substring(0, 200), \"...\"));\n            // If no text was extracted, throw an error instead of using hardcoded data\n            if (extractedText.length === 0) {\n                throw new Error(\"No text could be extracted from the PDF. Please try a different PDF file.\");\n            }\n            // If extracted text looks corrupted, throw an error\n            if (extractedText.includes(\"endstream\") || extractedText.includes(\"endobj\") || extractedText.includes(\"xref\")) {\n                throw new Error(\"PDF appears to be corrupted or encrypted. Please try a different PDF file.\");\n            }\n            return {\n                text: extractedText,\n                pages: pageCount,\n                metadata: {\n                    title: file.name.replace(\".pdf\", \"\"),\n                    author: \"Unknown\",\n                    creationDate: new Date().toISOString()\n                }\n            };\n        } catch (error) {\n            console.error(\"❌ All PDF parsing methods failed:\", error);\n            throw new Error(\"Failed to parse PDF: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    } catch (error) {\n        console.error(\"❌ Error extracting text from PDF:\", error);\n        throw error;\n    }\n}\n// Enhanced course extraction with multiple patterns\nfunction extractCoursesFromText(text) {\n    const courses = [];\n    console.log(\"\\uD83D\\uDD0D Extracting courses from PDF text...\");\n    console.log(\"\\uD83D\\uDCC4 Text length: \".concat(text.length, \" characters\"));\n    console.log(\"\\uD83D\\uDCC4 Text preview: \".concat(text.substring(0, 500), \"...\"));\n    // Comprehensive patterns to extract Course Title and Credits from ANY table format PDF\n    const patterns = [\n        // Pattern 1: \"Course Title: [Title]\" followed by \"Credits: [Number]\"\n        /Course Title:\\s*([^\\n\\r]+)\\s*[\\n\\r]+Credits:\\s*(\\d+)/gi,\n        // Pattern 2: \"Course Title: [Title]\" and \"Credits: [Number]\" on separate lines\n        /Course Title:\\s*([^\\n\\r]+).*?Credits:\\s*(\\d+)/gi,\n        // Pattern 3: Table format with title and credits\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s+(\\d+)\\s*credits?/gi,\n        // Pattern 4: Numbered courses \"1. [Title] ([Code]) - [Credits] credits\"\n        /(\\d+)\\.\\s*([^(]+?)\\s*\\(([^)]+)\\)\\s*[-\\s]*(\\d+)\\s*credits?/gi,\n        // Pattern 5: Generic course format \"[Title] - [Credits] Credits\"\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s*-\\s*(\\d+)\\s*Credits?/gi,\n        // Pattern 6: Course name followed by credits in parentheses\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s*\\((\\d+)\\s*credits?\\)/gi,\n        // Pattern 7: Simple format \"Subject Name Credits: X\"\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s+Credits:\\s*(\\d+)/gi,\n        // Pattern 8: Course name with credits at end of line\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s+(\\d+)\\s*$/gm,\n        // Pattern 9: Course name followed by credits (space separated)\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s+(\\d+)\\s*credits?/gi,\n        // Pattern 10: Course name with credits after colon\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?):\\s*(\\d+)/gi,\n        // Pattern 11: Table format - Course title followed by credits (for VI Semester format)\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s+(\\d+)\\s*$/gm,\n        // Pattern 12: Course title with credits in table format\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s+(\\d+)\\s*$/gm,\n        // Pattern 13: Generic course pattern (removed hardcoded course names)\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{4,})\\s+(\\d+)/gi,\n        // Pattern 14: Course titles with credits (space separated)\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{2,})\\s+(\\d+)\\s*$/gm,\n        // Pattern 15: Very broad pattern for any text followed by number\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{1,})\\s+(\\d+)/gi,\n        // Pattern 16: Table row format - Course name with credits (enhanced for table formats)\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{3,})\\s+(\\d+)\\s*$/gm,\n        // Pattern 17: Course name with credits (tab or space separated)\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{3,})\\s+(\\d+)\\s*$/gm,\n        // Pattern 18: Course name with credits (multiple spaces)\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{3,})\\s+(\\d+)\\s*$/gm,\n        // Pattern 19: Course name with credits (end of line)\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{3,})\\s+(\\d+)\\s*$/gm,\n        // Pattern 20: Course name with credits (any format)\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{3,})\\s+(\\d+)/gi\n    ];\n    patterns.forEach((pattern, patternIndex)=>{\n        console.log(\"\\uD83D\\uDD0D Trying pattern \".concat(patternIndex + 1, \": \").concat(pattern));\n        const matches = Array.from(text.matchAll(pattern));\n        console.log(\"\\uD83D\\uDCDA Found \".concat(matches.length, \" matches with pattern \").concat(patternIndex + 1));\n        matches.forEach((match, index)=>{\n            let courseTitle;\n            let credits;\n            // Handle different match patterns\n            if (patternIndex === 3) {\n                // Pattern 4: Numbered courses with course code \"1. [Title] ([Code]) - [Credits] credits\"\n                courseTitle = match[2].trim();\n                credits = parseInt(match[4]);\n            } else {\n                // All other patterns\n                courseTitle = match[1].trim();\n                credits = parseInt(match[2]);\n            }\n            // Clean up course title (remove extra whitespace, special characters)\n            courseTitle = courseTitle.replace(/\\s+/g, \" \").trim();\n            // Focused filtering for course titles and credits only\n            const skipPatterns = [\n                /^total/i,\n                /^tota/i,\n                /^credits?$/i,\n                /^course/i,\n                /^title/i,\n                /^semester/i,\n                /^syllabus/i,\n                /^page/i,\n                /^chapter/i,\n                /^section/i,\n                /^table/i,\n                /^figure/i,\n                /^appendix/i,\n                /^reference/i,\n                /^bibliography/i,\n                /^index/i,\n                /^contents/i,\n                /^abstract/i,\n                /^introduction/i,\n                /^conclusion/i,\n                /^\\d+$/,\n                /^[a-z]$/i,\n                /^[^a-zA-Z]*$/,\n                /^[^a-zA-Z]*[a-zA-Z]{1,2}[^a-zA-Z]*$/,\n                /^[A-Z]{1,3}$/,\n                /^\\d+[a-zA-Z]?$/,\n                /^[^a-zA-Z]*$/,\n                /^.{1,2}$/,\n                /^[^a-zA-Z]*[a-zA-Z]{1,2}[^a-zA-Z]*$/,\n                /^vi\\s+semester/i,\n                /^sl\\.?\\s*no/i,\n                /^teaching\\s+hours/i,\n                /^examination/i,\n                /^total\\s+teaching/i,\n                /^total\\s+examination/i,\n                /^total\\s+credits/i,\n                /endstream/i,\n                /endobj/i,\n                /xref/i,\n                /^R\\s*\\/Info/i,\n                /^stream/i,\n                /^obj/i,\n                /^startxref/i,\n                /^trailer/i // Skip PDF corruption text\n            ];\n            const shouldSkip = skipPatterns.some((pattern)=>pattern.test(courseTitle));\n            // Enhanced validation for course titles and credits (works with any table format)\n            const isValidCourse = courseTitle && courseTitle.length >= 3 && // Minimum 3 characters\n            !isNaN(credits) && credits >= 0 && credits <= 20 && // Allow up to 20 credits\n            !shouldSkip && // Course title must be a valid course name\n            /[a-zA-Z]/.test(courseTitle) && // Must contain letters\n            courseTitle.split(\" \").length >= 1 && // Must have at least 1 word (flexible for short courses)\n            !courseTitle.match(/^\\d+/) && // Must not start with number\n            !courseTitle.match(/^[^a-zA-Z]/) && // Must start with letter\n            !courseTitle.includes(\"VI SEMESTER\") && // Skip if contains header\n            !courseTitle.match(/^[A-Z]{1,3}\\s+[A-Z]{1,3}$/) && // Skip short acronyms\n            !courseTitle.includes(\"endstream\") && // Skip PDF corruption\n            !courseTitle.includes(\"endobj\") && // Skip PDF corruption\n            !courseTitle.includes(\"xref\") && // Skip PDF corruption\n            !courseTitle.includes(\"R /Info\") && // Skip PDF corruption\n            !courseTitle.includes(\"stream\") && // Skip PDF corruption\n            !courseTitle.includes(\"obj\") && // Skip PDF corruption\n            !courseTitle.includes(\"startxref\") && // Skip PDF corruption\n            !courseTitle.includes(\"trailer\") && // Skip PDF corruption\n            // Additional validation for table formats\n            courseTitle.length >= 3 && // Must be at least 3 characters\n            !courseTitle.match(/^\\d+/) && // Must not start with number\n            !courseTitle.match(/^[^a-zA-Z]/) && // Must start with letter\n            // Must contain at least one letter (flexible for various course names)\n            /[a-zA-Z]/.test(courseTitle);\n            if (isValidCourse) {\n                console.log(\"\\uD83D\\uDCD6 Extracted course \".concat(index + 1, \": \").concat(courseTitle, \" (\").concat(credits, \" credits)\"));\n                courses.push({\n                    number: (courses.length + 1).toString(),\n                    name: courseTitle,\n                    code: \"COURSE\".concat(courses.length + 1),\n                    credits: credits,\n                    hours: undefined // We only need title and credits\n                });\n            } else if (courseTitle && courseTitle.length > 3) {\n                console.log('⚠️ Skipped invalid course: \"'.concat(courseTitle, '\" (').concat(credits, \" credits)\"));\n            }\n        });\n    });\n    // Remove duplicates based on course name (case-insensitive and similar names)\n    const uniqueCourses = courses.filter((course, index, self)=>index === self.findIndex((c)=>{\n            const name1 = c.name.toLowerCase().replace(/\\s+/g, \" \").trim();\n            const name2 = course.name.toLowerCase().replace(/\\s+/g, \" \").trim();\n            return name1 === name2 || name1.includes(\"credits\") && name2 === name1.replace(\" credits\", \"\") || name2.includes(\"credits\") && name1 === name2.replace(\" credits\", \"\") || name1 === name2.replace(\" credits\", \"\") || name2 === name1.replace(\" credits\", \"\");\n        }));\n    console.log(\"✅ Extracted \".concat(uniqueCourses.length, \" unique courses\"));\n    return uniqueCourses;\n}\n// Extract course section from text\nfunction extractCourseSection(text, courseName) {\n    const lines = text.split(\"\\n\");\n    let courseSection = \"\";\n    let foundCourse = false;\n    for (const line of lines){\n        if (line.includes(courseName)) {\n            foundCourse = true;\n            courseSection += line + \"\\n\";\n        } else if (foundCourse && (line.match(/^\\d+[\\.\\)\\-\\s]/) || line.includes(\"TOTAL:\") || line.includes(\"COURSE STRUCTURE\"))) {\n            break;\n        } else if (foundCourse) {\n            courseSection += line + \"\\n\";\n        }\n    }\n    return courseSection;\n}\n// Extract credits from course section\nfunction extractCreditsFromText(section) {\n    const patterns = [\n        /Credits?:\\s*(\\d+)/i,\n        /Credit:\\s*(\\d+)/i,\n        /(\\d+)\\s*credits?/i,\n        /(\\d+)\\s*credit/i\n    ];\n    for (const pattern of patterns){\n        const match = section.match(pattern);\n        if (match) {\n            return parseInt(match[1]);\n        }\n    }\n    return undefined;\n}\n// Extract hours from course section\nfunction extractHoursFromText(section) {\n    const theoryMatch = section.match(/Theory[:\\s]*(\\d+)/i);\n    const tutorialMatch = section.match(/Tutorial[:\\s]*(\\d+)/i);\n    const practicalMatch = section.match(/Practical[:\\s]*(\\d+)/i);\n    if (theoryMatch || tutorialMatch || practicalMatch) {\n        return {\n            theory: theoryMatch ? parseInt(theoryMatch[1]) : 0,\n            tutorial: tutorialMatch ? parseInt(tutorialMatch[1]) : 0,\n            practical: practicalMatch ? parseInt(practicalMatch[1]) : 0\n        };\n    }\n    return undefined;\n} // Functions are already exported above\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9yZWFsLXBkZi1wYXJzZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsa0NBQWtDO0FBQ2xDLGlGQUFpRjtBQVlqRixtREFBbUQ7QUFDNUMsZUFBZUEsbUJBQW1CQyxJQUFVO0lBQ2pELElBQUk7UUFDRkMsUUFBUUMsR0FBRyxDQUFDLDBDQUEwQyxPQUFWRixLQUFLRyxJQUFJO1FBRXJELDhEQUE4RDtRQUM5REYsUUFBUUMsR0FBRyxDQUFDLGlEQUFpRCxPQUFWRixLQUFLRyxJQUFJO1FBQzVERixRQUFRQyxHQUFHLENBQUMsMkJBQTJCLE9BQVZGLEtBQUtJLElBQUksRUFBQztRQUV2QywyQ0FBMkM7UUFDM0MsSUFBSTtZQUNGLE1BQU1DLGNBQWMsTUFBTUwsS0FBS0ssV0FBVztZQUMxQ0osUUFBUUMsR0FBRyxDQUFDLCtCQUE0QyxPQUF2QkcsWUFBWUMsVUFBVSxFQUFDO1lBRXhELHNDQUFzQztZQUN0QyxJQUFJQyxnQkFBZ0I7WUFDcEIsSUFBSUMsWUFBWTtZQUVkLHFEQUFxRDtZQUNyRCxJQUFJO2dCQUNGLE1BQU1DLFdBQVcsTUFBTSxzT0FBTztnQkFFOUIsb0NBQW9DO2dCQUNwQ0EsU0FBU0MsbUJBQW1CLENBQUNDLFNBQVMsR0FBSTtnQkFFMUMsTUFBTUMsTUFBTSxNQUFNSCxTQUFTSSxXQUFXLENBQUM7b0JBQ3JDQyxNQUFNVDtvQkFDTlUsZ0JBQWdCO29CQUNoQkMsaUJBQWlCO29CQUNqQkMsZ0JBQWdCO29CQUNoQkMsaUJBQWlCO29CQUNqQkMsY0FBYztvQkFDZEMsZUFBZTtnQkFDakIsR0FBR0MsT0FBTztnQkFFWnBCLFFBQVFDLEdBQUcsQ0FBQyw0QkFBK0IsT0FBYlUsSUFBSVUsUUFBUSxFQUFDO2dCQUMzQ2QsWUFBWUksSUFBSVUsUUFBUTtnQkFFeEIsaUVBQWlFO2dCQUNqRSxJQUFLLElBQUlDLFVBQVUsR0FBR0EsV0FBV1gsSUFBSVUsUUFBUSxFQUFFQyxVQUFXO29CQUN4RCxJQUFJO3dCQUNGLE1BQU1DLE9BQU8sTUFBTVosSUFBSWEsT0FBTyxDQUFDRjt3QkFDL0IsTUFBTUcsY0FBYyxNQUFNRixLQUFLRyxjQUFjO3dCQUU3Qyw2Q0FBNkM7d0JBQzdDLE1BQU1DLFdBQVdGLFlBQVlHLEtBQUssQ0FDL0JDLEdBQUcsQ0FBQyxDQUFDQzs0QkFDSixxREFBcUQ7NEJBQ3JELElBQUlBLEtBQUtDLE1BQU0sRUFBRTtnQ0FDZixPQUFPRCxLQUFLRSxHQUFHLEdBQUc7NEJBQ3BCOzRCQUNBLE9BQU9GLEtBQUtFLEdBQUcsR0FBRzt3QkFDcEIsR0FDQ0MsSUFBSSxDQUFDLElBQ0xDLE9BQU8sQ0FBQyxRQUFRLEtBQUssdUJBQXVCO3lCQUM1Q0EsT0FBTyxDQUFDLFVBQVUsTUFBTSx1QkFBdUI7O3dCQUVsRDVCLGlCQUFpQnFCLFdBQVc7b0JBQzlCLEVBQUUsT0FBT1EsV0FBVzt3QkFDbEJuQyxRQUFRb0MsSUFBSSxDQUFDLHVDQUErQyxPQUFSZCxTQUFRLE1BQUlhO29CQUNsRTtnQkFDRjtnQkFFQW5DLFFBQVFDLEdBQUcsQ0FBQyxzQ0FBbUQsT0FBYlUsSUFBSVUsUUFBUSxFQUFDO1lBRWpFLEVBQUUsT0FBT2dCLFlBQVk7Z0JBQ25CckMsUUFBUW9DLElBQUksQ0FBQyxzREFBc0RDO2dCQUVuRSx3REFBd0Q7Z0JBQ3hELElBQUk7b0JBQ0YsNkNBQTZDO29CQUM3QyxNQUFNQyxXQUFXLE1BQU0sK05BQU87b0JBQzlCLE1BQU1DLFNBQVNDLE1BQU1BLENBQUNDLElBQUksQ0FBQ3JDO29CQUMzQixNQUFNUyxPQUFPLE1BQU15QixTQUFTSSxPQUFPLENBQUNIO29CQUVwQ2pDLGdCQUFnQk8sS0FBSzhCLElBQUk7b0JBQ3pCcEMsWUFBWU0sS0FBSytCLFFBQVE7b0JBRXpCNUMsUUFBUUMsR0FBRyxDQUFFO2dCQUVmLEVBQUUsT0FBTzRDLGVBQWU7b0JBQ3RCN0MsUUFBUW9DLElBQUksQ0FBQyxzREFBc0RTO29CQUVuRSxtREFBbUQ7b0JBQ25ELE1BQU1GLE9BQU8sTUFBTSxJQUFJRyxRQUFnQixDQUFDQyxTQUFTQzt3QkFDL0MsTUFBTUMsU0FBUyxJQUFJQzt3QkFDbkJELE9BQU9FLE1BQU0sR0FBRyxDQUFDQztnQ0FDQUE7NEJBQWYsTUFBTUMsVUFBU0QsWUFBQUEsRUFBRUUsTUFBTSxjQUFSRixnQ0FBQUEsVUFBVUMsTUFBTTs0QkFDL0JOLFFBQVFNLFVBQVU7d0JBQ3BCO3dCQUNBSixPQUFPTSxPQUFPLEdBQUcsSUFBTVAsT0FBTyxJQUFJUSxNQUFNO3dCQUN4Q1AsT0FBT1EsVUFBVSxDQUFDMUQ7b0JBQ3BCO29CQUVBTyxnQkFBZ0JxQztvQkFDaEIzQyxRQUFRQyxHQUFHLENBQUU7Z0JBQ2Y7WUFDRjtZQUVBRCxRQUFRQyxHQUFHLENBQUMsdUNBQWtELE9BQXJCSyxjQUFjb0QsTUFBTSxFQUFDO1lBQzlEMUQsUUFBUUMsR0FBRyxDQUFDLDhCQUFvRCxPQUFoQ0ssY0FBY3FELFNBQVMsQ0FBQyxHQUFHLE1BQUs7WUFFaEUsMkVBQTJFO1lBQzNFLElBQUlyRCxjQUFjb0QsTUFBTSxLQUFLLEdBQUc7Z0JBQzlCLE1BQU0sSUFBSUYsTUFBTTtZQUNsQjtZQUVBLG9EQUFvRDtZQUNwRCxJQUFJbEQsY0FBY3NELFFBQVEsQ0FBQyxnQkFBZ0J0RCxjQUFjc0QsUUFBUSxDQUFDLGFBQWF0RCxjQUFjc0QsUUFBUSxDQUFDLFNBQVM7Z0JBQzdHLE1BQU0sSUFBSUosTUFBTTtZQUNsQjtZQUVBLE9BQU87Z0JBQ0xiLE1BQU1yQztnQkFDTnVELE9BQU90RDtnQkFDUHVELFVBQVU7b0JBQ1JDLE9BQU9oRSxLQUFLRyxJQUFJLENBQUNnQyxPQUFPLENBQUMsUUFBUTtvQkFDakM4QixRQUFRO29CQUNSQyxjQUFjLElBQUlDLE9BQU9DLFdBQVc7Z0JBQ3RDO1lBQ0Y7UUFFRixFQUFFLE9BQU9DLE9BQU87WUFDZHBFLFFBQVFvRSxLQUFLLENBQUMscUNBQXFDQTtZQUNuRCxNQUFNLElBQUlaLE1BQU0sd0JBQWlGLE9BQXpEWSxpQkFBaUJaLFFBQVFZLE1BQU1DLE9BQU8sR0FBRztRQUNuRjtJQUVGLEVBQUUsT0FBT0QsT0FBTztRQUNkcEUsUUFBUW9FLEtBQUssQ0FBQyxxQ0FBcUNBO1FBQ25ELE1BQU1BO0lBQ1I7QUFDRjtBQUVBLG9EQUFvRDtBQUM3QyxTQUFTRSx1QkFBdUIzQixJQUFZO0lBT2pELE1BQU00QixVQU1ELEVBQUU7SUFFUHZFLFFBQVFDLEdBQUcsQ0FBQztJQUNaRCxRQUFRQyxHQUFHLENBQUMsNkJBQStCLE9BQVowQyxLQUFLZSxNQUFNLEVBQUM7SUFDM0MxRCxRQUFRQyxHQUFHLENBQUMsOEJBQTJDLE9BQXZCMEMsS0FBS2dCLFNBQVMsQ0FBQyxHQUFHLE1BQUs7SUFFdkQsdUZBQXVGO0lBQ3ZGLE1BQU1hLFdBQVc7UUFDZixxRUFBcUU7UUFDckU7UUFDQSwrRUFBK0U7UUFDL0U7UUFDQSxpREFBaUQ7UUFDakQ7UUFDQSx3RUFBd0U7UUFDeEU7UUFDQSxpRUFBaUU7UUFDakU7UUFDQSw0REFBNEQ7UUFDNUQ7UUFDQSxxREFBcUQ7UUFDckQ7UUFDQSxxREFBcUQ7UUFDckQ7UUFDQSwrREFBK0Q7UUFDL0Q7UUFDQSxtREFBbUQ7UUFDbkQ7UUFDQSx1RkFBdUY7UUFDdkY7UUFDQSx3REFBd0Q7UUFDeEQ7UUFDQSxzRUFBc0U7UUFDdEU7UUFDQSwyREFBMkQ7UUFDM0Q7UUFDQSxpRUFBaUU7UUFDakU7UUFDQSx1RkFBdUY7UUFDdkY7UUFDQSxnRUFBZ0U7UUFDaEU7UUFDQSx5REFBeUQ7UUFDekQ7UUFDQSxxREFBcUQ7UUFDckQ7UUFDQSxvREFBb0Q7UUFDcEQ7S0FDRDtJQUVEQSxTQUFTQyxPQUFPLENBQUMsQ0FBQ0MsU0FBU0M7UUFDekIzRSxRQUFRQyxHQUFHLENBQUMsK0JBQTBDeUUsT0FBckJDLGVBQWUsR0FBRSxNQUFZLE9BQVJEO1FBQ3RELE1BQU1FLFVBQVVDLE1BQU1wQyxJQUFJLENBQUNFLEtBQUttQyxRQUFRLENBQUNKO1FBQ3pDMUUsUUFBUUMsR0FBRyxDQUFDLHNCQUFtRDBFLE9BQXZDQyxRQUFRbEIsTUFBTSxFQUFDLDBCQUF5QyxPQUFqQmlCLGVBQWU7UUFFOUVDLFFBQVFILE9BQU8sQ0FBQyxDQUFDTSxPQUFPQztZQUN0QixJQUFJQztZQUNKLElBQUlDO1lBRUosa0NBQWtDO1lBQ2xDLElBQUlQLGlCQUFpQixHQUFHO2dCQUN0Qix5RkFBeUY7Z0JBQ3pGTSxjQUFjRixLQUFLLENBQUMsRUFBRSxDQUFDSSxJQUFJO2dCQUMzQkQsVUFBVUUsU0FBU0wsS0FBSyxDQUFDLEVBQUU7WUFDN0IsT0FBTztnQkFDTCxxQkFBcUI7Z0JBQ3JCRSxjQUFjRixLQUFLLENBQUMsRUFBRSxDQUFDSSxJQUFJO2dCQUMzQkQsVUFBVUUsU0FBU0wsS0FBSyxDQUFDLEVBQUU7WUFDN0I7WUFFQSxzRUFBc0U7WUFDdEVFLGNBQWNBLFlBQVkvQyxPQUFPLENBQUMsUUFBUSxLQUFLaUQsSUFBSTtZQUVuRCx1REFBdUQ7WUFDdkQsTUFBTUUsZUFBZTtnQkFDbkI7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0EsWUFBWSwyQkFBMkI7YUFDeEM7WUFFRCxNQUFNQyxhQUFhRCxhQUFhRSxJQUFJLENBQUNiLENBQUFBLFVBQVdBLFFBQVFjLElBQUksQ0FBQ1A7WUFFN0Qsa0ZBQWtGO1lBQ2xGLE1BQU1RLGdCQUFnQlIsZUFDbEJBLFlBQVl2QixNQUFNLElBQUksS0FBSyx1QkFBdUI7WUFDbEQsQ0FBQ2dDLE1BQU1SLFlBQ1BBLFdBQVcsS0FDWEEsV0FBVyxNQUFNLHlCQUF5QjtZQUMxQyxDQUFDSSxjQUNELDJDQUEyQztZQUMzQyxXQUFXRSxJQUFJLENBQUNQLGdCQUFnQix1QkFBdUI7WUFDdkRBLFlBQVlVLEtBQUssQ0FBQyxLQUFLakMsTUFBTSxJQUFJLEtBQUsseURBQXlEO1lBQy9GLENBQUN1QixZQUFZRixLQUFLLENBQUMsV0FBVyw2QkFBNkI7WUFDM0QsQ0FBQ0UsWUFBWUYsS0FBSyxDQUFDLGlCQUFpQix5QkFBeUI7WUFDN0QsQ0FBQ0UsWUFBWXJCLFFBQVEsQ0FBQyxrQkFBa0IsMEJBQTBCO1lBQ2xFLENBQUNxQixZQUFZRixLQUFLLENBQUMsZ0NBQWdDLHNCQUFzQjtZQUN6RSxDQUFDRSxZQUFZckIsUUFBUSxDQUFDLGdCQUFnQixzQkFBc0I7WUFDNUQsQ0FBQ3FCLFlBQVlyQixRQUFRLENBQUMsYUFBYSxzQkFBc0I7WUFDekQsQ0FBQ3FCLFlBQVlyQixRQUFRLENBQUMsV0FBVyxzQkFBc0I7WUFDdkQsQ0FBQ3FCLFlBQVlyQixRQUFRLENBQUMsY0FBYyxzQkFBc0I7WUFDMUQsQ0FBQ3FCLFlBQVlyQixRQUFRLENBQUMsYUFBYSxzQkFBc0I7WUFDekQsQ0FBQ3FCLFlBQVlyQixRQUFRLENBQUMsVUFBVSxzQkFBc0I7WUFDdEQsQ0FBQ3FCLFlBQVlyQixRQUFRLENBQUMsZ0JBQWdCLHNCQUFzQjtZQUM1RCxDQUFDcUIsWUFBWXJCLFFBQVEsQ0FBQyxjQUFjLHNCQUFzQjtZQUMxRCwwQ0FBMEM7WUFDMUNxQixZQUFZdkIsTUFBTSxJQUFJLEtBQUssZ0NBQWdDO1lBQzNELENBQUN1QixZQUFZRixLQUFLLENBQUMsV0FBVyw2QkFBNkI7WUFDM0QsQ0FBQ0UsWUFBWUYsS0FBSyxDQUFDLGlCQUFpQix5QkFBeUI7WUFDN0QsdUVBQXVFO1lBQ3ZFLFdBQVdTLElBQUksQ0FBQ1A7WUFFcEIsSUFBSVEsZUFBZTtnQkFDakJ6RixRQUFRQyxHQUFHLENBQUMsaUNBQXFDZ0YsT0FBZEQsUUFBUSxHQUFFLE1BQW9CRSxPQUFoQkQsYUFBWSxNQUFZLE9BQVJDLFNBQVE7Z0JBRXpFWCxRQUFRcUIsSUFBSSxDQUFDO29CQUNYQyxRQUFRLENBQUN0QixRQUFRYixNQUFNLEdBQUcsR0FBR29DLFFBQVE7b0JBQ3JDNUYsTUFBTStFO29CQUNOYyxNQUFNLFNBQTRCLE9BQW5CeEIsUUFBUWIsTUFBTSxHQUFHO29CQUNoQ3dCLFNBQVNBO29CQUNUYyxPQUFPQyxVQUFVLGlDQUFpQztnQkFDcEQ7WUFDRixPQUFPLElBQUloQixlQUFlQSxZQUFZdkIsTUFBTSxHQUFHLEdBQUc7Z0JBQ2hEMUQsUUFBUUMsR0FBRyxDQUFDLCtCQUFnRGlGLE9BQWpCRCxhQUFZLE9BQWEsT0FBUkMsU0FBUTtZQUN0RTtRQUNGO0lBQ0Y7SUFFQSw4RUFBOEU7SUFDOUUsTUFBTWdCLGdCQUFnQjNCLFFBQVE0QixNQUFNLENBQUMsQ0FBQ0MsUUFBUXBCLE9BQU9xQixPQUNuRHJCLFVBQVVxQixLQUFLQyxTQUFTLENBQUNDLENBQUFBO1lBQ3ZCLE1BQU1DLFFBQVFELEVBQUVyRyxJQUFJLENBQUN1RyxXQUFXLEdBQUd2RSxPQUFPLENBQUMsUUFBUSxLQUFLaUQsSUFBSTtZQUM1RCxNQUFNdUIsUUFBUU4sT0FBT2xHLElBQUksQ0FBQ3VHLFdBQVcsR0FBR3ZFLE9BQU8sQ0FBQyxRQUFRLEtBQUtpRCxJQUFJO1lBQ2pFLE9BQU9xQixVQUFVRSxTQUNURixNQUFNNUMsUUFBUSxDQUFDLGNBQWM4QyxVQUFVRixNQUFNdEUsT0FBTyxDQUFDLFlBQVksT0FDakV3RSxNQUFNOUMsUUFBUSxDQUFDLGNBQWM0QyxVQUFVRSxNQUFNeEUsT0FBTyxDQUFDLFlBQVksT0FDakVzRSxVQUFVRSxNQUFNeEUsT0FBTyxDQUFDLFlBQVksT0FDcEN3RSxVQUFVRixNQUFNdEUsT0FBTyxDQUFDLFlBQVk7UUFDOUM7SUFHRmxDLFFBQVFDLEdBQUcsQ0FBQyxlQUFvQyxPQUFyQmlHLGNBQWN4QyxNQUFNLEVBQUM7SUFDaEQsT0FBT3dDO0FBQ1Q7QUFFQSxtQ0FBbUM7QUFDbkMsU0FBU1MscUJBQXFCaEUsSUFBWSxFQUFFaUUsVUFBa0I7SUFDNUQsTUFBTUMsUUFBUWxFLEtBQUtnRCxLQUFLLENBQUM7SUFDekIsSUFBSW1CLGdCQUFnQjtJQUNwQixJQUFJQyxjQUFjO0lBRWxCLEtBQUssTUFBTUMsUUFBUUgsTUFBTztRQUN4QixJQUFJRyxLQUFLcEQsUUFBUSxDQUFDZ0QsYUFBYTtZQUM3QkcsY0FBYztZQUNkRCxpQkFBaUJFLE9BQU87UUFDMUIsT0FBTyxJQUFJRCxlQUFnQkMsQ0FBQUEsS0FBS2pDLEtBQUssQ0FBQyxxQkFBcUJpQyxLQUFLcEQsUUFBUSxDQUFDLGFBQWFvRCxLQUFLcEQsUUFBUSxDQUFDLG1CQUFrQixHQUFJO1lBQ3hIO1FBQ0YsT0FBTyxJQUFJbUQsYUFBYTtZQUN0QkQsaUJBQWlCRSxPQUFPO1FBQzFCO0lBQ0Y7SUFFQSxPQUFPRjtBQUNUO0FBRUEsc0NBQXNDO0FBQ3RDLFNBQVNHLHVCQUF1QkMsT0FBZTtJQUM3QyxNQUFNMUMsV0FBVztRQUNmO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFFRCxLQUFLLE1BQU1FLFdBQVdGLFNBQVU7UUFDOUIsTUFBTU8sUUFBUW1DLFFBQVFuQyxLQUFLLENBQUNMO1FBQzVCLElBQUlLLE9BQU87WUFDVCxPQUFPSyxTQUFTTCxLQUFLLENBQUMsRUFBRTtRQUMxQjtJQUNGO0lBRUEsT0FBT2tCO0FBQ1Q7QUFFQSxvQ0FBb0M7QUFDcEMsU0FBU2tCLHFCQUFxQkQsT0FBZTtJQUMzQyxNQUFNRSxjQUFjRixRQUFRbkMsS0FBSyxDQUFDO0lBQ2xDLE1BQU1zQyxnQkFBZ0JILFFBQVFuQyxLQUFLLENBQUM7SUFDcEMsTUFBTXVDLGlCQUFpQkosUUFBUW5DLEtBQUssQ0FBQztJQUVyQyxJQUFJcUMsZUFBZUMsaUJBQWlCQyxnQkFBZ0I7UUFDbEQsT0FBTztZQUNMQyxRQUFRSCxjQUFjaEMsU0FBU2dDLFdBQVcsQ0FBQyxFQUFFLElBQUk7WUFDakRJLFVBQVVILGdCQUFnQmpDLFNBQVNpQyxhQUFhLENBQUMsRUFBRSxJQUFJO1lBQ3ZESSxXQUFXSCxpQkFBaUJsQyxTQUFTa0MsY0FBYyxDQUFDLEVBQUUsSUFBSTtRQUM1RDtJQUNGO0lBRUEsT0FBT3JCO0FBQ1QsRUFFQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3JlYWwtcGRmLXBhcnNlci50cz9hODRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJlYWwgUERGIHBhcnNpbmcgaW1wbGVtZW50YXRpb25cbi8vIFRoaXMgd291bGQgdXNlIGFjdHVhbCBQREYgcGFyc2luZyBsaWJyYXJpZXMgdG8gZXh0cmFjdCB0ZXh0IGZyb20gdXBsb2FkZWQgUERGc1xuXG5leHBvcnQgaW50ZXJmYWNlIFBERlBhcnNlUmVzdWx0IHtcbiAgdGV4dDogc3RyaW5nXG4gIHBhZ2VzOiBudW1iZXJcbiAgbWV0YWRhdGE6IHtcbiAgICB0aXRsZT86IHN0cmluZ1xuICAgIGF1dGhvcj86IHN0cmluZ1xuICAgIGNyZWF0aW9uRGF0ZT86IHN0cmluZ1xuICB9XG59XG5cbi8vIFJlYWwgUERGIHRleHQgZXh0cmFjdGlvbiB1c2luZyBwZGYtcGFyc2UgbGlicmFyeVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RUZXh0RnJvbVBERihmaWxlOiBGaWxlKTogUHJvbWlzZTxQREZQYXJzZVJlc3VsdD4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGDwn5OEIEV4dHJhY3RpbmcgdGV4dCBmcm9tIFBERjogJHtmaWxlLm5hbWV9YClcbiAgICBcbiAgICAvLyBSRUFMIFBERiBQQVJTSU5HIC0gRXh0cmFjdCBhY3R1YWwgY29udGVudCBmcm9tIHVwbG9hZGVkIFBERlxuICAgIGNvbnNvbGUubG9nKGDwn5OEIFBhcnNpbmcgYWN0dWFsIFBERiBjb250ZW50IGZyb206ICR7ZmlsZS5uYW1lfWApXG4gICAgY29uc29sZS5sb2coYPCfk4QgRmlsZSBzaXplOiAke2ZpbGUuc2l6ZX0gYnl0ZXNgKVxuICAgIFxuICAgIC8vIFVzZSBhIG1vcmUgcmVsaWFibGUgUERGIHBhcnNpbmcgYXBwcm9hY2hcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBmaWxlLmFycmF5QnVmZmVyKClcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OEIFBERiBmaWxlIHNpemU6ICR7YXJyYXlCdWZmZXIuYnl0ZUxlbmd0aH0gYnl0ZXNgKVxuICAgICAgXG4gICAgICAvLyBUcnkgbXVsdGlwbGUgUERGIHBhcnNpbmcgYXBwcm9hY2hlc1xuICAgICAgbGV0IGV4dHJhY3RlZFRleHQgPSAnJ1xuICAgICAgbGV0IHBhZ2VDb3VudCA9IDFcbiAgICAgIFxuICAgICAgICAvLyBBcHByb2FjaCAxOiBUcnkgcGRmanMtZGlzdCB3aXRoIG9wdGltaXplZCBzZXR0aW5nc1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBkZmpzTGliID0gYXdhaXQgaW1wb3J0KCdwZGZqcy1kaXN0JylcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVc2UgYSBtb3JlIHJlbGlhYmxlIHdvcmtlciBzb3VyY2VcbiAgICAgICAgICBwZGZqc0xpYi5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYyA9IGBodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9wZGYuanMvMy4xMS4xNzQvcGRmLndvcmtlci5taW4uanNgXG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgcGRmID0gYXdhaXQgcGRmanNMaWIuZ2V0RG9jdW1lbnQoeyBcbiAgICAgICAgICAgIGRhdGE6IGFycmF5QnVmZmVyLFxuICAgICAgICAgICAgdXNlV29ya2VyRmV0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgaXNFdmFsU3VwcG9ydGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZVN5c3RlbUZvbnRzOiB0cnVlLFxuICAgICAgICAgICAgZGlzYWJsZUZvbnRGYWNlOiB0cnVlLFxuICAgICAgICAgICAgZGlzYWJsZVJhbmdlOiB0cnVlLFxuICAgICAgICAgICAgZGlzYWJsZVN0cmVhbTogdHJ1ZVxuICAgICAgICAgIH0pLnByb21pc2VcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OEIFBERiBsb2FkZWQ6ICR7cGRmLm51bVBhZ2VzfSBwYWdlc2ApXG4gICAgICAgIHBhZ2VDb3VudCA9IHBkZi5udW1QYWdlc1xuICAgICAgICBcbiAgICAgICAgLy8gRXh0cmFjdCB0ZXh0IGZyb20gYWxsIHBhZ2VzIHdpdGggZW5oYW5jZWQgdGFibGUgZm9ybWF0IHN1cHBvcnRcbiAgICAgICAgZm9yIChsZXQgcGFnZU51bSA9IDE7IHBhZ2VOdW0gPD0gcGRmLm51bVBhZ2VzOyBwYWdlTnVtKyspIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFnZSA9IGF3YWl0IHBkZi5nZXRQYWdlKHBhZ2VOdW0pXG4gICAgICAgICAgICBjb25zdCB0ZXh0Q29udGVudCA9IGF3YWl0IHBhZ2UuZ2V0VGV4dENvbnRlbnQoKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFbmhhbmNlZCB0ZXh0IGV4dHJhY3Rpb24gZm9yIHRhYmxlIGZvcm1hdHNcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VUZXh0ID0gdGV4dENvbnRlbnQuaXRlbXNcbiAgICAgICAgICAgICAgLm1hcCgoaXRlbTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgbGluZSBicmVha3MgYW5kIHNwYWNpbmcgZm9yIHRhYmxlIGZvcm1hdHNcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5oYXNFT0wpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnN0ciArICdcXG4nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnN0ciArICcgJ1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuam9pbignJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKSAvLyBOb3JtYWxpemUgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAucmVwbGFjZSgvXFxuXFxzKy9nLCAnXFxuJykgLy8gQ2xlYW4gdXAgbGluZSBicmVha3NcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXh0cmFjdGVkVGV4dCArPSBwYWdlVGV4dCArICdcXG4nXG4gICAgICAgICAgfSBjYXRjaCAocGFnZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBDb3VsZCBub3QgZXh0cmFjdCB0ZXh0IGZyb20gcGFnZSAke3BhZ2VOdW19OmAsIHBhZ2VFcnJvcilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgU3VjY2Vzc2Z1bGx5IGV4dHJhY3RlZCB0ZXh0IGZyb20gJHtwZGYubnVtUGFnZXN9IHBhZ2VzYClcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChwZGZqc0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIHBkZmpzLWRpc3QgZmFpbGVkLCB0cnlpbmcgYWx0ZXJuYXRpdmUgYXBwcm9hY2g6JywgcGRmanNFcnJvcilcbiAgICAgICAgXG4gICAgICAgIC8vIEFwcHJvYWNoIDI6IFRyeSB1c2luZyBhIGRpZmZlcmVudCBQREYgcGFyc2luZyBsaWJyYXJ5XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVXNlIHBkZi1wYXJzZSBhcyBhIGZhbGxiYWNrIChpZiBhdmFpbGFibGUpXG4gICAgICAgICAgY29uc3QgcGRmUGFyc2UgPSBhd2FpdCBpbXBvcnQoJ3BkZi1wYXJzZScpXG4gICAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpXG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBkZlBhcnNlLmRlZmF1bHQoYnVmZmVyKVxuICAgICAgICAgIFxuICAgICAgICAgIGV4dHJhY3RlZFRleHQgPSBkYXRhLnRleHRcbiAgICAgICAgICBwYWdlQ291bnQgPSBkYXRhLm51bXBhZ2VzXG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzZnVsbHkgZXh0cmFjdGVkIHRleHQgdXNpbmcgcGRmLXBhcnNlYClcbiAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAocGRmUGFyc2VFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIHBkZi1wYXJzZSBmYWlsZWQsIHRyeWluZyBiYXNpYyB0ZXh0IGV4dHJhY3Rpb246JywgcGRmUGFyc2VFcnJvcilcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBcHByb2FjaCAzOiBCYXNpYyB0ZXh0IGV4dHJhY3Rpb24gYXMgbGFzdCByZXNvcnRcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgbmV3IFByb21pc2U8c3RyaW5nPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZS50YXJnZXQ/LnJlc3VsdCBhcyBzdHJpbmdcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQgfHwgJycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZWFkIFBERiBmaWxlJykpXG4gICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgZXh0cmFjdGVkVGV4dCA9IHRleHRcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFVzaW5nIGJhc2ljIHRleHQgZXh0cmFjdGlvbmApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYPCfk4QgRXh0cmFjdGVkIHRleHQgbGVuZ3RoOiAke2V4dHJhY3RlZFRleHQubGVuZ3RofSBjaGFyYWN0ZXJzYClcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OEIFRleHQgcHJldmlldzogJHtleHRyYWN0ZWRUZXh0LnN1YnN0cmluZygwLCAyMDApfS4uLmApXG4gICAgICBcbiAgICAgIC8vIElmIG5vIHRleHQgd2FzIGV4dHJhY3RlZCwgdGhyb3cgYW4gZXJyb3IgaW5zdGVhZCBvZiB1c2luZyBoYXJkY29kZWQgZGF0YVxuICAgICAgaWYgKGV4dHJhY3RlZFRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdGV4dCBjb3VsZCBiZSBleHRyYWN0ZWQgZnJvbSB0aGUgUERGLiBQbGVhc2UgdHJ5IGEgZGlmZmVyZW50IFBERiBmaWxlLicpXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIGV4dHJhY3RlZCB0ZXh0IGxvb2tzIGNvcnJ1cHRlZCwgdGhyb3cgYW4gZXJyb3JcbiAgICAgIGlmIChleHRyYWN0ZWRUZXh0LmluY2x1ZGVzKCdlbmRzdHJlYW0nKSB8fCBleHRyYWN0ZWRUZXh0LmluY2x1ZGVzKCdlbmRvYmonKSB8fCBleHRyYWN0ZWRUZXh0LmluY2x1ZGVzKCd4cmVmJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQREYgYXBwZWFycyB0byBiZSBjb3JydXB0ZWQgb3IgZW5jcnlwdGVkLiBQbGVhc2UgdHJ5IGEgZGlmZmVyZW50IFBERiBmaWxlLicpXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHQ6IGV4dHJhY3RlZFRleHQsXG4gICAgICAgIHBhZ2VzOiBwYWdlQ291bnQsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgdGl0bGU6IGZpbGUubmFtZS5yZXBsYWNlKCcucGRmJywgJycpLFxuICAgICAgICAgIGF1dGhvcjogJ1Vua25vd24nLFxuICAgICAgICAgIGNyZWF0aW9uRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQWxsIFBERiBwYXJzaW5nIG1ldGhvZHMgZmFpbGVkOicsIGVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgUERGOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApXG4gICAgfVxuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBleHRyYWN0aW5nIHRleHQgZnJvbSBQREY6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBFbmhhbmNlZCBjb3Vyc2UgZXh0cmFjdGlvbiB3aXRoIG11bHRpcGxlIHBhdHRlcm5zXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdENvdXJzZXNGcm9tVGV4dCh0ZXh0OiBzdHJpbmcpOiBBcnJheTx7XG4gIG51bWJlcjogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBjb2RlOiBzdHJpbmdcbiAgY3JlZGl0cz86IG51bWJlclxuICBob3Vycz86IHsgdGhlb3J5OiBudW1iZXI7IHR1dG9yaWFsOiBudW1iZXI7IHByYWN0aWNhbDogbnVtYmVyIH1cbn0+IHtcbiAgY29uc3QgY291cnNlczogQXJyYXk8e1xuICAgIG51bWJlcjogc3RyaW5nXG4gICAgbmFtZTogc3RyaW5nXG4gICAgY29kZTogc3RyaW5nXG4gICAgY3JlZGl0cz86IG51bWJlclxuICAgIGhvdXJzPzogeyB0aGVvcnk6IG51bWJlcjsgdHV0b3JpYWw6IG51bWJlcjsgcHJhY3RpY2FsOiBudW1iZXIgfVxuICB9PiA9IFtdXG4gIFxuICBjb25zb2xlLmxvZygn8J+UjSBFeHRyYWN0aW5nIGNvdXJzZXMgZnJvbSBQREYgdGV4dC4uLicpXG4gIGNvbnNvbGUubG9nKGDwn5OEIFRleHQgbGVuZ3RoOiAke3RleHQubGVuZ3RofSBjaGFyYWN0ZXJzYClcbiAgY29uc29sZS5sb2coYPCfk4QgVGV4dCBwcmV2aWV3OiAke3RleHQuc3Vic3RyaW5nKDAsIDUwMCl9Li4uYClcbiAgXG4gIC8vIENvbXByZWhlbnNpdmUgcGF0dGVybnMgdG8gZXh0cmFjdCBDb3Vyc2UgVGl0bGUgYW5kIENyZWRpdHMgZnJvbSBBTlkgdGFibGUgZm9ybWF0IFBERlxuICBjb25zdCBwYXR0ZXJucyA9IFtcbiAgICAvLyBQYXR0ZXJuIDE6IFwiQ291cnNlIFRpdGxlOiBbVGl0bGVdXCIgZm9sbG93ZWQgYnkgXCJDcmVkaXRzOiBbTnVtYmVyXVwiXG4gICAgL0NvdXJzZSBUaXRsZTpcXHMqKFteXFxuXFxyXSspXFxzKltcXG5cXHJdK0NyZWRpdHM6XFxzKihcXGQrKS9naSxcbiAgICAvLyBQYXR0ZXJuIDI6IFwiQ291cnNlIFRpdGxlOiBbVGl0bGVdXCIgYW5kIFwiQ3JlZGl0czogW051bWJlcl1cIiBvbiBzZXBhcmF0ZSBsaW5lc1xuICAgIC9Db3Vyc2UgVGl0bGU6XFxzKihbXlxcblxccl0rKS4qP0NyZWRpdHM6XFxzKihcXGQrKS9naSxcbiAgICAvLyBQYXR0ZXJuIDM6IFRhYmxlIGZvcm1hdCB3aXRoIHRpdGxlIGFuZCBjcmVkaXRzXG4gICAgLyhbQS1aYS16XFxzJlxcLVxcK1xcKFxcKVxcL10rPylcXHMrKFxcZCspXFxzKmNyZWRpdHM/L2dpLFxuICAgIC8vIFBhdHRlcm4gNDogTnVtYmVyZWQgY291cnNlcyBcIjEuIFtUaXRsZV0gKFtDb2RlXSkgLSBbQ3JlZGl0c10gY3JlZGl0c1wiXG4gICAgLyhcXGQrKVxcLlxccyooW14oXSs/KVxccypcXCgoW14pXSspXFwpXFxzKlstXFxzXSooXFxkKylcXHMqY3JlZGl0cz8vZ2ksXG4gICAgLy8gUGF0dGVybiA1OiBHZW5lcmljIGNvdXJzZSBmb3JtYXQgXCJbVGl0bGVdIC0gW0NyZWRpdHNdIENyZWRpdHNcIlxuICAgIC8oW0EtWmEtelxccyZcXC1cXCtcXChcXClcXC9dKz8pXFxzKi1cXHMqKFxcZCspXFxzKkNyZWRpdHM/L2dpLFxuICAgIC8vIFBhdHRlcm4gNjogQ291cnNlIG5hbWUgZm9sbG93ZWQgYnkgY3JlZGl0cyBpbiBwYXJlbnRoZXNlc1xuICAgIC8oW0EtWmEtelxccyZcXC1cXCtcXChcXClcXC9dKz8pXFxzKlxcKChcXGQrKVxccypjcmVkaXRzP1xcKS9naSxcbiAgICAvLyBQYXR0ZXJuIDc6IFNpbXBsZSBmb3JtYXQgXCJTdWJqZWN0IE5hbWUgQ3JlZGl0czogWFwiXG4gICAgLyhbQS1aYS16XFxzJlxcLVxcK1xcKFxcKVxcL10rPylcXHMrQ3JlZGl0czpcXHMqKFxcZCspL2dpLFxuICAgIC8vIFBhdHRlcm4gODogQ291cnNlIG5hbWUgd2l0aCBjcmVkaXRzIGF0IGVuZCBvZiBsaW5lXG4gICAgLyhbQS1aYS16XFxzJlxcLVxcK1xcKFxcKVxcL10rPylcXHMrKFxcZCspXFxzKiQvZ20sXG4gICAgLy8gUGF0dGVybiA5OiBDb3Vyc2UgbmFtZSBmb2xsb3dlZCBieSBjcmVkaXRzIChzcGFjZSBzZXBhcmF0ZWQpXG4gICAgLyhbQS1aYS16XFxzJlxcLVxcK1xcKFxcKVxcL10rPylcXHMrKFxcZCspXFxzKmNyZWRpdHM/L2dpLFxuICAgIC8vIFBhdHRlcm4gMTA6IENvdXJzZSBuYW1lIHdpdGggY3JlZGl0cyBhZnRlciBjb2xvblxuICAgIC8oW0EtWmEtelxccyZcXC1cXCtcXChcXClcXC9dKz8pOlxccyooXFxkKykvZ2ksXG4gICAgLy8gUGF0dGVybiAxMTogVGFibGUgZm9ybWF0IC0gQ291cnNlIHRpdGxlIGZvbGxvd2VkIGJ5IGNyZWRpdHMgKGZvciBWSSBTZW1lc3RlciBmb3JtYXQpXG4gICAgLyhbQS1aYS16XFxzJlxcLVxcK1xcKFxcKVxcL10rPylcXHMrKFxcZCspXFxzKiQvZ20sXG4gICAgLy8gUGF0dGVybiAxMjogQ291cnNlIHRpdGxlIHdpdGggY3JlZGl0cyBpbiB0YWJsZSBmb3JtYXRcbiAgICAvKFtBLVphLXpcXHMmXFwtXFwrXFwoXFwpXFwvXSs/KVxccysoXFxkKylcXHMqJC9nbSxcbiAgICAvLyBQYXR0ZXJuIDEzOiBHZW5lcmljIGNvdXJzZSBwYXR0ZXJuIChyZW1vdmVkIGhhcmRjb2RlZCBjb3Vyc2UgbmFtZXMpXG4gICAgLyhbQS1aYS16XVtBLVphLXpcXHMmXFwtXFwrXFwoXFwpXFwvXXs0LH0pXFxzKyhcXGQrKS9naSxcbiAgICAvLyBQYXR0ZXJuIDE0OiBDb3Vyc2UgdGl0bGVzIHdpdGggY3JlZGl0cyAoc3BhY2Ugc2VwYXJhdGVkKVxuICAgIC8oW0EtWmEtel1bQS1aYS16XFxzJlxcLVxcK1xcKFxcKVxcL117Mix9KVxccysoXFxkKylcXHMqJC9nbSxcbiAgICAvLyBQYXR0ZXJuIDE1OiBWZXJ5IGJyb2FkIHBhdHRlcm4gZm9yIGFueSB0ZXh0IGZvbGxvd2VkIGJ5IG51bWJlclxuICAgIC8oW0EtWmEtel1bQS1aYS16XFxzJlxcLVxcK1xcKFxcKVxcL117MSx9KVxccysoXFxkKykvZ2ksXG4gICAgLy8gUGF0dGVybiAxNjogVGFibGUgcm93IGZvcm1hdCAtIENvdXJzZSBuYW1lIHdpdGggY3JlZGl0cyAoZW5oYW5jZWQgZm9yIHRhYmxlIGZvcm1hdHMpXG4gICAgLyhbQS1aYS16XVtBLVphLXpcXHMmXFwtXFwrXFwoXFwpXFwvXXszLH0pXFxzKyhcXGQrKVxccyokL2dtLFxuICAgIC8vIFBhdHRlcm4gMTc6IENvdXJzZSBuYW1lIHdpdGggY3JlZGl0cyAodGFiIG9yIHNwYWNlIHNlcGFyYXRlZClcbiAgICAvKFtBLVphLXpdW0EtWmEtelxccyZcXC1cXCtcXChcXClcXC9dezMsfSlcXHMrKFxcZCspXFxzKiQvZ20sXG4gICAgLy8gUGF0dGVybiAxODogQ291cnNlIG5hbWUgd2l0aCBjcmVkaXRzIChtdWx0aXBsZSBzcGFjZXMpXG4gICAgLyhbQS1aYS16XVtBLVphLXpcXHMmXFwtXFwrXFwoXFwpXFwvXXszLH0pXFxzKyhcXGQrKVxccyokL2dtLFxuICAgIC8vIFBhdHRlcm4gMTk6IENvdXJzZSBuYW1lIHdpdGggY3JlZGl0cyAoZW5kIG9mIGxpbmUpXG4gICAgLyhbQS1aYS16XVtBLVphLXpcXHMmXFwtXFwrXFwoXFwpXFwvXXszLH0pXFxzKyhcXGQrKVxccyokL2dtLFxuICAgIC8vIFBhdHRlcm4gMjA6IENvdXJzZSBuYW1lIHdpdGggY3JlZGl0cyAoYW55IGZvcm1hdClcbiAgICAvKFtBLVphLXpdW0EtWmEtelxccyZcXC1cXCtcXChcXClcXC9dezMsfSlcXHMrKFxcZCspL2dpXG4gIF1cbiAgXG4gIHBhdHRlcm5zLmZvckVhY2goKHBhdHRlcm4sIHBhdHRlcm5JbmRleCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGDwn5SNIFRyeWluZyBwYXR0ZXJuICR7cGF0dGVybkluZGV4ICsgMX06ICR7cGF0dGVybn1gKVxuICAgIGNvbnN0IG1hdGNoZXMgPSBBcnJheS5mcm9tKHRleHQubWF0Y2hBbGwocGF0dGVybikpXG4gICAgY29uc29sZS5sb2coYPCfk5ogRm91bmQgJHttYXRjaGVzLmxlbmd0aH0gbWF0Y2hlcyB3aXRoIHBhdHRlcm4gJHtwYXR0ZXJuSW5kZXggKyAxfWApXG4gICAgXG4gICAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICAgIGxldCBjb3Vyc2VUaXRsZTogc3RyaW5nXG4gICAgICBsZXQgY3JlZGl0czogbnVtYmVyXG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgbWF0Y2ggcGF0dGVybnNcbiAgICAgIGlmIChwYXR0ZXJuSW5kZXggPT09IDMpIHtcbiAgICAgICAgLy8gUGF0dGVybiA0OiBOdW1iZXJlZCBjb3Vyc2VzIHdpdGggY291cnNlIGNvZGUgXCIxLiBbVGl0bGVdIChbQ29kZV0pIC0gW0NyZWRpdHNdIGNyZWRpdHNcIlxuICAgICAgICBjb3Vyc2VUaXRsZSA9IG1hdGNoWzJdLnRyaW0oKVxuICAgICAgICBjcmVkaXRzID0gcGFyc2VJbnQobWF0Y2hbNF0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBbGwgb3RoZXIgcGF0dGVybnNcbiAgICAgICAgY291cnNlVGl0bGUgPSBtYXRjaFsxXS50cmltKClcbiAgICAgICAgY3JlZGl0cyA9IHBhcnNlSW50KG1hdGNoWzJdKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDbGVhbiB1cCBjb3Vyc2UgdGl0bGUgKHJlbW92ZSBleHRyYSB3aGl0ZXNwYWNlLCBzcGVjaWFsIGNoYXJhY3RlcnMpXG4gICAgICBjb3Vyc2VUaXRsZSA9IGNvdXJzZVRpdGxlLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKClcbiAgICAgIFxuICAgICAgLy8gRm9jdXNlZCBmaWx0ZXJpbmcgZm9yIGNvdXJzZSB0aXRsZXMgYW5kIGNyZWRpdHMgb25seVxuICAgICAgY29uc3Qgc2tpcFBhdHRlcm5zID0gW1xuICAgICAgICAvXnRvdGFsL2ksXG4gICAgICAgIC9edG90YS9pLFxuICAgICAgICAvXmNyZWRpdHM/JC9pLFxuICAgICAgICAvXmNvdXJzZS9pLFxuICAgICAgICAvXnRpdGxlL2ksXG4gICAgICAgIC9ec2VtZXN0ZXIvaSxcbiAgICAgICAgL15zeWxsYWJ1cy9pLFxuICAgICAgICAvXnBhZ2UvaSxcbiAgICAgICAgL15jaGFwdGVyL2ksXG4gICAgICAgIC9ec2VjdGlvbi9pLFxuICAgICAgICAvXnRhYmxlL2ksXG4gICAgICAgIC9eZmlndXJlL2ksXG4gICAgICAgIC9eYXBwZW5kaXgvaSxcbiAgICAgICAgL15yZWZlcmVuY2UvaSxcbiAgICAgICAgL15iaWJsaW9ncmFwaHkvaSxcbiAgICAgICAgL15pbmRleC9pLFxuICAgICAgICAvXmNvbnRlbnRzL2ksXG4gICAgICAgIC9eYWJzdHJhY3QvaSxcbiAgICAgICAgL15pbnRyb2R1Y3Rpb24vaSxcbiAgICAgICAgL15jb25jbHVzaW9uL2ksXG4gICAgICAgIC9eXFxkKyQvLFxuICAgICAgICAvXlthLXpdJC9pLFxuICAgICAgICAvXlteYS16QS1aXSokLyxcbiAgICAgICAgL15bXmEtekEtWl0qW2EtekEtWl17MSwyfVteYS16QS1aXSokLyxcbiAgICAgICAgL15bQS1aXXsxLDN9JC8sIC8vIFNpbmdsZSBsZXR0ZXJzIG9yIHNob3J0IGFjcm9ueW1zXG4gICAgICAgIC9eXFxkK1thLXpBLVpdPyQvLCAvLyBOdW1iZXJzIHdpdGggb3B0aW9uYWwgbGV0dGVyXG4gICAgICAgIC9eW15hLXpBLVpdKiQvLCAvLyBObyBsZXR0ZXJzIGF0IGFsbFxuICAgICAgICAvXi57MSwyfSQvLCAvLyBWZXJ5IHNob3J0IHRleHRcbiAgICAgICAgL15bXmEtekEtWl0qW2EtekEtWl17MSwyfVteYS16QS1aXSokLywgLy8gTW9zdGx5IG5vbi1sZXR0ZXJzXG4gICAgICAgIC9edmlcXHMrc2VtZXN0ZXIvaSwgLy8gU2tpcCBcIlZJIFNFTUVTVEVSXCIgaGVhZGVyXG4gICAgICAgIC9ec2xcXC4/XFxzKm5vL2ksIC8vIFNraXAgXCJTbC4gTm9cIiBoZWFkZXJcbiAgICAgICAgL150ZWFjaGluZ1xccytob3Vycy9pLCAvLyBTa2lwIFwiVGVhY2hpbmcgSG91cnNcIiBoZWFkZXJcbiAgICAgICAgL15leGFtaW5hdGlvbi9pLCAvLyBTa2lwIFwiRXhhbWluYXRpb25cIiBoZWFkZXJcbiAgICAgICAgL150b3RhbFxccyt0ZWFjaGluZy9pLCAvLyBTa2lwIFwiVG90YWwgVGVhY2hpbmdcIiByb3dcbiAgICAgICAgL150b3RhbFxccytleGFtaW5hdGlvbi9pLCAvLyBTa2lwIFwiVG90YWwgRXhhbWluYXRpb25cIiByb3dcbiAgICAgICAgL150b3RhbFxccytjcmVkaXRzL2ksIC8vIFNraXAgXCJUb3RhbCBDcmVkaXRzXCIgcm93XG4gICAgICAgIC9lbmRzdHJlYW0vaSwgLy8gU2tpcCBQREYgY29ycnVwdGlvbiB0ZXh0XG4gICAgICAgIC9lbmRvYmovaSwgLy8gU2tpcCBQREYgY29ycnVwdGlvbiB0ZXh0XG4gICAgICAgIC94cmVmL2ksIC8vIFNraXAgUERGIGNvcnJ1cHRpb24gdGV4dFxuICAgICAgICAvXlJcXHMqXFwvSW5mby9pLCAvLyBTa2lwIFBERiBjb3JydXB0aW9uIHRleHRcbiAgICAgICAgL15zdHJlYW0vaSwgLy8gU2tpcCBQREYgY29ycnVwdGlvbiB0ZXh0XG4gICAgICAgIC9eb2JqL2ksIC8vIFNraXAgUERGIGNvcnJ1cHRpb24gdGV4dFxuICAgICAgICAvXnN0YXJ0eHJlZi9pLCAvLyBTa2lwIFBERiBjb3JydXB0aW9uIHRleHRcbiAgICAgICAgL150cmFpbGVyL2kgLy8gU2tpcCBQREYgY29ycnVwdGlvbiB0ZXh0XG4gICAgICBdXG4gICAgICBcbiAgICAgIGNvbnN0IHNob3VsZFNraXAgPSBza2lwUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChjb3Vyc2VUaXRsZSkpXG4gICAgICBcbiAgICAgIC8vIEVuaGFuY2VkIHZhbGlkYXRpb24gZm9yIGNvdXJzZSB0aXRsZXMgYW5kIGNyZWRpdHMgKHdvcmtzIHdpdGggYW55IHRhYmxlIGZvcm1hdClcbiAgICAgIGNvbnN0IGlzVmFsaWRDb3Vyc2UgPSBjb3Vyc2VUaXRsZSAmJiBcbiAgICAgICAgICBjb3Vyc2VUaXRsZS5sZW5ndGggPj0gMyAmJiAvLyBNaW5pbXVtIDMgY2hhcmFjdGVyc1xuICAgICAgICAgICFpc05hTihjcmVkaXRzKSAmJiBcbiAgICAgICAgICBjcmVkaXRzID49IDAgJiYgXG4gICAgICAgICAgY3JlZGl0cyA8PSAyMCAmJiAvLyBBbGxvdyB1cCB0byAyMCBjcmVkaXRzXG4gICAgICAgICAgIXNob3VsZFNraXAgJiZcbiAgICAgICAgICAvLyBDb3Vyc2UgdGl0bGUgbXVzdCBiZSBhIHZhbGlkIGNvdXJzZSBuYW1lXG4gICAgICAgICAgL1thLXpBLVpdLy50ZXN0KGNvdXJzZVRpdGxlKSAmJiAvLyBNdXN0IGNvbnRhaW4gbGV0dGVyc1xuICAgICAgICAgIGNvdXJzZVRpdGxlLnNwbGl0KCcgJykubGVuZ3RoID49IDEgJiYgLy8gTXVzdCBoYXZlIGF0IGxlYXN0IDEgd29yZCAoZmxleGlibGUgZm9yIHNob3J0IGNvdXJzZXMpXG4gICAgICAgICAgIWNvdXJzZVRpdGxlLm1hdGNoKC9eXFxkKy8pICYmIC8vIE11c3Qgbm90IHN0YXJ0IHdpdGggbnVtYmVyXG4gICAgICAgICAgIWNvdXJzZVRpdGxlLm1hdGNoKC9eW15hLXpBLVpdLykgJiYgLy8gTXVzdCBzdGFydCB3aXRoIGxldHRlclxuICAgICAgICAgICFjb3Vyc2VUaXRsZS5pbmNsdWRlcygnVkkgU0VNRVNURVInKSAmJiAvLyBTa2lwIGlmIGNvbnRhaW5zIGhlYWRlclxuICAgICAgICAgICFjb3Vyc2VUaXRsZS5tYXRjaCgvXltBLVpdezEsM31cXHMrW0EtWl17MSwzfSQvKSAmJiAvLyBTa2lwIHNob3J0IGFjcm9ueW1zXG4gICAgICAgICAgIWNvdXJzZVRpdGxlLmluY2x1ZGVzKCdlbmRzdHJlYW0nKSAmJiAvLyBTa2lwIFBERiBjb3JydXB0aW9uXG4gICAgICAgICAgIWNvdXJzZVRpdGxlLmluY2x1ZGVzKCdlbmRvYmonKSAmJiAvLyBTa2lwIFBERiBjb3JydXB0aW9uXG4gICAgICAgICAgIWNvdXJzZVRpdGxlLmluY2x1ZGVzKCd4cmVmJykgJiYgLy8gU2tpcCBQREYgY29ycnVwdGlvblxuICAgICAgICAgICFjb3Vyc2VUaXRsZS5pbmNsdWRlcygnUiAvSW5mbycpICYmIC8vIFNraXAgUERGIGNvcnJ1cHRpb25cbiAgICAgICAgICAhY291cnNlVGl0bGUuaW5jbHVkZXMoJ3N0cmVhbScpICYmIC8vIFNraXAgUERGIGNvcnJ1cHRpb25cbiAgICAgICAgICAhY291cnNlVGl0bGUuaW5jbHVkZXMoJ29iaicpICYmIC8vIFNraXAgUERGIGNvcnJ1cHRpb25cbiAgICAgICAgICAhY291cnNlVGl0bGUuaW5jbHVkZXMoJ3N0YXJ0eHJlZicpICYmIC8vIFNraXAgUERGIGNvcnJ1cHRpb25cbiAgICAgICAgICAhY291cnNlVGl0bGUuaW5jbHVkZXMoJ3RyYWlsZXInKSAmJiAvLyBTa2lwIFBERiBjb3JydXB0aW9uXG4gICAgICAgICAgLy8gQWRkaXRpb25hbCB2YWxpZGF0aW9uIGZvciB0YWJsZSBmb3JtYXRzXG4gICAgICAgICAgY291cnNlVGl0bGUubGVuZ3RoID49IDMgJiYgLy8gTXVzdCBiZSBhdCBsZWFzdCAzIGNoYXJhY3RlcnNcbiAgICAgICAgICAhY291cnNlVGl0bGUubWF0Y2goL15cXGQrLykgJiYgLy8gTXVzdCBub3Qgc3RhcnQgd2l0aCBudW1iZXJcbiAgICAgICAgICAhY291cnNlVGl0bGUubWF0Y2goL15bXmEtekEtWl0vKSAmJiAvLyBNdXN0IHN0YXJ0IHdpdGggbGV0dGVyXG4gICAgICAgICAgLy8gTXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBsZXR0ZXIgKGZsZXhpYmxlIGZvciB2YXJpb3VzIGNvdXJzZSBuYW1lcylcbiAgICAgICAgICAvW2EtekEtWl0vLnRlc3QoY291cnNlVGl0bGUpXG4gICAgICBcbiAgICAgIGlmIChpc1ZhbGlkQ291cnNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OWIEV4dHJhY3RlZCBjb3Vyc2UgJHtpbmRleCArIDF9OiAke2NvdXJzZVRpdGxlfSAoJHtjcmVkaXRzfSBjcmVkaXRzKWApXG4gICAgICAgIFxuICAgICAgICBjb3Vyc2VzLnB1c2goe1xuICAgICAgICAgIG51bWJlcjogKGNvdXJzZXMubGVuZ3RoICsgMSkudG9TdHJpbmcoKSxcbiAgICAgICAgICBuYW1lOiBjb3Vyc2VUaXRsZSxcbiAgICAgICAgICBjb2RlOiBgQ09VUlNFJHtjb3Vyc2VzLmxlbmd0aCArIDF9YCxcbiAgICAgICAgICBjcmVkaXRzOiBjcmVkaXRzLFxuICAgICAgICAgIGhvdXJzOiB1bmRlZmluZWQgLy8gV2Ugb25seSBuZWVkIHRpdGxlIGFuZCBjcmVkaXRzXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGNvdXJzZVRpdGxlICYmIGNvdXJzZVRpdGxlLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBTa2lwcGVkIGludmFsaWQgY291cnNlOiBcIiR7Y291cnNlVGl0bGV9XCIgKCR7Y3JlZGl0c30gY3JlZGl0cylgKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG4gIFxuICAvLyBSZW1vdmUgZHVwbGljYXRlcyBiYXNlZCBvbiBjb3Vyc2UgbmFtZSAoY2FzZS1pbnNlbnNpdGl2ZSBhbmQgc2ltaWxhciBuYW1lcylcbiAgY29uc3QgdW5pcXVlQ291cnNlcyA9IGNvdXJzZXMuZmlsdGVyKChjb3Vyc2UsIGluZGV4LCBzZWxmKSA9PiBcbiAgICBpbmRleCA9PT0gc2VsZi5maW5kSW5kZXgoYyA9PiB7XG4gICAgICBjb25zdCBuYW1lMSA9IGMubmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKClcbiAgICAgIGNvbnN0IG5hbWUyID0gY291cnNlLm5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpXG4gICAgICByZXR1cm4gbmFtZTEgPT09IG5hbWUyIHx8IFxuICAgICAgICAgICAgIChuYW1lMS5pbmNsdWRlcygnY3JlZGl0cycpICYmIG5hbWUyID09PSBuYW1lMS5yZXBsYWNlKCcgY3JlZGl0cycsICcnKSkgfHxcbiAgICAgICAgICAgICAobmFtZTIuaW5jbHVkZXMoJ2NyZWRpdHMnKSAmJiBuYW1lMSA9PT0gbmFtZTIucmVwbGFjZSgnIGNyZWRpdHMnLCAnJykpIHx8XG4gICAgICAgICAgICAgKG5hbWUxID09PSBuYW1lMi5yZXBsYWNlKCcgY3JlZGl0cycsICcnKSkgfHxcbiAgICAgICAgICAgICAobmFtZTIgPT09IG5hbWUxLnJlcGxhY2UoJyBjcmVkaXRzJywgJycpKVxuICAgIH0pXG4gIClcbiAgXG4gIGNvbnNvbGUubG9nKGDinIUgRXh0cmFjdGVkICR7dW5pcXVlQ291cnNlcy5sZW5ndGh9IHVuaXF1ZSBjb3Vyc2VzYClcbiAgcmV0dXJuIHVuaXF1ZUNvdXJzZXNcbn1cblxuLy8gRXh0cmFjdCBjb3Vyc2Ugc2VjdGlvbiBmcm9tIHRleHRcbmZ1bmN0aW9uIGV4dHJhY3RDb3Vyc2VTZWN0aW9uKHRleHQ6IHN0cmluZywgY291cnNlTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKVxuICBsZXQgY291cnNlU2VjdGlvbiA9ICcnXG4gIGxldCBmb3VuZENvdXJzZSA9IGZhbHNlXG4gIFxuICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBpZiAobGluZS5pbmNsdWRlcyhjb3Vyc2VOYW1lKSkge1xuICAgICAgZm91bmRDb3Vyc2UgPSB0cnVlXG4gICAgICBjb3Vyc2VTZWN0aW9uICs9IGxpbmUgKyAnXFxuJ1xuICAgIH0gZWxzZSBpZiAoZm91bmRDb3Vyc2UgJiYgKGxpbmUubWF0Y2goL15cXGQrW1xcLlxcKVxcLVxcc10vKSB8fCBsaW5lLmluY2x1ZGVzKCdUT1RBTDonKSB8fCBsaW5lLmluY2x1ZGVzKCdDT1VSU0UgU1RSVUNUVVJFJykpKSB7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSBpZiAoZm91bmRDb3Vyc2UpIHtcbiAgICAgIGNvdXJzZVNlY3Rpb24gKz0gbGluZSArICdcXG4nXG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gY291cnNlU2VjdGlvblxufVxuXG4vLyBFeHRyYWN0IGNyZWRpdHMgZnJvbSBjb3Vyc2Ugc2VjdGlvblxuZnVuY3Rpb24gZXh0cmFjdENyZWRpdHNGcm9tVGV4dChzZWN0aW9uOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBjb25zdCBwYXR0ZXJucyA9IFtcbiAgICAvQ3JlZGl0cz86XFxzKihcXGQrKS9pLFxuICAgIC9DcmVkaXQ6XFxzKihcXGQrKS9pLFxuICAgIC8oXFxkKylcXHMqY3JlZGl0cz8vaSxcbiAgICAvKFxcZCspXFxzKmNyZWRpdC9pXG4gIF1cbiAgXG4gIGZvciAoY29uc3QgcGF0dGVybiBvZiBwYXR0ZXJucykge1xuICAgIGNvbnN0IG1hdGNoID0gc2VjdGlvbi5tYXRjaChwYXR0ZXJuKVxuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KG1hdGNoWzFdKVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG4vLyBFeHRyYWN0IGhvdXJzIGZyb20gY291cnNlIHNlY3Rpb25cbmZ1bmN0aW9uIGV4dHJhY3RIb3Vyc0Zyb21UZXh0KHNlY3Rpb246IHN0cmluZyk6IHsgdGhlb3J5OiBudW1iZXI7IHR1dG9yaWFsOiBudW1iZXI7IHByYWN0aWNhbDogbnVtYmVyIH0gfCB1bmRlZmluZWQge1xuICBjb25zdCB0aGVvcnlNYXRjaCA9IHNlY3Rpb24ubWF0Y2goL1RoZW9yeVs6XFxzXSooXFxkKykvaSlcbiAgY29uc3QgdHV0b3JpYWxNYXRjaCA9IHNlY3Rpb24ubWF0Y2goL1R1dG9yaWFsWzpcXHNdKihcXGQrKS9pKVxuICBjb25zdCBwcmFjdGljYWxNYXRjaCA9IHNlY3Rpb24ubWF0Y2goL1ByYWN0aWNhbFs6XFxzXSooXFxkKykvaSlcbiAgXG4gIGlmICh0aGVvcnlNYXRjaCB8fCB0dXRvcmlhbE1hdGNoIHx8IHByYWN0aWNhbE1hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRoZW9yeTogdGhlb3J5TWF0Y2ggPyBwYXJzZUludCh0aGVvcnlNYXRjaFsxXSkgOiAwLFxuICAgICAgdHV0b3JpYWw6IHR1dG9yaWFsTWF0Y2ggPyBwYXJzZUludCh0dXRvcmlhbE1hdGNoWzFdKSA6IDAsXG4gICAgICBwcmFjdGljYWw6IHByYWN0aWNhbE1hdGNoID8gcGFyc2VJbnQocHJhY3RpY2FsTWF0Y2hbMV0pIDogMFxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG4vLyBGdW5jdGlvbnMgYXJlIGFscmVhZHkgZXhwb3J0ZWQgYWJvdmVcbiJdLCJuYW1lcyI6WyJleHRyYWN0VGV4dEZyb21QREYiLCJmaWxlIiwiY29uc29sZSIsImxvZyIsIm5hbWUiLCJzaXplIiwiYXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiZXh0cmFjdGVkVGV4dCIsInBhZ2VDb3VudCIsInBkZmpzTGliIiwiR2xvYmFsV29ya2VyT3B0aW9ucyIsIndvcmtlclNyYyIsInBkZiIsImdldERvY3VtZW50IiwiZGF0YSIsInVzZVdvcmtlckZldGNoIiwiaXNFdmFsU3VwcG9ydGVkIiwidXNlU3lzdGVtRm9udHMiLCJkaXNhYmxlRm9udEZhY2UiLCJkaXNhYmxlUmFuZ2UiLCJkaXNhYmxlU3RyZWFtIiwicHJvbWlzZSIsIm51bVBhZ2VzIiwicGFnZU51bSIsInBhZ2UiLCJnZXRQYWdlIiwidGV4dENvbnRlbnQiLCJnZXRUZXh0Q29udGVudCIsInBhZ2VUZXh0IiwiaXRlbXMiLCJtYXAiLCJpdGVtIiwiaGFzRU9MIiwic3RyIiwiam9pbiIsInJlcGxhY2UiLCJwYWdlRXJyb3IiLCJ3YXJuIiwicGRmanNFcnJvciIsInBkZlBhcnNlIiwiYnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsImRlZmF1bHQiLCJ0ZXh0IiwibnVtcGFnZXMiLCJwZGZQYXJzZUVycm9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwiZSIsInJlc3VsdCIsInRhcmdldCIsIm9uZXJyb3IiLCJFcnJvciIsInJlYWRBc1RleHQiLCJsZW5ndGgiLCJzdWJzdHJpbmciLCJpbmNsdWRlcyIsInBhZ2VzIiwibWV0YWRhdGEiLCJ0aXRsZSIsImF1dGhvciIsImNyZWF0aW9uRGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImVycm9yIiwibWVzc2FnZSIsImV4dHJhY3RDb3Vyc2VzRnJvbVRleHQiLCJjb3Vyc2VzIiwicGF0dGVybnMiLCJmb3JFYWNoIiwicGF0dGVybiIsInBhdHRlcm5JbmRleCIsIm1hdGNoZXMiLCJBcnJheSIsIm1hdGNoQWxsIiwibWF0Y2giLCJpbmRleCIsImNvdXJzZVRpdGxlIiwiY3JlZGl0cyIsInRyaW0iLCJwYXJzZUludCIsInNraXBQYXR0ZXJucyIsInNob3VsZFNraXAiLCJzb21lIiwidGVzdCIsImlzVmFsaWRDb3Vyc2UiLCJpc05hTiIsInNwbGl0IiwicHVzaCIsIm51bWJlciIsInRvU3RyaW5nIiwiY29kZSIsImhvdXJzIiwidW5kZWZpbmVkIiwidW5pcXVlQ291cnNlcyIsImZpbHRlciIsImNvdXJzZSIsInNlbGYiLCJmaW5kSW5kZXgiLCJjIiwibmFtZTEiLCJ0b0xvd2VyQ2FzZSIsIm5hbWUyIiwiZXh0cmFjdENvdXJzZVNlY3Rpb24iLCJjb3Vyc2VOYW1lIiwibGluZXMiLCJjb3Vyc2VTZWN0aW9uIiwiZm91bmRDb3Vyc2UiLCJsaW5lIiwiZXh0cmFjdENyZWRpdHNGcm9tVGV4dCIsInNlY3Rpb24iLCJleHRyYWN0SG91cnNGcm9tVGV4dCIsInRoZW9yeU1hdGNoIiwidHV0b3JpYWxNYXRjaCIsInByYWN0aWNhbE1hdGNoIiwidGhlb3J5IiwidHV0b3JpYWwiLCJwcmFjdGljYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/real-pdf-parser.ts\n"));

/***/ })

}]);