"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_lib_real-pdf-parser_ts";
exports.ids = ["_ssr_lib_real-pdf-parser_ts"];
exports.modules = {

/***/ "(ssr)/./lib/real-pdf-parser.ts":
/*!********************************!*\
  !*** ./lib/real-pdf-parser.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractCoursesFromText: () => (/* binding */ extractCoursesFromText),\n/* harmony export */   extractTextFromPDF: () => (/* binding */ extractTextFromPDF)\n/* harmony export */ });\n// Real PDF parsing implementation\n// This would use actual PDF parsing libraries to extract text from uploaded PDFs\n// Real PDF text extraction using pdf-parse library\nasync function extractTextFromPDF(file) {\n    try {\n        console.log(`üìÑ Extracting text from PDF: ${file.name}`);\n        // REAL PDF PARSING - Extract actual content from uploaded PDF\n        console.log(`üìÑ Parsing actual PDF content from: ${file.name}`);\n        console.log(`üìÑ File size: ${file.size} bytes`);\n        // Use a more reliable PDF parsing approach\n        try {\n            const arrayBuffer = await file.arrayBuffer();\n            console.log(`üìÑ PDF file size: ${arrayBuffer.byteLength} bytes`);\n            // Try multiple PDF parsing approaches\n            let extractedText = \"\";\n            let pageCount = 1;\n            // Approach 1: Try pdfjs-dist with optimized settings\n            try {\n                const pdfjsLib = await __webpack_require__.e(/*! import() */ \"vendor-chunks/pdfjs-dist\").then(__webpack_require__.bind(__webpack_require__, /*! pdfjs-dist */ \"(ssr)/./node_modules/pdfjs-dist/build/pdf.mjs\"));\n                // Use a more reliable worker source\n                pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;\n                const pdf = await pdfjsLib.getDocument({\n                    data: arrayBuffer,\n                    useWorkerFetch: false,\n                    isEvalSupported: false,\n                    useSystemFonts: true,\n                    disableFontFace: true,\n                    disableRange: true,\n                    disableStream: true\n                }).promise;\n                console.log(`üìÑ PDF loaded: ${pdf.numPages} pages`);\n                pageCount = pdf.numPages;\n                // Extract text from all pages with enhanced table format support\n                for(let pageNum = 1; pageNum <= pdf.numPages; pageNum++){\n                    try {\n                        const page = await pdf.getPage(pageNum);\n                        const textContent = await page.getTextContent();\n                        // Enhanced text extraction for table formats\n                        const pageText = textContent.items.map((item)=>{\n                            // Preserve line breaks and spacing for table formats\n                            if (item.hasEOL) {\n                                return item.str + \"\\n\";\n                            }\n                            return item.str + \" \";\n                        }).join(\"\").replace(/\\s+/g, \" \") // Normalize whitespace\n                        .replace(/\\n\\s+/g, \"\\n\") // Clean up line breaks\n                        ;\n                        extractedText += pageText + \"\\n\";\n                    } catch (pageError) {\n                        console.warn(`‚ö†Ô∏è Could not extract text from page ${pageNum}:`, pageError);\n                    }\n                }\n                console.log(`‚úÖ Successfully extracted text from ${pdf.numPages} pages`);\n            } catch (pdfjsError) {\n                console.warn(\"‚ö†Ô∏è pdfjs-dist failed, trying alternative approach:\", pdfjsError);\n                // Approach 2: Try using a different PDF parsing library\n                try {\n                    // Use pdf-parse as a fallback (if available)\n                    const pdfParse = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/pdf-parse\"), __webpack_require__.e(\"_ssr_node_modules_pdf-parse_lib_pdf_js_sync_recursive_build_pdf_js_\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! pdf-parse */ \"(ssr)/./node_modules/pdf-parse/index.js\", 23));\n                    const buffer = Buffer.from(arrayBuffer);\n                    const data = await pdfParse.default(buffer);\n                    extractedText = data.text;\n                    pageCount = data.numpages;\n                    console.log(`‚úÖ Successfully extracted text using pdf-parse`);\n                } catch (pdfParseError) {\n                    console.warn(\"‚ö†Ô∏è pdf-parse failed, trying basic text extraction:\", pdfParseError);\n                    // Approach 3: Basic text extraction as last resort\n                    const text = await new Promise((resolve, reject)=>{\n                        const reader = new FileReader();\n                        reader.onload = (e)=>{\n                            const result = e.target?.result;\n                            resolve(result || \"\");\n                        };\n                        reader.onerror = ()=>reject(new Error(\"Failed to read PDF file\"));\n                        reader.readAsText(file);\n                    });\n                    extractedText = text;\n                    console.log(`‚úÖ Using basic text extraction`);\n                }\n            }\n            console.log(`üìÑ Extracted text length: ${extractedText.length} characters`);\n            console.log(`üìÑ Text preview: ${extractedText.substring(0, 200)}...`);\n            // If no text was extracted, throw an error instead of using hardcoded data\n            if (extractedText.length === 0) {\n                throw new Error(\"No text could be extracted from the PDF. Please try a different PDF file.\");\n            }\n            // If extracted text looks corrupted, throw an error\n            if (extractedText.includes(\"endstream\") || extractedText.includes(\"endobj\") || extractedText.includes(\"xref\")) {\n                throw new Error(\"PDF appears to be corrupted or encrypted. Please try a different PDF file.\");\n            }\n            return {\n                text: extractedText,\n                pages: pageCount,\n                metadata: {\n                    title: file.name.replace(\".pdf\", \"\"),\n                    author: \"Unknown\",\n                    creationDate: new Date().toISOString()\n                }\n            };\n        } catch (error) {\n            console.error(\"‚ùå All PDF parsing methods failed:\", error);\n            throw new Error(`Failed to parse PDF: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n        }\n    } catch (error) {\n        console.error(\"‚ùå Error extracting text from PDF:\", error);\n        throw error;\n    }\n}\n// Enhanced course extraction with multiple patterns\nfunction extractCoursesFromText(text) {\n    const courses = [];\n    console.log(\"\\uD83D\\uDD0D Extracting courses from PDF text...\");\n    console.log(`üìÑ Text length: ${text.length} characters`);\n    console.log(`üìÑ Text preview: ${text.substring(0, 500)}...`);\n    // Comprehensive patterns to extract Course Title and Credits from ANY table format PDF\n    const patterns = [\n        // Pattern 1: \"Course Title: [Title]\" followed by \"Credits: [Number]\"\n        /Course Title:\\s*([^\\n\\r]+)\\s*[\\n\\r]+Credits:\\s*(\\d+)/gi,\n        // Pattern 2: \"Course Title: [Title]\" and \"Credits: [Number]\" on separate lines\n        /Course Title:\\s*([^\\n\\r]+).*?Credits:\\s*(\\d+)/gi,\n        // Pattern 3: Table format with title and credits\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s+(\\d+)\\s*credits?/gi,\n        // Pattern 4: Numbered courses \"1. [Title] ([Code]) - [Credits] credits\"\n        /(\\d+)\\.\\s*([^(]+?)\\s*\\(([^)]+)\\)\\s*[-\\s]*(\\d+)\\s*credits?/gi,\n        // Pattern 5: Generic course format \"[Title] - [Credits] Credits\"\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s*-\\s*(\\d+)\\s*Credits?/gi,\n        // Pattern 6: Course name followed by credits in parentheses\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s*\\((\\d+)\\s*credits?\\)/gi,\n        // Pattern 7: Simple format \"Subject Name Credits: X\"\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s+Credits:\\s*(\\d+)/gi,\n        // Pattern 8: Course name with credits at end of line\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s+(\\d+)\\s*$/gm,\n        // Pattern 9: Course name followed by credits (space separated)\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s+(\\d+)\\s*credits?/gi,\n        // Pattern 10: Course name with credits after colon\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?):\\s*(\\d+)/gi,\n        // Pattern 11: Table format - Course title followed by credits (for VI Semester format)\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s+(\\d+)\\s*$/gm,\n        // Pattern 12: Course title with credits in table format\n        /([A-Za-z\\s&\\-\\+\\(\\)\\/]+?)\\s+(\\d+)\\s*$/gm,\n        // Pattern 13: Generic course pattern (removed hardcoded course names)\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{4,})\\s+(\\d+)/gi,\n        // Pattern 14: Course titles with credits (space separated)\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{2,})\\s+(\\d+)\\s*$/gm,\n        // Pattern 15: Very broad pattern for any text followed by number\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{1,})\\s+(\\d+)/gi,\n        // Pattern 16: Table row format - Course name with credits (enhanced for table formats)\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{3,})\\s+(\\d+)\\s*$/gm,\n        // Pattern 17: Course name with credits (tab or space separated)\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{3,})\\s+(\\d+)\\s*$/gm,\n        // Pattern 18: Course name with credits (multiple spaces)\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{3,})\\s+(\\d+)\\s*$/gm,\n        // Pattern 19: Course name with credits (end of line)\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{3,})\\s+(\\d+)\\s*$/gm,\n        // Pattern 20: Course name with credits (any format)\n        /([A-Za-z][A-Za-z\\s&\\-\\+\\(\\)\\/]{3,})\\s+(\\d+)/gi\n    ];\n    patterns.forEach((pattern, patternIndex)=>{\n        console.log(`üîç Trying pattern ${patternIndex + 1}: ${pattern}`);\n        const matches = Array.from(text.matchAll(pattern));\n        console.log(`üìö Found ${matches.length} matches with pattern ${patternIndex + 1}`);\n        matches.forEach((match, index)=>{\n            let courseTitle;\n            let credits;\n            // Handle different match patterns\n            if (patternIndex === 3) {\n                // Pattern 4: Numbered courses with course code \"1. [Title] ([Code]) - [Credits] credits\"\n                courseTitle = match[2].trim();\n                credits = parseInt(match[4]);\n            } else {\n                // All other patterns\n                courseTitle = match[1].trim();\n                credits = parseInt(match[2]);\n            }\n            // Clean up course title (remove extra whitespace, special characters)\n            courseTitle = courseTitle.replace(/\\s+/g, \" \").trim();\n            // Focused filtering for course titles and credits only\n            const skipPatterns = [\n                /^total/i,\n                /^tota/i,\n                /^credits?$/i,\n                /^course/i,\n                /^title/i,\n                /^semester/i,\n                /^syllabus/i,\n                /^page/i,\n                /^chapter/i,\n                /^section/i,\n                /^table/i,\n                /^figure/i,\n                /^appendix/i,\n                /^reference/i,\n                /^bibliography/i,\n                /^index/i,\n                /^contents/i,\n                /^abstract/i,\n                /^introduction/i,\n                /^conclusion/i,\n                /^\\d+$/,\n                /^[a-z]$/i,\n                /^[^a-zA-Z]*$/,\n                /^[^a-zA-Z]*[a-zA-Z]{1,2}[^a-zA-Z]*$/,\n                /^[A-Z]{1,3}$/,\n                /^\\d+[a-zA-Z]?$/,\n                /^[^a-zA-Z]*$/,\n                /^.{1,2}$/,\n                /^[^a-zA-Z]*[a-zA-Z]{1,2}[^a-zA-Z]*$/,\n                /^vi\\s+semester/i,\n                /^sl\\.?\\s*no/i,\n                /^teaching\\s+hours/i,\n                /^examination/i,\n                /^total\\s+teaching/i,\n                /^total\\s+examination/i,\n                /^total\\s+credits/i,\n                /endstream/i,\n                /endobj/i,\n                /xref/i,\n                /^R\\s*\\/Info/i,\n                /^stream/i,\n                /^obj/i,\n                /^startxref/i,\n                /^trailer/i // Skip PDF corruption text\n            ];\n            const shouldSkip = skipPatterns.some((pattern)=>pattern.test(courseTitle));\n            // Enhanced validation for course titles and credits (works with any table format)\n            const isValidCourse = courseTitle && courseTitle.length >= 3 && // Minimum 3 characters\n            !isNaN(credits) && credits >= 0 && credits <= 20 && // Allow up to 20 credits\n            !shouldSkip && // Course title must be a valid course name\n            /[a-zA-Z]/.test(courseTitle) && // Must contain letters\n            courseTitle.split(\" \").length >= 1 && // Must have at least 1 word (flexible for short courses)\n            !courseTitle.match(/^\\d+/) && // Must not start with number\n            !courseTitle.match(/^[^a-zA-Z]/) && // Must start with letter\n            !courseTitle.includes(\"VI SEMESTER\") && // Skip if contains header\n            !courseTitle.match(/^[A-Z]{1,3}\\s+[A-Z]{1,3}$/) && // Skip short acronyms\n            !courseTitle.includes(\"endstream\") && // Skip PDF corruption\n            !courseTitle.includes(\"endobj\") && // Skip PDF corruption\n            !courseTitle.includes(\"xref\") && // Skip PDF corruption\n            !courseTitle.includes(\"R /Info\") && // Skip PDF corruption\n            !courseTitle.includes(\"stream\") && // Skip PDF corruption\n            !courseTitle.includes(\"obj\") && // Skip PDF corruption\n            !courseTitle.includes(\"startxref\") && // Skip PDF corruption\n            !courseTitle.includes(\"trailer\") && // Skip PDF corruption\n            // Additional validation for table formats\n            courseTitle.length >= 3 && // Must be at least 3 characters\n            !courseTitle.match(/^\\d+/) && // Must not start with number\n            !courseTitle.match(/^[^a-zA-Z]/) && // Must start with letter\n            // Must contain at least one letter (flexible for various course names)\n            /[a-zA-Z]/.test(courseTitle);\n            if (isValidCourse) {\n                console.log(`üìñ Extracted course ${index + 1}: ${courseTitle} (${credits} credits)`);\n                courses.push({\n                    number: (courses.length + 1).toString(),\n                    name: courseTitle,\n                    code: `COURSE${courses.length + 1}`,\n                    credits: credits,\n                    hours: undefined // We only need title and credits\n                });\n            } else if (courseTitle && courseTitle.length > 3) {\n                console.log(`‚ö†Ô∏è Skipped invalid course: \"${courseTitle}\" (${credits} credits)`);\n            }\n        });\n    });\n    // Remove duplicates based on course name (case-insensitive and similar names)\n    const uniqueCourses = courses.filter((course, index, self)=>index === self.findIndex((c)=>{\n            const name1 = c.name.toLowerCase().replace(/\\s+/g, \" \").trim();\n            const name2 = course.name.toLowerCase().replace(/\\s+/g, \" \").trim();\n            return name1 === name2 || name1.includes(\"credits\") && name2 === name1.replace(\" credits\", \"\") || name2.includes(\"credits\") && name1 === name2.replace(\" credits\", \"\") || name1 === name2.replace(\" credits\", \"\") || name2 === name1.replace(\" credits\", \"\");\n        }));\n    console.log(`‚úÖ Extracted ${uniqueCourses.length} unique courses`);\n    return uniqueCourses;\n}\n// Extract course section from text\nfunction extractCourseSection(text, courseName) {\n    const lines = text.split(\"\\n\");\n    let courseSection = \"\";\n    let foundCourse = false;\n    for (const line of lines){\n        if (line.includes(courseName)) {\n            foundCourse = true;\n            courseSection += line + \"\\n\";\n        } else if (foundCourse && (line.match(/^\\d+[\\.\\)\\-\\s]/) || line.includes(\"TOTAL:\") || line.includes(\"COURSE STRUCTURE\"))) {\n            break;\n        } else if (foundCourse) {\n            courseSection += line + \"\\n\";\n        }\n    }\n    return courseSection;\n}\n// Extract credits from course section\nfunction extractCreditsFromText(section) {\n    const patterns = [\n        /Credits?:\\s*(\\d+)/i,\n        /Credit:\\s*(\\d+)/i,\n        /(\\d+)\\s*credits?/i,\n        /(\\d+)\\s*credit/i\n    ];\n    for (const pattern of patterns){\n        const match = section.match(pattern);\n        if (match) {\n            return parseInt(match[1]);\n        }\n    }\n    return undefined;\n}\n// Extract hours from course section\nfunction extractHoursFromText(section) {\n    const theoryMatch = section.match(/Theory[:\\s]*(\\d+)/i);\n    const tutorialMatch = section.match(/Tutorial[:\\s]*(\\d+)/i);\n    const practicalMatch = section.match(/Practical[:\\s]*(\\d+)/i);\n    if (theoryMatch || tutorialMatch || practicalMatch) {\n        return {\n            theory: theoryMatch ? parseInt(theoryMatch[1]) : 0,\n            tutorial: tutorialMatch ? parseInt(tutorialMatch[1]) : 0,\n            practical: practicalMatch ? parseInt(practicalMatch[1]) : 0\n        };\n    }\n    return undefined;\n} // Functions are already exported above\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWVDLGlCQUFpQkMsZ0JBQWdCO1FBQ2xELE9BQU87WUFDTEMsUUFBUUgsY0FBY2hDLFNBQVNnQyxXQUFXLENBQUMsRUFBRSxJQUFJO1lBQ2pESSxVQUFVSCxnQkFBZ0JqQyxTQUFTaUMsYUFBYSxDQUFDLEVBQUUsSUFBSTtZQUN2REksV0FBV0gsaUJBQWlCbEMsU0FBU2tDLGNBQWMsQ0FBQyxFQUFFLElBQUk7UUFDNUQ7SUFDRjtJQUVBLE9BQU9yQjtBQUNULEVBRUEsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtdGltZXRhYmxlLWdlbmVyYXRvci8uL2xpYi9yZWFsLXBkZi1wYXJzZXIudHM/YTg0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSZWFsIFBERiBwYXJzaW5nIGltcGxlbWVudGF0aW9uXG4vLyBUaGlzIHdvdWxkIHVzZSBhY3R1YWwgUERGIHBhcnNpbmcgbGlicmFyaWVzIHRvIGV4dHJhY3QgdGV4dCBmcm9tIHVwbG9hZGVkIFBERnNcblxuZXhwb3J0IGludGVyZmFjZSBQREZQYXJzZVJlc3VsdCB7XG4gIHRleHQ6IHN0cmluZ1xuICBwYWdlczogbnVtYmVyXG4gIG1ldGFkYXRhOiB7XG4gICAgdGl0bGU/OiBzdHJpbmdcbiAgICBhdXRob3I/OiBzdHJpbmdcbiAgICBjcmVhdGlvbkRhdGU/OiBzdHJpbmdcbiAgfVxufVxuXG4vLyBSZWFsIFBERiB0ZXh0IGV4dHJhY3Rpb24gdXNpbmcgcGRmLXBhcnNlIGxpYnJhcnlcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHRyYWN0VGV4dEZyb21QREYoZmlsZTogRmlsZSk6IFByb21pc2U8UERGUGFyc2VSZXN1bHQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhg8J+ThCBFeHRyYWN0aW5nIHRleHQgZnJvbSBQREY6ICR7ZmlsZS5uYW1lfWApXG4gICAgXG4gICAgLy8gUkVBTCBQREYgUEFSU0lORyAtIEV4dHJhY3QgYWN0dWFsIGNvbnRlbnQgZnJvbSB1cGxvYWRlZCBQREZcbiAgICBjb25zb2xlLmxvZyhg8J+ThCBQYXJzaW5nIGFjdHVhbCBQREYgY29udGVudCBmcm9tOiAke2ZpbGUubmFtZX1gKVxuICAgIGNvbnNvbGUubG9nKGDwn5OEIEZpbGUgc2l6ZTogJHtmaWxlLnNpemV9IGJ5dGVzYClcbiAgICBcbiAgICAvLyBVc2UgYSBtb3JlIHJlbGlhYmxlIFBERiBwYXJzaW5nIGFwcHJvYWNoXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpXG4gICAgICBjb25zb2xlLmxvZyhg8J+ThCBQREYgZmlsZSBzaXplOiAke2FycmF5QnVmZmVyLmJ5dGVMZW5ndGh9IGJ5dGVzYClcbiAgICAgIFxuICAgICAgLy8gVHJ5IG11bHRpcGxlIFBERiBwYXJzaW5nIGFwcHJvYWNoZXNcbiAgICAgIGxldCBleHRyYWN0ZWRUZXh0ID0gJydcbiAgICAgIGxldCBwYWdlQ291bnQgPSAxXG4gICAgICBcbiAgICAgICAgLy8gQXBwcm9hY2ggMTogVHJ5IHBkZmpzLWRpc3Qgd2l0aCBvcHRpbWl6ZWQgc2V0dGluZ3NcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwZGZqc0xpYiA9IGF3YWl0IGltcG9ydCgncGRmanMtZGlzdCcpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXNlIGEgbW9yZSByZWxpYWJsZSB3b3JrZXIgc291cmNlXG4gICAgICAgICAgcGRmanNMaWIuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgPSBgaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvcGRmLmpzLzMuMTEuMTc0L3BkZi53b3JrZXIubWluLmpzYFxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHBkZiA9IGF3YWl0IHBkZmpzTGliLmdldERvY3VtZW50KHsgXG4gICAgICAgICAgICBkYXRhOiBhcnJheUJ1ZmZlcixcbiAgICAgICAgICAgIHVzZVdvcmtlckZldGNoOiBmYWxzZSxcbiAgICAgICAgICAgIGlzRXZhbFN1cHBvcnRlZDogZmFsc2UsXG4gICAgICAgICAgICB1c2VTeXN0ZW1Gb250czogdHJ1ZSxcbiAgICAgICAgICAgIGRpc2FibGVGb250RmFjZTogdHJ1ZSxcbiAgICAgICAgICAgIGRpc2FibGVSYW5nZTogdHJ1ZSxcbiAgICAgICAgICAgIGRpc2FibGVTdHJlYW06IHRydWVcbiAgICAgICAgICB9KS5wcm9taXNlXG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+ThCBQREYgbG9hZGVkOiAke3BkZi5udW1QYWdlc30gcGFnZXNgKVxuICAgICAgICBwYWdlQ291bnQgPSBwZGYubnVtUGFnZXNcbiAgICAgICAgXG4gICAgICAgIC8vIEV4dHJhY3QgdGV4dCBmcm9tIGFsbCBwYWdlcyB3aXRoIGVuaGFuY2VkIHRhYmxlIGZvcm1hdCBzdXBwb3J0XG4gICAgICAgIGZvciAobGV0IHBhZ2VOdW0gPSAxOyBwYWdlTnVtIDw9IHBkZi5udW1QYWdlczsgcGFnZU51bSsrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBwZGYuZ2V0UGFnZShwYWdlTnVtKVxuICAgICAgICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSBhd2FpdCBwYWdlLmdldFRleHRDb250ZW50KClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRW5oYW5jZWQgdGV4dCBleHRyYWN0aW9uIGZvciB0YWJsZSBmb3JtYXRzXG4gICAgICAgICAgICBjb25zdCBwYWdlVGV4dCA9IHRleHRDb250ZW50Lml0ZW1zXG4gICAgICAgICAgICAgIC5tYXAoKGl0ZW06IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIGxpbmUgYnJlYWtzIGFuZCBzcGFjaW5nIGZvciB0YWJsZSBmb3JtYXRzXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaGFzRU9MKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5zdHIgKyAnXFxuJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5zdHIgKyAnICdcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmpvaW4oJycpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJykgLy8gTm9ybWFsaXplIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcblxccysvZywgJ1xcbicpIC8vIENsZWFuIHVwIGxpbmUgYnJlYWtzXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4dHJhY3RlZFRleHQgKz0gcGFnZVRleHQgKyAnXFxuJ1xuICAgICAgICAgIH0gY2F0Y2ggKHBhZ2VFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gQ291bGQgbm90IGV4dHJhY3QgdGV4dCBmcm9tIHBhZ2UgJHtwYWdlTnVtfTpgLCBwYWdlRXJyb3IpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSBleHRyYWN0ZWQgdGV4dCBmcm9tICR7cGRmLm51bVBhZ2VzfSBwYWdlc2ApXG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAocGRmanNFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBwZGZqcy1kaXN0IGZhaWxlZCwgdHJ5aW5nIGFsdGVybmF0aXZlIGFwcHJvYWNoOicsIHBkZmpzRXJyb3IpXG4gICAgICAgIFxuICAgICAgICAvLyBBcHByb2FjaCAyOiBUcnkgdXNpbmcgYSBkaWZmZXJlbnQgUERGIHBhcnNpbmcgbGlicmFyeVxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFVzZSBwZGYtcGFyc2UgYXMgYSBmYWxsYmFjayAoaWYgYXZhaWxhYmxlKVxuICAgICAgICAgIGNvbnN0IHBkZlBhcnNlID0gYXdhaXQgaW1wb3J0KCdwZGYtcGFyc2UnKVxuICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyKVxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwZGZQYXJzZS5kZWZhdWx0KGJ1ZmZlcilcbiAgICAgICAgICBcbiAgICAgICAgICBleHRyYWN0ZWRUZXh0ID0gZGF0YS50ZXh0XG4gICAgICAgICAgcGFnZUNvdW50ID0gZGF0YS5udW1wYWdlc1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgU3VjY2Vzc2Z1bGx5IGV4dHJhY3RlZCB0ZXh0IHVzaW5nIHBkZi1wYXJzZWApXG4gICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKHBkZlBhcnNlRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBwZGYtcGFyc2UgZmFpbGVkLCB0cnlpbmcgYmFzaWMgdGV4dCBleHRyYWN0aW9uOicsIHBkZlBhcnNlRXJyb3IpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQXBwcm9hY2ggMzogQmFzaWMgdGV4dCBleHRyYWN0aW9uIGFzIGxhc3QgcmVzb3J0XG4gICAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IG5ldyBQcm9taXNlPHN0cmluZz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGUudGFyZ2V0Py5yZXN1bHQgYXMgc3RyaW5nXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0IHx8ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gcmVhZCBQREYgZmlsZScpKVxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIFxuICAgICAgICAgIGV4dHJhY3RlZFRleHQgPSB0ZXh0XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBVc2luZyBiYXNpYyB0ZXh0IGV4dHJhY3Rpb25gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OEIEV4dHJhY3RlZCB0ZXh0IGxlbmd0aDogJHtleHRyYWN0ZWRUZXh0Lmxlbmd0aH0gY2hhcmFjdGVyc2ApXG4gICAgICBjb25zb2xlLmxvZyhg8J+ThCBUZXh0IHByZXZpZXc6ICR7ZXh0cmFjdGVkVGV4dC5zdWJzdHJpbmcoMCwgMjAwKX0uLi5gKVxuICAgICAgXG4gICAgICAvLyBJZiBubyB0ZXh0IHdhcyBleHRyYWN0ZWQsIHRocm93IGFuIGVycm9yIGluc3RlYWQgb2YgdXNpbmcgaGFyZGNvZGVkIGRhdGFcbiAgICAgIGlmIChleHRyYWN0ZWRUZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRleHQgY291bGQgYmUgZXh0cmFjdGVkIGZyb20gdGhlIFBERi4gUGxlYXNlIHRyeSBhIGRpZmZlcmVudCBQREYgZmlsZS4nKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiBleHRyYWN0ZWQgdGV4dCBsb29rcyBjb3JydXB0ZWQsIHRocm93IGFuIGVycm9yXG4gICAgICBpZiAoZXh0cmFjdGVkVGV4dC5pbmNsdWRlcygnZW5kc3RyZWFtJykgfHwgZXh0cmFjdGVkVGV4dC5pbmNsdWRlcygnZW5kb2JqJykgfHwgZXh0cmFjdGVkVGV4dC5pbmNsdWRlcygneHJlZicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUERGIGFwcGVhcnMgdG8gYmUgY29ycnVwdGVkIG9yIGVuY3J5cHRlZC4gUGxlYXNlIHRyeSBhIGRpZmZlcmVudCBQREYgZmlsZS4nKVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiBleHRyYWN0ZWRUZXh0LFxuICAgICAgICBwYWdlczogcGFnZUNvdW50LFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHRpdGxlOiBmaWxlLm5hbWUucmVwbGFjZSgnLnBkZicsICcnKSxcbiAgICAgICAgICBhdXRob3I6ICdVbmtub3duJyxcbiAgICAgICAgICBjcmVhdGlvbkRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEFsbCBQREYgcGFyc2luZyBtZXRob2RzIGZhaWxlZDonLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIFBERjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKVxuICAgIH1cbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZXh0cmFjdGluZyB0ZXh0IGZyb20gUERGOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gRW5oYW5jZWQgY291cnNlIGV4dHJhY3Rpb24gd2l0aCBtdWx0aXBsZSBwYXR0ZXJuc1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RDb3Vyc2VzRnJvbVRleHQodGV4dDogc3RyaW5nKTogQXJyYXk8e1xuICBudW1iZXI6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgY29kZTogc3RyaW5nXG4gIGNyZWRpdHM/OiBudW1iZXJcbiAgaG91cnM/OiB7IHRoZW9yeTogbnVtYmVyOyB0dXRvcmlhbDogbnVtYmVyOyBwcmFjdGljYWw6IG51bWJlciB9XG59PiB7XG4gIGNvbnN0IGNvdXJzZXM6IEFycmF5PHtcbiAgICBudW1iZXI6IHN0cmluZ1xuICAgIG5hbWU6IHN0cmluZ1xuICAgIGNvZGU6IHN0cmluZ1xuICAgIGNyZWRpdHM/OiBudW1iZXJcbiAgICBob3Vycz86IHsgdGhlb3J5OiBudW1iZXI7IHR1dG9yaWFsOiBudW1iZXI7IHByYWN0aWNhbDogbnVtYmVyIH1cbiAgfT4gPSBbXVxuICBcbiAgY29uc29sZS5sb2coJ/CflI0gRXh0cmFjdGluZyBjb3Vyc2VzIGZyb20gUERGIHRleHQuLi4nKVxuICBjb25zb2xlLmxvZyhg8J+ThCBUZXh0IGxlbmd0aDogJHt0ZXh0Lmxlbmd0aH0gY2hhcmFjdGVyc2ApXG4gIGNvbnNvbGUubG9nKGDwn5OEIFRleHQgcHJldmlldzogJHt0ZXh0LnN1YnN0cmluZygwLCA1MDApfS4uLmApXG4gIFxuICAvLyBDb21wcmVoZW5zaXZlIHBhdHRlcm5zIHRvIGV4dHJhY3QgQ291cnNlIFRpdGxlIGFuZCBDcmVkaXRzIGZyb20gQU5ZIHRhYmxlIGZvcm1hdCBQREZcbiAgY29uc3QgcGF0dGVybnMgPSBbXG4gICAgLy8gUGF0dGVybiAxOiBcIkNvdXJzZSBUaXRsZTogW1RpdGxlXVwiIGZvbGxvd2VkIGJ5IFwiQ3JlZGl0czogW051bWJlcl1cIlxuICAgIC9Db3Vyc2UgVGl0bGU6XFxzKihbXlxcblxccl0rKVxccypbXFxuXFxyXStDcmVkaXRzOlxccyooXFxkKykvZ2ksXG4gICAgLy8gUGF0dGVybiAyOiBcIkNvdXJzZSBUaXRsZTogW1RpdGxlXVwiIGFuZCBcIkNyZWRpdHM6IFtOdW1iZXJdXCIgb24gc2VwYXJhdGUgbGluZXNcbiAgICAvQ291cnNlIFRpdGxlOlxccyooW15cXG5cXHJdKykuKj9DcmVkaXRzOlxccyooXFxkKykvZ2ksXG4gICAgLy8gUGF0dGVybiAzOiBUYWJsZSBmb3JtYXQgd2l0aCB0aXRsZSBhbmQgY3JlZGl0c1xuICAgIC8oW0EtWmEtelxccyZcXC1cXCtcXChcXClcXC9dKz8pXFxzKyhcXGQrKVxccypjcmVkaXRzPy9naSxcbiAgICAvLyBQYXR0ZXJuIDQ6IE51bWJlcmVkIGNvdXJzZXMgXCIxLiBbVGl0bGVdIChbQ29kZV0pIC0gW0NyZWRpdHNdIGNyZWRpdHNcIlxuICAgIC8oXFxkKylcXC5cXHMqKFteKF0rPylcXHMqXFwoKFteKV0rKVxcKVxccypbLVxcc10qKFxcZCspXFxzKmNyZWRpdHM/L2dpLFxuICAgIC8vIFBhdHRlcm4gNTogR2VuZXJpYyBjb3Vyc2UgZm9ybWF0IFwiW1RpdGxlXSAtIFtDcmVkaXRzXSBDcmVkaXRzXCJcbiAgICAvKFtBLVphLXpcXHMmXFwtXFwrXFwoXFwpXFwvXSs/KVxccyotXFxzKihcXGQrKVxccypDcmVkaXRzPy9naSxcbiAgICAvLyBQYXR0ZXJuIDY6IENvdXJzZSBuYW1lIGZvbGxvd2VkIGJ5IGNyZWRpdHMgaW4gcGFyZW50aGVzZXNcbiAgICAvKFtBLVphLXpcXHMmXFwtXFwrXFwoXFwpXFwvXSs/KVxccypcXCgoXFxkKylcXHMqY3JlZGl0cz9cXCkvZ2ksXG4gICAgLy8gUGF0dGVybiA3OiBTaW1wbGUgZm9ybWF0IFwiU3ViamVjdCBOYW1lIENyZWRpdHM6IFhcIlxuICAgIC8oW0EtWmEtelxccyZcXC1cXCtcXChcXClcXC9dKz8pXFxzK0NyZWRpdHM6XFxzKihcXGQrKS9naSxcbiAgICAvLyBQYXR0ZXJuIDg6IENvdXJzZSBuYW1lIHdpdGggY3JlZGl0cyBhdCBlbmQgb2YgbGluZVxuICAgIC8oW0EtWmEtelxccyZcXC1cXCtcXChcXClcXC9dKz8pXFxzKyhcXGQrKVxccyokL2dtLFxuICAgIC8vIFBhdHRlcm4gOTogQ291cnNlIG5hbWUgZm9sbG93ZWQgYnkgY3JlZGl0cyAoc3BhY2Ugc2VwYXJhdGVkKVxuICAgIC8oW0EtWmEtelxccyZcXC1cXCtcXChcXClcXC9dKz8pXFxzKyhcXGQrKVxccypjcmVkaXRzPy9naSxcbiAgICAvLyBQYXR0ZXJuIDEwOiBDb3Vyc2UgbmFtZSB3aXRoIGNyZWRpdHMgYWZ0ZXIgY29sb25cbiAgICAvKFtBLVphLXpcXHMmXFwtXFwrXFwoXFwpXFwvXSs/KTpcXHMqKFxcZCspL2dpLFxuICAgIC8vIFBhdHRlcm4gMTE6IFRhYmxlIGZvcm1hdCAtIENvdXJzZSB0aXRsZSBmb2xsb3dlZCBieSBjcmVkaXRzIChmb3IgVkkgU2VtZXN0ZXIgZm9ybWF0KVxuICAgIC8oW0EtWmEtelxccyZcXC1cXCtcXChcXClcXC9dKz8pXFxzKyhcXGQrKVxccyokL2dtLFxuICAgIC8vIFBhdHRlcm4gMTI6IENvdXJzZSB0aXRsZSB3aXRoIGNyZWRpdHMgaW4gdGFibGUgZm9ybWF0XG4gICAgLyhbQS1aYS16XFxzJlxcLVxcK1xcKFxcKVxcL10rPylcXHMrKFxcZCspXFxzKiQvZ20sXG4gICAgLy8gUGF0dGVybiAxMzogR2VuZXJpYyBjb3Vyc2UgcGF0dGVybiAocmVtb3ZlZCBoYXJkY29kZWQgY291cnNlIG5hbWVzKVxuICAgIC8oW0EtWmEtel1bQS1aYS16XFxzJlxcLVxcK1xcKFxcKVxcL117NCx9KVxccysoXFxkKykvZ2ksXG4gICAgLy8gUGF0dGVybiAxNDogQ291cnNlIHRpdGxlcyB3aXRoIGNyZWRpdHMgKHNwYWNlIHNlcGFyYXRlZClcbiAgICAvKFtBLVphLXpdW0EtWmEtelxccyZcXC1cXCtcXChcXClcXC9dezIsfSlcXHMrKFxcZCspXFxzKiQvZ20sXG4gICAgLy8gUGF0dGVybiAxNTogVmVyeSBicm9hZCBwYXR0ZXJuIGZvciBhbnkgdGV4dCBmb2xsb3dlZCBieSBudW1iZXJcbiAgICAvKFtBLVphLXpdW0EtWmEtelxccyZcXC1cXCtcXChcXClcXC9dezEsfSlcXHMrKFxcZCspL2dpLFxuICAgIC8vIFBhdHRlcm4gMTY6IFRhYmxlIHJvdyBmb3JtYXQgLSBDb3Vyc2UgbmFtZSB3aXRoIGNyZWRpdHMgKGVuaGFuY2VkIGZvciB0YWJsZSBmb3JtYXRzKVxuICAgIC8oW0EtWmEtel1bQS1aYS16XFxzJlxcLVxcK1xcKFxcKVxcL117Myx9KVxccysoXFxkKylcXHMqJC9nbSxcbiAgICAvLyBQYXR0ZXJuIDE3OiBDb3Vyc2UgbmFtZSB3aXRoIGNyZWRpdHMgKHRhYiBvciBzcGFjZSBzZXBhcmF0ZWQpXG4gICAgLyhbQS1aYS16XVtBLVphLXpcXHMmXFwtXFwrXFwoXFwpXFwvXXszLH0pXFxzKyhcXGQrKVxccyokL2dtLFxuICAgIC8vIFBhdHRlcm4gMTg6IENvdXJzZSBuYW1lIHdpdGggY3JlZGl0cyAobXVsdGlwbGUgc3BhY2VzKVxuICAgIC8oW0EtWmEtel1bQS1aYS16XFxzJlxcLVxcK1xcKFxcKVxcL117Myx9KVxccysoXFxkKylcXHMqJC9nbSxcbiAgICAvLyBQYXR0ZXJuIDE5OiBDb3Vyc2UgbmFtZSB3aXRoIGNyZWRpdHMgKGVuZCBvZiBsaW5lKVxuICAgIC8oW0EtWmEtel1bQS1aYS16XFxzJlxcLVxcK1xcKFxcKVxcL117Myx9KVxccysoXFxkKylcXHMqJC9nbSxcbiAgICAvLyBQYXR0ZXJuIDIwOiBDb3Vyc2UgbmFtZSB3aXRoIGNyZWRpdHMgKGFueSBmb3JtYXQpXG4gICAgLyhbQS1aYS16XVtBLVphLXpcXHMmXFwtXFwrXFwoXFwpXFwvXXszLH0pXFxzKyhcXGQrKS9naVxuICBdXG4gIFxuICBwYXR0ZXJucy5mb3JFYWNoKChwYXR0ZXJuLCBwYXR0ZXJuSW5kZXgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhg8J+UjSBUcnlpbmcgcGF0dGVybiAke3BhdHRlcm5JbmRleCArIDF9OiAke3BhdHRlcm59YClcbiAgICBjb25zdCBtYXRjaGVzID0gQXJyYXkuZnJvbSh0ZXh0Lm1hdGNoQWxsKHBhdHRlcm4pKVxuICAgIGNvbnNvbGUubG9nKGDwn5OaIEZvdW5kICR7bWF0Y2hlcy5sZW5ndGh9IG1hdGNoZXMgd2l0aCBwYXR0ZXJuICR7cGF0dGVybkluZGV4ICsgMX1gKVxuICAgIFxuICAgIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgICBsZXQgY291cnNlVGl0bGU6IHN0cmluZ1xuICAgICAgbGV0IGNyZWRpdHM6IG51bWJlclxuICAgICAgXG4gICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IG1hdGNoIHBhdHRlcm5zXG4gICAgICBpZiAocGF0dGVybkluZGV4ID09PSAzKSB7XG4gICAgICAgIC8vIFBhdHRlcm4gNDogTnVtYmVyZWQgY291cnNlcyB3aXRoIGNvdXJzZSBjb2RlIFwiMS4gW1RpdGxlXSAoW0NvZGVdKSAtIFtDcmVkaXRzXSBjcmVkaXRzXCJcbiAgICAgICAgY291cnNlVGl0bGUgPSBtYXRjaFsyXS50cmltKClcbiAgICAgICAgY3JlZGl0cyA9IHBhcnNlSW50KG1hdGNoWzRdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWxsIG90aGVyIHBhdHRlcm5zXG4gICAgICAgIGNvdXJzZVRpdGxlID0gbWF0Y2hbMV0udHJpbSgpXG4gICAgICAgIGNyZWRpdHMgPSBwYXJzZUludChtYXRjaFsyXSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gdXAgY291cnNlIHRpdGxlIChyZW1vdmUgZXh0cmEgd2hpdGVzcGFjZSwgc3BlY2lhbCBjaGFyYWN0ZXJzKVxuICAgICAgY291cnNlVGl0bGUgPSBjb3Vyc2VUaXRsZS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpXG4gICAgICBcbiAgICAgIC8vIEZvY3VzZWQgZmlsdGVyaW5nIGZvciBjb3Vyc2UgdGl0bGVzIGFuZCBjcmVkaXRzIG9ubHlcbiAgICAgIGNvbnN0IHNraXBQYXR0ZXJucyA9IFtcbiAgICAgICAgL150b3RhbC9pLFxuICAgICAgICAvXnRvdGEvaSxcbiAgICAgICAgL15jcmVkaXRzPyQvaSxcbiAgICAgICAgL15jb3Vyc2UvaSxcbiAgICAgICAgL150aXRsZS9pLFxuICAgICAgICAvXnNlbWVzdGVyL2ksXG4gICAgICAgIC9ec3lsbGFidXMvaSxcbiAgICAgICAgL15wYWdlL2ksXG4gICAgICAgIC9eY2hhcHRlci9pLFxuICAgICAgICAvXnNlY3Rpb24vaSxcbiAgICAgICAgL150YWJsZS9pLFxuICAgICAgICAvXmZpZ3VyZS9pLFxuICAgICAgICAvXmFwcGVuZGl4L2ksXG4gICAgICAgIC9ecmVmZXJlbmNlL2ksXG4gICAgICAgIC9eYmlibGlvZ3JhcGh5L2ksXG4gICAgICAgIC9eaW5kZXgvaSxcbiAgICAgICAgL15jb250ZW50cy9pLFxuICAgICAgICAvXmFic3RyYWN0L2ksXG4gICAgICAgIC9eaW50cm9kdWN0aW9uL2ksXG4gICAgICAgIC9eY29uY2x1c2lvbi9pLFxuICAgICAgICAvXlxcZCskLyxcbiAgICAgICAgL15bYS16XSQvaSxcbiAgICAgICAgL15bXmEtekEtWl0qJC8sXG4gICAgICAgIC9eW15hLXpBLVpdKlthLXpBLVpdezEsMn1bXmEtekEtWl0qJC8sXG4gICAgICAgIC9eW0EtWl17MSwzfSQvLCAvLyBTaW5nbGUgbGV0dGVycyBvciBzaG9ydCBhY3Jvbnltc1xuICAgICAgICAvXlxcZCtbYS16QS1aXT8kLywgLy8gTnVtYmVycyB3aXRoIG9wdGlvbmFsIGxldHRlclxuICAgICAgICAvXlteYS16QS1aXSokLywgLy8gTm8gbGV0dGVycyBhdCBhbGxcbiAgICAgICAgL14uezEsMn0kLywgLy8gVmVyeSBzaG9ydCB0ZXh0XG4gICAgICAgIC9eW15hLXpBLVpdKlthLXpBLVpdezEsMn1bXmEtekEtWl0qJC8sIC8vIE1vc3RseSBub24tbGV0dGVyc1xuICAgICAgICAvXnZpXFxzK3NlbWVzdGVyL2ksIC8vIFNraXAgXCJWSSBTRU1FU1RFUlwiIGhlYWRlclxuICAgICAgICAvXnNsXFwuP1xccypuby9pLCAvLyBTa2lwIFwiU2wuIE5vXCIgaGVhZGVyXG4gICAgICAgIC9edGVhY2hpbmdcXHMraG91cnMvaSwgLy8gU2tpcCBcIlRlYWNoaW5nIEhvdXJzXCIgaGVhZGVyXG4gICAgICAgIC9eZXhhbWluYXRpb24vaSwgLy8gU2tpcCBcIkV4YW1pbmF0aW9uXCIgaGVhZGVyXG4gICAgICAgIC9edG90YWxcXHMrdGVhY2hpbmcvaSwgLy8gU2tpcCBcIlRvdGFsIFRlYWNoaW5nXCIgcm93XG4gICAgICAgIC9edG90YWxcXHMrZXhhbWluYXRpb24vaSwgLy8gU2tpcCBcIlRvdGFsIEV4YW1pbmF0aW9uXCIgcm93XG4gICAgICAgIC9edG90YWxcXHMrY3JlZGl0cy9pLCAvLyBTa2lwIFwiVG90YWwgQ3JlZGl0c1wiIHJvd1xuICAgICAgICAvZW5kc3RyZWFtL2ksIC8vIFNraXAgUERGIGNvcnJ1cHRpb24gdGV4dFxuICAgICAgICAvZW5kb2JqL2ksIC8vIFNraXAgUERGIGNvcnJ1cHRpb24gdGV4dFxuICAgICAgICAveHJlZi9pLCAvLyBTa2lwIFBERiBjb3JydXB0aW9uIHRleHRcbiAgICAgICAgL15SXFxzKlxcL0luZm8vaSwgLy8gU2tpcCBQREYgY29ycnVwdGlvbiB0ZXh0XG4gICAgICAgIC9ec3RyZWFtL2ksIC8vIFNraXAgUERGIGNvcnJ1cHRpb24gdGV4dFxuICAgICAgICAvXm9iai9pLCAvLyBTa2lwIFBERiBjb3JydXB0aW9uIHRleHRcbiAgICAgICAgL15zdGFydHhyZWYvaSwgLy8gU2tpcCBQREYgY29ycnVwdGlvbiB0ZXh0XG4gICAgICAgIC9edHJhaWxlci9pIC8vIFNraXAgUERGIGNvcnJ1cHRpb24gdGV4dFxuICAgICAgXVxuICAgICAgXG4gICAgICBjb25zdCBzaG91bGRTa2lwID0gc2tpcFBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBwYXR0ZXJuLnRlc3QoY291cnNlVGl0bGUpKVxuICAgICAgXG4gICAgICAvLyBFbmhhbmNlZCB2YWxpZGF0aW9uIGZvciBjb3Vyc2UgdGl0bGVzIGFuZCBjcmVkaXRzICh3b3JrcyB3aXRoIGFueSB0YWJsZSBmb3JtYXQpXG4gICAgICBjb25zdCBpc1ZhbGlkQ291cnNlID0gY291cnNlVGl0bGUgJiYgXG4gICAgICAgICAgY291cnNlVGl0bGUubGVuZ3RoID49IDMgJiYgLy8gTWluaW11bSAzIGNoYXJhY3RlcnNcbiAgICAgICAgICAhaXNOYU4oY3JlZGl0cykgJiYgXG4gICAgICAgICAgY3JlZGl0cyA+PSAwICYmIFxuICAgICAgICAgIGNyZWRpdHMgPD0gMjAgJiYgLy8gQWxsb3cgdXAgdG8gMjAgY3JlZGl0c1xuICAgICAgICAgICFzaG91bGRTa2lwICYmXG4gICAgICAgICAgLy8gQ291cnNlIHRpdGxlIG11c3QgYmUgYSB2YWxpZCBjb3Vyc2UgbmFtZVxuICAgICAgICAgIC9bYS16QS1aXS8udGVzdChjb3Vyc2VUaXRsZSkgJiYgLy8gTXVzdCBjb250YWluIGxldHRlcnNcbiAgICAgICAgICBjb3Vyc2VUaXRsZS5zcGxpdCgnICcpLmxlbmd0aCA+PSAxICYmIC8vIE11c3QgaGF2ZSBhdCBsZWFzdCAxIHdvcmQgKGZsZXhpYmxlIGZvciBzaG9ydCBjb3Vyc2VzKVxuICAgICAgICAgICFjb3Vyc2VUaXRsZS5tYXRjaCgvXlxcZCsvKSAmJiAvLyBNdXN0IG5vdCBzdGFydCB3aXRoIG51bWJlclxuICAgICAgICAgICFjb3Vyc2VUaXRsZS5tYXRjaCgvXlteYS16QS1aXS8pICYmIC8vIE11c3Qgc3RhcnQgd2l0aCBsZXR0ZXJcbiAgICAgICAgICAhY291cnNlVGl0bGUuaW5jbHVkZXMoJ1ZJIFNFTUVTVEVSJykgJiYgLy8gU2tpcCBpZiBjb250YWlucyBoZWFkZXJcbiAgICAgICAgICAhY291cnNlVGl0bGUubWF0Y2goL15bQS1aXXsxLDN9XFxzK1tBLVpdezEsM30kLykgJiYgLy8gU2tpcCBzaG9ydCBhY3Jvbnltc1xuICAgICAgICAgICFjb3Vyc2VUaXRsZS5pbmNsdWRlcygnZW5kc3RyZWFtJykgJiYgLy8gU2tpcCBQREYgY29ycnVwdGlvblxuICAgICAgICAgICFjb3Vyc2VUaXRsZS5pbmNsdWRlcygnZW5kb2JqJykgJiYgLy8gU2tpcCBQREYgY29ycnVwdGlvblxuICAgICAgICAgICFjb3Vyc2VUaXRsZS5pbmNsdWRlcygneHJlZicpICYmIC8vIFNraXAgUERGIGNvcnJ1cHRpb25cbiAgICAgICAgICAhY291cnNlVGl0bGUuaW5jbHVkZXMoJ1IgL0luZm8nKSAmJiAvLyBTa2lwIFBERiBjb3JydXB0aW9uXG4gICAgICAgICAgIWNvdXJzZVRpdGxlLmluY2x1ZGVzKCdzdHJlYW0nKSAmJiAvLyBTa2lwIFBERiBjb3JydXB0aW9uXG4gICAgICAgICAgIWNvdXJzZVRpdGxlLmluY2x1ZGVzKCdvYmonKSAmJiAvLyBTa2lwIFBERiBjb3JydXB0aW9uXG4gICAgICAgICAgIWNvdXJzZVRpdGxlLmluY2x1ZGVzKCdzdGFydHhyZWYnKSAmJiAvLyBTa2lwIFBERiBjb3JydXB0aW9uXG4gICAgICAgICAgIWNvdXJzZVRpdGxlLmluY2x1ZGVzKCd0cmFpbGVyJykgJiYgLy8gU2tpcCBQREYgY29ycnVwdGlvblxuICAgICAgICAgIC8vIEFkZGl0aW9uYWwgdmFsaWRhdGlvbiBmb3IgdGFibGUgZm9ybWF0c1xuICAgICAgICAgIGNvdXJzZVRpdGxlLmxlbmd0aCA+PSAzICYmIC8vIE11c3QgYmUgYXQgbGVhc3QgMyBjaGFyYWN0ZXJzXG4gICAgICAgICAgIWNvdXJzZVRpdGxlLm1hdGNoKC9eXFxkKy8pICYmIC8vIE11c3Qgbm90IHN0YXJ0IHdpdGggbnVtYmVyXG4gICAgICAgICAgIWNvdXJzZVRpdGxlLm1hdGNoKC9eW15hLXpBLVpdLykgJiYgLy8gTXVzdCBzdGFydCB3aXRoIGxldHRlclxuICAgICAgICAgIC8vIE11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgbGV0dGVyIChmbGV4aWJsZSBmb3IgdmFyaW91cyBjb3Vyc2UgbmFtZXMpXG4gICAgICAgICAgL1thLXpBLVpdLy50ZXN0KGNvdXJzZVRpdGxlKVxuICAgICAgXG4gICAgICBpZiAoaXNWYWxpZENvdXJzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+TliBFeHRyYWN0ZWQgY291cnNlICR7aW5kZXggKyAxfTogJHtjb3Vyc2VUaXRsZX0gKCR7Y3JlZGl0c30gY3JlZGl0cylgKVxuICAgICAgICBcbiAgICAgICAgY291cnNlcy5wdXNoKHtcbiAgICAgICAgICBudW1iZXI6IChjb3Vyc2VzLmxlbmd0aCArIDEpLnRvU3RyaW5nKCksXG4gICAgICAgICAgbmFtZTogY291cnNlVGl0bGUsXG4gICAgICAgICAgY29kZTogYENPVVJTRSR7Y291cnNlcy5sZW5ndGggKyAxfWAsXG4gICAgICAgICAgY3JlZGl0czogY3JlZGl0cyxcbiAgICAgICAgICBob3VyczogdW5kZWZpbmVkIC8vIFdlIG9ubHkgbmVlZCB0aXRsZSBhbmQgY3JlZGl0c1xuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChjb3Vyc2VUaXRsZSAmJiBjb3Vyc2VUaXRsZS5sZW5ndGggPiAzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gU2tpcHBlZCBpbnZhbGlkIGNvdXJzZTogXCIke2NvdXJzZVRpdGxlfVwiICgke2NyZWRpdHN9IGNyZWRpdHMpYClcbiAgICAgIH1cbiAgICB9KVxuICB9KVxuICBcbiAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXMgYmFzZWQgb24gY291cnNlIG5hbWUgKGNhc2UtaW5zZW5zaXRpdmUgYW5kIHNpbWlsYXIgbmFtZXMpXG4gIGNvbnN0IHVuaXF1ZUNvdXJzZXMgPSBjb3Vyc2VzLmZpbHRlcigoY291cnNlLCBpbmRleCwgc2VsZikgPT4gXG4gICAgaW5kZXggPT09IHNlbGYuZmluZEluZGV4KGMgPT4ge1xuICAgICAgY29uc3QgbmFtZTEgPSBjLm5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpXG4gICAgICBjb25zdCBuYW1lMiA9IGNvdXJzZS5uYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKVxuICAgICAgcmV0dXJuIG5hbWUxID09PSBuYW1lMiB8fCBcbiAgICAgICAgICAgICAobmFtZTEuaW5jbHVkZXMoJ2NyZWRpdHMnKSAmJiBuYW1lMiA9PT0gbmFtZTEucmVwbGFjZSgnIGNyZWRpdHMnLCAnJykpIHx8XG4gICAgICAgICAgICAgKG5hbWUyLmluY2x1ZGVzKCdjcmVkaXRzJykgJiYgbmFtZTEgPT09IG5hbWUyLnJlcGxhY2UoJyBjcmVkaXRzJywgJycpKSB8fFxuICAgICAgICAgICAgIChuYW1lMSA9PT0gbmFtZTIucmVwbGFjZSgnIGNyZWRpdHMnLCAnJykpIHx8XG4gICAgICAgICAgICAgKG5hbWUyID09PSBuYW1lMS5yZXBsYWNlKCcgY3JlZGl0cycsICcnKSlcbiAgICB9KVxuICApXG4gIFxuICBjb25zb2xlLmxvZyhg4pyFIEV4dHJhY3RlZCAke3VuaXF1ZUNvdXJzZXMubGVuZ3RofSB1bmlxdWUgY291cnNlc2ApXG4gIHJldHVybiB1bmlxdWVDb3Vyc2VzXG59XG5cbi8vIEV4dHJhY3QgY291cnNlIHNlY3Rpb24gZnJvbSB0ZXh0XG5mdW5jdGlvbiBleHRyYWN0Q291cnNlU2VjdGlvbih0ZXh0OiBzdHJpbmcsIGNvdXJzZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJylcbiAgbGV0IGNvdXJzZVNlY3Rpb24gPSAnJ1xuICBsZXQgZm91bmRDb3Vyc2UgPSBmYWxzZVxuICBcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgaWYgKGxpbmUuaW5jbHVkZXMoY291cnNlTmFtZSkpIHtcbiAgICAgIGZvdW5kQ291cnNlID0gdHJ1ZVxuICAgICAgY291cnNlU2VjdGlvbiArPSBsaW5lICsgJ1xcbidcbiAgICB9IGVsc2UgaWYgKGZvdW5kQ291cnNlICYmIChsaW5lLm1hdGNoKC9eXFxkK1tcXC5cXClcXC1cXHNdLykgfHwgbGluZS5pbmNsdWRlcygnVE9UQUw6JykgfHwgbGluZS5pbmNsdWRlcygnQ09VUlNFIFNUUlVDVFVSRScpKSkge1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2UgaWYgKGZvdW5kQ291cnNlKSB7XG4gICAgICBjb3Vyc2VTZWN0aW9uICs9IGxpbmUgKyAnXFxuJ1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIGNvdXJzZVNlY3Rpb25cbn1cblxuLy8gRXh0cmFjdCBjcmVkaXRzIGZyb20gY291cnNlIHNlY3Rpb25cbmZ1bmN0aW9uIGV4dHJhY3RDcmVkaXRzRnJvbVRleHQoc2VjdGlvbjogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgcGF0dGVybnMgPSBbXG4gICAgL0NyZWRpdHM/OlxccyooXFxkKykvaSxcbiAgICAvQ3JlZGl0OlxccyooXFxkKykvaSxcbiAgICAvKFxcZCspXFxzKmNyZWRpdHM/L2ksXG4gICAgLyhcXGQrKVxccypjcmVkaXQvaVxuICBdXG4gIFxuICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICBjb25zdCBtYXRjaCA9IHNlY3Rpb24ubWF0Y2gocGF0dGVybilcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChtYXRjaFsxXSlcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuLy8gRXh0cmFjdCBob3VycyBmcm9tIGNvdXJzZSBzZWN0aW9uXG5mdW5jdGlvbiBleHRyYWN0SG91cnNGcm9tVGV4dChzZWN0aW9uOiBzdHJpbmcpOiB7IHRoZW9yeTogbnVtYmVyOyB0dXRvcmlhbDogbnVtYmVyOyBwcmFjdGljYWw6IG51bWJlciB9IHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgdGhlb3J5TWF0Y2ggPSBzZWN0aW9uLm1hdGNoKC9UaGVvcnlbOlxcc10qKFxcZCspL2kpXG4gIGNvbnN0IHR1dG9yaWFsTWF0Y2ggPSBzZWN0aW9uLm1hdGNoKC9UdXRvcmlhbFs6XFxzXSooXFxkKykvaSlcbiAgY29uc3QgcHJhY3RpY2FsTWF0Y2ggPSBzZWN0aW9uLm1hdGNoKC9QcmFjdGljYWxbOlxcc10qKFxcZCspL2kpXG4gIFxuICBpZiAodGhlb3J5TWF0Y2ggfHwgdHV0b3JpYWxNYXRjaCB8fCBwcmFjdGljYWxNYXRjaCkge1xuICAgIHJldHVybiB7XG4gICAgICB0aGVvcnk6IHRoZW9yeU1hdGNoID8gcGFyc2VJbnQodGhlb3J5TWF0Y2hbMV0pIDogMCxcbiAgICAgIHR1dG9yaWFsOiB0dXRvcmlhbE1hdGNoID8gcGFyc2VJbnQodHV0b3JpYWxNYXRjaFsxXSkgOiAwLFxuICAgICAgcHJhY3RpY2FsOiBwcmFjdGljYWxNYXRjaCA/IHBhcnNlSW50KHByYWN0aWNhbE1hdGNoWzFdKSA6IDBcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuLy8gRnVuY3Rpb25zIGFyZSBhbHJlYWR5IGV4cG9ydGVkIGFib3ZlXG4iXSwibmFtZXMiOlsiZXh0cmFjdFRleHRGcm9tUERGIiwiZmlsZSIsImNvbnNvbGUiLCJsb2ciLCJuYW1lIiwic2l6ZSIsImFycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsImV4dHJhY3RlZFRleHQiLCJwYWdlQ291bnQiLCJwZGZqc0xpYiIsIkdsb2JhbFdvcmtlck9wdGlvbnMiLCJ3b3JrZXJTcmMiLCJwZGYiLCJnZXREb2N1bWVudCIsImRhdGEiLCJ1c2VXb3JrZXJGZXRjaCIsImlzRXZhbFN1cHBvcnRlZCIsInVzZVN5c3RlbUZvbnRzIiwiZGlzYWJsZUZvbnRGYWNlIiwiZGlzYWJsZVJhbmdlIiwiZGlzYWJsZVN0cmVhbSIsInByb21pc2UiLCJudW1QYWdlcyIsInBhZ2VOdW0iLCJwYWdlIiwiZ2V0UGFnZSIsInRleHRDb250ZW50IiwiZ2V0VGV4dENvbnRlbnQiLCJwYWdlVGV4dCIsIml0ZW1zIiwibWFwIiwiaXRlbSIsImhhc0VPTCIsInN0ciIsImpvaW4iLCJyZXBsYWNlIiwicGFnZUVycm9yIiwid2FybiIsInBkZmpzRXJyb3IiLCJwZGZQYXJzZSIsImJ1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJkZWZhdWx0IiwidGV4dCIsIm51bXBhZ2VzIiwicGRmUGFyc2VFcnJvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsImUiLCJyZXN1bHQiLCJ0YXJnZXQiLCJvbmVycm9yIiwiRXJyb3IiLCJyZWFkQXNUZXh0IiwibGVuZ3RoIiwic3Vic3RyaW5nIiwiaW5jbHVkZXMiLCJwYWdlcyIsIm1ldGFkYXRhIiwidGl0bGUiLCJhdXRob3IiLCJjcmVhdGlvbkRhdGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJlcnJvciIsIm1lc3NhZ2UiLCJleHRyYWN0Q291cnNlc0Zyb21UZXh0IiwiY291cnNlcyIsInBhdHRlcm5zIiwiZm9yRWFjaCIsInBhdHRlcm4iLCJwYXR0ZXJuSW5kZXgiLCJtYXRjaGVzIiwiQXJyYXkiLCJtYXRjaEFsbCIsIm1hdGNoIiwiaW5kZXgiLCJjb3Vyc2VUaXRsZSIsImNyZWRpdHMiLCJ0cmltIiwicGFyc2VJbnQiLCJza2lwUGF0dGVybnMiLCJzaG91bGRTa2lwIiwic29tZSIsInRlc3QiLCJpc1ZhbGlkQ291cnNlIiwiaXNOYU4iLCJzcGxpdCIsInB1c2giLCJudW1iZXIiLCJ0b1N0cmluZyIsImNvZGUiLCJob3VycyIsInVuZGVmaW5lZCIsInVuaXF1ZUNvdXJzZXMiLCJmaWx0ZXIiLCJjb3Vyc2UiLCJzZWxmIiwiZmluZEluZGV4IiwiYyIsIm5hbWUxIiwidG9Mb3dlckNhc2UiLCJuYW1lMiIsImV4dHJhY3RDb3Vyc2VTZWN0aW9uIiwiY291cnNlTmFtZSIsImxpbmVzIiwiY291cnNlU2VjdGlvbiIsImZvdW5kQ291cnNlIiwibGluZSIsImV4dHJhY3RDcmVkaXRzRnJvbVRleHQiLCJzZWN0aW9uIiwiZXh0cmFjdEhvdXJzRnJvbVRleHQiLCJ0aGVvcnlNYXRjaCIsInR1dG9yaWFsTWF0Y2giLCJwcmFjdGljYWxNYXRjaCIsInRoZW9yeSIsInR1dG9yaWFsIiwicHJhY3RpY2FsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./lib/real-pdf-parser.ts\n");

/***/ })

};
;