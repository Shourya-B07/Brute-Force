"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfjs-dist";
exports.ids = ["vendor-chunks/pdfjs-dist"];
exports.modules = {

/***/ "(ssr)/./node_modules/pdfjs-dist/build/pdf.mjs":
/*!***********************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortException: () => (/* binding */ AbortException),\n/* harmony export */   AnnotationEditorLayer: () => (/* binding */ AnnotationEditorLayer),\n/* harmony export */   AnnotationEditorParamsType: () => (/* binding */ AnnotationEditorParamsType),\n/* harmony export */   AnnotationEditorType: () => (/* binding */ AnnotationEditorType),\n/* harmony export */   AnnotationEditorUIManager: () => (/* binding */ AnnotationEditorUIManager),\n/* harmony export */   AnnotationLayer: () => (/* binding */ AnnotationLayer),\n/* harmony export */   AnnotationMode: () => (/* binding */ AnnotationMode),\n/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),\n/* harmony export */   ColorPicker: () => (/* binding */ ColorPicker),\n/* harmony export */   DOMSVGFactory: () => (/* binding */ DOMSVGFactory),\n/* harmony export */   DrawLayer: () => (/* binding */ DrawLayer),\n/* harmony export */   FeatureTest: () => (/* binding */ util_FeatureTest),\n/* harmony export */   GlobalWorkerOptions: () => (/* binding */ GlobalWorkerOptions),\n/* harmony export */   ImageKind: () => (/* binding */ util_ImageKind),\n/* harmony export */   InvalidPDFException: () => (/* binding */ InvalidPDFException),\n/* harmony export */   MathClamp: () => (/* binding */ MathClamp),\n/* harmony export */   OPS: () => (/* binding */ OPS),\n/* harmony export */   OutputScale: () => (/* binding */ OutputScale),\n/* harmony export */   PDFDataRangeTransport: () => (/* binding */ PDFDataRangeTransport),\n/* harmony export */   PDFDateString: () => (/* binding */ PDFDateString),\n/* harmony export */   PDFWorker: () => (/* binding */ PDFWorker),\n/* harmony export */   PasswordResponses: () => (/* binding */ PasswordResponses),\n/* harmony export */   PermissionFlag: () => (/* binding */ PermissionFlag),\n/* harmony export */   PixelsPerInch: () => (/* binding */ PixelsPerInch),\n/* harmony export */   RenderingCancelledException: () => (/* binding */ RenderingCancelledException),\n/* harmony export */   ResponseException: () => (/* binding */ ResponseException),\n/* harmony export */   SignatureExtractor: () => (/* binding */ SignatureExtractor),\n/* harmony export */   SupportedImageMimeTypes: () => (/* binding */ SupportedImageMimeTypes),\n/* harmony export */   TextLayer: () => (/* binding */ TextLayer),\n/* harmony export */   TouchManager: () => (/* binding */ TouchManager),\n/* harmony export */   Util: () => (/* binding */ Util),\n/* harmony export */   VerbosityLevel: () => (/* binding */ VerbosityLevel),\n/* harmony export */   XfaLayer: () => (/* binding */ XfaLayer),\n/* harmony export */   build: () => (/* binding */ build),\n/* harmony export */   createValidAbsoluteUrl: () => (/* binding */ createValidAbsoluteUrl),\n/* harmony export */   fetchData: () => (/* binding */ fetchData),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getFilenameFromUrl: () => (/* binding */ getFilenameFromUrl),\n/* harmony export */   getPdfFilenameFromUrl: () => (/* binding */ getPdfFilenameFromUrl),\n/* harmony export */   getRGB: () => (/* binding */ getRGB),\n/* harmony export */   getUuid: () => (/* binding */ getUuid),\n/* harmony export */   getXfaPageViewport: () => (/* binding */ getXfaPageViewport),\n/* harmony export */   isDataScheme: () => (/* binding */ isDataScheme),\n/* harmony export */   isPdfFile: () => (/* binding */ isPdfFile),\n/* harmony export */   isValidExplicitDest: () => (/* binding */ isValidExplicitDest),\n/* harmony export */   noContextMenu: () => (/* binding */ noContextMenu),\n/* harmony export */   normalizeUnicode: () => (/* binding */ normalizeUnicode),\n/* harmony export */   setLayerDimensions: () => (/* binding */ setLayerDimensions),\n/* harmony export */   shadow: () => (/* binding */ shadow),\n/* harmony export */   stopEvent: () => (/* binding */ stopEvent),\n/* harmony export */   updateUrlHash: () => (/* binding */ updateUrlHash),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2024 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */ /**\n * pdfjsVersion = 5.4.149\n * pdfjsBuild = 9e2e9e209\n */ /******/ // The require scope\n/******/ var __nested_webpack_require_898__ = {};\n/******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{\n    /******/ // define getter functions for harmony exports\n    /******/ __nested_webpack_require_898__.d = (exports, definition)=>{\n        /******/ for(var key in definition){\n            /******/ if (__nested_webpack_require_898__.o(definition, key) && !__nested_webpack_require_898__.o(exports, key)) {\n                /******/ Object.defineProperty(exports, key, {\n                    enumerable: true,\n                    get: definition[key]\n                });\n            /******/ }\n        /******/ }\n    /******/ };\n/******/ })();\n/******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{\n    /******/ __nested_webpack_require_898__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);\n/******/ })();\n/******/ /************************************************************************/ var __webpack_exports__ = {};\n; // ./src/shared/util.js\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nconst FONT_IDENTITY_MATRIX = [\n    0.001,\n    0,\n    0,\n    0.001,\n    0,\n    0\n];\nconst LINE_FACTOR = 1.35;\nconst LINE_DESCENT_FACTOR = 0.35;\nconst BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\nconst RenderingIntentFlag = {\n    ANY: 0x01,\n    DISPLAY: 0x02,\n    PRINT: 0x04,\n    SAVE: 0x08,\n    ANNOTATIONS_FORMS: 0x10,\n    ANNOTATIONS_STORAGE: 0x20,\n    ANNOTATIONS_DISABLE: 0x40,\n    IS_EDITING: 0x80,\n    OPLIST: 0x100\n};\nconst AnnotationMode = {\n    DISABLE: 0,\n    ENABLE: 1,\n    ENABLE_FORMS: 2,\n    ENABLE_STORAGE: 3\n};\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nconst AnnotationEditorType = {\n    DISABLE: -1,\n    NONE: 0,\n    FREETEXT: 3,\n    HIGHLIGHT: 9,\n    STAMP: 13,\n    INK: 15,\n    POPUP: 16,\n    SIGNATURE: 101,\n    COMMENT: 102\n};\nconst AnnotationEditorParamsType = {\n    RESIZE: 1,\n    CREATE: 2,\n    FREETEXT_SIZE: 11,\n    FREETEXT_COLOR: 12,\n    FREETEXT_OPACITY: 13,\n    INK_COLOR: 21,\n    INK_THICKNESS: 22,\n    INK_OPACITY: 23,\n    HIGHLIGHT_COLOR: 31,\n    HIGHLIGHT_THICKNESS: 32,\n    HIGHLIGHT_FREE: 33,\n    HIGHLIGHT_SHOW_ALL: 34,\n    DRAW_STEP: 41\n};\nconst PermissionFlag = {\n    PRINT: 0x04,\n    MODIFY_CONTENTS: 0x08,\n    COPY: 0x10,\n    MODIFY_ANNOTATIONS: 0x20,\n    FILL_INTERACTIVE_FORMS: 0x100,\n    COPY_FOR_ACCESSIBILITY: 0x200,\n    ASSEMBLE: 0x400,\n    PRINT_HIGH_QUALITY: 0x800\n};\nconst TextRenderingMode = {\n    FILL: 0,\n    STROKE: 1,\n    FILL_STROKE: 2,\n    INVISIBLE: 3,\n    FILL_ADD_TO_PATH: 4,\n    STROKE_ADD_TO_PATH: 5,\n    FILL_STROKE_ADD_TO_PATH: 6,\n    ADD_TO_PATH: 7,\n    FILL_STROKE_MASK: 3,\n    ADD_TO_PATH_FLAG: 4\n};\nconst util_ImageKind = {\n    GRAYSCALE_1BPP: 1,\n    RGB_24BPP: 2,\n    RGBA_32BPP: 3\n};\nconst AnnotationType = {\n    TEXT: 1,\n    LINK: 2,\n    FREETEXT: 3,\n    LINE: 4,\n    SQUARE: 5,\n    CIRCLE: 6,\n    POLYGON: 7,\n    POLYLINE: 8,\n    HIGHLIGHT: 9,\n    UNDERLINE: 10,\n    SQUIGGLY: 11,\n    STRIKEOUT: 12,\n    STAMP: 13,\n    CARET: 14,\n    INK: 15,\n    POPUP: 16,\n    FILEATTACHMENT: 17,\n    SOUND: 18,\n    MOVIE: 19,\n    WIDGET: 20,\n    SCREEN: 21,\n    PRINTERMARK: 22,\n    TRAPNET: 23,\n    WATERMARK: 24,\n    THREED: 25,\n    REDACT: 26\n};\nconst AnnotationReplyType = {\n    GROUP: \"Group\",\n    REPLY: \"R\"\n};\nconst AnnotationFlag = {\n    INVISIBLE: 0x01,\n    HIDDEN: 0x02,\n    PRINT: 0x04,\n    NOZOOM: 0x08,\n    NOROTATE: 0x10,\n    NOVIEW: 0x20,\n    READONLY: 0x40,\n    LOCKED: 0x80,\n    TOGGLENOVIEW: 0x100,\n    LOCKEDCONTENTS: 0x200\n};\nconst AnnotationFieldFlag = {\n    READONLY: 0x0000001,\n    REQUIRED: 0x0000002,\n    NOEXPORT: 0x0000004,\n    MULTILINE: 0x0001000,\n    PASSWORD: 0x0002000,\n    NOTOGGLETOOFF: 0x0004000,\n    RADIO: 0x0008000,\n    PUSHBUTTON: 0x0010000,\n    COMBO: 0x0020000,\n    EDIT: 0x0040000,\n    SORT: 0x0080000,\n    FILESELECT: 0x0100000,\n    MULTISELECT: 0x0200000,\n    DONOTSPELLCHECK: 0x0400000,\n    DONOTSCROLL: 0x0800000,\n    COMB: 0x1000000,\n    RICHTEXT: 0x2000000,\n    RADIOSINUNISON: 0x2000000,\n    COMMITONSELCHANGE: 0x4000000\n};\nconst AnnotationBorderStyleType = {\n    SOLID: 1,\n    DASHED: 2,\n    BEVELED: 3,\n    INSET: 4,\n    UNDERLINE: 5\n};\nconst AnnotationActionEventType = {\n    E: \"Mouse Enter\",\n    X: \"Mouse Exit\",\n    D: \"Mouse Down\",\n    U: \"Mouse Up\",\n    Fo: \"Focus\",\n    Bl: \"Blur\",\n    PO: \"PageOpen\",\n    PC: \"PageClose\",\n    PV: \"PageVisible\",\n    PI: \"PageInvisible\",\n    K: \"Keystroke\",\n    F: \"Format\",\n    V: \"Validate\",\n    C: \"Calculate\"\n};\nconst DocumentActionEventType = {\n    WC: \"WillClose\",\n    WS: \"WillSave\",\n    DS: \"DidSave\",\n    WP: \"WillPrint\",\n    DP: \"DidPrint\"\n};\nconst PageActionEventType = {\n    O: \"PageOpen\",\n    C: \"PageClose\"\n};\nconst VerbosityLevel = {\n    ERRORS: 0,\n    WARNINGS: 1,\n    INFOS: 5\n};\nconst OPS = {\n    dependency: 1,\n    setLineWidth: 2,\n    setLineCap: 3,\n    setLineJoin: 4,\n    setMiterLimit: 5,\n    setDash: 6,\n    setRenderingIntent: 7,\n    setFlatness: 8,\n    setGState: 9,\n    save: 10,\n    restore: 11,\n    transform: 12,\n    moveTo: 13,\n    lineTo: 14,\n    curveTo: 15,\n    curveTo2: 16,\n    curveTo3: 17,\n    closePath: 18,\n    rectangle: 19,\n    stroke: 20,\n    closeStroke: 21,\n    fill: 22,\n    eoFill: 23,\n    fillStroke: 24,\n    eoFillStroke: 25,\n    closeFillStroke: 26,\n    closeEOFillStroke: 27,\n    endPath: 28,\n    clip: 29,\n    eoClip: 30,\n    beginText: 31,\n    endText: 32,\n    setCharSpacing: 33,\n    setWordSpacing: 34,\n    setHScale: 35,\n    setLeading: 36,\n    setFont: 37,\n    setTextRenderingMode: 38,\n    setTextRise: 39,\n    moveText: 40,\n    setLeadingMoveText: 41,\n    setTextMatrix: 42,\n    nextLine: 43,\n    showText: 44,\n    showSpacedText: 45,\n    nextLineShowText: 46,\n    nextLineSetSpacingShowText: 47,\n    setCharWidth: 48,\n    setCharWidthAndBounds: 49,\n    setStrokeColorSpace: 50,\n    setFillColorSpace: 51,\n    setStrokeColor: 52,\n    setStrokeColorN: 53,\n    setFillColor: 54,\n    setFillColorN: 55,\n    setStrokeGray: 56,\n    setFillGray: 57,\n    setStrokeRGBColor: 58,\n    setFillRGBColor: 59,\n    setStrokeCMYKColor: 60,\n    setFillCMYKColor: 61,\n    shadingFill: 62,\n    beginInlineImage: 63,\n    beginImageData: 64,\n    endInlineImage: 65,\n    paintXObject: 66,\n    markPoint: 67,\n    markPointProps: 68,\n    beginMarkedContent: 69,\n    beginMarkedContentProps: 70,\n    endMarkedContent: 71,\n    beginCompat: 72,\n    endCompat: 73,\n    paintFormXObjectBegin: 74,\n    paintFormXObjectEnd: 75,\n    beginGroup: 76,\n    endGroup: 77,\n    beginAnnotation: 80,\n    endAnnotation: 81,\n    paintImageMaskXObject: 83,\n    paintImageMaskXObjectGroup: 84,\n    paintImageXObject: 85,\n    paintInlineImageXObject: 86,\n    paintInlineImageXObjectGroup: 87,\n    paintImageXObjectRepeat: 88,\n    paintImageMaskXObjectRepeat: 89,\n    paintSolidColorImageMask: 90,\n    constructPath: 91,\n    setStrokeTransparent: 92,\n    setFillTransparent: 93,\n    rawFillPath: 94\n};\nconst DrawOPS = {\n    moveTo: 0,\n    lineTo: 1,\n    curveTo: 2,\n    closePath: 3\n};\nconst PasswordResponses = {\n    NEED_PASSWORD: 1,\n    INCORRECT_PASSWORD: 2\n};\nlet verbosity = VerbosityLevel.WARNINGS;\nfunction setVerbosityLevel(level) {\n    if (Number.isInteger(level)) {\n        verbosity = level;\n    }\n}\nfunction getVerbosityLevel() {\n    return verbosity;\n}\nfunction info(msg) {\n    if (verbosity >= VerbosityLevel.INFOS) {\n        console.log(`Info: ${msg}`);\n    }\n}\nfunction warn(msg) {\n    if (verbosity >= VerbosityLevel.WARNINGS) {\n        console.log(`Warning: ${msg}`);\n    }\n}\nfunction unreachable(msg) {\n    throw new Error(msg);\n}\nfunction assert(cond, msg) {\n    if (!cond) {\n        unreachable(msg);\n    }\n}\nfunction _isValidProtocol(url) {\n    switch(url?.protocol){\n        case \"http:\":\n        case \"https:\":\n        case \"ftp:\":\n        case \"mailto:\":\n        case \"tel:\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n    if (!url) {\n        return null;\n    }\n    if (options && typeof url === \"string\") {\n        if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n            const dots = url.match(/\\./g);\n            if (dots?.length >= 2) {\n                url = `http://${url}`;\n            }\n        }\n        if (options.tryConvertEncoding) {\n            try {\n                url = stringToUTF8String(url);\n            } catch  {}\n        }\n    }\n    const absoluteUrl = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);\n    return _isValidProtocol(absoluteUrl) ? absoluteUrl : null;\n}\nfunction updateUrlHash(url, hash, allowRel = false) {\n    const res = URL.parse(url);\n    if (res) {\n        res.hash = hash;\n        return res.href;\n    }\n    if (allowRel && createValidAbsoluteUrl(url, \"http://example.com\")) {\n        return url.split(\"#\", 1)[0] + `${hash ? `#${hash}` : \"\"}`;\n    }\n    return \"\";\n}\nfunction shadow(obj, prop, value, nonSerializable = false) {\n    Object.defineProperty(obj, prop, {\n        value,\n        enumerable: !nonSerializable,\n        configurable: true,\n        writable: false\n    });\n    return value;\n}\nconst BaseException = function BaseExceptionClosure() {\n    function BaseException(message, name) {\n        this.message = message;\n        this.name = name;\n    }\n    BaseException.prototype = new Error();\n    BaseException.constructor = BaseException;\n    return BaseException;\n}();\nclass PasswordException extends BaseException {\n    constructor(msg, code){\n        super(msg, \"PasswordException\");\n        this.code = code;\n    }\n}\nclass UnknownErrorException extends BaseException {\n    constructor(msg, details){\n        super(msg, \"UnknownErrorException\");\n        this.details = details;\n    }\n}\nclass InvalidPDFException extends BaseException {\n    constructor(msg){\n        super(msg, \"InvalidPDFException\");\n    }\n}\nclass ResponseException extends BaseException {\n    constructor(msg, status, missing){\n        super(msg, \"ResponseException\");\n        this.status = status;\n        this.missing = missing;\n    }\n}\nclass FormatError extends BaseException {\n    constructor(msg){\n        super(msg, \"FormatError\");\n    }\n}\nclass AbortException extends BaseException {\n    constructor(msg){\n        super(msg, \"AbortException\");\n    }\n}\nfunction bytesToString(bytes) {\n    if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n        unreachable(\"Invalid argument for bytesToString\");\n    }\n    const length = bytes.length;\n    const MAX_ARGUMENT_COUNT = 8192;\n    if (length < MAX_ARGUMENT_COUNT) {\n        return String.fromCharCode.apply(null, bytes);\n    }\n    const strBuf = [];\n    for(let i = 0; i < length; i += MAX_ARGUMENT_COUNT){\n        const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n        const chunk = bytes.subarray(i, chunkEnd);\n        strBuf.push(String.fromCharCode.apply(null, chunk));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToBytes(str) {\n    if (typeof str !== \"string\") {\n        unreachable(\"Invalid argument for stringToBytes\");\n    }\n    const length = str.length;\n    const bytes = new Uint8Array(length);\n    for(let i = 0; i < length; ++i){\n        bytes[i] = str.charCodeAt(i) & 0xff;\n    }\n    return bytes;\n}\nfunction string32(value) {\n    return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\nfunction objectSize(obj) {\n    return Object.keys(obj).length;\n}\nfunction isLittleEndian() {\n    const buffer8 = new Uint8Array(4);\n    buffer8[0] = 1;\n    const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n    return view32[0] === 1;\n}\nfunction isEvalSupported() {\n    try {\n        new Function(\"\");\n        return true;\n    } catch  {\n        return false;\n    }\n}\nclass util_FeatureTest {\n    static get isLittleEndian() {\n        return shadow(this, \"isLittleEndian\", isLittleEndian());\n    }\n    static get isEvalSupported() {\n        return shadow(this, \"isEvalSupported\", isEvalSupported());\n    }\n    static get isOffscreenCanvasSupported() {\n        return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n    }\n    static get isImageDecoderSupported() {\n        return shadow(this, \"isImageDecoderSupported\", typeof ImageDecoder !== \"undefined\");\n    }\n    static get platform() {\n        const { platform, userAgent } = navigator;\n        return shadow(this, \"platform\", {\n            isAndroid: userAgent.includes(\"Android\"),\n            isLinux: platform.includes(\"Linux\"),\n            isMac: platform.includes(\"Mac\"),\n            isWindows: platform.includes(\"Win\"),\n            isFirefox: userAgent.includes(\"Firefox\")\n        });\n    }\n    static get isCSSRoundSupported() {\n        return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n    }\n}\nconst hexNumbers = Array.from(Array(256).keys(), (n)=>n.toString(16).padStart(2, \"0\"));\nclass Util {\n    static makeHexColor(r, g, b) {\n        return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n    }\n    static domMatrixToTransform(dm) {\n        return [\n            dm.a,\n            dm.b,\n            dm.c,\n            dm.d,\n            dm.e,\n            dm.f\n        ];\n    }\n    static scaleMinMax(transform, minMax) {\n        let temp;\n        if (transform[0]) {\n            if (transform[0] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[0];\n            minMax[2] *= transform[0];\n            if (transform[3] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[3];\n            minMax[3] *= transform[3];\n        } else {\n            temp = minMax[0];\n            minMax[0] = minMax[1];\n            minMax[1] = temp;\n            temp = minMax[2];\n            minMax[2] = minMax[3];\n            minMax[3] = temp;\n            if (transform[1] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[1];\n            minMax[3] *= transform[1];\n            if (transform[2] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[2];\n            minMax[2] *= transform[2];\n        }\n        minMax[0] += transform[4];\n        minMax[1] += transform[5];\n        minMax[2] += transform[4];\n        minMax[3] += transform[5];\n    }\n    static transform(m1, m2) {\n        return [\n            m1[0] * m2[0] + m1[2] * m2[1],\n            m1[1] * m2[0] + m1[3] * m2[1],\n            m1[0] * m2[2] + m1[2] * m2[3],\n            m1[1] * m2[2] + m1[3] * m2[3],\n            m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n            m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n        ];\n    }\n    static multiplyByDOMMatrix(m, md) {\n        return [\n            m[0] * md.a + m[2] * md.b,\n            m[1] * md.a + m[3] * md.b,\n            m[0] * md.c + m[2] * md.d,\n            m[1] * md.c + m[3] * md.d,\n            m[0] * md.e + m[2] * md.f + m[4],\n            m[1] * md.e + m[3] * md.f + m[5]\n        ];\n    }\n    static applyTransform(p, m, pos = 0) {\n        const p0 = p[pos];\n        const p1 = p[pos + 1];\n        p[pos] = p0 * m[0] + p1 * m[2] + m[4];\n        p[pos + 1] = p0 * m[1] + p1 * m[3] + m[5];\n    }\n    static applyTransformToBezier(p, transform, pos = 0) {\n        const m0 = transform[0];\n        const m1 = transform[1];\n        const m2 = transform[2];\n        const m3 = transform[3];\n        const m4 = transform[4];\n        const m5 = transform[5];\n        for(let i = 0; i < 6; i += 2){\n            const pI = p[pos + i];\n            const pI1 = p[pos + i + 1];\n            p[pos + i] = pI * m0 + pI1 * m2 + m4;\n            p[pos + i + 1] = pI * m1 + pI1 * m3 + m5;\n        }\n    }\n    static applyInverseTransform(p, m) {\n        const p0 = p[0];\n        const p1 = p[1];\n        const d = m[0] * m[3] - m[1] * m[2];\n        p[0] = (p0 * m[3] - p1 * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n        p[1] = (-p0 * m[1] + p1 * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    }\n    static axialAlignedBoundingBox(rect, transform, output) {\n        const m0 = transform[0];\n        const m1 = transform[1];\n        const m2 = transform[2];\n        const m3 = transform[3];\n        const m4 = transform[4];\n        const m5 = transform[5];\n        const r0 = rect[0];\n        const r1 = rect[1];\n        const r2 = rect[2];\n        const r3 = rect[3];\n        let a0 = m0 * r0 + m4;\n        let a2 = a0;\n        let a1 = m0 * r2 + m4;\n        let a3 = a1;\n        let b0 = m3 * r1 + m5;\n        let b2 = b0;\n        let b1 = m3 * r3 + m5;\n        let b3 = b1;\n        if (m1 !== 0 || m2 !== 0) {\n            const m1r0 = m1 * r0;\n            const m1r2 = m1 * r2;\n            const m2r1 = m2 * r1;\n            const m2r3 = m2 * r3;\n            a0 += m2r1;\n            a3 += m2r1;\n            a1 += m2r3;\n            a2 += m2r3;\n            b0 += m1r0;\n            b3 += m1r0;\n            b1 += m1r2;\n            b2 += m1r2;\n        }\n        output[0] = Math.min(output[0], a0, a1, a2, a3);\n        output[1] = Math.min(output[1], b0, b1, b2, b3);\n        output[2] = Math.max(output[2], a0, a1, a2, a3);\n        output[3] = Math.max(output[3], b0, b1, b2, b3);\n    }\n    static inverseTransform(m) {\n        const d = m[0] * m[3] - m[1] * m[2];\n        return [\n            m[3] / d,\n            -m[1] / d,\n            -m[2] / d,\n            m[0] / d,\n            (m[2] * m[5] - m[4] * m[3]) / d,\n            (m[4] * m[1] - m[5] * m[0]) / d\n        ];\n    }\n    static singularValueDecompose2dScale(matrix, output) {\n        const m0 = matrix[0];\n        const m1 = matrix[1];\n        const m2 = matrix[2];\n        const m3 = matrix[3];\n        const a = m0 ** 2 + m1 ** 2;\n        const b = m0 * m2 + m1 * m3;\n        const c = m2 ** 2 + m3 ** 2;\n        const first = (a + c) / 2;\n        const second = Math.sqrt(first ** 2 - (a * c - b ** 2));\n        output[0] = Math.sqrt(first + second || 1);\n        output[1] = Math.sqrt(first - second || 1);\n    }\n    static normalizeRect(rect) {\n        const r = rect.slice(0);\n        if (rect[0] > rect[2]) {\n            r[0] = rect[2];\n            r[2] = rect[0];\n        }\n        if (rect[1] > rect[3]) {\n            r[1] = rect[3];\n            r[3] = rect[1];\n        }\n        return r;\n    }\n    static intersect(rect1, rect2) {\n        const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n        const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n        if (xLow > xHigh) {\n            return null;\n        }\n        const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n        const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n        if (yLow > yHigh) {\n            return null;\n        }\n        return [\n            xLow,\n            yLow,\n            xHigh,\n            yHigh\n        ];\n    }\n    static pointBoundingBox(x, y, minMax) {\n        minMax[0] = Math.min(minMax[0], x);\n        minMax[1] = Math.min(minMax[1], y);\n        minMax[2] = Math.max(minMax[2], x);\n        minMax[3] = Math.max(minMax[3], y);\n    }\n    static rectBoundingBox(x0, y0, x1, y1, minMax) {\n        minMax[0] = Math.min(minMax[0], x0, x1);\n        minMax[1] = Math.min(minMax[1], y0, y1);\n        minMax[2] = Math.max(minMax[2], x0, x1);\n        minMax[3] = Math.max(minMax[3], y0, y1);\n    }\n    static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {\n        if (t <= 0 || t >= 1) {\n            return;\n        }\n        const mt = 1 - t;\n        const tt = t * t;\n        const ttt = tt * t;\n        const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;\n        const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;\n        minMax[0] = Math.min(minMax[0], x);\n        minMax[1] = Math.min(minMax[1], y);\n        minMax[2] = Math.max(minMax[2], x);\n        minMax[3] = Math.max(minMax[3], y);\n    }\n    static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {\n        if (Math.abs(a) < 1e-12) {\n            if (Math.abs(b) >= 1e-12) {\n                this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);\n            }\n            return;\n        }\n        const delta = b ** 2 - 4 * c * a;\n        if (delta < 0) {\n            return;\n        }\n        const sqrtDelta = Math.sqrt(delta);\n        const a2 = 2 * a;\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);\n    }\n    static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n        minMax[0] = Math.min(minMax[0], x0, x3);\n        minMax[1] = Math.min(minMax[1], y0, y3);\n        minMax[2] = Math.max(minMax[2], x0, x3);\n        minMax[3] = Math.max(minMax[3], y0, y3);\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);\n    }\n}\nconst PDFStringTranslateTable = /* unused pure expression or super */ null && 0;\nfunction stringToPDFString(str, keepEscapeSequence = false) {\n    if (str[0] >= \"\\xef\") {\n        let encoding;\n        if (str[0] === \"\\xfe\" && str[1] === \"\\xff\") {\n            encoding = \"utf-16be\";\n            if (str.length % 2 === 1) {\n                str = str.slice(0, -1);\n            }\n        } else if (str[0] === \"\\xff\" && str[1] === \"\\xfe\") {\n            encoding = \"utf-16le\";\n            if (str.length % 2 === 1) {\n                str = str.slice(0, -1);\n            }\n        } else if (str[0] === \"\\xef\" && str[1] === \"\\xbb\" && str[2] === \"\\xbf\") {\n            encoding = \"utf-8\";\n        }\n        if (encoding) {\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(str);\n                const decoded = decoder.decode(buffer);\n                if (keepEscapeSequence || !decoded.includes(\"\\x1b\")) {\n                    return decoded;\n                }\n                return decoded.replaceAll(/\\x1b[^\\x1b]*(?:\\x1b|$)/g, \"\");\n            } catch (ex) {\n                warn(`stringToPDFString: \"${ex}\".`);\n            }\n        }\n    }\n    const strBuf = [];\n    for(let i = 0, ii = str.length; i < ii; i++){\n        const charCode = str.charCodeAt(i);\n        if (!keepEscapeSequence && charCode === 0x1b) {\n            while(++i < ii && str.charCodeAt(i) !== 0x1b){}\n            continue;\n        }\n        const code = PDFStringTranslateTable[charCode];\n        strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToUTF8String(str) {\n    return decodeURIComponent(escape(str));\n}\nfunction utf8StringToString(str) {\n    return unescape(encodeURIComponent(str));\n}\nfunction isArrayEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for(let i = 0, ii = arr1.length; i < ii; i++){\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getModificationDate(date = new Date()) {\n    if (!(date instanceof Date)) {\n        date = new Date(date);\n    }\n    const buffer = [\n        date.getUTCFullYear().toString(),\n        (date.getUTCMonth() + 1).toString().padStart(2, \"0\"),\n        date.getUTCDate().toString().padStart(2, \"0\"),\n        date.getUTCHours().toString().padStart(2, \"0\"),\n        date.getUTCMinutes().toString().padStart(2, \"0\"),\n        date.getUTCSeconds().toString().padStart(2, \"0\")\n    ];\n    return buffer.join(\"\");\n}\nlet NormalizeRegex = null;\nlet NormalizationMap = null;\nfunction normalizeUnicode(str) {\n    if (!NormalizeRegex) {\n        NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n        NormalizationMap = new Map([\n            [\n                \"ﬅ\",\n                \"ſt\"\n            ]\n        ]);\n    }\n    return str.replaceAll(NormalizeRegex, (_, p1, p2)=>p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2));\n}\nfunction getUuid() {\n    if (typeof crypto.randomUUID === \"function\") {\n        return crypto.randomUUID();\n    }\n    const buf = new Uint8Array(32);\n    crypto.getRandomValues(buf);\n    return bytesToString(buf);\n}\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nfunction _isValidExplicitDest(validRef, validName, dest) {\n    if (!Array.isArray(dest) || dest.length < 2) {\n        return false;\n    }\n    const [page, zoom, ...args] = dest;\n    if (!validRef(page) && !Number.isInteger(page)) {\n        return false;\n    }\n    if (!validName(zoom)) {\n        return false;\n    }\n    const argsLen = args.length;\n    let allowNull = true;\n    switch(zoom.name){\n        case \"XYZ\":\n            if (argsLen < 2 || argsLen > 3) {\n                return false;\n            }\n            break;\n        case \"Fit\":\n        case \"FitB\":\n            return argsLen === 0;\n        case \"FitH\":\n        case \"FitBH\":\n        case \"FitV\":\n        case \"FitBV\":\n            if (argsLen > 1) {\n                return false;\n            }\n            break;\n        case \"FitR\":\n            if (argsLen !== 4) {\n                return false;\n            }\n            allowNull = false;\n            break;\n        default:\n            return false;\n    }\n    for (const arg of args){\n        if (typeof arg === \"number\" || allowNull && arg === null) {\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\nfunction MathClamp(v, min, max) {\n    return Math.min(Math.max(v, min), max);\n}\nfunction toHexUtil(arr) {\n    if (Uint8Array.prototype.toHex) {\n        return arr.toHex();\n    }\n    return Array.from(arr, (num)=>hexNumbers[num]).join(\"\");\n}\nfunction toBase64Util(arr) {\n    if (Uint8Array.prototype.toBase64) {\n        return arr.toBase64();\n    }\n    return btoa(bytesToString(arr));\n}\nfunction fromBase64Util(str) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(str);\n    }\n    return stringToBytes(atob(str));\n}\nif (typeof Promise.try !== \"function\") {\n    Promise.try = function(fn, ...args) {\n        return new Promise((resolve)=>{\n            resolve(fn(...args));\n        });\n    };\n}\nif (typeof Math.sumPrecise !== \"function\") {\n    Math.sumPrecise = function(numbers) {\n        return numbers.reduce((a, b)=>a + b, 0);\n    };\n}\n; // ./src/display/display_utils.js\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nclass PixelsPerInch {\n    static{\n        this.CSS = 96.0;\n    }\n    static{\n        this.PDF = 72.0;\n    }\n    static{\n        this.PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n    }\n}\nasync function fetchData(url, type = \"text\") {\n    if (isValidFetchUrl(url, document.baseURI)) {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n        switch(type){\n            case \"arraybuffer\":\n                return response.arrayBuffer();\n            case \"blob\":\n                return response.blob();\n            case \"json\":\n                return response.json();\n        }\n        return response.text();\n    }\n    return new Promise((resolve, reject)=>{\n        const request = new XMLHttpRequest();\n        request.open(\"GET\", url, true);\n        request.responseType = type;\n        request.onreadystatechange = ()=>{\n            if (request.readyState !== XMLHttpRequest.DONE) {\n                return;\n            }\n            if (request.status === 200 || request.status === 0) {\n                switch(type){\n                    case \"arraybuffer\":\n                    case \"blob\":\n                    case \"json\":\n                        resolve(request.response);\n                        return;\n                }\n                resolve(request.responseText);\n                return;\n            }\n            reject(new Error(request.statusText));\n        };\n        request.send(null);\n    });\n}\nclass PageViewport {\n    constructor({ viewBox, userUnit, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }){\n        this.viewBox = viewBox;\n        this.userUnit = userUnit;\n        this.scale = scale;\n        this.rotation = rotation;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        scale *= userUnit;\n        const centerX = (viewBox[2] + viewBox[0]) / 2;\n        const centerY = (viewBox[3] + viewBox[1]) / 2;\n        let rotateA, rotateB, rotateC, rotateD;\n        rotation %= 360;\n        if (rotation < 0) {\n            rotation += 360;\n        }\n        switch(rotation){\n            case 180:\n                rotateA = -1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = 1;\n                break;\n            case 90:\n                rotateA = 0;\n                rotateB = 1;\n                rotateC = 1;\n                rotateD = 0;\n                break;\n            case 270:\n                rotateA = 0;\n                rotateB = -1;\n                rotateC = -1;\n                rotateD = 0;\n                break;\n            case 0:\n                rotateA = 1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = -1;\n                break;\n            default:\n                throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n        }\n        if (dontFlip) {\n            rotateC = -rotateC;\n            rotateD = -rotateD;\n        }\n        let offsetCanvasX, offsetCanvasY;\n        let width, height;\n        if (rotateA === 0) {\n            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n            width = (viewBox[3] - viewBox[1]) * scale;\n            height = (viewBox[2] - viewBox[0]) * scale;\n        } else {\n            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n            width = (viewBox[2] - viewBox[0]) * scale;\n            height = (viewBox[3] - viewBox[1]) * scale;\n        }\n        this.transform = [\n            rotateA * scale,\n            rotateB * scale,\n            rotateC * scale,\n            rotateD * scale,\n            offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,\n            offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY\n        ];\n        this.width = width;\n        this.height = height;\n    }\n    get rawDims() {\n        const dims = this.viewBox;\n        return shadow(this, \"rawDims\", {\n            pageWidth: dims[2] - dims[0],\n            pageHeight: dims[3] - dims[1],\n            pageX: dims[0],\n            pageY: dims[1]\n        });\n    }\n    clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.viewBox.slice(),\n            userUnit: this.userUnit,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    convertToViewportPoint(x, y) {\n        const p = [\n            x,\n            y\n        ];\n        Util.applyTransform(p, this.transform);\n        return p;\n    }\n    convertToViewportRectangle(rect) {\n        const topLeft = [\n            rect[0],\n            rect[1]\n        ];\n        Util.applyTransform(topLeft, this.transform);\n        const bottomRight = [\n            rect[2],\n            rect[3]\n        ];\n        Util.applyTransform(bottomRight, this.transform);\n        return [\n            topLeft[0],\n            topLeft[1],\n            bottomRight[0],\n            bottomRight[1]\n        ];\n    }\n    convertToPdfPoint(x, y) {\n        const p = [\n            x,\n            y\n        ];\n        Util.applyInverseTransform(p, this.transform);\n        return p;\n    }\n}\nclass RenderingCancelledException extends BaseException {\n    constructor(msg, extraDelay = 0){\n        super(msg, \"RenderingCancelledException\");\n        this.extraDelay = extraDelay;\n    }\n}\nfunction isDataScheme(url) {\n    const ii = url.length;\n    let i = 0;\n    while(i < ii && url[i].trim() === \"\"){\n        i++;\n    }\n    return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\nfunction isPdfFile(filename) {\n    return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\nfunction getFilenameFromUrl(url) {\n    [url] = url.split(/[#?]/, 1);\n    return url.substring(url.lastIndexOf(\"/\") + 1);\n}\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n    if (typeof url !== \"string\") {\n        return defaultFilename;\n    }\n    if (isDataScheme(url)) {\n        warn('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n        return defaultFilename;\n    }\n    const getURL = (urlString)=>{\n        try {\n            return new URL(urlString);\n        } catch  {\n            try {\n                return new URL(decodeURIComponent(urlString));\n            } catch  {\n                try {\n                    return new URL(urlString, \"https://foo.bar\");\n                } catch  {\n                    try {\n                        return new URL(decodeURIComponent(urlString), \"https://foo.bar\");\n                    } catch  {\n                        return null;\n                    }\n                }\n            }\n        }\n    };\n    const newURL = getURL(url);\n    if (!newURL) {\n        return defaultFilename;\n    }\n    const decode = (name)=>{\n        try {\n            let decoded = decodeURIComponent(name);\n            if (decoded.includes(\"/\")) {\n                decoded = decoded.split(\"/\").at(-1);\n                if (decoded.test(/^\\.pdf$/i)) {\n                    return decoded;\n                }\n                return name;\n            }\n            return decoded;\n        } catch  {\n            return name;\n        }\n    };\n    const pdfRegex = /\\.pdf$/i;\n    const filename = newURL.pathname.split(\"/\").at(-1);\n    if (pdfRegex.test(filename)) {\n        return decode(filename);\n    }\n    if (newURL.searchParams.size > 0) {\n        const values = Array.from(newURL.searchParams.values()).reverse();\n        for (const value of values){\n            if (pdfRegex.test(value)) {\n                return decode(value);\n            }\n        }\n        const keys = Array.from(newURL.searchParams.keys()).reverse();\n        for (const key of keys){\n            if (pdfRegex.test(key)) {\n                return decode(key);\n            }\n        }\n    }\n    if (newURL.hash) {\n        const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n        const hashFilename = reFilename.exec(newURL.hash);\n        if (hashFilename) {\n            return decode(hashFilename[0]);\n        }\n    }\n    return defaultFilename;\n}\nclass StatTimer {\n    time(name) {\n        if (name in this.started) {\n            warn(`Timer is already running for ${name}`);\n        }\n        this.started[name] = Date.now();\n    }\n    timeEnd(name) {\n        if (!(name in this.started)) {\n            warn(`Timer has not been started for ${name}`);\n        }\n        this.times.push({\n            name,\n            start: this.started[name],\n            end: Date.now()\n        });\n        delete this.started[name];\n    }\n    toString() {\n        const outBuf = [];\n        let longest = 0;\n        for (const { name } of this.times){\n            longest = Math.max(name.length, longest);\n        }\n        for (const { name, start, end } of this.times){\n            outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n        }\n        return outBuf.join(\"\");\n    }\n    constructor(){\n        this.started = Object.create(null);\n        this.times = [];\n    }\n}\nfunction isValidFetchUrl(url, baseUrl) {\n    const res = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);\n    return res?.protocol === \"http:\" || res?.protocol === \"https:\";\n}\nfunction noContextMenu(e) {\n    e.preventDefault();\n}\nfunction stopEvent(e) {\n    e.preventDefault();\n    e.stopPropagation();\n}\nfunction deprecated(details) {\n    console.log(\"Deprecated API usage: \" + details);\n}\nclass PDFDateString {\n    static #regex;\n    static toDateObject(input) {\n        if (input instanceof Date) {\n            return input;\n        }\n        if (!input || typeof input !== \"string\") {\n            return null;\n        }\n        this.#regex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n        const matches = this.#regex.exec(input);\n        if (!matches) {\n            return null;\n        }\n        const year = parseInt(matches[1], 10);\n        let month = parseInt(matches[2], 10);\n        month = month >= 1 && month <= 12 ? month - 1 : 0;\n        let day = parseInt(matches[3], 10);\n        day = day >= 1 && day <= 31 ? day : 1;\n        let hour = parseInt(matches[4], 10);\n        hour = hour >= 0 && hour <= 23 ? hour : 0;\n        let minute = parseInt(matches[5], 10);\n        minute = minute >= 0 && minute <= 59 ? minute : 0;\n        let second = parseInt(matches[6], 10);\n        second = second >= 0 && second <= 59 ? second : 0;\n        const universalTimeRelation = matches[7] || \"Z\";\n        let offsetHour = parseInt(matches[8], 10);\n        offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n        let offsetMinute = parseInt(matches[9], 10) || 0;\n        offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n        if (universalTimeRelation === \"-\") {\n            hour += offsetHour;\n            minute += offsetMinute;\n        } else if (universalTimeRelation === \"+\") {\n            hour -= offsetHour;\n            minute -= offsetMinute;\n        }\n        return new Date(Date.UTC(year, month, day, hour, minute, second));\n    }\n}\nfunction getXfaPageViewport(xfaPage, { scale = 1, rotation = 0 }) {\n    const { width, height } = xfaPage.attributes.style;\n    const viewBox = [\n        0,\n        0,\n        parseInt(width),\n        parseInt(height)\n    ];\n    return new PageViewport({\n        viewBox,\n        userUnit: 1,\n        scale,\n        rotation\n    });\n}\nfunction getRGB(color) {\n    if (color.startsWith(\"#\")) {\n        const colorRGB = parseInt(color.slice(1), 16);\n        return [\n            (colorRGB & 0xff0000) >> 16,\n            (colorRGB & 0x00ff00) >> 8,\n            colorRGB & 0x0000ff\n        ];\n    }\n    if (color.startsWith(\"rgb(\")) {\n        return color.slice(4, -1).split(\",\").map((x)=>parseInt(x));\n    }\n    if (color.startsWith(\"rgba(\")) {\n        return color.slice(5, -1).split(\",\").map((x)=>parseInt(x)).slice(0, 3);\n    }\n    warn(`Not a valid color format: \"${color}\"`);\n    return [\n        0,\n        0,\n        0\n    ];\n}\nfunction getColorValues(colors) {\n    const span = document.createElement(\"span\");\n    span.style.visibility = \"hidden\";\n    span.style.colorScheme = \"only light\";\n    document.body.append(span);\n    for (const name of colors.keys()){\n        span.style.color = name;\n        const computedColor = window.getComputedStyle(span).color;\n        colors.set(name, getRGB(computedColor));\n    }\n    span.remove();\n}\nfunction getCurrentTransform(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction getCurrentTransformInverse(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform().invertSelf();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n    if (viewport instanceof PageViewport) {\n        const { pageWidth, pageHeight } = viewport.rawDims;\n        const { style } = div;\n        const useRound = util_FeatureTest.isCSSRoundSupported;\n        const w = `var(--total-scale-factor) * ${pageWidth}px`, h = `var(--total-scale-factor) * ${pageHeight}px`;\n        const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x))` : `calc(${w})`, heightStr = useRound ? `round(down, ${h}, var(--scale-round-y))` : `calc(${h})`;\n        if (!mustFlip || viewport.rotation % 180 === 0) {\n            style.width = widthStr;\n            style.height = heightStr;\n        } else {\n            style.width = heightStr;\n            style.height = widthStr;\n        }\n    }\n    if (mustRotate) {\n        div.setAttribute(\"data-main-rotation\", viewport.rotation);\n    }\n}\nclass OutputScale {\n    constructor(){\n        const { pixelRatio } = OutputScale;\n        this.sx = pixelRatio;\n        this.sy = pixelRatio;\n    }\n    get scaled() {\n        return this.sx !== 1 || this.sy !== 1;\n    }\n    get symmetric() {\n        return this.sx === this.sy;\n    }\n    limitCanvas(width, height, maxPixels, maxDim, capAreaFactor = -1) {\n        let maxAreaScale = Infinity, maxWidthScale = Infinity, maxHeightScale = Infinity;\n        maxPixels = OutputScale.capPixels(maxPixels, capAreaFactor);\n        if (maxPixels > 0) {\n            maxAreaScale = Math.sqrt(maxPixels / (width * height));\n        }\n        if (maxDim !== -1) {\n            maxWidthScale = maxDim / width;\n            maxHeightScale = maxDim / height;\n        }\n        const maxScale = Math.min(maxAreaScale, maxWidthScale, maxHeightScale);\n        if (this.sx > maxScale || this.sy > maxScale) {\n            this.sx = maxScale;\n            this.sy = maxScale;\n            return true;\n        }\n        return false;\n    }\n    static get pixelRatio() {\n        return globalThis.devicePixelRatio || 1;\n    }\n    static capPixels(maxPixels, capAreaFactor) {\n        if (capAreaFactor >= 0) {\n            const winPixels = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + capAreaFactor / 100));\n            return maxPixels > 0 ? Math.min(maxPixels, winPixels) : winPixels;\n        }\n        return maxPixels;\n    }\n}\nconst SupportedImageMimeTypes = [\n    \"image/apng\",\n    \"image/avif\",\n    \"image/bmp\",\n    \"image/gif\",\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/svg+xml\",\n    \"image/webp\",\n    \"image/x-icon\"\n];\n; // ./src/display/editor/toolbar.js\nclass EditorToolbar {\n    #toolbar;\n    #colorPicker;\n    #editor;\n    #buttons;\n    #altText;\n    #comment;\n    #signatureDescriptionButton;\n    static #l10nRemove = null;\n    constructor(editor){\n        this.#toolbar = null;\n        this.#colorPicker = null;\n        this.#buttons = null;\n        this.#altText = null;\n        this.#comment = null;\n        this.#signatureDescriptionButton = null;\n        this.#editor = editor;\n        EditorToolbar.#l10nRemove ||= Object.freeze({\n            freetext: \"pdfjs-editor-remove-freetext-button\",\n            highlight: \"pdfjs-editor-remove-highlight-button\",\n            ink: \"pdfjs-editor-remove-ink-button\",\n            stamp: \"pdfjs-editor-remove-stamp-button\",\n            signature: \"pdfjs-editor-remove-signature-button\"\n        });\n    }\n    render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.classList.add(\"editToolbar\", \"hidden\");\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        const signal = this.#editor._uiManager._signal;\n        if (signal instanceof AbortSignal && !signal.aborted) {\n            editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            editToolbar.addEventListener(\"pointerdown\", EditorToolbar.#pointerDown, {\n                signal\n            });\n        }\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        const position = this.#editor.toolbarPosition;\n        if (position) {\n            const { style } = editToolbar;\n            const x = this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0];\n            style.insetInlineEnd = `${100 * x}%`;\n            style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;\n        }\n        return editToolbar;\n    }\n    get div() {\n        return this.#toolbar;\n    }\n    static #pointerDown(e) {\n        e.stopPropagation();\n    }\n    #focusIn(e) {\n        this.#editor._focusEventsAllowed = false;\n        stopEvent(e);\n    }\n    #focusOut(e) {\n        this.#editor._focusEventsAllowed = true;\n        stopEvent(e);\n    }\n    #addListenersToElement(element) {\n        const signal = this.#editor._uiManager._signal;\n        if (!(signal instanceof AbortSignal) || signal.aborted) {\n            return false;\n        }\n        element.addEventListener(\"focusin\", this.#focusIn.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"focusout\", this.#focusOut.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        return true;\n    }\n    hide() {\n        this.#toolbar.classList.add(\"hidden\");\n        this.#colorPicker?.hideDropdown();\n    }\n    show() {\n        this.#toolbar.classList.remove(\"hidden\");\n        this.#altText?.shown();\n        this.#comment?.shown();\n    }\n    addDeleteButton() {\n        const { editorType, _uiManager } = this.#editor;\n        const button = document.createElement(\"button\");\n        button.classList.add(\"basic\", \"deleteButton\");\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", EditorToolbar.#l10nRemove[editorType]);\n        if (this.#addListenersToElement(button)) {\n            button.addEventListener(\"click\", (e)=>{\n                _uiManager.delete();\n            }, {\n                signal: _uiManager._signal\n            });\n        }\n        this.#buttons.append(button);\n    }\n    get #divider() {\n        const divider = document.createElement(\"div\");\n        divider.className = \"divider\";\n        return divider;\n    }\n    async addAltText(altText) {\n        const button = await altText.render();\n        this.#addListenersToElement(button);\n        this.#buttons.append(button, this.#divider);\n        this.#altText = altText;\n    }\n    addComment(comment) {\n        if (this.#comment) {\n            return;\n        }\n        const button = comment.render();\n        if (!button) {\n            return;\n        }\n        this.#addListenersToElement(button);\n        this.#buttons.append(button, this.#divider);\n        this.#comment = comment;\n        comment.toolbar = this;\n    }\n    addColorPicker(colorPicker) {\n        if (this.#colorPicker) {\n            return;\n        }\n        this.#colorPicker = colorPicker;\n        const button = colorPicker.renderButton();\n        this.#addListenersToElement(button);\n        this.#buttons.append(button, this.#divider);\n    }\n    async addEditSignatureButton(signatureManager) {\n        const button = this.#signatureDescriptionButton = await signatureManager.renderEditButton(this.#editor);\n        this.#addListenersToElement(button);\n        this.#buttons.append(button, this.#divider);\n    }\n    async addButton(name, tool) {\n        switch(name){\n            case \"colorPicker\":\n                this.addColorPicker(tool);\n                break;\n            case \"altText\":\n                await this.addAltText(tool);\n                break;\n            case \"editSignature\":\n                await this.addEditSignatureButton(tool);\n                break;\n            case \"delete\":\n                this.addDeleteButton();\n                break;\n            case \"comment\":\n                this.addComment(tool);\n                break;\n        }\n    }\n    updateEditSignatureButton(description) {\n        if (this.#signatureDescriptionButton) {\n            this.#signatureDescriptionButton.title = description;\n        }\n    }\n    remove() {\n        this.#toolbar.remove();\n        this.#colorPicker?.destroy();\n        this.#colorPicker = null;\n    }\n}\nclass FloatingToolbar {\n    #buttons;\n    #toolbar;\n    #uiManager;\n    constructor(uiManager){\n        this.#buttons = null;\n        this.#toolbar = null;\n        this.#uiManager = uiManager;\n    }\n    #render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.className = \"editToolbar\";\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        const signal = this.#uiManager._signal;\n        if (signal instanceof AbortSignal && !signal.aborted) {\n            editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n        }\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        if (this.#uiManager.hasCommentManager()) {\n            this.#makeButton(\"commentButton\", `pdfjs-comment-floating-button`, \"pdfjs-comment-floating-button-label\", ()=>{\n                this.#uiManager.commentSelection(\"floating_button\");\n            });\n        }\n        this.#makeButton(\"highlightButton\", `pdfjs-highlight-floating-button1`, \"pdfjs-highlight-floating-button-label\", ()=>{\n            this.#uiManager.highlightSelection(\"floating_button\");\n        });\n        return editToolbar;\n    }\n    #getLastPoint(boxes, isLTR) {\n        let lastY = 0;\n        let lastX = 0;\n        for (const box of boxes){\n            const y = box.y + box.height;\n            if (y < lastY) {\n                continue;\n            }\n            const x = box.x + (isLTR ? box.width : 0);\n            if (y > lastY) {\n                lastX = x;\n                lastY = y;\n                continue;\n            }\n            if (isLTR) {\n                if (x > lastX) {\n                    lastX = x;\n                }\n            } else if (x < lastX) {\n                lastX = x;\n            }\n        }\n        return [\n            isLTR ? 1 - lastX : lastX,\n            lastY\n        ];\n    }\n    show(parent, boxes, isLTR) {\n        const [x, y] = this.#getLastPoint(boxes, isLTR);\n        const { style } = this.#toolbar ||= this.#render();\n        parent.append(this.#toolbar);\n        style.insetInlineEnd = `${100 * x}%`;\n        style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;\n    }\n    hide() {\n        this.#toolbar.remove();\n    }\n    #makeButton(buttonClass, l10nId, labelL10nId, clickHandler) {\n        const button = document.createElement(\"button\");\n        button.classList.add(\"basic\", buttonClass);\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", l10nId);\n        const span = document.createElement(\"span\");\n        button.append(span);\n        span.className = \"visuallyHidden\";\n        span.setAttribute(\"data-l10n-id\", labelL10nId);\n        const signal = this.#uiManager._signal;\n        if (signal instanceof AbortSignal && !signal.aborted) {\n            button.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            button.addEventListener(\"click\", clickHandler, {\n                signal\n            });\n        }\n        this.#buttons.append(button);\n    }\n}\n; // ./src/display/editor/tools.js\nfunction bindEvents(obj, element, names) {\n    for (const name of names){\n        element.addEventListener(name, obj[name].bind(obj));\n    }\n}\nclass IdManager {\n    #id;\n    get id() {\n        return `${AnnotationEditorPrefix}${this.#id++}`;\n    }\n    constructor(){\n        this.#id = 0;\n    }\n}\nclass ImageManager {\n    #baseId;\n    #id;\n    #cache;\n    static get _isSVGFittingCanvas() {\n        const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n        const canvas = new OffscreenCanvas(1, 3);\n        const ctx = canvas.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        const image = new Image();\n        image.src = svg;\n        const promise = image.decode().then(()=>{\n            ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n            return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n        });\n        return shadow(this, \"_isSVGFittingCanvas\", promise);\n    }\n    async #get(key, rawData) {\n        this.#cache ||= new Map();\n        let data = this.#cache.get(key);\n        if (data === null) {\n            return null;\n        }\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        try {\n            data ||= {\n                bitmap: null,\n                id: `image_${this.#baseId}_${this.#id++}`,\n                refCounter: 0,\n                isSvg: false\n            };\n            let image;\n            if (typeof rawData === \"string\") {\n                data.url = rawData;\n                image = await fetchData(rawData, \"blob\");\n            } else if (rawData instanceof File) {\n                image = data.file = rawData;\n            } else if (rawData instanceof Blob) {\n                image = rawData;\n            }\n            if (image.type === \"image/svg+xml\") {\n                const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n                const fileReader = new FileReader();\n                const imageElement = new Image();\n                const imagePromise = new Promise((resolve, reject)=>{\n                    imageElement.onload = ()=>{\n                        data.bitmap = imageElement;\n                        data.isSvg = true;\n                        resolve();\n                    };\n                    fileReader.onload = async ()=>{\n                        const url = data.svgUrl = fileReader.result;\n                        imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;\n                    };\n                    imageElement.onerror = fileReader.onerror = reject;\n                });\n                fileReader.readAsDataURL(image);\n                await imagePromise;\n            } else {\n                data.bitmap = await createImageBitmap(image);\n            }\n            data.refCounter = 1;\n        } catch (e) {\n            warn(e);\n            data = null;\n        }\n        this.#cache.set(key, data);\n        if (data) {\n            this.#cache.set(data.id, data);\n        }\n        return data;\n    }\n    async getFromFile(file) {\n        const { lastModified, name, size, type } = file;\n        return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n    }\n    async getFromUrl(url) {\n        return this.#get(url, url);\n    }\n    async getFromBlob(id, blobPromise) {\n        const blob = await blobPromise;\n        return this.#get(id, blob);\n    }\n    async getFromId(id) {\n        this.#cache ||= new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return null;\n        }\n        if (data.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        if (data.file) {\n            return this.getFromFile(data.file);\n        }\n        if (data.blobPromise) {\n            const { blobPromise } = data;\n            delete data.blobPromise;\n            return this.getFromBlob(data.id, blobPromise);\n        }\n        return this.getFromUrl(data.url);\n    }\n    getFromCanvas(id, canvas) {\n        this.#cache ||= new Map();\n        let data = this.#cache.get(id);\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        const offscreen = new OffscreenCanvas(canvas.width, canvas.height);\n        const ctx = offscreen.getContext(\"2d\");\n        ctx.drawImage(canvas, 0, 0);\n        data = {\n            bitmap: offscreen.transferToImageBitmap(),\n            id: `image_${this.#baseId}_${this.#id++}`,\n            refCounter: 1,\n            isSvg: false\n        };\n        this.#cache.set(id, data);\n        this.#cache.set(data.id, data);\n        return data;\n    }\n    getSvgUrl(id) {\n        const data = this.#cache.get(id);\n        if (!data?.isSvg) {\n            return null;\n        }\n        return data.svgUrl;\n    }\n    deleteId(id) {\n        this.#cache ||= new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return;\n        }\n        data.refCounter -= 1;\n        if (data.refCounter !== 0) {\n            return;\n        }\n        const { bitmap } = data;\n        if (!data.url && !data.file) {\n            const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n            const ctx = canvas.getContext(\"bitmaprenderer\");\n            ctx.transferFromImageBitmap(bitmap);\n            data.blobPromise = canvas.convertToBlob();\n        }\n        bitmap.close?.();\n        data.bitmap = null;\n    }\n    isValidId(id) {\n        return id.startsWith(`image_${this.#baseId}_`);\n    }\n    constructor(){\n        this.#baseId = getUuid();\n        this.#id = 0;\n        this.#cache = null;\n    }\n}\nclass CommandManager {\n    #commands;\n    #locked;\n    #maxSize;\n    #position;\n    constructor(maxSize = 128){\n        this.#commands = [];\n        this.#locked = false;\n        this.#position = -1;\n        this.#maxSize = maxSize;\n    }\n    add({ cmd, undo, post, mustExec, type = NaN, overwriteIfSameType = false, keepUndo = false }) {\n        if (mustExec) {\n            cmd();\n        }\n        if (this.#locked) {\n            return;\n        }\n        const save = {\n            cmd,\n            undo,\n            post,\n            type\n        };\n        if (this.#position === -1) {\n            if (this.#commands.length > 0) {\n                this.#commands.length = 0;\n            }\n            this.#position = 0;\n            this.#commands.push(save);\n            return;\n        }\n        if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n            if (keepUndo) {\n                save.undo = this.#commands[this.#position].undo;\n            }\n            this.#commands[this.#position] = save;\n            return;\n        }\n        const next = this.#position + 1;\n        if (next === this.#maxSize) {\n            this.#commands.splice(0, 1);\n        } else {\n            this.#position = next;\n            if (next < this.#commands.length) {\n                this.#commands.splice(next);\n            }\n        }\n        this.#commands.push(save);\n    }\n    undo() {\n        if (this.#position === -1) {\n            return;\n        }\n        this.#locked = true;\n        const { undo, post } = this.#commands[this.#position];\n        undo();\n        post?.();\n        this.#locked = false;\n        this.#position -= 1;\n    }\n    redo() {\n        if (this.#position < this.#commands.length - 1) {\n            this.#position += 1;\n            this.#locked = true;\n            const { cmd, post } = this.#commands[this.#position];\n            cmd();\n            post?.();\n            this.#locked = false;\n        }\n    }\n    hasSomethingToUndo() {\n        return this.#position !== -1;\n    }\n    hasSomethingToRedo() {\n        return this.#position < this.#commands.length - 1;\n    }\n    cleanType(type) {\n        if (this.#position === -1) {\n            return;\n        }\n        for(let i = this.#position; i >= 0; i--){\n            if (this.#commands[i].type !== type) {\n                this.#commands.splice(i + 1, this.#position - i);\n                this.#position = i;\n                return;\n            }\n        }\n        this.#commands.length = 0;\n        this.#position = -1;\n    }\n    destroy() {\n        this.#commands = null;\n    }\n}\nclass KeyboardManager {\n    constructor(callbacks){\n        this.buffer = [];\n        this.callbacks = new Map();\n        this.allKeys = new Set();\n        const { isMac } = util_FeatureTest.platform;\n        for (const [keys, callback, options = {}] of callbacks){\n            for (const key of keys){\n                const isMacKey = key.startsWith(\"mac+\");\n                if (isMac && isMacKey) {\n                    this.callbacks.set(key.slice(4), {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                } else if (!isMac && !isMacKey) {\n                    this.callbacks.set(key, {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                }\n            }\n        }\n    }\n    #serialize(event) {\n        if (event.altKey) {\n            this.buffer.push(\"alt\");\n        }\n        if (event.ctrlKey) {\n            this.buffer.push(\"ctrl\");\n        }\n        if (event.metaKey) {\n            this.buffer.push(\"meta\");\n        }\n        if (event.shiftKey) {\n            this.buffer.push(\"shift\");\n        }\n        this.buffer.push(event.key);\n        const str = this.buffer.join(\"+\");\n        this.buffer.length = 0;\n        return str;\n    }\n    exec(self, event) {\n        if (!this.allKeys.has(event.key)) {\n            return;\n        }\n        const info = this.callbacks.get(this.#serialize(event));\n        if (!info) {\n            return;\n        }\n        const { callback, options: { bubbles = false, args = [], checker = null } } = info;\n        if (checker && !checker(self, event)) {\n            return;\n        }\n        callback.bind(self, ...args, event)();\n        if (!bubbles) {\n            stopEvent(event);\n        }\n    }\n}\nclass ColorManager {\n    static{\n        this._colorsMapping = new Map([\n            [\n                \"CanvasText\",\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            [\n                \"Canvas\",\n                [\n                    255,\n                    255,\n                    255\n                ]\n            ]\n        ]);\n    }\n    get _colors() {\n        const colors = new Map([\n            [\n                \"CanvasText\",\n                null\n            ],\n            [\n                \"Canvas\",\n                null\n            ]\n        ]);\n        getColorValues(colors);\n        return shadow(this, \"_colors\", colors);\n    }\n    convert(color) {\n        const rgb = getRGB(color);\n        if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n            return rgb;\n        }\n        for (const [name, RGB] of this._colors){\n            if (RGB.every((x, i)=>x === rgb[i])) {\n                return ColorManager._colorsMapping.get(name);\n            }\n        }\n        return rgb;\n    }\n    getHexCode(name) {\n        const rgb = this._colors.get(name);\n        if (!rgb) {\n            return name;\n        }\n        return Util.makeHexColor(...rgb);\n    }\n}\nclass AnnotationEditorUIManager {\n    #abortController;\n    #activeEditor;\n    #allEditableAnnotations;\n    #allEditors;\n    #allLayers;\n    #altTextManager;\n    #annotationStorage;\n    #changedExistingAnnotations;\n    #commandManager;\n    #commentManager;\n    #copyPasteAC;\n    #currentDrawingSession;\n    #currentPageIndex;\n    #deletedAnnotationsElementIds;\n    #draggingEditors;\n    #editorTypes;\n    #editorsToRescale;\n    #enableHighlightFloatingButton;\n    #enableUpdatedAddImage;\n    #enableNewAltTextWhenAddingImage;\n    #filterFactory;\n    #focusMainContainerTimeoutId;\n    #focusManagerAC;\n    #highlightColors;\n    #highlightWhenShiftUp;\n    #floatingToolbar;\n    #idManager;\n    #isEnabled;\n    #isPointerDown;\n    #isWaiting;\n    #keyboardManagerAC;\n    #lastActiveElement;\n    #mainHighlightColorPicker;\n    #missingCanvases;\n    #mlManager;\n    #mode;\n    #selectedEditors;\n    #selectedTextNode;\n    #signatureManager;\n    #pageColors;\n    #showAllStates;\n    #pdfDocument;\n    #previousStates;\n    #translation;\n    #translationTimeoutId;\n    #container;\n    #viewer;\n    #viewerAlert;\n    #updateModeCapability;\n    static{\n        this.TRANSLATE_SMALL = 1;\n    }\n    static{\n        this.TRANSLATE_BIG = 10;\n    }\n    static get _keyboardManager() {\n        const proto = AnnotationEditorUIManager.prototype;\n        const arrowChecker = (self)=>self.#container.contains(document.activeElement) && document.activeElement.tagName !== \"BUTTON\" && self.hasSomethingToControl();\n        const textInputChecker = (_self, { target: el })=>{\n            if (el instanceof HTMLInputElement) {\n                const { type } = el;\n                return type !== \"text\" && type !== \"number\";\n            }\n            return true;\n        };\n        const small = this.TRANSLATE_SMALL;\n        const big = this.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+a\",\n                    \"mac+meta+a\"\n                ],\n                proto.selectAll,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+z\",\n                    \"mac+meta+z\"\n                ],\n                proto.undo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+y\",\n                    \"ctrl+shift+z\",\n                    \"mac+meta+shift+z\",\n                    \"ctrl+shift+Z\",\n                    \"mac+meta+shift+Z\"\n                ],\n                proto.redo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Backspace\",\n                    \"alt+Backspace\",\n                    \"ctrl+Backspace\",\n                    \"shift+Backspace\",\n                    \"mac+Backspace\",\n                    \"mac+alt+Backspace\",\n                    \"mac+ctrl+Backspace\",\n                    \"Delete\",\n                    \"ctrl+Delete\",\n                    \"shift+Delete\",\n                    \"mac+Delete\"\n                ],\n                proto.delete,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Enter\",\n                    \"mac+Enter\"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self, { target: el })=>!(el instanceof HTMLButtonElement) && self.#container.contains(el) && !self.isEnterHandled\n                }\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self, { target: el })=>!(el instanceof HTMLButtonElement) && self.#container.contains(document.activeElement)\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.unselectAll\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    constructor(container, viewer, viewerAlert, altTextManager, commentManager, signatureManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom){\n        this.#abortController = new AbortController();\n        this.#activeEditor = null;\n        this.#allEditableAnnotations = null;\n        this.#allEditors = new Map();\n        this.#allLayers = new Map();\n        this.#altTextManager = null;\n        this.#annotationStorage = null;\n        this.#changedExistingAnnotations = null;\n        this.#commandManager = new CommandManager();\n        this.#commentManager = null;\n        this.#copyPasteAC = null;\n        this.#currentDrawingSession = null;\n        this.#currentPageIndex = 0;\n        this.#deletedAnnotationsElementIds = new Set();\n        this.#draggingEditors = null;\n        this.#editorTypes = null;\n        this.#editorsToRescale = new Set();\n        this._editorUndoBar = null;\n        this.#enableHighlightFloatingButton = false;\n        this.#enableUpdatedAddImage = false;\n        this.#enableNewAltTextWhenAddingImage = false;\n        this.#filterFactory = null;\n        this.#focusMainContainerTimeoutId = null;\n        this.#focusManagerAC = null;\n        this.#highlightColors = null;\n        this.#highlightWhenShiftUp = false;\n        this.#floatingToolbar = null;\n        this.#idManager = new IdManager();\n        this.#isEnabled = false;\n        this.#isPointerDown = false;\n        this.#isWaiting = false;\n        this.#keyboardManagerAC = null;\n        this.#lastActiveElement = null;\n        this.#mainHighlightColorPicker = null;\n        this.#missingCanvases = null;\n        this.#mlManager = null;\n        this.#mode = AnnotationEditorType.NONE;\n        this.#selectedEditors = new Set();\n        this.#selectedTextNode = null;\n        this.#signatureManager = null;\n        this.#pageColors = null;\n        this.#showAllStates = null;\n        this.#pdfDocument = null;\n        this.#previousStates = {\n            isEditing: false,\n            isEmpty: true,\n            hasSomethingToUndo: false,\n            hasSomethingToRedo: false,\n            hasSelectedEditor: false,\n            hasSelectedText: false\n        };\n        this.#translation = [\n            0,\n            0\n        ];\n        this.#translationTimeoutId = null;\n        this.#container = null;\n        this.#viewer = null;\n        this.#viewerAlert = null;\n        this.#updateModeCapability = null;\n        const signal = this._signal = this.#abortController.signal;\n        this.#container = container;\n        this.#viewer = viewer;\n        this.#viewerAlert = viewerAlert;\n        this.#altTextManager = altTextManager;\n        this.#commentManager = commentManager;\n        this.#signatureManager = signatureManager;\n        this.#pdfDocument = pdfDocument;\n        this._eventBus = eventBus;\n        eventBus._on(\"editingaction\", this.onEditingAction.bind(this), {\n            signal\n        });\n        eventBus._on(\"pagechanging\", this.onPageChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"scalechanging\", this.onScaleChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"rotationchanging\", this.onRotationChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"setpreference\", this.onSetPreference.bind(this), {\n            signal\n        });\n        eventBus._on(\"switchannotationeditorparams\", (evt)=>this.updateParams(evt.type, evt.value), {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", ()=>{\n            this.#isPointerDown = true;\n        }, {\n            capture: true,\n            signal\n        });\n        window.addEventListener(\"pointerup\", ()=>{\n            this.#isPointerDown = false;\n        }, {\n            capture: true,\n            signal\n        });\n        this.#addSelectionListener();\n        this.#addDragAndDropListeners();\n        this.#addKeyboardManager();\n        this.#annotationStorage = pdfDocument.annotationStorage;\n        this.#filterFactory = pdfDocument.filterFactory;\n        this.#pageColors = pageColors;\n        this.#highlightColors = highlightColors || null;\n        this.#enableHighlightFloatingButton = enableHighlightFloatingButton;\n        this.#enableUpdatedAddImage = enableUpdatedAddImage;\n        this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;\n        this.#mlManager = mlManager || null;\n        this.viewParameters = {\n            realScale: PixelsPerInch.PDF_TO_CSS_UNITS,\n            rotation: 0\n        };\n        this.isShiftKeyDown = false;\n        this._editorUndoBar = editorUndoBar || null;\n        this._supportsPinchToZoom = supportsPinchToZoom !== false;\n    }\n    destroy() {\n        this.#updateModeCapability?.resolve();\n        this.#updateModeCapability = null;\n        this.#abortController?.abort();\n        this.#abortController = null;\n        this._signal = null;\n        for (const layer of this.#allLayers.values()){\n            layer.destroy();\n        }\n        this.#allLayers.clear();\n        this.#allEditors.clear();\n        this.#editorsToRescale.clear();\n        this.#missingCanvases?.clear();\n        this.#activeEditor = null;\n        this.#selectedEditors.clear();\n        this.#commandManager.destroy();\n        this.#altTextManager?.destroy();\n        this.#commentManager?.destroy();\n        this.#signatureManager?.destroy();\n        this.#floatingToolbar?.hide();\n        this.#floatingToolbar = null;\n        this.#mainHighlightColorPicker?.destroy();\n        this.#mainHighlightColorPicker = null;\n        this.#allEditableAnnotations = null;\n        if (this.#focusMainContainerTimeoutId) {\n            clearTimeout(this.#focusMainContainerTimeoutId);\n            this.#focusMainContainerTimeoutId = null;\n        }\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n            this.#translationTimeoutId = null;\n        }\n        this._editorUndoBar?.destroy();\n        this.#pdfDocument = null;\n    }\n    combinedSignal(ac) {\n        return AbortSignal.any([\n            this._signal,\n            ac.signal\n        ]);\n    }\n    get mlManager() {\n        return this.#mlManager;\n    }\n    get useNewAltTextFlow() {\n        return this.#enableUpdatedAddImage;\n    }\n    get useNewAltTextWhenAddingImage() {\n        return this.#enableNewAltTextWhenAddingImage;\n    }\n    get hcmFilter() {\n        return shadow(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n    }\n    get direction() {\n        return shadow(this, \"direction\", getComputedStyle(this.#container).direction);\n    }\n    get _highlightColors() {\n        return shadow(this, \"_highlightColors\", this.#highlightColors ? new Map(this.#highlightColors.split(\",\").map((pair)=>{\n            pair = pair.split(\"=\").map((x)=>x.trim());\n            pair[1] = pair[1].toUpperCase();\n            return pair;\n        })) : null);\n    }\n    get highlightColors() {\n        const { _highlightColors } = this;\n        if (!_highlightColors) {\n            return shadow(this, \"highlightColors\", null);\n        }\n        const map = new Map();\n        const hasHCM = !!this.#pageColors;\n        for (const [name, color] of _highlightColors){\n            const isNameForHCM = name.endsWith(\"_HCM\");\n            if (hasHCM && isNameForHCM) {\n                map.set(name.replace(\"_HCM\", \"\"), color);\n                continue;\n            }\n            if (!hasHCM && !isNameForHCM) {\n                map.set(name, color);\n            }\n        }\n        return shadow(this, \"highlightColors\", map);\n    }\n    get highlightColorNames() {\n        return shadow(this, \"highlightColorNames\", this.highlightColors ? new Map(Array.from(this.highlightColors, (e)=>e.reverse())) : null);\n    }\n    getNonHCMColor(color) {\n        if (!this._highlightColors) {\n            return color;\n        }\n        const colorName = this.highlightColorNames.get(color);\n        return this._highlightColors.get(colorName) || color;\n    }\n    getNonHCMColorName(color) {\n        return this.highlightColorNames.get(color) || color;\n    }\n    setCurrentDrawingSession(layer) {\n        if (layer) {\n            this.unselectAll();\n            this.disableUserSelect(true);\n        } else {\n            this.disableUserSelect(false);\n        }\n        this.#currentDrawingSession = layer;\n    }\n    setMainHighlightColorPicker(colorPicker) {\n        this.#mainHighlightColorPicker = colorPicker;\n    }\n    editAltText(editor, firstTime = false) {\n        this.#altTextManager?.editAltText(this, editor, firstTime);\n    }\n    hasCommentManager() {\n        return !!this.#commentManager;\n    }\n    editComment(editor, position) {\n        this.#commentManager?.open(this, editor, position);\n    }\n    getSignature(editor) {\n        this.#signatureManager?.getSignature({\n            uiManager: this,\n            editor\n        });\n    }\n    get signatureManager() {\n        return this.#signatureManager;\n    }\n    switchToMode(mode, callback) {\n        this._eventBus.on(\"annotationeditormodechanged\", callback, {\n            once: true,\n            signal: this._signal\n        });\n        this._eventBus.dispatch(\"showannotationeditorui\", {\n            source: this,\n            mode\n        });\n    }\n    setPreference(name, value) {\n        this._eventBus.dispatch(\"setpreference\", {\n            source: this,\n            name,\n            value\n        });\n    }\n    onSetPreference({ name, value }) {\n        switch(name){\n            case \"enableNewAltTextWhenAddingImage\":\n                this.#enableNewAltTextWhenAddingImage = value;\n                break;\n        }\n    }\n    onPageChanging({ pageNumber }) {\n        this.#currentPageIndex = pageNumber - 1;\n    }\n    focusMainContainer() {\n        this.#container.focus();\n    }\n    findParent(x, y) {\n        for (const layer of this.#allLayers.values()){\n            const { x: layerX, y: layerY, width, height } = layer.div.getBoundingClientRect();\n            if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    disableUserSelect(value = false) {\n        this.#viewer.classList.toggle(\"noUserSelect\", value);\n    }\n    addShouldRescale(editor) {\n        this.#editorsToRescale.add(editor);\n    }\n    removeShouldRescale(editor) {\n        this.#editorsToRescale.delete(editor);\n    }\n    onScaleChanging({ scale }) {\n        this.commitOrRemove();\n        this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;\n        for (const editor of this.#editorsToRescale){\n            editor.onScaleChanging();\n        }\n        this.#currentDrawingSession?.onScaleChanging();\n    }\n    onRotationChanging({ pagesRotation }) {\n        this.commitOrRemove();\n        this.viewParameters.rotation = pagesRotation;\n    }\n    #getAnchorElementForSelection({ anchorNode }) {\n        return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;\n    }\n    #getLayerForTextLayer(textLayer) {\n        const { currentLayer } = this;\n        if (currentLayer.hasTextLayer(textLayer)) {\n            return currentLayer;\n        }\n        for (const layer of this.#allLayers.values()){\n            if (layer.hasTextLayer(textLayer)) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    highlightSelection(methodOfCreation = \"\", comment = false) {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;\n        const text = selection.toString();\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        selection.empty();\n        const layer = this.#getLayerForTextLayer(textLayer);\n        const isNoneMode = this.#mode === AnnotationEditorType.NONE;\n        const callback = ()=>{\n            const editor = layer?.createAndAddNewEditor({\n                x: 0,\n                y: 0\n            }, false, {\n                methodOfCreation,\n                boxes,\n                anchorNode,\n                anchorOffset,\n                focusNode,\n                focusOffset,\n                text\n            });\n            if (isNoneMode) {\n                this.showAllEditors(\"highlight\", true, true);\n            }\n            if (comment) {\n                editor?.editComment();\n            }\n        };\n        if (isNoneMode) {\n            this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);\n            return;\n        }\n        callback();\n    }\n    commentSelection(methodOfCreation = \"\") {\n        this.highlightSelection(methodOfCreation, true);\n    }\n    #displayFloatingToolbar() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        this.#floatingToolbar ||= new FloatingToolbar(this);\n        this.#floatingToolbar.show(textLayer, boxes, this.direction === \"ltr\");\n    }\n    addToAnnotationStorage(editor) {\n        if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n            this.#annotationStorage.setValue(editor.id, editor);\n        }\n    }\n    a11yAlert(messageId, args = null) {\n        const viewerAlert = this.#viewerAlert;\n        if (!viewerAlert) {\n            return;\n        }\n        viewerAlert.setAttribute(\"data-l10n-id\", messageId);\n        if (args) {\n            viewerAlert.setAttribute(\"data-l10n-args\", JSON.stringify(args));\n        } else {\n            viewerAlert.removeAttribute(\"data-l10n-args\");\n        }\n    }\n    #selectionChange() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            if (this.#selectedTextNode) {\n                this.#floatingToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        const { anchorNode } = selection;\n        if (anchorNode === this.#selectedTextNode) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        if (!textLayer) {\n            if (this.#selectedTextNode) {\n                this.#floatingToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        this.#floatingToolbar?.hide();\n        this.#selectedTextNode = anchorNode;\n        this.#dispatchUpdateStates({\n            hasSelectedText: true\n        });\n        if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.showAllEditors(\"highlight\", true, true);\n        }\n        this.#highlightWhenShiftUp = this.isShiftKeyDown;\n        if (!this.isShiftKeyDown) {\n            const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;\n            activeLayer?.toggleDrawing();\n            if (this.#isPointerDown) {\n                const ac = new AbortController();\n                const signal = this.combinedSignal(ac);\n                const pointerup = (e)=>{\n                    if (e.type === \"pointerup\" && e.button !== 0) {\n                        return;\n                    }\n                    ac.abort();\n                    activeLayer?.toggleDrawing(true);\n                    if (e.type === \"pointerup\") {\n                        this.#onSelectEnd(\"main_toolbar\");\n                    }\n                };\n                window.addEventListener(\"pointerup\", pointerup, {\n                    signal\n                });\n                window.addEventListener(\"blur\", pointerup, {\n                    signal\n                });\n            } else {\n                activeLayer?.toggleDrawing(true);\n                this.#onSelectEnd(\"main_toolbar\");\n            }\n        }\n    }\n    #onSelectEnd(methodOfCreation = \"\") {\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.highlightSelection(methodOfCreation);\n        } else if (this.#enableHighlightFloatingButton) {\n            this.#displayFloatingToolbar();\n        }\n    }\n    #addSelectionListener() {\n        document.addEventListener(\"selectionchange\", this.#selectionChange.bind(this), {\n            signal: this._signal\n        });\n    }\n    #addFocusManager() {\n        if (this.#focusManagerAC) {\n            return;\n        }\n        this.#focusManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#focusManagerAC);\n        window.addEventListener(\"focus\", this.focus.bind(this), {\n            signal\n        });\n        window.addEventListener(\"blur\", this.blur.bind(this), {\n            signal\n        });\n    }\n    #removeFocusManager() {\n        this.#focusManagerAC?.abort();\n        this.#focusManagerAC = null;\n    }\n    blur() {\n        this.isShiftKeyDown = false;\n        if (this.#highlightWhenShiftUp) {\n            this.#highlightWhenShiftUp = false;\n            this.#onSelectEnd(\"main_toolbar\");\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        const { activeElement } = document;\n        for (const editor of this.#selectedEditors){\n            if (editor.div.contains(activeElement)) {\n                this.#lastActiveElement = [\n                    editor,\n                    activeElement\n                ];\n                editor._focusEventsAllowed = false;\n                break;\n            }\n        }\n    }\n    focus() {\n        if (!this.#lastActiveElement) {\n            return;\n        }\n        const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n        this.#lastActiveElement = null;\n        lastActiveElement.addEventListener(\"focusin\", ()=>{\n            lastEditor._focusEventsAllowed = true;\n        }, {\n            once: true,\n            signal: this._signal\n        });\n        lastActiveElement.focus();\n    }\n    #addKeyboardManager() {\n        if (this.#keyboardManagerAC) {\n            return;\n        }\n        this.#keyboardManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#keyboardManagerAC);\n        window.addEventListener(\"keydown\", this.keydown.bind(this), {\n            signal\n        });\n        window.addEventListener(\"keyup\", this.keyup.bind(this), {\n            signal\n        });\n    }\n    #removeKeyboardManager() {\n        this.#keyboardManagerAC?.abort();\n        this.#keyboardManagerAC = null;\n    }\n    #addCopyPasteListeners() {\n        if (this.#copyPasteAC) {\n            return;\n        }\n        this.#copyPasteAC = new AbortController();\n        const signal = this.combinedSignal(this.#copyPasteAC);\n        document.addEventListener(\"copy\", this.copy.bind(this), {\n            signal\n        });\n        document.addEventListener(\"cut\", this.cut.bind(this), {\n            signal\n        });\n        document.addEventListener(\"paste\", this.paste.bind(this), {\n            signal\n        });\n    }\n    #removeCopyPasteListeners() {\n        this.#copyPasteAC?.abort();\n        this.#copyPasteAC = null;\n    }\n    #addDragAndDropListeners() {\n        const signal = this._signal;\n        document.addEventListener(\"dragover\", this.dragOver.bind(this), {\n            signal\n        });\n        document.addEventListener(\"drop\", this.drop.bind(this), {\n            signal\n        });\n    }\n    addEditListeners() {\n        this.#addKeyboardManager();\n        this.#addCopyPasteListeners();\n    }\n    removeEditListeners() {\n        this.#removeKeyboardManager();\n        this.#removeCopyPasteListeners();\n    }\n    dragOver(event) {\n        for (const { type } of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(type)) {\n                    event.dataTransfer.dropEffect = \"copy\";\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    drop(event) {\n        for (const item of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    copy(event) {\n        event.preventDefault();\n        this.#activeEditor?.commitOrRemove();\n        if (!this.hasSelection) {\n            return;\n        }\n        const editors = [];\n        for (const editor of this.#selectedEditors){\n            const serialized = editor.serialize(true);\n            if (serialized) {\n                editors.push(serialized);\n            }\n        }\n        if (editors.length === 0) {\n            return;\n        }\n        event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n    }\n    cut(event) {\n        this.copy(event);\n        this.delete();\n    }\n    async paste(event) {\n        event.preventDefault();\n        const { clipboardData } = event;\n        for (const item of clipboardData.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    return;\n                }\n            }\n        }\n        let data = clipboardData.getData(\"application/pdfjs\");\n        if (!data) {\n            return;\n        }\n        try {\n            data = JSON.parse(data);\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n            return;\n        }\n        if (!Array.isArray(data)) {\n            return;\n        }\n        this.unselectAll();\n        const layer = this.currentLayer;\n        try {\n            const newEditors = [];\n            for (const editor of data){\n                const deserializedEditor = await layer.deserialize(editor);\n                if (!deserializedEditor) {\n                    return;\n                }\n                newEditors.push(deserializedEditor);\n            }\n            const cmd = ()=>{\n                for (const editor of newEditors){\n                    this.#addEditorToLayer(editor);\n                }\n                this.#selectEditors(newEditors);\n            };\n            const undo = ()=>{\n                for (const editor of newEditors){\n                    editor.remove();\n                }\n            };\n            this.addCommands({\n                cmd,\n                undo,\n                mustExec: true\n            });\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n        }\n    }\n    keydown(event) {\n        if (!this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = true;\n        }\n        if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {\n            AnnotationEditorUIManager._keyboardManager.exec(this, event);\n        }\n    }\n    keyup(event) {\n        if (this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = false;\n            if (this.#highlightWhenShiftUp) {\n                this.#highlightWhenShiftUp = false;\n                this.#onSelectEnd(\"main_toolbar\");\n            }\n        }\n    }\n    onEditingAction({ name }) {\n        switch(name){\n            case \"undo\":\n            case \"redo\":\n            case \"delete\":\n            case \"selectAll\":\n                this[name]();\n                break;\n            case \"highlightSelection\":\n                this.highlightSelection(\"context_menu\");\n                break;\n            case \"commentSelection\":\n                this.commentSelection(\"context_menu\");\n                break;\n        }\n    }\n    #dispatchUpdateStates(details) {\n        const hasChanged = Object.entries(details).some(([key, value])=>this.#previousStates[key] !== value);\n        if (hasChanged) {\n            this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n                source: this,\n                details: Object.assign(this.#previousStates, details)\n            });\n            if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {\n                this.#dispatchUpdateUI([\n                    [\n                        AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                        true\n                    ]\n                ]);\n            }\n        }\n    }\n    #dispatchUpdateUI(details) {\n        this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n            source: this,\n            details\n        });\n    }\n    setEditingState(isEditing) {\n        if (isEditing) {\n            this.#addFocusManager();\n            this.#addCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: this.#mode !== AnnotationEditorType.NONE,\n                isEmpty: this.#isEmpty(),\n                hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                hasSelectedEditor: false\n            });\n        } else {\n            this.#removeFocusManager();\n            this.#removeCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: false\n            });\n            this.disableUserSelect(false);\n        }\n    }\n    registerEditorTypes(types) {\n        if (this.#editorTypes) {\n            return;\n        }\n        this.#editorTypes = types;\n        for (const editorType of this.#editorTypes){\n            this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n        }\n    }\n    getId() {\n        return this.#idManager.id;\n    }\n    get currentLayer() {\n        return this.#allLayers.get(this.#currentPageIndex);\n    }\n    getLayer(pageIndex) {\n        return this.#allLayers.get(pageIndex);\n    }\n    get currentPageIndex() {\n        return this.#currentPageIndex;\n    }\n    addLayer(layer) {\n        this.#allLayers.set(layer.pageIndex, layer);\n        if (this.#isEnabled) {\n            layer.enable();\n        } else {\n            layer.disable();\n        }\n    }\n    removeLayer(layer) {\n        this.#allLayers.delete(layer.pageIndex);\n    }\n    async updateMode(mode, editId = null, isFromKeyboard = false, mustEnterInEditMode = false, editComment = false) {\n        if (this.#mode === mode) {\n            return;\n        }\n        if (this.#updateModeCapability) {\n            await this.#updateModeCapability.promise;\n            if (!this.#updateModeCapability) {\n                return;\n            }\n        }\n        this.#updateModeCapability = Promise.withResolvers();\n        this.#currentDrawingSession?.commitOrRemove();\n        if (this.#mode === AnnotationEditorType.POPUP) {\n            this.#commentManager?.hideSidebar();\n        }\n        this.#mode = mode;\n        if (mode === AnnotationEditorType.NONE) {\n            this.setEditingState(false);\n            this.#disableAll();\n            this._editorUndoBar?.hide();\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        if (mode === AnnotationEditorType.SIGNATURE) {\n            await this.#signatureManager?.loadSignatures();\n        }\n        if (mode === AnnotationEditorType.POPUP) {\n            this.#allEditableAnnotations ||= await this.#pdfDocument.getAnnotationsByType(new Set(this.#editorTypes.map((editorClass)=>editorClass._editorType)));\n            this.#commentManager?.showSidebar(this.#allEditableAnnotations);\n        }\n        this.setEditingState(true);\n        await this.#enableAll();\n        this.unselectAll();\n        for (const layer of this.#allLayers.values()){\n            layer.updateMode(mode);\n        }\n        if (!editId) {\n            if (isFromKeyboard) {\n                this.addNewEditorFromKeyboard();\n            }\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        for (const editor of this.#allEditors.values()){\n            if (editor.annotationElementId === editId || editor.id === editId) {\n                this.setSelected(editor);\n                if (editComment) {\n                    editor.editComment();\n                } else if (mustEnterInEditMode) {\n                    editor.enterInEditMode();\n                }\n            } else {\n                editor.unselect();\n            }\n        }\n        this.#updateModeCapability.resolve();\n    }\n    addNewEditorFromKeyboard() {\n        if (this.currentLayer.canCreateNewEmptyEditor()) {\n            this.currentLayer.addNewEditor();\n        }\n    }\n    updateToolbar(options) {\n        if (options.mode === this.#mode) {\n            return;\n        }\n        this._eventBus.dispatch(\"switchannotationeditormode\", {\n            source: this,\n            ...options\n        });\n    }\n    updateParams(type, value) {\n        if (!this.#editorTypes) {\n            return;\n        }\n        switch(type){\n            case AnnotationEditorParamsType.CREATE:\n                this.currentLayer.addNewEditor(value);\n                return;\n            case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:\n                this._eventBus.dispatch(\"reporttelemetry\", {\n                    source: this,\n                    details: {\n                        type: \"editing\",\n                        data: {\n                            type: \"highlight\",\n                            action: \"toggle_visibility\"\n                        }\n                    }\n                });\n                (this.#showAllStates ||= new Map()).set(type, value);\n                this.showAllEditors(\"highlight\", value);\n                break;\n        }\n        if (this.hasSelection) {\n            for (const editor of this.#selectedEditors){\n                editor.updateParams(type, value);\n            }\n        } else {\n            for (const editorType of this.#editorTypes){\n                editorType.updateDefaultParams(type, value);\n            }\n        }\n    }\n    showAllEditors(type, visible, updateButton = false) {\n        for (const editor of this.#allEditors.values()){\n            if (editor.editorType === type) {\n                editor.show(visible);\n            }\n        }\n        const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;\n        if (state !== visible) {\n            this.#dispatchUpdateUI([\n                [\n                    AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL,\n                    visible\n                ]\n            ]);\n        }\n    }\n    enableWaiting(mustWait = false) {\n        if (this.#isWaiting === mustWait) {\n            return;\n        }\n        this.#isWaiting = mustWait;\n        for (const layer of this.#allLayers.values()){\n            if (mustWait) {\n                layer.disableClick();\n            } else {\n                layer.enableClick();\n            }\n            layer.div.classList.toggle(\"waiting\", mustWait);\n        }\n    }\n    async #enableAll() {\n        if (!this.#isEnabled) {\n            this.#isEnabled = true;\n            const promises = [];\n            for (const layer of this.#allLayers.values()){\n                promises.push(layer.enable());\n            }\n            await Promise.all(promises);\n            for (const editor of this.#allEditors.values()){\n                editor.enable();\n            }\n        }\n    }\n    #disableAll() {\n        this.unselectAll();\n        if (this.#isEnabled) {\n            this.#isEnabled = false;\n            for (const layer of this.#allLayers.values()){\n                layer.disable();\n            }\n            for (const editor of this.#allEditors.values()){\n                editor.disable();\n            }\n        }\n    }\n    getEditors(pageIndex) {\n        const editors = [];\n        for (const editor of this.#allEditors.values()){\n            if (editor.pageIndex === pageIndex) {\n                editors.push(editor);\n            }\n        }\n        return editors;\n    }\n    getEditor(id) {\n        return this.#allEditors.get(id);\n    }\n    addEditor(editor) {\n        this.#allEditors.set(editor.id, editor);\n    }\n    removeEditor(editor) {\n        if (editor.div.contains(document.activeElement)) {\n            if (this.#focusMainContainerTimeoutId) {\n                clearTimeout(this.#focusMainContainerTimeoutId);\n            }\n            this.#focusMainContainerTimeoutId = setTimeout(()=>{\n                this.focusMainContainer();\n                this.#focusMainContainerTimeoutId = null;\n            }, 0);\n        }\n        this.#allEditors.delete(editor.id);\n        if (editor.annotationElementId) {\n            this.#missingCanvases?.delete(editor.annotationElementId);\n        }\n        this.unselect(editor);\n        if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n            this.#annotationStorage?.remove(editor.id);\n        }\n    }\n    addDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n        this.addChangedExistingAnnotation(editor);\n        editor.deleted = true;\n    }\n    isDeletedAnnotationElement(annotationElementId) {\n        return this.#deletedAnnotationsElementIds.has(annotationElementId);\n    }\n    removeDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n        this.removeChangedExistingAnnotation(editor);\n        editor.deleted = false;\n    }\n    #addEditorToLayer(editor) {\n        const layer = this.#allLayers.get(editor.pageIndex);\n        if (layer) {\n            layer.addOrRebuild(editor);\n        } else {\n            this.addEditor(editor);\n            this.addToAnnotationStorage(editor);\n        }\n    }\n    setActiveEditor(editor) {\n        if (this.#activeEditor === editor) {\n            return;\n        }\n        this.#activeEditor = editor;\n        if (editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    get #lastSelectedEditor() {\n        let ed = null;\n        for (ed of this.#selectedEditors){}\n        return ed;\n    }\n    updateUI(editor) {\n        if (this.#lastSelectedEditor === editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    updateUIForDefaultProperties(editorType) {\n        this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n    }\n    toggleSelected(editor) {\n        if (this.#selectedEditors.has(editor)) {\n            this.#selectedEditors.delete(editor);\n            editor.unselect();\n            this.#dispatchUpdateStates({\n                hasSelectedEditor: this.hasSelection\n            });\n            return;\n        }\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    setSelected(editor) {\n        this.updateToolbar({\n            mode: editor.mode,\n            editId: editor.id\n        });\n        this.#currentDrawingSession?.commitOrRemove();\n        for (const ed of this.#selectedEditors){\n            if (ed !== editor) {\n                ed.unselect();\n            }\n        }\n        this.#selectedEditors.clear();\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    isSelected(editor) {\n        return this.#selectedEditors.has(editor);\n    }\n    get firstSelectedEditor() {\n        return this.#selectedEditors.values().next().value;\n    }\n    unselect(editor) {\n        editor.unselect();\n        this.#selectedEditors.delete(editor);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    get hasSelection() {\n        return this.#selectedEditors.size !== 0;\n    }\n    get isEnterHandled() {\n        return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;\n    }\n    undo() {\n        this.#commandManager.undo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n            hasSomethingToRedo: true,\n            isEmpty: this.#isEmpty()\n        });\n        this._editorUndoBar?.hide();\n    }\n    redo() {\n        this.#commandManager.redo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n            isEmpty: this.#isEmpty()\n        });\n    }\n    addCommands(params) {\n        this.#commandManager.add(params);\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: false,\n            isEmpty: this.#isEmpty()\n        });\n    }\n    cleanUndoStack(type) {\n        this.#commandManager.cleanType(type);\n    }\n    #isEmpty() {\n        if (this.#allEditors.size === 0) {\n            return true;\n        }\n        if (this.#allEditors.size === 1) {\n            for (const editor of this.#allEditors.values()){\n                return editor.isEmpty();\n            }\n        }\n        return false;\n    }\n    delete() {\n        this.commitOrRemove();\n        const drawingEditor = this.currentLayer?.endDrawingSession(true);\n        if (!this.hasSelection && !drawingEditor) {\n            return;\n        }\n        const editors = drawingEditor ? [\n            drawingEditor\n        ] : [\n            ...this.#selectedEditors\n        ];\n        const cmd = ()=>{\n            this._editorUndoBar?.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);\n            for (const editor of editors){\n                editor.remove();\n            }\n        };\n        const undo = ()=>{\n            for (const editor of editors){\n                this.#addEditorToLayer(editor);\n            }\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: true\n        });\n    }\n    commitOrRemove() {\n        this.#activeEditor?.commitOrRemove();\n    }\n    hasSomethingToControl() {\n        return this.#activeEditor || this.hasSelection;\n    }\n    #selectEditors(editors) {\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        for (const editor of editors){\n            if (editor.isEmpty()) {\n                continue;\n            }\n            this.#selectedEditors.add(editor);\n            editor.select();\n        }\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    selectAll() {\n        for (const editor of this.#selectedEditors){\n            editor.commit();\n        }\n        this.#selectEditors(this.#allEditors.values());\n    }\n    unselectAll() {\n        if (this.#activeEditor) {\n            this.#activeEditor.commitOrRemove();\n            if (this.#mode !== AnnotationEditorType.NONE) {\n                return;\n            }\n        }\n        if (this.#currentDrawingSession?.commitOrRemove()) {\n            return;\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: false\n        });\n    }\n    translateSelectedEditors(x, y, noCommit = false) {\n        if (!noCommit) {\n            this.commitOrRemove();\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        this.#translation[0] += x;\n        this.#translation[1] += y;\n        const [totalX, totalY] = this.#translation;\n        const editors = [\n            ...this.#selectedEditors\n        ];\n        const TIME_TO_WAIT = 1000;\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n        }\n        this.#translationTimeoutId = setTimeout(()=>{\n            this.#translationTimeoutId = null;\n            this.#translation[0] = this.#translation[1] = 0;\n            this.addCommands({\n                cmd: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(totalX, totalY);\n                            editor.translationDone();\n                        }\n                    }\n                },\n                undo: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(-totalX, -totalY);\n                            editor.translationDone();\n                        }\n                    }\n                },\n                mustExec: false\n            });\n        }, TIME_TO_WAIT);\n        for (const editor of editors){\n            editor.translateInPage(x, y);\n            editor.translationDone();\n        }\n    }\n    setUpDragSession() {\n        if (!this.hasSelection) {\n            return;\n        }\n        this.disableUserSelect(true);\n        this.#draggingEditors = new Map();\n        for (const editor of this.#selectedEditors){\n            this.#draggingEditors.set(editor, {\n                savedX: editor.x,\n                savedY: editor.y,\n                savedPageIndex: editor.pageIndex,\n                newX: 0,\n                newY: 0,\n                newPageIndex: -1\n            });\n        }\n    }\n    endDragSession() {\n        if (!this.#draggingEditors) {\n            return false;\n        }\n        this.disableUserSelect(false);\n        const map = this.#draggingEditors;\n        this.#draggingEditors = null;\n        let mustBeAddedInUndoStack = false;\n        for (const [{ x, y, pageIndex }, value] of map){\n            value.newX = x;\n            value.newY = y;\n            value.newPageIndex = pageIndex;\n            mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n        }\n        if (!mustBeAddedInUndoStack) {\n            return false;\n        }\n        const move = (editor, x, y, pageIndex)=>{\n            if (this.#allEditors.has(editor.id)) {\n                const parent = this.#allLayers.get(pageIndex);\n                if (parent) {\n                    editor._setParentAndPosition(parent, x, y);\n                } else {\n                    editor.pageIndex = pageIndex;\n                    editor.x = x;\n                    editor.y = y;\n                }\n            }\n        };\n        this.addCommands({\n            cmd: ()=>{\n                for (const [editor, { newX, newY, newPageIndex }] of map){\n                    move(editor, newX, newY, newPageIndex);\n                }\n            },\n            undo: ()=>{\n                for (const [editor, { savedX, savedY, savedPageIndex }] of map){\n                    move(editor, savedX, savedY, savedPageIndex);\n                }\n            },\n            mustExec: true\n        });\n        return true;\n    }\n    dragSelectedEditors(tx, ty) {\n        if (!this.#draggingEditors) {\n            return;\n        }\n        for (const editor of this.#draggingEditors.keys()){\n            editor.drag(tx, ty);\n        }\n    }\n    rebuild(editor) {\n        if (editor.parent === null) {\n            const parent = this.getLayer(editor.pageIndex);\n            if (parent) {\n                parent.changeParent(editor);\n                parent.addOrRebuild(editor);\n            } else {\n                this.addEditor(editor);\n                this.addToAnnotationStorage(editor);\n                editor.rebuild();\n            }\n        } else {\n            editor.parent.addOrRebuild(editor);\n        }\n    }\n    get isEditorHandlingKeyboard() {\n        return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();\n    }\n    isActive(editor) {\n        return this.#activeEditor === editor;\n    }\n    getActive() {\n        return this.#activeEditor;\n    }\n    getMode() {\n        return this.#mode;\n    }\n    get imageManager() {\n        return shadow(this, \"imageManager\", new ImageManager());\n    }\n    getSelectionBoxes(textLayer) {\n        if (!textLayer) {\n            return null;\n        }\n        const selection = document.getSelection();\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {\n                return null;\n            }\n        }\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        let rotator;\n        switch(textLayer.getAttribute(\"data-main-rotation\")){\n            case \"90\":\n                rotator = (x, y, w, h)=>({\n                        x: (y - layerY) / parentHeight,\n                        y: 1 - (x + w - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            case \"180\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (x + w - layerX) / parentWidth,\n                        y: 1 - (y + h - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n            case \"270\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (y + h - layerY) / parentHeight,\n                        y: (x - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            default:\n                rotator = (x, y, w, h)=>({\n                        x: (x - layerX) / parentWidth,\n                        y: (y - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n        }\n        const boxes = [];\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            const range = selection.getRangeAt(i);\n            if (range.collapsed) {\n                continue;\n            }\n            for (const { x, y, width, height } of range.getClientRects()){\n                if (width === 0 || height === 0) {\n                    continue;\n                }\n                boxes.push(rotator(x, y, width, height));\n            }\n        }\n        return boxes.length === 0 ? null : boxes;\n    }\n    addChangedExistingAnnotation({ annotationElementId, id }) {\n        (this.#changedExistingAnnotations ||= new Map()).set(annotationElementId, id);\n    }\n    removeChangedExistingAnnotation({ annotationElementId }) {\n        this.#changedExistingAnnotations?.delete(annotationElementId);\n    }\n    renderAnnotationElement(annotation) {\n        const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);\n        if (!editorId) {\n            return;\n        }\n        const editor = this.#annotationStorage.getRawValue(editorId);\n        if (!editor) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {\n            return;\n        }\n        editor.renderAnnotationElement(annotation);\n    }\n    setMissingCanvas(annotationId, annotationElementId, canvas) {\n        const editor = this.#missingCanvases?.get(annotationId);\n        if (!editor) {\n            return;\n        }\n        editor.setCanvas(annotationElementId, canvas);\n        this.#missingCanvases.delete(annotationId);\n    }\n    addMissingCanvas(annotationId, editor) {\n        (this.#missingCanvases ||= new Map()).set(annotationId, editor);\n    }\n}\n; // ./src/display/editor/alt_text.js\nclass AltText {\n    #altText;\n    #altTextDecorative;\n    #altTextButton;\n    #altTextButtonLabel;\n    #altTextTooltip;\n    #altTextTooltipTimeout;\n    #altTextWasFromKeyBoard;\n    #badge;\n    #editor;\n    #guessedText;\n    #textWithDisclaimer;\n    #useNewAltTextFlow;\n    static #l10nNewButton = null;\n    static{\n        this._l10n = null;\n    }\n    constructor(editor){\n        this.#altText = null;\n        this.#altTextDecorative = false;\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#altTextTooltipTimeout = null;\n        this.#altTextWasFromKeyBoard = false;\n        this.#badge = null;\n        this.#editor = null;\n        this.#guessedText = null;\n        this.#textWithDisclaimer = null;\n        this.#useNewAltTextFlow = false;\n        this.#editor = editor;\n        this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;\n        AltText.#l10nNewButton ||= Object.freeze({\n            added: \"pdfjs-editor-new-alt-text-added-button\",\n            \"added-label\": \"pdfjs-editor-new-alt-text-added-button-label\",\n            missing: \"pdfjs-editor-new-alt-text-missing-button\",\n            \"missing-label\": \"pdfjs-editor-new-alt-text-missing-button-label\",\n            review: \"pdfjs-editor-new-alt-text-to-review-button\",\n            \"review-label\": \"pdfjs-editor-new-alt-text-to-review-button-label\"\n        });\n    }\n    static initialize(l10n) {\n        AltText._l10n ??= l10n;\n    }\n    async render() {\n        const altText = this.#altTextButton = document.createElement(\"button\");\n        altText.className = \"altText\";\n        altText.tabIndex = \"0\";\n        const label = this.#altTextButtonLabel = document.createElement(\"span\");\n        altText.append(label);\n        if (this.#useNewAltTextFlow) {\n            altText.classList.add(\"new\");\n            altText.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton.missing);\n            label.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[\"missing-label\"]);\n        } else {\n            altText.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button\");\n            label.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button-label\");\n        }\n        const signal = this.#editor._uiManager._signal;\n        altText.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        altText.addEventListener(\"pointerdown\", (event)=>event.stopPropagation(), {\n            signal\n        });\n        const onClick = (event)=>{\n            event.preventDefault();\n            this.#editor._uiManager.editAltText(this.#editor);\n            if (this.#useNewAltTextFlow) {\n                this.#editor._reportTelemetry({\n                    action: \"pdfjs.image.alt_text.image_status_label_clicked\",\n                    data: {\n                        label: this.#label\n                    }\n                });\n            }\n        };\n        altText.addEventListener(\"click\", onClick, {\n            capture: true,\n            signal\n        });\n        altText.addEventListener(\"keydown\", (event)=>{\n            if (event.target === altText && event.key === \"Enter\") {\n                this.#altTextWasFromKeyBoard = true;\n                onClick(event);\n            }\n        }, {\n            signal\n        });\n        await this.#setState();\n        return altText;\n    }\n    get #label() {\n        return this.#altText && \"added\" || this.#altText === null && this.guessedText && \"review\" || \"missing\";\n    }\n    finish() {\n        if (!this.#altTextButton) {\n            return;\n        }\n        this.#altTextButton.focus({\n            focusVisible: this.#altTextWasFromKeyBoard\n        });\n        this.#altTextWasFromKeyBoard = false;\n    }\n    isEmpty() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText === null;\n        }\n        return !this.#altText && !this.#altTextDecorative;\n    }\n    hasData() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText !== null || !!this.#guessedText;\n        }\n        return this.isEmpty();\n    }\n    get guessedText() {\n        return this.#guessedText;\n    }\n    async setGuessedText(guessedText) {\n        if (this.#altText !== null) {\n            return;\n        }\n        this.#guessedText = guessedText;\n        this.#textWithDisclaimer = await AltText._l10n.get(\"pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer\", {\n            generatedAltText: guessedText\n        });\n        this.#setState();\n    }\n    toggleAltTextBadge(visibility = false) {\n        if (!this.#useNewAltTextFlow || this.#altText) {\n            this.#badge?.remove();\n            this.#badge = null;\n            return;\n        }\n        if (!this.#badge) {\n            const badge = this.#badge = document.createElement(\"div\");\n            badge.className = \"noAltTextBadge\";\n            this.#editor.div.append(badge);\n        }\n        this.#badge.classList.toggle(\"hidden\", !visibility);\n    }\n    serialize(isForCopying) {\n        let altText = this.#altText;\n        if (!isForCopying && this.#guessedText === altText) {\n            altText = this.#textWithDisclaimer;\n        }\n        return {\n            altText,\n            decorative: this.#altTextDecorative,\n            guessedText: this.#guessedText,\n            textWithDisclaimer: this.#textWithDisclaimer\n        };\n    }\n    get data() {\n        return {\n            altText: this.#altText,\n            decorative: this.#altTextDecorative\n        };\n    }\n    set data({ altText, decorative, guessedText, textWithDisclaimer, cancel = false }) {\n        if (guessedText) {\n            this.#guessedText = guessedText;\n            this.#textWithDisclaimer = textWithDisclaimer;\n        }\n        if (this.#altText === altText && this.#altTextDecorative === decorative) {\n            return;\n        }\n        if (!cancel) {\n            this.#altText = altText;\n            this.#altTextDecorative = decorative;\n        }\n        this.#setState();\n    }\n    toggle(enabled = false) {\n        if (!this.#altTextButton) {\n            return;\n        }\n        if (!enabled && this.#altTextTooltipTimeout) {\n            clearTimeout(this.#altTextTooltipTimeout);\n            this.#altTextTooltipTimeout = null;\n        }\n        this.#altTextButton.disabled = !enabled;\n    }\n    shown() {\n        this.#editor._reportTelemetry({\n            action: \"pdfjs.image.alt_text.image_status_label_displayed\",\n            data: {\n                label: this.#label\n            }\n        });\n    }\n    destroy() {\n        this.#altTextButton?.remove();\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#badge?.remove();\n        this.#badge = null;\n    }\n    async #setState() {\n        const button = this.#altTextButton;\n        if (!button) {\n            return;\n        }\n        if (this.#useNewAltTextFlow) {\n            button.classList.toggle(\"done\", !!this.#altText);\n            button.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[this.#label]);\n            this.#altTextButtonLabel?.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[`${this.#label}-label`]);\n            if (!this.#altText) {\n                this.#altTextTooltip?.remove();\n                return;\n            }\n        } else {\n            if (!this.#altText && !this.#altTextDecorative) {\n                button.classList.remove(\"done\");\n                this.#altTextTooltip?.remove();\n                return;\n            }\n            button.classList.add(\"done\");\n            button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-edit-button\");\n        }\n        let tooltip = this.#altTextTooltip;\n        if (!tooltip) {\n            this.#altTextTooltip = tooltip = document.createElement(\"span\");\n            tooltip.className = \"tooltip\";\n            tooltip.setAttribute(\"role\", \"tooltip\");\n            tooltip.id = `alt-text-tooltip-${this.#editor.id}`;\n            const DELAY_TO_SHOW_TOOLTIP = 100;\n            const signal = this.#editor._uiManager._signal;\n            signal.addEventListener(\"abort\", ()=>{\n                clearTimeout(this.#altTextTooltipTimeout);\n                this.#altTextTooltipTimeout = null;\n            }, {\n                once: true\n            });\n            button.addEventListener(\"mouseenter\", ()=>{\n                this.#altTextTooltipTimeout = setTimeout(()=>{\n                    this.#altTextTooltipTimeout = null;\n                    this.#altTextTooltip.classList.add(\"show\");\n                    this.#editor._reportTelemetry({\n                        action: \"alt_text_tooltip\"\n                    });\n                }, DELAY_TO_SHOW_TOOLTIP);\n            }, {\n                signal\n            });\n            button.addEventListener(\"mouseleave\", ()=>{\n                if (this.#altTextTooltipTimeout) {\n                    clearTimeout(this.#altTextTooltipTimeout);\n                    this.#altTextTooltipTimeout = null;\n                }\n                this.#altTextTooltip?.classList.remove(\"show\");\n            }, {\n                signal\n            });\n        }\n        if (this.#altTextDecorative) {\n            tooltip.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-decorative-tooltip\");\n        } else {\n            tooltip.removeAttribute(\"data-l10n-id\");\n            tooltip.textContent = this.#altText;\n        }\n        if (!tooltip.parentNode) {\n            button.append(tooltip);\n        }\n        const element = this.#editor.getElementForAltText();\n        element?.setAttribute(\"aria-describedby\", tooltip.id);\n    }\n}\n; // ./src/display/editor/comment.js\nclass Comment {\n    #commentButton;\n    #commentWasFromKeyBoard;\n    #editor;\n    #initialText;\n    #text;\n    #date;\n    #deleted;\n    constructor(editor){\n        this.#commentButton = null;\n        this.#commentWasFromKeyBoard = false;\n        this.#editor = null;\n        this.#initialText = null;\n        this.#text = null;\n        this.#date = null;\n        this.#deleted = false;\n        this.#editor = editor;\n        this.toolbar = null;\n    }\n    render() {\n        if (!this.#editor._uiManager.hasCommentManager()) {\n            return null;\n        }\n        const comment = this.#commentButton = document.createElement(\"button\");\n        comment.className = \"comment\";\n        comment.tabIndex = \"0\";\n        comment.setAttribute(\"data-l10n-id\", \"pdfjs-editor-edit-comment-button\");\n        const signal = this.#editor._uiManager._signal;\n        if (!(signal instanceof AbortSignal) || signal.aborted) {\n            return comment;\n        }\n        comment.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        comment.addEventListener(\"pointerdown\", (event)=>event.stopPropagation(), {\n            signal\n        });\n        const onClick = (event)=>{\n            event.preventDefault();\n            this.edit();\n        };\n        comment.addEventListener(\"click\", onClick, {\n            capture: true,\n            signal\n        });\n        comment.addEventListener(\"keydown\", (event)=>{\n            if (event.target === comment && event.key === \"Enter\") {\n                this.#commentWasFromKeyBoard = true;\n                onClick(event);\n            }\n        }, {\n            signal\n        });\n        return comment;\n    }\n    edit() {\n        const { bottom, left, right } = this.#editor.getClientDimensions();\n        const position = {\n            top: bottom\n        };\n        if (this.#editor._uiManager.direction === \"ltr\") {\n            position.right = right;\n        } else {\n            position.left = left;\n        }\n        this.#editor._uiManager.editComment(this.#editor, position);\n    }\n    finish() {\n        if (!this.#commentButton) {\n            return;\n        }\n        this.#commentButton.focus({\n            focusVisible: this.#commentWasFromKeyBoard\n        });\n        this.#commentWasFromKeyBoard = false;\n    }\n    isDeleted() {\n        return this.#deleted || this.#text === \"\";\n    }\n    hasBeenEdited() {\n        return this.isDeleted() || this.#text !== this.#initialText;\n    }\n    serialize() {\n        return this.data;\n    }\n    get data() {\n        return {\n            text: this.#text,\n            date: this.#date,\n            deleted: this.#deleted\n        };\n    }\n    set data(text) {\n        if (text === null) {\n            this.#text = \"\";\n            this.#deleted = true;\n            return;\n        }\n        this.#text = text;\n        this.#date = new Date();\n        this.#deleted = false;\n    }\n    setInitialText(text) {\n        this.#initialText = text;\n        this.data = text;\n    }\n    toggle(enabled = false) {\n        if (!this.#commentButton) {\n            return;\n        }\n        this.#commentButton.disabled = !enabled;\n    }\n    shown() {}\n    destroy() {\n        this.#commentButton?.remove();\n        this.#commentButton = null;\n        this.#text = \"\";\n        this.#date = null;\n        this.#editor = null;\n        this.#commentWasFromKeyBoard = false;\n        this.#deleted = false;\n    }\n}\n; // ./src/display/touch_manager.js\nclass TouchManager {\n    #container;\n    #isPinching;\n    #isPinchingStopped;\n    #isPinchingDisabled;\n    #onPinchStart;\n    #onPinching;\n    #onPinchEnd;\n    #pointerDownAC;\n    #signal;\n    #touchInfo;\n    #touchManagerAC;\n    #touchMoveAC;\n    constructor({ container, isPinchingDisabled = null, isPinchingStopped = null, onPinchStart = null, onPinching = null, onPinchEnd = null, signal }){\n        this.#isPinching = false;\n        this.#isPinchingStopped = null;\n        this.#pointerDownAC = null;\n        this.#touchInfo = null;\n        this.#touchMoveAC = null;\n        this.#container = container;\n        this.#isPinchingStopped = isPinchingStopped;\n        this.#isPinchingDisabled = isPinchingDisabled;\n        this.#onPinchStart = onPinchStart;\n        this.#onPinching = onPinching;\n        this.#onPinchEnd = onPinchEnd;\n        this.#touchManagerAC = new AbortController();\n        this.#signal = AbortSignal.any([\n            signal,\n            this.#touchManagerAC.signal\n        ]);\n        container.addEventListener(\"touchstart\", this.#onTouchStart.bind(this), {\n            passive: false,\n            signal: this.#signal\n        });\n    }\n    get MIN_TOUCH_DISTANCE_TO_PINCH() {\n        return 35 / OutputScale.pixelRatio;\n    }\n    #onTouchStart(evt) {\n        if (this.#isPinchingDisabled?.()) {\n            return;\n        }\n        if (evt.touches.length === 1) {\n            if (this.#pointerDownAC) {\n                return;\n            }\n            const pointerDownAC = this.#pointerDownAC = new AbortController();\n            const signal = AbortSignal.any([\n                this.#signal,\n                pointerDownAC.signal\n            ]);\n            const container = this.#container;\n            const opts = {\n                capture: true,\n                signal,\n                passive: false\n            };\n            const cancelPointerDown = (e)=>{\n                if (e.pointerType === \"touch\") {\n                    this.#pointerDownAC?.abort();\n                    this.#pointerDownAC = null;\n                }\n            };\n            container.addEventListener(\"pointerdown\", (e)=>{\n                if (e.pointerType === \"touch\") {\n                    stopEvent(e);\n                    cancelPointerDown(e);\n                }\n            }, opts);\n            container.addEventListener(\"pointerup\", cancelPointerDown, opts);\n            container.addEventListener(\"pointercancel\", cancelPointerDown, opts);\n            return;\n        }\n        if (!this.#touchMoveAC) {\n            this.#touchMoveAC = new AbortController();\n            const signal = AbortSignal.any([\n                this.#signal,\n                this.#touchMoveAC.signal\n            ]);\n            const container = this.#container;\n            const opt = {\n                signal,\n                capture: false,\n                passive: false\n            };\n            container.addEventListener(\"touchmove\", this.#onTouchMove.bind(this), opt);\n            const onTouchEnd = this.#onTouchEnd.bind(this);\n            container.addEventListener(\"touchend\", onTouchEnd, opt);\n            container.addEventListener(\"touchcancel\", onTouchEnd, opt);\n            opt.capture = true;\n            container.addEventListener(\"pointerdown\", stopEvent, opt);\n            container.addEventListener(\"pointermove\", stopEvent, opt);\n            container.addEventListener(\"pointercancel\", stopEvent, opt);\n            container.addEventListener(\"pointerup\", stopEvent, opt);\n            this.#onPinchStart?.();\n        }\n        stopEvent(evt);\n        if (evt.touches.length !== 2 || this.#isPinchingStopped?.()) {\n            this.#touchInfo = null;\n            return;\n        }\n        let [touch0, touch1] = evt.touches;\n        if (touch0.identifier > touch1.identifier) {\n            [touch0, touch1] = [\n                touch1,\n                touch0\n            ];\n        }\n        this.#touchInfo = {\n            touch0X: touch0.screenX,\n            touch0Y: touch0.screenY,\n            touch1X: touch1.screenX,\n            touch1Y: touch1.screenY\n        };\n    }\n    #onTouchMove(evt) {\n        if (!this.#touchInfo || evt.touches.length !== 2) {\n            return;\n        }\n        stopEvent(evt);\n        let [touch0, touch1] = evt.touches;\n        if (touch0.identifier > touch1.identifier) {\n            [touch0, touch1] = [\n                touch1,\n                touch0\n            ];\n        }\n        const { screenX: screen0X, screenY: screen0Y } = touch0;\n        const { screenX: screen1X, screenY: screen1Y } = touch1;\n        const touchInfo = this.#touchInfo;\n        const { touch0X: pTouch0X, touch0Y: pTouch0Y, touch1X: pTouch1X, touch1Y: pTouch1Y } = touchInfo;\n        const prevGapX = pTouch1X - pTouch0X;\n        const prevGapY = pTouch1Y - pTouch0Y;\n        const currGapX = screen1X - screen0X;\n        const currGapY = screen1Y - screen0Y;\n        const distance = Math.hypot(currGapX, currGapY) || 1;\n        const pDistance = Math.hypot(prevGapX, prevGapY) || 1;\n        if (!this.#isPinching && Math.abs(pDistance - distance) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) {\n            return;\n        }\n        touchInfo.touch0X = screen0X;\n        touchInfo.touch0Y = screen0Y;\n        touchInfo.touch1X = screen1X;\n        touchInfo.touch1Y = screen1Y;\n        if (!this.#isPinching) {\n            this.#isPinching = true;\n            return;\n        }\n        const origin = [\n            (screen0X + screen1X) / 2,\n            (screen0Y + screen1Y) / 2\n        ];\n        this.#onPinching?.(origin, pDistance, distance);\n    }\n    #onTouchEnd(evt) {\n        if (evt.touches.length >= 2) {\n            return;\n        }\n        if (this.#touchMoveAC) {\n            this.#touchMoveAC.abort();\n            this.#touchMoveAC = null;\n            this.#onPinchEnd?.();\n        }\n        if (!this.#touchInfo) {\n            return;\n        }\n        stopEvent(evt);\n        this.#touchInfo = null;\n        this.#isPinching = false;\n    }\n    destroy() {\n        this.#touchManagerAC?.abort();\n        this.#touchManagerAC = null;\n        this.#pointerDownAC?.abort();\n        this.#pointerDownAC = null;\n    }\n}\n; // ./src/display/editor/editor.js\nclass AnnotationEditor {\n    #accessibilityData;\n    #allResizerDivs;\n    #altText;\n    #comment;\n    #disabled;\n    #dragPointerId;\n    #dragPointerType;\n    #keepAspectRatio;\n    #resizersDiv;\n    #lastPointerCoords;\n    #savedDimensions;\n    #focusAC;\n    #focusedResizerName;\n    #hasBeenClicked;\n    #initialRect;\n    #isEditing;\n    #isInEditMode;\n    #isResizerEnabledForKeyboard;\n    #moveInDOMTimeout;\n    #prevDragX;\n    #prevDragY;\n    #telemetryTimeouts;\n    #touchManager;\n    static{\n        this._l10n = null;\n    }\n    static{\n        this._l10nResizer = null;\n    }\n    #isDraggable;\n    #zIndex;\n    static{\n        this._borderLineWidth = -1;\n    }\n    static{\n        this._colorManager = new ColorManager();\n    }\n    static{\n        this._zIndex = 1;\n    }\n    static{\n        this._telemetryTimeout = 1000;\n    }\n    static get _resizerKeyboardManager() {\n        const resize = AnnotationEditor.prototype._resizeWithKeyboard;\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_resizerKeyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                AnnotationEditor.prototype._stopResizingWithKeyboard\n            ]\n        ]));\n    }\n    constructor(parameters){\n        this.#accessibilityData = null;\n        this.#allResizerDivs = null;\n        this.#altText = null;\n        this.#comment = null;\n        this.#disabled = false;\n        this.#dragPointerId = null;\n        this.#dragPointerType = \"\";\n        this.#keepAspectRatio = false;\n        this.#resizersDiv = null;\n        this.#lastPointerCoords = null;\n        this.#savedDimensions = null;\n        this.#focusAC = null;\n        this.#focusedResizerName = \"\";\n        this.#hasBeenClicked = false;\n        this.#initialRect = null;\n        this.#isEditing = false;\n        this.#isInEditMode = false;\n        this.#isResizerEnabledForKeyboard = false;\n        this.#moveInDOMTimeout = null;\n        this.#prevDragX = 0;\n        this.#prevDragY = 0;\n        this.#telemetryTimeouts = null;\n        this.#touchManager = null;\n        this.isSelected = false;\n        this._isCopy = false;\n        this._editToolbar = null;\n        this._initialOptions = Object.create(null);\n        this._initialData = null;\n        this._isVisible = true;\n        this._uiManager = null;\n        this._focusEventsAllowed = true;\n        this.#isDraggable = false;\n        this.#zIndex = AnnotationEditor._zIndex++;\n        this.parent = parameters.parent;\n        this.id = parameters.id;\n        this.width = this.height = null;\n        this.pageIndex = parameters.parent.pageIndex;\n        this.name = parameters.name;\n        this.div = null;\n        this._uiManager = parameters.uiManager;\n        this.annotationElementId = null;\n        this._willKeepAspectRatio = false;\n        this._initialOptions.isCentered = parameters.isCentered;\n        this._structTreeParentId = null;\n        this.annotationElementId = parameters.annotationElementId || null;\n        const { rotation, rawDims: { pageWidth, pageHeight, pageX, pageY } } = this.parent.viewport;\n        this.rotation = rotation;\n        this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n        this.pageDimensions = [\n            pageWidth,\n            pageHeight\n        ];\n        this.pageTranslation = [\n            pageX,\n            pageY\n        ];\n        const [width, height] = this.parentDimensions;\n        this.x = parameters.x / width;\n        this.y = parameters.y / height;\n        this.isAttachedToDOM = false;\n        this.deleted = false;\n    }\n    get editorType() {\n        return Object.getPrototypeOf(this).constructor._type;\n    }\n    get mode() {\n        return Object.getPrototypeOf(this).constructor._editorType;\n    }\n    static get isDrawer() {\n        return false;\n    }\n    static get _defaultLineColor() {\n        return shadow(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n    }\n    static deleteAnnotationElement(editor) {\n        const fakeEditor = new FakeEditor({\n            id: editor.parent.getNextId(),\n            parent: editor.parent,\n            uiManager: editor._uiManager\n        });\n        fakeEditor.annotationElementId = editor.annotationElementId;\n        fakeEditor.deleted = true;\n        fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n    }\n    static initialize(l10n, _uiManager) {\n        AnnotationEditor._l10n ??= l10n;\n        AnnotationEditor._l10nResizer ||= Object.freeze({\n            topLeft: \"pdfjs-editor-resizer-top-left\",\n            topMiddle: \"pdfjs-editor-resizer-top-middle\",\n            topRight: \"pdfjs-editor-resizer-top-right\",\n            middleRight: \"pdfjs-editor-resizer-middle-right\",\n            bottomRight: \"pdfjs-editor-resizer-bottom-right\",\n            bottomMiddle: \"pdfjs-editor-resizer-bottom-middle\",\n            bottomLeft: \"pdfjs-editor-resizer-bottom-left\",\n            middleLeft: \"pdfjs-editor-resizer-middle-left\"\n        });\n        if (AnnotationEditor._borderLineWidth !== -1) {\n            return;\n        }\n        const style = getComputedStyle(document.documentElement);\n        AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n    }\n    static updateDefaultParams(_type, _value) {}\n    static get defaultPropertiesToUpdate() {\n        return [];\n    }\n    static isHandlingMimeForPasting(mime) {\n        return false;\n    }\n    static paste(item, parent) {\n        unreachable(\"Not implemented\");\n    }\n    get propertiesToUpdate() {\n        return [];\n    }\n    get _isDraggable() {\n        return this.#isDraggable;\n    }\n    set _isDraggable(value) {\n        this.#isDraggable = value;\n        this.div?.classList.toggle(\"draggable\", value);\n    }\n    get isEnterHandled() {\n        return true;\n    }\n    center() {\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        switch(this.parentRotation){\n            case 90:\n                this.x -= this.height * pageHeight / (pageWidth * 2);\n                this.y += this.width * pageWidth / (pageHeight * 2);\n                break;\n            case 180:\n                this.x += this.width / 2;\n                this.y += this.height / 2;\n                break;\n            case 270:\n                this.x += this.height * pageHeight / (pageWidth * 2);\n                this.y -= this.width * pageWidth / (pageHeight * 2);\n                break;\n            default:\n                this.x -= this.width / 2;\n                this.y -= this.height / 2;\n                break;\n        }\n        this.fixAndSetPosition();\n    }\n    addCommands(params) {\n        this._uiManager.addCommands(params);\n    }\n    get currentLayer() {\n        return this._uiManager.currentLayer;\n    }\n    setInBackground() {\n        this.div.style.zIndex = 0;\n    }\n    setInForeground() {\n        this.div.style.zIndex = this.#zIndex;\n    }\n    setParent(parent) {\n        if (parent !== null) {\n            this.pageIndex = parent.pageIndex;\n            this.pageDimensions = parent.pageDimensions;\n        } else {\n            this.#stopResizing();\n        }\n        this.parent = parent;\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.#hasBeenClicked) {\n            this.parent.setSelected(this);\n        } else {\n            this.#hasBeenClicked = false;\n        }\n    }\n    focusout(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            return;\n        }\n        const target = event.relatedTarget;\n        if (target?.closest(`#${this.id}`)) {\n            return;\n        }\n        event.preventDefault();\n        if (!this.parent?.isMultipleSelection) {\n            this.commitOrRemove();\n        }\n    }\n    commitOrRemove() {\n        if (this.isEmpty()) {\n            this.remove();\n        } else {\n            this.commit();\n        }\n    }\n    commit() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        this.addToAnnotationStorage();\n    }\n    addToAnnotationStorage() {\n        this._uiManager.addToAnnotationStorage(this);\n    }\n    setAt(x, y, tx, ty) {\n        const [width, height] = this.parentDimensions;\n        [tx, ty] = this.screenToPageTranslation(tx, ty);\n        this.x = (x + tx) / width;\n        this.y = (y + ty) / height;\n        this.fixAndSetPosition();\n    }\n    _moveAfterPaste(baseX, baseY) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n        this._onTranslated();\n    }\n    #translate([width, height], x, y) {\n        [x, y] = this.screenToPageTranslation(x, y);\n        this.x += x / width;\n        this.y += y / height;\n        this._onTranslating(this.x, this.y);\n        this.fixAndSetPosition();\n    }\n    translate(x, y) {\n        this.#translate(this.parentDimensions, x, y);\n    }\n    translateInPage(x, y) {\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        this.#translate(this.pageDimensions, x, y);\n        this.div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    translationDone() {\n        this._onTranslated(this.x, this.y);\n    }\n    drag(tx, ty) {\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        const { div, parentDimensions: [parentWidth, parentHeight] } = this;\n        this.x += tx / parentWidth;\n        this.y += ty / parentHeight;\n        if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n            const { x, y } = this.div.getBoundingClientRect();\n            if (this.parent.findNewParent(this, x, y)) {\n                this.x -= Math.floor(this.x);\n                this.y -= Math.floor(this.y);\n            }\n        }\n        let { x, y } = this;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        const { style } = div;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this._onTranslating(x, y);\n        div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    _onTranslating(x, y) {}\n    _onTranslated(x, y) {}\n    get _hasBeenMoved() {\n        return !!this.#initialRect && (this.#initialRect[0] !== this.x || this.#initialRect[1] !== this.y);\n    }\n    get _hasBeenResized() {\n        return !!this.#initialRect && (this.#initialRect[2] !== this.width || this.#initialRect[3] !== this.height);\n    }\n    getBaseTranslation() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { _borderLineWidth } = AnnotationEditor;\n        const x = _borderLineWidth / parentWidth;\n        const y = _borderLineWidth / parentHeight;\n        switch(this.rotation){\n            case 90:\n                return [\n                    -x,\n                    y\n                ];\n            case 180:\n                return [\n                    x,\n                    y\n                ];\n            case 270:\n                return [\n                    x,\n                    -y\n                ];\n            default:\n                return [\n                    -x,\n                    -y\n                ];\n        }\n    }\n    get _mustFixPosition() {\n        return true;\n    }\n    fixAndSetPosition(rotation = this.rotation) {\n        const { div: { style }, pageDimensions: [pageWidth, pageHeight] } = this;\n        let { x, y, width, height } = this;\n        width *= pageWidth;\n        height *= pageHeight;\n        x *= pageWidth;\n        y *= pageHeight;\n        if (this._mustFixPosition) {\n            switch(rotation){\n                case 0:\n                    x = MathClamp(x, 0, pageWidth - width);\n                    y = MathClamp(y, 0, pageHeight - height);\n                    break;\n                case 90:\n                    x = MathClamp(x, 0, pageWidth - height);\n                    y = MathClamp(y, width, pageHeight);\n                    break;\n                case 180:\n                    x = MathClamp(x, width, pageWidth);\n                    y = MathClamp(y, height, pageHeight);\n                    break;\n                case 270:\n                    x = MathClamp(x, height, pageWidth);\n                    y = MathClamp(y, 0, pageHeight - width);\n                    break;\n            }\n        }\n        this.x = x /= pageWidth;\n        this.y = y /= pageHeight;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this.moveInDOM();\n    }\n    static #rotatePoint(x, y, angle) {\n        switch(angle){\n            case 90:\n                return [\n                    y,\n                    -x\n                ];\n            case 180:\n                return [\n                    -x,\n                    -y\n                ];\n            case 270:\n                return [\n                    -y,\n                    x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    screenToPageTranslation(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n    }\n    pageTranslationToScreen(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n    }\n    #getRotationMatrix(rotation) {\n        switch(rotation){\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        -pageWidth / pageHeight,\n                        pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            case 180:\n                return [\n                    -1,\n                    0,\n                    0,\n                    -1\n                ];\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        pageWidth / pageHeight,\n                        -pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            default:\n                return [\n                    1,\n                    0,\n                    0,\n                    1\n                ];\n        }\n    }\n    get parentScale() {\n        return this._uiManager.viewParameters.realScale;\n    }\n    get parentRotation() {\n        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n    }\n    get parentDimensions() {\n        const { parentScale, pageDimensions: [pageWidth, pageHeight] } = this;\n        return [\n            pageWidth * parentScale,\n            pageHeight * parentScale\n        ];\n    }\n    setDims(width, height) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { style } = this.div;\n        style.width = `${(100 * width / parentWidth).toFixed(2)}%`;\n        if (!this.#keepAspectRatio) {\n            style.height = `${(100 * height / parentHeight).toFixed(2)}%`;\n        }\n    }\n    fixDims() {\n        const { style } = this.div;\n        const { height, width } = style;\n        const widthPercent = width.endsWith(\"%\");\n        const heightPercent = !this.#keepAspectRatio && height.endsWith(\"%\");\n        if (widthPercent && heightPercent) {\n            return;\n        }\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        if (!widthPercent) {\n            style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;\n        }\n        if (!this.#keepAspectRatio && !heightPercent) {\n            style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;\n        }\n    }\n    getInitialTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    #createResizers() {\n        if (this.#resizersDiv) {\n            return;\n        }\n        this.#resizersDiv = document.createElement(\"div\");\n        this.#resizersDiv.classList.add(\"resizers\");\n        const classes = this._willKeepAspectRatio ? [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomRight\",\n            \"bottomLeft\"\n        ] : [\n            \"topLeft\",\n            \"topMiddle\",\n            \"topRight\",\n            \"middleRight\",\n            \"bottomRight\",\n            \"bottomMiddle\",\n            \"bottomLeft\",\n            \"middleLeft\"\n        ];\n        const signal = this._uiManager._signal;\n        for (const name of classes){\n            const div = document.createElement(\"div\");\n            this.#resizersDiv.append(div);\n            div.classList.add(\"resizer\", name);\n            div.setAttribute(\"data-resizer-name\", name);\n            div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name), {\n                signal\n            });\n            div.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            div.tabIndex = -1;\n        }\n        this.div.prepend(this.#resizersDiv);\n    }\n    #resizerPointerdown(name, event) {\n        event.preventDefault();\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        this.#altText?.toggle(false);\n        const savedDraggable = this._isDraggable;\n        this._isDraggable = false;\n        this.#lastPointerCoords = [\n            event.screenX,\n            event.screenY\n        ];\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        this.parent.togglePointerEvents(false);\n        window.addEventListener(\"pointermove\", this.#resizerPointermove.bind(this, name), {\n            passive: true,\n            capture: true,\n            signal\n        });\n        window.addEventListener(\"touchmove\", stopEvent, {\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const savedParentCursor = this.parent.div.style.cursor;\n        const savedCursor = this.div.style.cursor;\n        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n        const pointerUpCallback = ()=>{\n            ac.abort();\n            this.parent.togglePointerEvents(true);\n            this.#altText?.toggle(true);\n            this._isDraggable = savedDraggable;\n            this.parent.div.style.cursor = savedParentCursor;\n            this.div.style.cursor = savedCursor;\n            this.#addResizeToUndoStack();\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    #resize(x, y, width, height) {\n        this.width = width;\n        this.height = height;\n        this.x = x;\n        this.y = y;\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(parentWidth * width, parentHeight * height);\n        this.fixAndSetPosition();\n        this._onResized();\n    }\n    _onResized() {}\n    #addResizeToUndoStack() {\n        if (!this.#savedDimensions) {\n            return;\n        }\n        const { savedX, savedY, savedWidth, savedHeight } = this.#savedDimensions;\n        this.#savedDimensions = null;\n        const newX = this.x;\n        const newY = this.y;\n        const newWidth = this.width;\n        const newHeight = this.height;\n        if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n            return;\n        }\n        this.addCommands({\n            cmd: this.#resize.bind(this, newX, newY, newWidth, newHeight),\n            undo: this.#resize.bind(this, savedX, savedY, savedWidth, savedHeight),\n            mustExec: true\n        });\n    }\n    static _round(x) {\n        return Math.round(x * 10000) / 10000;\n    }\n    #resizerPointermove(name, event) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n        const transf = (x, y)=>[\n                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                rotationMatrix[1] * x + rotationMatrix[3] * y\n            ];\n        const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n        const invTransf = (x, y)=>[\n                invRotationMatrix[0] * x + invRotationMatrix[2] * y,\n                invRotationMatrix[1] * x + invRotationMatrix[3] * y\n            ];\n        let getPoint;\n        let getOpposite;\n        let isDiagonal = false;\n        let isHorizontal = false;\n        switch(name){\n            case \"topLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h\n                    ];\n                break;\n            case \"topMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                break;\n            case \"topRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h\n                    ];\n                break;\n            case \"middleRight\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                break;\n            case \"bottomRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        0\n                    ];\n                break;\n            case \"bottomMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                break;\n            case \"bottomLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        0\n                    ];\n                break;\n            case \"middleLeft\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                break;\n        }\n        const point = getPoint(savedWidth, savedHeight);\n        const oppositePoint = getOpposite(savedWidth, savedHeight);\n        let transfOppositePoint = transf(...oppositePoint);\n        const oppositeX = AnnotationEditor._round(savedX + transfOppositePoint[0]);\n        const oppositeY = AnnotationEditor._round(savedY + transfOppositePoint[1]);\n        let ratioX = 1;\n        let ratioY = 1;\n        let deltaX, deltaY;\n        if (!event.fromKeyboard) {\n            const { screenX, screenY } = event;\n            const [lastScreenX, lastScreenY] = this.#lastPointerCoords;\n            [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);\n            this.#lastPointerCoords[0] = screenX;\n            this.#lastPointerCoords[1] = screenY;\n        } else {\n            ({ deltaX, deltaY } = event);\n        }\n        [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n        if (isDiagonal) {\n            const oldDiag = Math.hypot(savedWidth, savedHeight);\n            ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n        } else if (isHorizontal) {\n            ratioX = MathClamp(Math.abs(oppositePoint[0] - point[0] - deltaX), minWidth, 1) / savedWidth;\n        } else {\n            ratioY = MathClamp(Math.abs(oppositePoint[1] - point[1] - deltaY), minHeight, 1) / savedHeight;\n        }\n        const newWidth = AnnotationEditor._round(savedWidth * ratioX);\n        const newHeight = AnnotationEditor._round(savedHeight * ratioY);\n        transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n        const newX = oppositeX - transfOppositePoint[0];\n        const newY = oppositeY - transfOppositePoint[1];\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        this.width = newWidth;\n        this.height = newHeight;\n        this.x = newX;\n        this.y = newY;\n        this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n        this.fixAndSetPosition();\n        this._onResizing();\n    }\n    _onResizing() {}\n    altTextFinish() {\n        this.#altText?.finish();\n    }\n    get toolbarButtons() {\n        return null;\n    }\n    async addEditToolbar() {\n        if (this._editToolbar || this.#isInEditMode) {\n            return this._editToolbar;\n        }\n        this._editToolbar = new EditorToolbar(this);\n        this.div.append(this._editToolbar.render());\n        const { toolbarButtons } = this;\n        if (toolbarButtons) {\n            for (const [name, tool] of toolbarButtons){\n                await this._editToolbar.addButton(name, tool);\n            }\n        }\n        this._editToolbar.addButton(\"comment\", this.addCommentButton());\n        this._editToolbar.addButton(\"delete\");\n        return this._editToolbar;\n    }\n    removeEditToolbar() {\n        if (!this._editToolbar) {\n            return;\n        }\n        this._editToolbar.remove();\n        this._editToolbar = null;\n        this.#altText?.destroy();\n    }\n    addContainer(container) {\n        const editToolbarDiv = this._editToolbar?.div;\n        if (editToolbarDiv) {\n            editToolbarDiv.before(container);\n        } else {\n            this.div.append(container);\n        }\n    }\n    getClientDimensions() {\n        return this.div.getBoundingClientRect();\n    }\n    createAltText() {\n        if (!this.#altText) {\n            AltText.initialize(AnnotationEditor._l10n);\n            this.#altText = new AltText(this);\n            if (this.#accessibilityData) {\n                this.#altText.data = this.#accessibilityData;\n                this.#accessibilityData = null;\n            }\n        }\n        return this.#altText;\n    }\n    get altTextData() {\n        return this.#altText?.data;\n    }\n    set altTextData(data) {\n        if (!this.#altText) {\n            return;\n        }\n        this.#altText.data = data;\n    }\n    get guessedAltText() {\n        return this.#altText?.guessedText;\n    }\n    async setGuessedAltText(text) {\n        await this.#altText?.setGuessedText(text);\n    }\n    serializeAltText(isForCopying) {\n        return this.#altText?.serialize(isForCopying);\n    }\n    hasAltText() {\n        return !!this.#altText && !this.#altText.isEmpty();\n    }\n    hasAltTextData() {\n        return this.#altText?.hasData() ?? false;\n    }\n    addCommentButton() {\n        if (this.#comment) {\n            return this.#comment;\n        }\n        return this.#comment = new Comment(this);\n    }\n    get commentColor() {\n        return null;\n    }\n    get comment() {\n        const comment = this.#comment;\n        return {\n            text: comment.data.text,\n            date: comment.data.date,\n            deleted: comment.isDeleted(),\n            color: this.commentColor\n        };\n    }\n    set comment(text) {\n        if (!this.#comment) {\n            this.#comment = new Comment(this);\n        }\n        this.#comment.data = text;\n    }\n    setCommentData(text) {\n        if (!this.#comment) {\n            this.#comment = new Comment(this);\n        }\n        this.#comment.setInitialText(text);\n    }\n    get hasEditedComment() {\n        return this.#comment?.hasBeenEdited();\n    }\n    async editComment() {\n        if (!this.#comment) {\n            this.#comment = new Comment(this);\n        }\n        this.#comment.edit();\n    }\n    addComment(serialized) {\n        if (this.hasEditedComment) {\n            const DEFAULT_POPUP_WIDTH = 180;\n            const DEFAULT_POPUP_HEIGHT = 100;\n            const [, , , trY] = serialized.rect;\n            const [pageWidth] = this.pageDimensions;\n            const [pageX] = this.pageTranslation;\n            const blX = pageX + pageWidth + 1;\n            const blY = trY - DEFAULT_POPUP_HEIGHT;\n            const trX = blX + DEFAULT_POPUP_WIDTH;\n            serialized.popup = {\n                contents: this.comment.text,\n                deleted: this.comment.deleted,\n                rect: [\n                    blX,\n                    blY,\n                    trX,\n                    trY\n                ]\n            };\n        }\n    }\n    render() {\n        const div = this.div = document.createElement(\"div\");\n        div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n        div.className = this.name;\n        div.setAttribute(\"id\", this.id);\n        div.tabIndex = this.#disabled ? -1 : 0;\n        div.setAttribute(\"role\", \"application\");\n        if (this.defaultL10nId) {\n            div.setAttribute(\"data-l10n-id\", this.defaultL10nId);\n        }\n        if (!this._isVisible) {\n            div.classList.add(\"hidden\");\n        }\n        this.setInForeground();\n        this.#addFocusListeners();\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        if (this.parentRotation % 180 !== 0) {\n            div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n            div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n        }\n        const [tx, ty] = this.getInitialTranslation();\n        this.translate(tx, ty);\n        bindEvents(this, div, [\n            \"keydown\",\n            \"pointerdown\",\n            \"dblclick\"\n        ]);\n        if (this.isResizable && this._uiManager._supportsPinchToZoom) {\n            this.#touchManager ||= new TouchManager({\n                container: div,\n                isPinchingDisabled: ()=>!this.isSelected,\n                onPinchStart: this.#touchPinchStartCallback.bind(this),\n                onPinching: this.#touchPinchCallback.bind(this),\n                onPinchEnd: this.#touchPinchEndCallback.bind(this),\n                signal: this._uiManager._signal\n            });\n        }\n        this._uiManager._editorUndoBar?.hide();\n        return div;\n    }\n    #touchPinchStartCallback() {\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        this.#altText?.toggle(false);\n        this.parent.togglePointerEvents(false);\n    }\n    #touchPinchCallback(_origin, prevDistance, distance) {\n        const slowDownFactor = 0.7;\n        let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;\n        if (factor === 1) {\n            return;\n        }\n        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n        const transf = (x, y)=>[\n                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                rotationMatrix[1] * x + rotationMatrix[3] * y\n            ];\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n        factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n        const newWidth = AnnotationEditor._round(savedWidth * factor);\n        const newHeight = AnnotationEditor._round(savedHeight * factor);\n        if (newWidth === savedWidth && newHeight === savedHeight) {\n            return;\n        }\n        this.#initialRect ||= [\n            savedX,\n            savedY,\n            savedWidth,\n            savedHeight\n        ];\n        const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);\n        const centerX = AnnotationEditor._round(savedX + transfCenterPoint[0]);\n        const centerY = AnnotationEditor._round(savedY + transfCenterPoint[1]);\n        const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);\n        this.x = centerX - newTransfCenterPoint[0];\n        this.y = centerY - newTransfCenterPoint[1];\n        this.width = newWidth;\n        this.height = newHeight;\n        this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n        this.fixAndSetPosition();\n        this._onResizing();\n    }\n    #touchPinchEndCallback() {\n        this.#altText?.toggle(true);\n        this.parent.togglePointerEvents(true);\n        this.#addResizeToUndoStack();\n    }\n    pointerdown(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            event.preventDefault();\n            return;\n        }\n        this.#hasBeenClicked = true;\n        if (this._isDraggable) {\n            this.#setUpDragSession(event);\n            return;\n        }\n        this.#selectOnPointerEvent(event);\n    }\n    #selectOnPointerEvent(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n            this.parent.toggleSelected(this);\n        } else {\n            this.parent.setSelected(this);\n        }\n    }\n    #setUpDragSession(event) {\n        const { isSelected } = this;\n        this._uiManager.setUpDragSession();\n        let hasDraggingStarted = false;\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        const opts = {\n            capture: true,\n            passive: false,\n            signal\n        };\n        const cancelDrag = (e)=>{\n            ac.abort();\n            this.#dragPointerId = null;\n            this.#hasBeenClicked = false;\n            if (!this._uiManager.endDragSession()) {\n                this.#selectOnPointerEvent(e);\n            }\n            if (hasDraggingStarted) {\n                this._onStopDragging();\n            }\n        };\n        if (isSelected) {\n            this.#prevDragX = event.clientX;\n            this.#prevDragY = event.clientY;\n            this.#dragPointerId = event.pointerId;\n            this.#dragPointerType = event.pointerType;\n            window.addEventListener(\"pointermove\", (e)=>{\n                if (!hasDraggingStarted) {\n                    hasDraggingStarted = true;\n                    this._onStartDragging();\n                }\n                const { clientX: x, clientY: y, pointerId } = e;\n                if (pointerId !== this.#dragPointerId) {\n                    stopEvent(e);\n                    return;\n                }\n                const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);\n                this.#prevDragX = x;\n                this.#prevDragY = y;\n                this._uiManager.dragSelectedEditors(tx, ty);\n            }, opts);\n            window.addEventListener(\"touchmove\", stopEvent, opts);\n            window.addEventListener(\"pointerdown\", (e)=>{\n                if (e.pointerType === this.#dragPointerType) {\n                    if (this.#touchManager || e.isPrimary) {\n                        cancelDrag(e);\n                    }\n                }\n                stopEvent(e);\n            }, opts);\n        }\n        const pointerUpCallback = (e)=>{\n            if (!this.#dragPointerId || this.#dragPointerId === e.pointerId) {\n                cancelDrag(e);\n                return;\n            }\n            stopEvent(e);\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    _onStartDragging() {}\n    _onStopDragging() {}\n    moveInDOM() {\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n        }\n        this.#moveInDOMTimeout = setTimeout(()=>{\n            this.#moveInDOMTimeout = null;\n            this.parent?.moveEditorInDOM(this);\n        }, 0);\n    }\n    _setParentAndPosition(parent, x, y) {\n        parent.changeParent(this);\n        this.x = x;\n        this.y = y;\n        this.fixAndSetPosition();\n        this._onTranslated();\n    }\n    getRect(tx, ty, rotation = this.rotation) {\n        const scale = this.parentScale;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const shiftX = tx / scale;\n        const shiftY = ty / scale;\n        const x = this.x * pageWidth;\n        const y = this.y * pageHeight;\n        const width = this.width * pageWidth;\n        const height = this.height * pageHeight;\n        switch(rotation){\n            case 0:\n                return [\n                    x + shiftX + pageX,\n                    pageHeight - y - shiftY - height + pageY,\n                    x + shiftX + width + pageX,\n                    pageHeight - y - shiftY + pageY\n                ];\n            case 90:\n                return [\n                    x + shiftY + pageX,\n                    pageHeight - y + shiftX + pageY,\n                    x + shiftY + height + pageX,\n                    pageHeight - y + shiftX + width + pageY\n                ];\n            case 180:\n                return [\n                    x - shiftX - width + pageX,\n                    pageHeight - y + shiftY + pageY,\n                    x - shiftX + pageX,\n                    pageHeight - y + shiftY + height + pageY\n                ];\n            case 270:\n                return [\n                    x - shiftY - height + pageX,\n                    pageHeight - y - shiftX - width + pageY,\n                    x - shiftY + pageX,\n                    pageHeight - y - shiftX + pageY\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    getRectInCurrentCoords(rect, pageHeight) {\n        const [x1, y1, x2, y2] = rect;\n        const width = x2 - x1;\n        const height = y2 - y1;\n        switch(this.rotation){\n            case 0:\n                return [\n                    x1,\n                    pageHeight - y2,\n                    width,\n                    height\n                ];\n            case 90:\n                return [\n                    x1,\n                    pageHeight - y1,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    x2,\n                    pageHeight - y1,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    x2,\n                    pageHeight - y2,\n                    height,\n                    width\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    getPDFRect() {\n        return this.getRect(0, 0);\n    }\n    onceAdded(focus) {}\n    isEmpty() {\n        return false;\n    }\n    enableEditMode() {\n        if (this.isInEditMode()) {\n            return false;\n        }\n        this.parent.setEditingState(false);\n        this.#isInEditMode = true;\n        return true;\n    }\n    disableEditMode() {\n        if (!this.isInEditMode()) {\n            return false;\n        }\n        this.parent.setEditingState(true);\n        this.#isInEditMode = false;\n        return true;\n    }\n    isInEditMode() {\n        return this.#isInEditMode;\n    }\n    shouldGetKeyboardEvents() {\n        return this.#isResizerEnabledForKeyboard;\n    }\n    needsToBeRebuilt() {\n        return this.div && !this.isAttachedToDOM;\n    }\n    get isOnScreen() {\n        const { top, left, bottom, right } = this.getClientDimensions();\n        const { innerHeight, innerWidth } = window;\n        return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;\n    }\n    #addFocusListeners() {\n        if (this.#focusAC || !this.div) {\n            return;\n        }\n        this.#focusAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#focusAC);\n        this.div.addEventListener(\"focusin\", this.focusin.bind(this), {\n            signal\n        });\n        this.div.addEventListener(\"focusout\", this.focusout.bind(this), {\n            signal\n        });\n    }\n    rebuild() {\n        this.#addFocusListeners();\n    }\n    rotate(_angle) {}\n    resize() {}\n    serializeDeleted() {\n        return {\n            id: this.annotationElementId,\n            deleted: true,\n            pageIndex: this.pageIndex,\n            popupRef: this._initialData?.popupRef || \"\"\n        };\n    }\n    serialize(isForCopying = false, context = null) {\n        unreachable(\"An editor must be serializable\");\n    }\n    static async deserialize(data, parent, uiManager) {\n        const editor = new this.prototype.constructor({\n            parent,\n            id: parent.getNextId(),\n            uiManager,\n            annotationElementId: data.annotationElementId\n        });\n        editor.rotation = data.rotation;\n        editor.#accessibilityData = data.accessibilityData;\n        editor._isCopy = data.isCopy || false;\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n        editor.x = x / pageWidth;\n        editor.y = y / pageHeight;\n        editor.width = width / pageWidth;\n        editor.height = height / pageHeight;\n        return editor;\n    }\n    get hasBeenModified() {\n        return !!this.annotationElementId && (this.deleted || this.serialize() !== null);\n    }\n    remove() {\n        this.#focusAC?.abort();\n        this.#focusAC = null;\n        if (!this.isEmpty()) {\n            this.commit();\n        }\n        if (this.parent) {\n            this.parent.remove(this);\n        } else {\n            this._uiManager.removeEditor(this);\n        }\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n            this.#moveInDOMTimeout = null;\n        }\n        this.#stopResizing();\n        this.removeEditToolbar();\n        if (this.#telemetryTimeouts) {\n            for (const timeout of this.#telemetryTimeouts.values()){\n                clearTimeout(timeout);\n            }\n            this.#telemetryTimeouts = null;\n        }\n        this.parent = null;\n        this.#touchManager?.destroy();\n        this.#touchManager = null;\n    }\n    get isResizable() {\n        return false;\n    }\n    makeResizable() {\n        if (this.isResizable) {\n            this.#createResizers();\n            this.#resizersDiv.classList.remove(\"hidden\");\n        }\n    }\n    get toolbarPosition() {\n        return null;\n    }\n    keydown(event) {\n        if (!this.isResizable || event.target !== this.div || event.key !== \"Enter\") {\n            return;\n        }\n        this._uiManager.setSelected(this);\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const children = this.#resizersDiv.children;\n        if (!this.#allResizerDivs) {\n            this.#allResizerDivs = Array.from(children);\n            const boundResizerKeydown = this.#resizerKeydown.bind(this);\n            const boundResizerBlur = this.#resizerBlur.bind(this);\n            const signal = this._uiManager._signal;\n            for (const div of this.#allResizerDivs){\n                const name = div.getAttribute(\"data-resizer-name\");\n                div.setAttribute(\"role\", \"spinbutton\");\n                div.addEventListener(\"keydown\", boundResizerKeydown, {\n                    signal\n                });\n                div.addEventListener(\"blur\", boundResizerBlur, {\n                    signal\n                });\n                div.addEventListener(\"focus\", this.#resizerFocus.bind(this, name), {\n                    signal\n                });\n                div.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        const first = this.#allResizerDivs[0];\n        let firstPosition = 0;\n        for (const div of children){\n            if (div === first) {\n                break;\n            }\n            firstPosition++;\n        }\n        const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);\n        if (nextFirstPosition !== firstPosition) {\n            if (nextFirstPosition < firstPosition) {\n                for(let i = 0; i < firstPosition - nextFirstPosition; i++){\n                    this.#resizersDiv.append(this.#resizersDiv.firstChild);\n                }\n            } else if (nextFirstPosition > firstPosition) {\n                for(let i = 0; i < nextFirstPosition - firstPosition; i++){\n                    this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);\n                }\n            }\n            let i = 0;\n            for (const child of children){\n                const div = this.#allResizerDivs[i++];\n                const name = div.getAttribute(\"data-resizer-name\");\n                child.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        this.#setResizerTabIndex(0);\n        this.#isResizerEnabledForKeyboard = true;\n        this.#resizersDiv.firstChild.focus({\n            focusVisible: true\n        });\n        event.preventDefault();\n        event.stopImmediatePropagation();\n    }\n    #resizerKeydown(event) {\n        AnnotationEditor._resizerKeyboardManager.exec(this, event);\n    }\n    #resizerBlur(event) {\n        if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {\n            this.#stopResizing();\n        }\n    }\n    #resizerFocus(name) {\n        this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : \"\";\n    }\n    #setResizerTabIndex(value) {\n        if (!this.#allResizerDivs) {\n            return;\n        }\n        for (const div of this.#allResizerDivs){\n            div.tabIndex = value;\n        }\n    }\n    _resizeWithKeyboard(x, y) {\n        if (!this.#isResizerEnabledForKeyboard) {\n            return;\n        }\n        this.#resizerPointermove(this.#focusedResizerName, {\n            deltaX: x,\n            deltaY: y,\n            fromKeyboard: true\n        });\n    }\n    #stopResizing() {\n        this.#isResizerEnabledForKeyboard = false;\n        this.#setResizerTabIndex(-1);\n        this.#addResizeToUndoStack();\n    }\n    _stopResizingWithKeyboard() {\n        this.#stopResizing();\n        this.div.focus();\n    }\n    select() {\n        if (this.isSelected && this._editToolbar) {\n            return;\n        }\n        this.isSelected = true;\n        this.makeResizable();\n        this.div?.classList.add(\"selectedEditor\");\n        if (!this._editToolbar) {\n            this.addEditToolbar().then(()=>{\n                if (this.div?.classList.contains(\"selectedEditor\")) {\n                    this._editToolbar?.show();\n                }\n            });\n            return;\n        }\n        this._editToolbar?.show();\n        this.#altText?.toggleAltTextBadge(false);\n    }\n    unselect() {\n        if (!this.isSelected) {\n            return;\n        }\n        this.isSelected = false;\n        this.#resizersDiv?.classList.add(\"hidden\");\n        this.div?.classList.remove(\"selectedEditor\");\n        if (this.div?.contains(document.activeElement)) {\n            this._uiManager.currentLayer.div.focus({\n                preventScroll: true\n            });\n        }\n        this._editToolbar?.hide();\n        this.#altText?.toggleAltTextBadge(true);\n    }\n    updateParams(type, value) {}\n    disableEditing() {}\n    enableEditing() {}\n    get canChangeContent() {\n        return false;\n    }\n    enterInEditMode() {\n        if (!this.canChangeContent) {\n            return;\n        }\n        this.enableEditMode();\n        this.div.focus();\n    }\n    dblclick(event) {\n        this.enterInEditMode();\n        this.parent.updateToolbar({\n            mode: this.constructor._editorType,\n            editId: this.id\n        });\n    }\n    getElementForAltText() {\n        return this.div;\n    }\n    get contentDiv() {\n        return this.div;\n    }\n    get isEditing() {\n        return this.#isEditing;\n    }\n    set isEditing(value) {\n        this.#isEditing = value;\n        if (!this.parent) {\n            return;\n        }\n        if (value) {\n            this.parent.setSelected(this);\n            this.parent.setActiveEditor(this);\n        } else {\n            this.parent.setActiveEditor(null);\n        }\n    }\n    setAspectRatio(width, height) {\n        this.#keepAspectRatio = true;\n        const aspectRatio = width / height;\n        const { style } = this.div;\n        style.aspectRatio = aspectRatio;\n        style.height = \"auto\";\n    }\n    static get MIN_SIZE() {\n        return 16;\n    }\n    static canCreateNewEmptyEditor() {\n        return true;\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\"\n        };\n    }\n    get telemetryFinalData() {\n        return null;\n    }\n    _reportTelemetry(data, mustWait = false) {\n        if (mustWait) {\n            this.#telemetryTimeouts ||= new Map();\n            const { action } = data;\n            let timeout = this.#telemetryTimeouts.get(action);\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n            timeout = setTimeout(()=>{\n                this._reportTelemetry(data);\n                this.#telemetryTimeouts.delete(action);\n                if (this.#telemetryTimeouts.size === 0) {\n                    this.#telemetryTimeouts = null;\n                }\n            }, AnnotationEditor._telemetryTimeout);\n            this.#telemetryTimeouts.set(action, timeout);\n            return;\n        }\n        data.type ||= this.editorType;\n        this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n            source: this,\n            details: {\n                type: \"editing\",\n                data\n            }\n        });\n    }\n    show(visible = this._isVisible) {\n        this.div.classList.toggle(\"hidden\", !visible);\n        this._isVisible = visible;\n    }\n    enable() {\n        if (this.div) {\n            this.div.tabIndex = 0;\n        }\n        this.#disabled = false;\n    }\n    disable() {\n        if (this.div) {\n            this.div.tabIndex = -1;\n        }\n        this.#disabled = true;\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        let content = annotation.container.querySelector(\".annotationContent\");\n        if (!content) {\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            annotation.container.prepend(content);\n        } else if (content.nodeName === \"CANVAS\") {\n            const canvas = content;\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            canvas.before(content);\n        }\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        const { firstChild } = annotation.container;\n        if (firstChild?.nodeName === \"DIV\" && firstChild.classList.contains(\"annotationContent\")) {\n            firstChild.remove();\n        }\n    }\n}\nclass FakeEditor extends AnnotationEditor {\n    constructor(params){\n        super(params);\n        this.annotationElementId = params.annotationElementId;\n        this.deleted = true;\n    }\n    serialize() {\n        return this.serializeDeleted();\n    }\n}\n; // ./src/shared/murmurhash3.js\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\nclass MurmurHash3_64 {\n    constructor(seed){\n        this.h1 = seed ? seed & 0xffffffff : SEED;\n        this.h2 = seed ? seed & 0xffffffff : SEED;\n    }\n    update(input) {\n        let data, length;\n        if (typeof input === \"string\") {\n            data = new Uint8Array(input.length * 2);\n            length = 0;\n            for(let i = 0, ii = input.length; i < ii; i++){\n                const code = input.charCodeAt(i);\n                if (code <= 0xff) {\n                    data[length++] = code;\n                } else {\n                    data[length++] = code >>> 8;\n                    data[length++] = code & 0xff;\n                }\n            }\n        } else if (ArrayBuffer.isView(input)) {\n            data = input.slice();\n            length = data.byteLength;\n        } else {\n            throw new Error(\"Invalid data format, must be a string or TypedArray.\");\n        }\n        const blockCounts = length >> 2;\n        const tailLength = length - blockCounts * 4;\n        const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n        let k1 = 0, k2 = 0;\n        let h1 = this.h1, h2 = this.h2;\n        const C1 = 0xcc9e2d51, C2 = 0x1b873593;\n        const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;\n        for(let i = 0; i < blockCounts; i++){\n            if (i & 1) {\n                k1 = dataUint32[i];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                h1 ^= k1;\n                h1 = h1 << 13 | h1 >>> 19;\n                h1 = h1 * 5 + 0xe6546b64;\n            } else {\n                k2 = dataUint32[i];\n                k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n                k2 = k2 << 15 | k2 >>> 17;\n                k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n                h2 ^= k2;\n                h2 = h2 << 13 | h2 >>> 19;\n                h2 = h2 * 5 + 0xe6546b64;\n            }\n        }\n        k1 = 0;\n        switch(tailLength){\n            case 3:\n                k1 ^= data[blockCounts * 4 + 2] << 16;\n            case 2:\n                k1 ^= data[blockCounts * 4 + 1] << 8;\n            case 1:\n                k1 ^= data[blockCounts * 4];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                if (blockCounts & 1) {\n                    h1 ^= k1;\n                } else {\n                    h2 ^= k1;\n                }\n        }\n        this.h1 = h1;\n        this.h2 = h2;\n    }\n    hexdigest() {\n        let h1 = this.h1, h2 = this.h2;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n        h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n        h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n    }\n}\n; // ./src/display/annotation_storage.js\nconst SerializableEmpty = Object.freeze({\n    map: null,\n    hash: \"\",\n    transfer: undefined\n});\nclass AnnotationStorage {\n    #modified;\n    #modifiedIds;\n    #storage;\n    constructor(){\n        this.#modified = false;\n        this.#modifiedIds = null;\n        this.#storage = new Map();\n        this.onSetModified = null;\n        this.onResetModified = null;\n        this.onAnnotationEditor = null;\n    }\n    getValue(key, defaultValue) {\n        const value = this.#storage.get(key);\n        if (value === undefined) {\n            return defaultValue;\n        }\n        return Object.assign(defaultValue, value);\n    }\n    getRawValue(key) {\n        return this.#storage.get(key);\n    }\n    remove(key) {\n        this.#storage.delete(key);\n        if (this.#storage.size === 0) {\n            this.resetModified();\n        }\n        if (typeof this.onAnnotationEditor === \"function\") {\n            for (const value of this.#storage.values()){\n                if (value instanceof AnnotationEditor) {\n                    return;\n                }\n            }\n            this.onAnnotationEditor(null);\n        }\n    }\n    setValue(key, value) {\n        const obj = this.#storage.get(key);\n        let modified = false;\n        if (obj !== undefined) {\n            for (const [entry, val] of Object.entries(value)){\n                if (obj[entry] !== val) {\n                    modified = true;\n                    obj[entry] = val;\n                }\n            }\n        } else {\n            modified = true;\n            this.#storage.set(key, value);\n        }\n        if (modified) {\n            this.#setModified();\n        }\n        if (value instanceof AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n            this.onAnnotationEditor(value.constructor._type);\n        }\n    }\n    has(key) {\n        return this.#storage.has(key);\n    }\n    get size() {\n        return this.#storage.size;\n    }\n    #setModified() {\n        if (!this.#modified) {\n            this.#modified = true;\n            if (typeof this.onSetModified === \"function\") {\n                this.onSetModified();\n            }\n        }\n    }\n    resetModified() {\n        if (this.#modified) {\n            this.#modified = false;\n            if (typeof this.onResetModified === \"function\") {\n                this.onResetModified();\n            }\n        }\n    }\n    get print() {\n        return new PrintAnnotationStorage(this);\n    }\n    get serializable() {\n        if (this.#storage.size === 0) {\n            return SerializableEmpty;\n        }\n        const map = new Map(), hash = new MurmurHash3_64(), transfer = [];\n        const context = Object.create(null);\n        let hasBitmap = false;\n        for (const [key, val] of this.#storage){\n            const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;\n            if (serialized) {\n                map.set(key, serialized);\n                hash.update(`${key}:${JSON.stringify(serialized)}`);\n                hasBitmap ||= !!serialized.bitmap;\n            }\n        }\n        if (hasBitmap) {\n            for (const value of map.values()){\n                if (value.bitmap) {\n                    transfer.push(value.bitmap);\n                }\n            }\n        }\n        return map.size > 0 ? {\n            map,\n            hash: hash.hexdigest(),\n            transfer\n        } : SerializableEmpty;\n    }\n    get editorStats() {\n        let stats = null;\n        const typeToEditor = new Map();\n        for (const value of this.#storage.values()){\n            if (!(value instanceof AnnotationEditor)) {\n                continue;\n            }\n            const editorStats = value.telemetryFinalData;\n            if (!editorStats) {\n                continue;\n            }\n            const { type } = editorStats;\n            if (!typeToEditor.has(type)) {\n                typeToEditor.set(type, Object.getPrototypeOf(value).constructor);\n            }\n            stats ||= Object.create(null);\n            const map = stats[type] ||= new Map();\n            for (const [key, val] of Object.entries(editorStats)){\n                if (key === \"type\") {\n                    continue;\n                }\n                let counters = map.get(key);\n                if (!counters) {\n                    counters = new Map();\n                    map.set(key, counters);\n                }\n                const count = counters.get(val) ?? 0;\n                counters.set(val, count + 1);\n            }\n        }\n        for (const [type, editor] of typeToEditor){\n            stats[type] = editor.computeTelemetryFinalData(stats[type]);\n        }\n        return stats;\n    }\n    resetModifiedIds() {\n        this.#modifiedIds = null;\n    }\n    get modifiedIds() {\n        if (this.#modifiedIds) {\n            return this.#modifiedIds;\n        }\n        const ids = [];\n        for (const value of this.#storage.values()){\n            if (!(value instanceof AnnotationEditor) || !value.annotationElementId || !value.serialize()) {\n                continue;\n            }\n            ids.push(value.annotationElementId);\n        }\n        return this.#modifiedIds = {\n            ids: new Set(ids),\n            hash: ids.join(\",\")\n        };\n    }\n    [Symbol.iterator]() {\n        return this.#storage.entries();\n    }\n}\nclass PrintAnnotationStorage extends AnnotationStorage {\n    #serializable;\n    constructor(parent){\n        super();\n        const { map, hash, transfer } = parent.serializable;\n        const clone = structuredClone(map, transfer ? {\n            transfer\n        } : null);\n        this.#serializable = {\n            map: clone,\n            hash,\n            transfer\n        };\n    }\n    get print() {\n        unreachable(\"Should not call PrintAnnotationStorage.print\");\n    }\n    get serializable() {\n        return this.#serializable;\n    }\n    get modifiedIds() {\n        return shadow(this, \"modifiedIds\", {\n            ids: new Set(),\n            hash: \"\"\n        });\n    }\n}\n; // ./src/display/font_loader.js\nclass FontLoader {\n    #systemFonts;\n    constructor({ ownerDocument = globalThis.document, styleElement = null }){\n        this.#systemFonts = new Set();\n        this._document = ownerDocument;\n        this.nativeFontFaces = new Set();\n        this.styleElement = null;\n        this.loadingRequests = [];\n        this.loadTestFontId = 0;\n    }\n    addNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.add(nativeFontFace);\n        this._document.fonts.add(nativeFontFace);\n    }\n    removeNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.delete(nativeFontFace);\n        this._document.fonts.delete(nativeFontFace);\n    }\n    insertRule(rule) {\n        if (!this.styleElement) {\n            this.styleElement = this._document.createElement(\"style\");\n            this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n        }\n        const styleSheet = this.styleElement.sheet;\n        styleSheet.insertRule(rule, styleSheet.cssRules.length);\n    }\n    clear() {\n        for (const nativeFontFace of this.nativeFontFaces){\n            this._document.fonts.delete(nativeFontFace);\n        }\n        this.nativeFontFaces.clear();\n        this.#systemFonts.clear();\n        if (this.styleElement) {\n            this.styleElement.remove();\n            this.styleElement = null;\n        }\n    }\n    async loadSystemFont({ systemFontInfo: info, disableFontFace, _inspectFont }) {\n        if (!info || this.#systemFonts.has(info.loadedName)) {\n            return;\n        }\n        assert(!disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n        if (this.isFontLoadingAPISupported) {\n            const { loadedName, src, style } = info;\n            const fontFace = new FontFace(loadedName, src, style);\n            this.addNativeFontFace(fontFace);\n            try {\n                await fontFace.load();\n                this.#systemFonts.add(loadedName);\n                _inspectFont?.(info);\n            } catch  {\n                warn(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n                this.removeNativeFontFace(fontFace);\n            }\n            return;\n        }\n        unreachable(\"Not implemented: loadSystemFont without the Font Loading API.\");\n    }\n    async bind(font) {\n        if (font.attached || font.missingFile && !font.systemFontInfo) {\n            return;\n        }\n        font.attached = true;\n        if (font.systemFontInfo) {\n            await this.loadSystemFont(font);\n            return;\n        }\n        if (this.isFontLoadingAPISupported) {\n            const nativeFontFace = font.createNativeFontFace();\n            if (nativeFontFace) {\n                this.addNativeFontFace(nativeFontFace);\n                try {\n                    await nativeFontFace.loaded;\n                } catch (ex) {\n                    warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n                    font.disableFontFace = true;\n                    throw ex;\n                }\n            }\n            return;\n        }\n        const rule = font.createFontFaceRule();\n        if (rule) {\n            this.insertRule(rule);\n            if (this.isSyncFontLoadingSupported) {\n                return;\n            }\n            await new Promise((resolve)=>{\n                const request = this._queueLoadingCallback(resolve);\n                this._prepareFontLoadEvent(font, request);\n            });\n        }\n    }\n    get isFontLoadingAPISupported() {\n        const hasFonts = !!this._document?.fonts;\n        return shadow(this, \"isFontLoadingAPISupported\", hasFonts);\n    }\n    get isSyncFontLoadingSupported() {\n        return shadow(this, \"isSyncFontLoadingSupported\", isNodeJS || util_FeatureTest.platform.isFirefox);\n    }\n    _queueLoadingCallback(callback) {\n        function completeRequest() {\n            assert(!request.done, \"completeRequest() cannot be called twice.\");\n            request.done = true;\n            while(loadingRequests.length > 0 && loadingRequests[0].done){\n                const otherRequest = loadingRequests.shift();\n                setTimeout(otherRequest.callback, 0);\n            }\n        }\n        const { loadingRequests } = this;\n        const request = {\n            done: false,\n            complete: completeRequest,\n            callback\n        };\n        loadingRequests.push(request);\n        return request;\n    }\n    get _loadTestFont() {\n        const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n        return shadow(this, \"_loadTestFont\", testFont);\n    }\n    _prepareFontLoadEvent(font, request) {\n        function int32(data, offset) {\n            return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n        }\n        function spliceString(s, offset, remove, insert) {\n            const chunk1 = s.substring(0, offset);\n            const chunk2 = s.substring(offset + remove);\n            return chunk1 + insert + chunk2;\n        }\n        let i, ii;\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = 1;\n        canvas.height = 1;\n        const ctx = canvas.getContext(\"2d\");\n        let called = 0;\n        function isFontReady(name, callback) {\n            if (++called > 30) {\n                warn(\"Load test font never loaded.\");\n                callback();\n                return;\n            }\n            ctx.font = \"30px \" + name;\n            ctx.fillText(\".\", 0, 20);\n            const imageData = ctx.getImageData(0, 0, 1, 1);\n            if (imageData.data[3] > 0) {\n                callback();\n                return;\n            }\n            setTimeout(isFontReady.bind(null, name, callback));\n        }\n        const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n        let data = this._loadTestFont;\n        const COMMENT_OFFSET = 976;\n        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n        const CFF_CHECKSUM_OFFSET = 16;\n        const XXXX_VALUE = 0x58585858;\n        let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n        for(i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4){\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n        }\n        if (i < loadTestFontId.length) {\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n        }\n        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));\n        const url = `url(data:font/opentype;base64,${btoa(data)});`;\n        const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n        this.insertRule(rule);\n        const div = this._document.createElement(\"div\");\n        div.style.visibility = \"hidden\";\n        div.style.width = div.style.height = \"10px\";\n        div.style.position = \"absolute\";\n        div.style.top = div.style.left = \"0px\";\n        for (const name of [\n            font.loadedName,\n            loadTestFontId\n        ]){\n            const span = this._document.createElement(\"span\");\n            span.textContent = \"Hi\";\n            span.style.fontFamily = name;\n            div.append(span);\n        }\n        this._document.body.append(div);\n        isFontReady(loadTestFontId, ()=>{\n            div.remove();\n            request.complete();\n        });\n    }\n}\nclass FontFaceObject {\n    constructor(translatedData, inspectFont = null){\n        this.compiledGlyphs = Object.create(null);\n        for(const i in translatedData){\n            this[i] = translatedData[i];\n        }\n        this._inspectFont = inspectFont;\n    }\n    createNativeFontFace() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        let nativeFontFace;\n        if (!this.cssFontInfo) {\n            nativeFontFace = new FontFace(this.loadedName, this.data, {});\n        } else {\n            const css = {\n                weight: this.cssFontInfo.fontWeight\n            };\n            if (this.cssFontInfo.italicAngle) {\n                css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n            }\n            nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n        }\n        this._inspectFont?.(this);\n        return nativeFontFace;\n    }\n    createFontFaceRule() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;\n        let rule;\n        if (!this.cssFontInfo) {\n            rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n        } else {\n            let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n            if (this.cssFontInfo.italicAngle) {\n                css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n            }\n            rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n        }\n        this._inspectFont?.(this, url);\n        return rule;\n    }\n    getPathGenerator(objs, character) {\n        if (this.compiledGlyphs[character] !== undefined) {\n            return this.compiledGlyphs[character];\n        }\n        const objId = this.loadedName + \"_path_\" + character;\n        let cmds;\n        try {\n            cmds = objs.get(objId);\n        } catch (ex) {\n            warn(`getPathGenerator - ignoring character: \"${ex}\".`);\n        }\n        const path = new Path2D(cmds || \"\");\n        if (!this.fontExtraProperties) {\n            objs.delete(objId);\n        }\n        return this.compiledGlyphs[character] = path;\n    }\n}\n; // ./src/display/api_utils.js\nfunction getUrlProp(val) {\n    if (val instanceof URL) {\n        return val.href;\n    }\n    if (typeof val === \"string\") {\n        if (isNodeJS) {\n            return val;\n        }\n        const url = URL.parse(val, window.location);\n        if (url) {\n            return url.href;\n        }\n    }\n    throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n}\nfunction getDataProp(val) {\n    if (isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n        throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n    }\n    if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n        return val;\n    }\n    if (typeof val === \"string\") {\n        return stringToBytes(val);\n    }\n    if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === \"object\" && !isNaN(val?.length)) {\n        return new Uint8Array(val);\n    }\n    throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n}\nfunction getFactoryUrlProp(val) {\n    if (typeof val !== \"string\") {\n        return null;\n    }\n    if (val.endsWith(\"/\")) {\n        return val;\n    }\n    throw new Error(`Invalid factory url: \"${val}\" must include trailing slash.`);\n}\nconst isRefProxy = (v)=>typeof v === \"object\" && Number.isInteger(v?.num) && v.num >= 0 && Number.isInteger(v?.gen) && v.gen >= 0;\nconst isNameProxy = (v)=>typeof v === \"object\" && typeof v?.name === \"string\";\nconst isValidExplicitDest = _isValidExplicitDest.bind(null, isRefProxy, isNameProxy);\nclass LoopbackPort {\n    #listeners;\n    #deferred;\n    postMessage(obj, transfer) {\n        const event = {\n            data: structuredClone(obj, transfer ? {\n                transfer\n            } : null)\n        };\n        this.#deferred.then(()=>{\n            for (const [listener] of this.#listeners){\n                listener.call(this, event);\n            }\n        });\n    }\n    addEventListener(name, listener, options = null) {\n        let rmAbort = null;\n        if (options?.signal instanceof AbortSignal) {\n            const { signal } = options;\n            if (signal.aborted) {\n                warn(\"LoopbackPort - cannot use an `aborted` signal.\");\n                return;\n            }\n            const onAbort = ()=>this.removeEventListener(name, listener);\n            rmAbort = ()=>signal.removeEventListener(\"abort\", onAbort);\n            signal.addEventListener(\"abort\", onAbort);\n        }\n        this.#listeners.set(listener, rmAbort);\n    }\n    removeEventListener(name, listener) {\n        const rmAbort = this.#listeners.get(listener);\n        rmAbort?.();\n        this.#listeners.delete(listener);\n    }\n    terminate() {\n        for (const [, rmAbort] of this.#listeners){\n            rmAbort?.();\n        }\n        this.#listeners.clear();\n    }\n    constructor(){\n        this.#listeners = new Map();\n        this.#deferred = Promise.resolve();\n    }\n}\n; // ./src/shared/message_handler.js\nconst CallbackKind = {\n    DATA: 1,\n    ERROR: 2\n};\nconst StreamKind = {\n    CANCEL: 1,\n    CANCEL_COMPLETE: 2,\n    CLOSE: 3,\n    ENQUEUE: 4,\n    ERROR: 5,\n    PULL: 6,\n    PULL_COMPLETE: 7,\n    START_COMPLETE: 8\n};\nfunction onFn() {}\nfunction wrapReason(ex) {\n    if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof PasswordException || ex instanceof ResponseException || ex instanceof UnknownErrorException) {\n        return ex;\n    }\n    if (!(ex instanceof Error || typeof ex === \"object\" && ex !== null)) {\n        unreachable('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n    }\n    switch(ex.name){\n        case \"AbortException\":\n            return new AbortException(ex.message);\n        case \"InvalidPDFException\":\n            return new InvalidPDFException(ex.message);\n        case \"PasswordException\":\n            return new PasswordException(ex.message, ex.code);\n        case \"ResponseException\":\n            return new ResponseException(ex.message, ex.status, ex.missing);\n        case \"UnknownErrorException\":\n            return new UnknownErrorException(ex.message, ex.details);\n    }\n    return new UnknownErrorException(ex.message, ex.toString());\n}\nclass MessageHandler {\n    #messageAC;\n    constructor(sourceName, targetName, comObj){\n        this.#messageAC = new AbortController();\n        this.sourceName = sourceName;\n        this.targetName = targetName;\n        this.comObj = comObj;\n        this.callbackId = 1;\n        this.streamId = 1;\n        this.streamSinks = Object.create(null);\n        this.streamControllers = Object.create(null);\n        this.callbackCapabilities = Object.create(null);\n        this.actionHandler = Object.create(null);\n        comObj.addEventListener(\"message\", this.#onMessage.bind(this), {\n            signal: this.#messageAC.signal\n        });\n    }\n    #onMessage({ data }) {\n        if (data.targetName !== this.sourceName) {\n            return;\n        }\n        if (data.stream) {\n            this.#processStreamMessage(data);\n            return;\n        }\n        if (data.callback) {\n            const callbackId = data.callbackId;\n            const capability = this.callbackCapabilities[callbackId];\n            if (!capability) {\n                throw new Error(`Cannot resolve callback ${callbackId}`);\n            }\n            delete this.callbackCapabilities[callbackId];\n            if (data.callback === CallbackKind.DATA) {\n                capability.resolve(data.data);\n            } else if (data.callback === CallbackKind.ERROR) {\n                capability.reject(wrapReason(data.reason));\n            } else {\n                throw new Error(\"Unexpected callback case\");\n            }\n            return;\n        }\n        const action = this.actionHandler[data.action];\n        if (!action) {\n            throw new Error(`Unknown action from worker: ${data.action}`);\n        }\n        if (data.callbackId) {\n            const sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n            Promise.try(action, data.data).then(function(result) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.DATA,\n                    callbackId: data.callbackId,\n                    data: result\n                });\n            }, function(reason) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.ERROR,\n                    callbackId: data.callbackId,\n                    reason: wrapReason(reason)\n                });\n            });\n            return;\n        }\n        if (data.streamId) {\n            this.#createStreamSink(data);\n            return;\n        }\n        action(data.data);\n    }\n    on(actionName, handler) {\n        const ah = this.actionHandler;\n        if (ah[actionName]) {\n            throw new Error(`There is already an actionName called \"${actionName}\"`);\n        }\n        ah[actionName] = handler;\n    }\n    send(actionName, data, transfers) {\n        this.comObj.postMessage({\n            sourceName: this.sourceName,\n            targetName: this.targetName,\n            action: actionName,\n            data\n        }, transfers);\n    }\n    sendWithPromise(actionName, data, transfers) {\n        const callbackId = this.callbackId++;\n        const capability = Promise.withResolvers();\n        this.callbackCapabilities[callbackId] = capability;\n        try {\n            this.comObj.postMessage({\n                sourceName: this.sourceName,\n                targetName: this.targetName,\n                action: actionName,\n                callbackId,\n                data\n            }, transfers);\n        } catch (ex) {\n            capability.reject(ex);\n        }\n        return capability.promise;\n    }\n    sendWithStream(actionName, data, queueingStrategy, transfers) {\n        const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;\n        return new ReadableStream({\n            start: (controller)=>{\n                const startCapability = Promise.withResolvers();\n                this.streamControllers[streamId] = {\n                    controller,\n                    startCall: startCapability,\n                    pullCall: null,\n                    cancelCall: null,\n                    isClosed: false\n                };\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    action: actionName,\n                    streamId,\n                    data,\n                    desiredSize: controller.desiredSize\n                }, transfers);\n                return startCapability.promise;\n            },\n            pull: (controller)=>{\n                const pullCapability = Promise.withResolvers();\n                this.streamControllers[streamId].pullCall = pullCapability;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.PULL,\n                    streamId,\n                    desiredSize: controller.desiredSize\n                });\n                return pullCapability.promise;\n            },\n            cancel: (reason)=>{\n                assert(reason instanceof Error, \"cancel must have a valid reason\");\n                const cancelCapability = Promise.withResolvers();\n                this.streamControllers[streamId].cancelCall = cancelCapability;\n                this.streamControllers[streamId].isClosed = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CANCEL,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n                return cancelCapability.promise;\n            }\n        }, queueingStrategy);\n    }\n    #createStreamSink(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const self = this, action = this.actionHandler[data.action];\n        const streamSink = {\n            enqueue (chunk, size = 1, transfers) {\n                if (this.isCancelled) {\n                    return;\n                }\n                const lastDesiredSize = this.desiredSize;\n                this.desiredSize -= size;\n                if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n                    this.sinkCapability = Promise.withResolvers();\n                    this.ready = this.sinkCapability.promise;\n                }\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ENQUEUE,\n                    streamId,\n                    chunk\n                }, transfers);\n            },\n            close () {\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CLOSE,\n                    streamId\n                });\n                delete self.streamSinks[streamId];\n            },\n            error (reason) {\n                assert(reason instanceof Error, \"error must have a valid reason\");\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ERROR,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n            },\n            sinkCapability: Promise.withResolvers(),\n            onPull: null,\n            onCancel: null,\n            isCancelled: false,\n            desiredSize: data.desiredSize,\n            ready: null\n        };\n        streamSink.sinkCapability.resolve();\n        streamSink.ready = streamSink.sinkCapability.promise;\n        this.streamSinks[streamId] = streamSink;\n        Promise.try(action, data.data, streamSink).then(function() {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                success: true\n            });\n        }, function(reason) {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                reason: wrapReason(reason)\n            });\n        });\n    }\n    #processStreamMessage(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];\n        switch(data.stream){\n            case StreamKind.START_COMPLETE:\n                if (data.success) {\n                    streamController.startCall.resolve();\n                } else {\n                    streamController.startCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL_COMPLETE:\n                if (data.success) {\n                    streamController.pullCall.resolve();\n                } else {\n                    streamController.pullCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL:\n                if (!streamSink) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                    break;\n                }\n                if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n                    streamSink.sinkCapability.resolve();\n                }\n                streamSink.desiredSize = data.desiredSize;\n                Promise.try(streamSink.onPull || onFn).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                break;\n            case StreamKind.ENQUEUE:\n                assert(streamController, \"enqueue should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.controller.enqueue(data.chunk);\n                break;\n            case StreamKind.CLOSE:\n                assert(streamController, \"close should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.isClosed = true;\n                streamController.controller.close();\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.ERROR:\n                assert(streamController, \"error should have stream controller\");\n                streamController.controller.error(wrapReason(data.reason));\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL_COMPLETE:\n                if (data.success) {\n                    streamController.cancelCall.resolve();\n                } else {\n                    streamController.cancelCall.reject(wrapReason(data.reason));\n                }\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL:\n                if (!streamSink) {\n                    break;\n                }\n                const dataReason = wrapReason(data.reason);\n                Promise.try(streamSink.onCancel || onFn, dataReason).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                streamSink.sinkCapability.reject(dataReason);\n                streamSink.isCancelled = true;\n                delete this.streamSinks[streamId];\n                break;\n            default:\n                throw new Error(\"Unexpected stream case\");\n        }\n    }\n    async #deleteStreamController(streamController, streamId) {\n        await Promise.allSettled([\n            streamController.startCall?.promise,\n            streamController.pullCall?.promise,\n            streamController.cancelCall?.promise\n        ]);\n        delete this.streamControllers[streamId];\n    }\n    destroy() {\n        this.#messageAC?.abort();\n        this.#messageAC = null;\n    }\n}\n; // ./src/display/canvas_factory.js\nclass BaseCanvasFactory {\n    #enableHWA;\n    constructor({ enableHWA = false }){\n        this.#enableHWA = false;\n        this.#enableHWA = enableHWA;\n    }\n    create(width, height) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        const canvas = this._createCanvas(width, height);\n        return {\n            canvas,\n            context: canvas.getContext(\"2d\", {\n                willReadFrequently: !this.#enableHWA\n            })\n        };\n    }\n    reset(canvasAndContext, width, height) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        canvasAndContext.canvas.width = width;\n        canvasAndContext.canvas.height = height;\n    }\n    destroy(canvasAndContext) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        canvasAndContext.canvas.width = 0;\n        canvasAndContext.canvas.height = 0;\n        canvasAndContext.canvas = null;\n        canvasAndContext.context = null;\n    }\n    _createCanvas(width, height) {\n        unreachable(\"Abstract method `_createCanvas` called.\");\n    }\n}\nclass DOMCanvasFactory extends BaseCanvasFactory {\n    constructor({ ownerDocument = globalThis.document, enableHWA = false }){\n        super({\n            enableHWA\n        });\n        this._document = ownerDocument;\n    }\n    _createCanvas(width, height) {\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n}\n; // ./src/display/cmap_reader_factory.js\nclass BaseCMapReaderFactory {\n    constructor({ baseUrl = null, isCompressed = true }){\n        this.baseUrl = baseUrl;\n        this.isCompressed = isCompressed;\n    }\n    async fetch({ name }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.\");\n        }\n        if (!name) {\n            throw new Error(\"CMap name must be specified.\");\n        }\n        const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n        return this._fetch(url).then((cMapData)=>({\n                cMapData,\n                isCompressed: this.isCompressed\n            })).catch((reason)=>{\n            throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, this.isCompressed ? \"arraybuffer\" : \"text\");\n        return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);\n    }\n}\n; // ./src/display/filter_factory.js\nclass BaseFilterFactory {\n    addFilter(maps) {\n        return \"none\";\n    }\n    addHCMFilter(fgColor, bgColor) {\n        return \"none\";\n    }\n    addAlphaFilter(map) {\n        return \"none\";\n    }\n    addLuminosityFilter(map) {\n        return \"none\";\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        return \"none\";\n    }\n    destroy(keepHCM = false) {}\n}\nclass DOMFilterFactory extends BaseFilterFactory {\n    #baseUrl;\n    #_cache;\n    #_defs;\n    #docId;\n    #document;\n    #_hcmCache;\n    #id;\n    constructor({ docId, ownerDocument = globalThis.document }){\n        super();\n        this.#id = 0;\n        this.#docId = docId;\n        this.#document = ownerDocument;\n    }\n    get #cache() {\n        return this.#_cache ||= new Map();\n    }\n    get #hcmCache() {\n        return this.#_hcmCache ||= new Map();\n    }\n    get #defs() {\n        if (!this.#_defs) {\n            const div = this.#document.createElement(\"div\");\n            const { style } = div;\n            style.visibility = \"hidden\";\n            style.contain = \"strict\";\n            style.width = style.height = 0;\n            style.position = \"absolute\";\n            style.top = style.left = 0;\n            style.zIndex = -1;\n            const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n            svg.setAttribute(\"width\", 0);\n            svg.setAttribute(\"height\", 0);\n            this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n            div.append(svg);\n            svg.append(this.#_defs);\n            this.#document.body.append(div);\n        }\n        return this.#_defs;\n    }\n    #createTables(maps) {\n        if (maps.length === 1) {\n            const mapR = maps[0];\n            const buffer = new Array(256);\n            for(let i = 0; i < 256; i++){\n                buffer[i] = mapR[i] / 255;\n            }\n            const table = buffer.join(\",\");\n            return [\n                table,\n                table,\n                table\n            ];\n        }\n        const [mapR, mapG, mapB] = maps;\n        const bufferR = new Array(256);\n        const bufferG = new Array(256);\n        const bufferB = new Array(256);\n        for(let i = 0; i < 256; i++){\n            bufferR[i] = mapR[i] / 255;\n            bufferG[i] = mapG[i] / 255;\n            bufferB[i] = mapB[i] / 255;\n        }\n        return [\n            bufferR.join(\",\"),\n            bufferG.join(\",\"),\n            bufferB.join(\",\")\n        ];\n    }\n    #createUrl(id) {\n        if (this.#baseUrl === undefined) {\n            this.#baseUrl = \"\";\n            const url = this.#document.URL;\n            if (url !== this.#document.baseURI) {\n                if (isDataScheme(url)) {\n                    warn('#createUrl: ignore \"data:\"-URL for performance reasons.');\n                } else {\n                    this.#baseUrl = updateUrlHash(url, \"\");\n                }\n            }\n        }\n        return `url(${this.#baseUrl}#${id})`;\n    }\n    addFilter(maps) {\n        if (!maps) {\n            return \"none\";\n        }\n        let value = this.#cache.get(maps);\n        if (value) {\n            return value;\n        }\n        const [tableR, tableG, tableB] = this.#createTables(maps);\n        const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(maps, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(maps, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n        return url;\n    }\n    addHCMFilter(fgColor, bgColor) {\n        const key = `${fgColor}-${bgColor}`;\n        const filterName = \"base\";\n        let info = this.#hcmCache.get(filterName);\n        if (info?.key === key) {\n            return info.url;\n        }\n        if (info) {\n            info.filter?.remove();\n            info.key = key;\n            info.url = \"none\";\n            info.filter = null;\n        } else {\n            info = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info);\n        }\n        if (!fgColor || !bgColor) {\n            return info.url;\n        }\n        const fgRGB = this.#getRGB(fgColor);\n        fgColor = Util.makeHexColor(...fgRGB);\n        const bgRGB = this.#getRGB(bgColor);\n        bgColor = Util.makeHexColor(...bgRGB);\n        this.#defs.style.color = \"\";\n        if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n            return info.url;\n        }\n        const map = new Array(256);\n        for(let i = 0; i <= 255; i++){\n            const x = i / 255;\n            map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n        }\n        const table = map.join(\",\");\n        const id = `g_${this.#docId}_hcm_filter`;\n        const filter = info.filter = this.#createFilter(id);\n        this.#addTransferMapConversion(table, table, table, filter);\n        this.#addGrayConversion(filter);\n        const getSteps = (c, n)=>{\n            const start = fgRGB[c] / 255;\n            const end = bgRGB[c] / 255;\n            const arr = new Array(n + 1);\n            for(let i = 0; i <= n; i++){\n                arr[i] = start + i / n * (end - start);\n            }\n            return arr.join(\",\");\n        };\n        this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n        info.url = this.#createUrl(id);\n        return info.url;\n    }\n    addAlphaFilter(map) {\n        let value = this.#cache.get(map);\n        if (value) {\n            return value;\n        }\n        const [tableA] = this.#createTables([\n            map\n        ]);\n        const key = `alpha_${tableA}`;\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(map, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_alpha_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapAlphaConversion(tableA, filter);\n        return url;\n    }\n    addLuminosityFilter(map) {\n        let value = this.#cache.get(map || \"luminosity\");\n        if (value) {\n            return value;\n        }\n        let tableA, key;\n        if (map) {\n            [tableA] = this.#createTables([\n                map\n            ]);\n            key = `luminosity_${tableA}`;\n        } else {\n            key = \"luminosity\";\n        }\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(map, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addLuminosityConversion(filter);\n        if (map) {\n            this.#addTransferMapAlphaConversion(tableA, filter);\n        }\n        return url;\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n        let info = this.#hcmCache.get(filterName);\n        if (info?.key === key) {\n            return info.url;\n        }\n        if (info) {\n            info.filter?.remove();\n            info.key = key;\n            info.url = \"none\";\n            info.filter = null;\n        } else {\n            info = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info);\n        }\n        if (!fgColor || !bgColor) {\n            return info.url;\n        }\n        const [fgRGB, bgRGB] = [\n            fgColor,\n            bgColor\n        ].map(this.#getRGB.bind(this));\n        let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n        let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n        let [newFgRGB, newBgRGB] = [\n            newFgColor,\n            newBgColor\n        ].map(this.#getRGB.bind(this));\n        if (bgGray < fgGray) {\n            [fgGray, bgGray, newFgRGB, newBgRGB] = [\n                bgGray,\n                fgGray,\n                newBgRGB,\n                newFgRGB\n            ];\n        }\n        this.#defs.style.color = \"\";\n        const getSteps = (fg, bg, n)=>{\n            const arr = new Array(256);\n            const step = (bgGray - fgGray) / n;\n            const newStart = fg / 255;\n            const newStep = (bg - fg) / (255 * n);\n            let prev = 0;\n            for(let i = 0; i <= n; i++){\n                const k = Math.round(fgGray + i * step);\n                const value = newStart + i * newStep;\n                for(let j = prev; j <= k; j++){\n                    arr[j] = value;\n                }\n                prev = k + 1;\n            }\n            for(let i = prev; i < 256; i++){\n                arr[i] = arr[prev - 1];\n            }\n            return arr.join(\",\");\n        };\n        const id = `g_${this.#docId}_hcm_${filterName}_filter`;\n        const filter = info.filter = this.#createFilter(id);\n        this.#addGrayConversion(filter);\n        this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n        info.url = this.#createUrl(id);\n        return info.url;\n    }\n    destroy(keepHCM = false) {\n        if (keepHCM && this.#_hcmCache?.size) {\n            return;\n        }\n        this.#_defs?.parentNode.parentNode.remove();\n        this.#_defs = null;\n        this.#_cache?.clear();\n        this.#_cache = null;\n        this.#_hcmCache?.clear();\n        this.#_hcmCache = null;\n        this.#id = 0;\n    }\n    #addLuminosityConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0\");\n        filter.append(feColorMatrix);\n    }\n    #addGrayConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n        filter.append(feColorMatrix);\n    }\n    #createFilter(id) {\n        const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n        filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n        filter.setAttribute(\"id\", id);\n        this.#defs.append(filter);\n        return filter;\n    }\n    #appendFeFunc(feComponentTransfer, func, table) {\n        const feFunc = this.#document.createElementNS(SVG_NS, func);\n        feFunc.setAttribute(\"type\", \"discrete\");\n        feFunc.setAttribute(\"tableValues\", table);\n        feComponentTransfer.append(feFunc);\n    }\n    #addTransferMapConversion(rTable, gTable, bTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n    }\n    #addTransferMapAlphaConversion(aTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncA\", aTable);\n    }\n    #getRGB(color) {\n        this.#defs.style.color = color;\n        return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n    }\n}\n; // ./src/display/standard_fontdata_factory.js\nclass BaseStandardFontDataFactory {\n    constructor({ baseUrl = null }){\n        this.baseUrl = baseUrl;\n    }\n    async fetch({ filename }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `standardFontDataUrl` API parameter is provided.\");\n        }\n        if (!filename) {\n            throw new Error(\"Font filename must be specified.\");\n        }\n        const url = `${this.baseUrl}${filename}`;\n        return this._fetch(url).catch((reason)=>{\n            throw new Error(`Unable to load font data at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, \"arraybuffer\");\n        return new Uint8Array(data);\n    }\n}\n; // ./src/display/wasm_factory.js\nclass BaseWasmFactory {\n    constructor({ baseUrl = null }){\n        this.baseUrl = baseUrl;\n    }\n    async fetch({ filename }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `wasmUrl` API parameter is provided.\");\n        }\n        if (!filename) {\n            throw new Error(\"Wasm filename must be specified.\");\n        }\n        const url = `${this.baseUrl}${filename}`;\n        return this._fetch(url).catch((reason)=>{\n            throw new Error(`Unable to load wasm data at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMWasmFactory extends BaseWasmFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, \"arraybuffer\");\n        return new Uint8Array(data);\n    }\n}\n; // ./src/display/node_utils.js\nif (isNodeJS) {\n    warn(\"Please use the `legacy` build in Node.js environments.\");\n}\nasync function node_utils_fetchData(url) {\n    const fs = process.getBuiltinModule(\"fs\");\n    const data = await fs.promises.readFile(url);\n    return new Uint8Array(data);\n}\nclass NodeFilterFactory extends BaseFilterFactory {\n}\nclass NodeCanvasFactory extends BaseCanvasFactory {\n    _createCanvas(width, height) {\n        const require = process.getBuiltinModule(\"module\").createRequire(\"file:///C:/Users/shour/OneDrive/Desktop/bruteforce/node_modules/pdfjs-dist/build/pdf.mjs\");\n        const canvas = require(\"@napi-rs/canvas\");\n        return canvas.createCanvas(width, height);\n    }\n}\nclass NodeCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\nclass NodeStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\nclass NodeWasmFactory extends BaseWasmFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\n; // ./src/display/canvas_dependency_tracker.js\nconst FORCED_DEPENDENCY_LABEL = \"__forcedDependency\";\nclass CanvasDependencyTracker {\n    #simple;\n    #incremental;\n    #namedDependencies;\n    #savesStack;\n    #markedContentStack;\n    #baseTransformStack;\n    #clipBox;\n    #pendingBBox;\n    #pendingBBoxIdx;\n    #pendingDependencies;\n    #operations;\n    #fontBBoxTrustworthy;\n    #canvasWidth;\n    #canvasHeight;\n    constructor(canvas){\n        this.#simple = {\n            __proto__: null\n        };\n        this.#incremental = {\n            __proto__: null,\n            transform: [],\n            moveText: [],\n            sameLineText: [],\n            [FORCED_DEPENDENCY_LABEL]: []\n        };\n        this.#namedDependencies = new Map();\n        this.#savesStack = [];\n        this.#markedContentStack = [];\n        this.#baseTransformStack = [\n            [\n                1,\n                0,\n                0,\n                1,\n                0,\n                0\n            ]\n        ];\n        this.#clipBox = [\n            -Infinity,\n            -Infinity,\n            Infinity,\n            Infinity\n        ];\n        this.#pendingBBox = new Float64Array([\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ]);\n        this.#pendingBBoxIdx = -1;\n        this.#pendingDependencies = new Set();\n        this.#operations = new Map();\n        this.#fontBBoxTrustworthy = new Map();\n        this.#canvasWidth = canvas.width;\n        this.#canvasHeight = canvas.height;\n    }\n    save(opIdx) {\n        this.#simple = {\n            __proto__: this.#simple\n        };\n        this.#incremental = {\n            __proto__: this.#incremental,\n            transform: {\n                __proto__: this.#incremental.transform\n            },\n            moveText: {\n                __proto__: this.#incremental.moveText\n            },\n            sameLineText: {\n                __proto__: this.#incremental.sameLineText\n            },\n            [FORCED_DEPENDENCY_LABEL]: {\n                __proto__: this.#incremental[FORCED_DEPENDENCY_LABEL]\n            }\n        };\n        this.#clipBox = {\n            __proto__: this.#clipBox\n        };\n        this.#savesStack.push([\n            opIdx,\n            null\n        ]);\n        return this;\n    }\n    restore(opIdx) {\n        const previous = Object.getPrototypeOf(this.#simple);\n        if (previous === null) {\n            return this;\n        }\n        this.#simple = previous;\n        this.#incremental = Object.getPrototypeOf(this.#incremental);\n        this.#clipBox = Object.getPrototypeOf(this.#clipBox);\n        const lastPair = this.#savesStack.pop();\n        if (lastPair !== undefined) {\n            lastPair[1] = opIdx;\n        }\n        return this;\n    }\n    recordOpenMarker(idx) {\n        this.#savesStack.push([\n            idx,\n            null\n        ]);\n        return this;\n    }\n    getOpenMarker() {\n        if (this.#savesStack.length === 0) {\n            return null;\n        }\n        return this.#savesStack.at(-1)[0];\n    }\n    recordCloseMarker(idx) {\n        const lastPair = this.#savesStack.pop();\n        if (lastPair !== undefined) {\n            lastPair[1] = idx;\n        }\n        return this;\n    }\n    beginMarkedContent(opIdx) {\n        this.#markedContentStack.push([\n            opIdx,\n            null\n        ]);\n        return this;\n    }\n    endMarkedContent(opIdx) {\n        const lastPair = this.#markedContentStack.pop();\n        if (lastPair !== undefined) {\n            lastPair[1] = opIdx;\n        }\n        return this;\n    }\n    pushBaseTransform(ctx) {\n        this.#baseTransformStack.push(Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform()));\n        return this;\n    }\n    popBaseTransform() {\n        if (this.#baseTransformStack.length > 1) {\n            this.#baseTransformStack.pop();\n        }\n        return this;\n    }\n    recordSimpleData(name, idx) {\n        this.#simple[name] = idx;\n        return this;\n    }\n    recordIncrementalData(name, idx) {\n        this.#incremental[name].push(idx);\n        return this;\n    }\n    resetIncrementalData(name, idx) {\n        this.#incremental[name].length = 0;\n        return this;\n    }\n    recordNamedData(name, idx) {\n        this.#namedDependencies.set(name, idx);\n        return this;\n    }\n    recordFutureForcedDependency(name, idx) {\n        this.recordIncrementalData(FORCED_DEPENDENCY_LABEL, idx);\n        return this;\n    }\n    inheritSimpleDataAsFutureForcedDependencies(names) {\n        for (const name of names){\n            if (name in this.#simple) {\n                this.recordFutureForcedDependency(name, this.#simple[name]);\n            }\n        }\n        return this;\n    }\n    inheritPendingDependenciesAsFutureForcedDependencies() {\n        for (const dep of this.#pendingDependencies){\n            this.recordFutureForcedDependency(FORCED_DEPENDENCY_LABEL, dep);\n        }\n        return this;\n    }\n    resetBBox(idx) {\n        this.#pendingBBoxIdx = idx;\n        this.#pendingBBox[0] = Infinity;\n        this.#pendingBBox[1] = Infinity;\n        this.#pendingBBox[2] = -Infinity;\n        this.#pendingBBox[3] = -Infinity;\n        return this;\n    }\n    get hasPendingBBox() {\n        return this.#pendingBBoxIdx !== -1;\n    }\n    recordClipBox(idx, ctx, minX, maxX, minY, maxY) {\n        const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());\n        const clipBox = [\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ];\n        Util.axialAlignedBoundingBox([\n            minX,\n            minY,\n            maxX,\n            maxY\n        ], transform, clipBox);\n        const intersection = Util.intersect(this.#clipBox, clipBox);\n        if (intersection) {\n            this.#clipBox[0] = intersection[0];\n            this.#clipBox[1] = intersection[1];\n            this.#clipBox[2] = intersection[2];\n            this.#clipBox[3] = intersection[3];\n        } else {\n            this.#clipBox[0] = this.#clipBox[1] = Infinity;\n            this.#clipBox[2] = this.#clipBox[3] = -Infinity;\n        }\n        return this;\n    }\n    recordBBox(idx, ctx, minX, maxX, minY, maxY) {\n        const clipBox = this.#clipBox;\n        if (clipBox[0] === Infinity) {\n            return this;\n        }\n        const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());\n        if (clipBox[0] === -Infinity) {\n            Util.axialAlignedBoundingBox([\n                minX,\n                minY,\n                maxX,\n                maxY\n            ], transform, this.#pendingBBox);\n            return this;\n        }\n        const bbox = [\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ];\n        Util.axialAlignedBoundingBox([\n            minX,\n            minY,\n            maxX,\n            maxY\n        ], transform, bbox);\n        this.#pendingBBox[0] = Math.min(this.#pendingBBox[0], Math.max(bbox[0], clipBox[0]));\n        this.#pendingBBox[1] = Math.min(this.#pendingBBox[1], Math.max(bbox[1], clipBox[1]));\n        this.#pendingBBox[2] = Math.max(this.#pendingBBox[2], Math.min(bbox[2], clipBox[2]));\n        this.#pendingBBox[3] = Math.max(this.#pendingBBox[3], Math.min(bbox[3], clipBox[3]));\n        return this;\n    }\n    recordCharacterBBox(idx, ctx, font, scale = 1, x = 0, y = 0, getMeasure) {\n        const fontBBox = font.bbox;\n        let isBBoxTrustworthy;\n        let computedBBox;\n        if (fontBBox) {\n            isBBoxTrustworthy = fontBBox[2] !== fontBBox[0] && fontBBox[3] !== fontBBox[1] && this.#fontBBoxTrustworthy.get(font);\n            if (isBBoxTrustworthy !== false) {\n                computedBBox = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                Util.axialAlignedBoundingBox(fontBBox, font.fontMatrix, computedBBox);\n                if (scale !== 1 || x !== 0 || y !== 0) {\n                    Util.scaleMinMax([\n                        scale,\n                        0,\n                        0,\n                        -scale,\n                        x,\n                        y\n                    ], computedBBox);\n                }\n                if (isBBoxTrustworthy) {\n                    return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);\n                }\n            }\n        }\n        if (!getMeasure) {\n            return this.recordFullPageBBox(idx);\n        }\n        const measure = getMeasure();\n        if (fontBBox && computedBBox && isBBoxTrustworthy === undefined) {\n            isBBoxTrustworthy = computedBBox[0] <= x - measure.actualBoundingBoxLeft && computedBBox[2] >= x + measure.actualBoundingBoxRight && computedBBox[1] <= y - measure.actualBoundingBoxAscent && computedBBox[3] >= y + measure.actualBoundingBoxDescent;\n            this.#fontBBoxTrustworthy.set(font, isBBoxTrustworthy);\n            if (isBBoxTrustworthy) {\n                return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);\n            }\n        }\n        return this.recordBBox(idx, ctx, x - measure.actualBoundingBoxLeft, x + measure.actualBoundingBoxRight, y - measure.actualBoundingBoxAscent, y + measure.actualBoundingBoxDescent);\n    }\n    recordFullPageBBox(idx) {\n        this.#pendingBBox[0] = Math.max(0, this.#clipBox[0]);\n        this.#pendingBBox[1] = Math.max(0, this.#clipBox[1]);\n        this.#pendingBBox[2] = Math.min(this.#canvasWidth, this.#clipBox[2]);\n        this.#pendingBBox[3] = Math.min(this.#canvasHeight, this.#clipBox[3]);\n        return this;\n    }\n    getSimpleIndex(dependencyName) {\n        return this.#simple[dependencyName];\n    }\n    recordDependencies(idx, dependencyNames) {\n        const pendingDependencies = this.#pendingDependencies;\n        const simple = this.#simple;\n        const incremental = this.#incremental;\n        for (const name of dependencyNames){\n            if (name in this.#simple) {\n                pendingDependencies.add(simple[name]);\n            } else if (name in incremental) {\n                incremental[name].forEach(pendingDependencies.add, pendingDependencies);\n            }\n        }\n        return this;\n    }\n    copyDependenciesFromIncrementalOperation(idx, name) {\n        const operations = this.#operations;\n        const pendingDependencies = this.#pendingDependencies;\n        for (const depIdx of this.#incremental[name]){\n            operations.get(depIdx).dependencies.forEach(pendingDependencies.add, pendingDependencies.add(depIdx));\n        }\n        return this;\n    }\n    recordNamedDependency(idx, name) {\n        if (this.#namedDependencies.has(name)) {\n            this.#pendingDependencies.add(this.#namedDependencies.get(name));\n        }\n        return this;\n    }\n    recordOperation(idx, preserveBbox = false) {\n        this.recordDependencies(idx, [\n            FORCED_DEPENDENCY_LABEL\n        ]);\n        const dependencies = new Set(this.#pendingDependencies);\n        const pairs = this.#savesStack.concat(this.#markedContentStack);\n        const bbox = this.#pendingBBoxIdx === idx ? {\n            minX: this.#pendingBBox[0],\n            minY: this.#pendingBBox[1],\n            maxX: this.#pendingBBox[2],\n            maxY: this.#pendingBBox[3]\n        } : null;\n        this.#operations.set(idx, {\n            bbox,\n            pairs,\n            dependencies\n        });\n        if (!preserveBbox) {\n            this.#pendingBBoxIdx = -1;\n        }\n        this.#pendingDependencies.clear();\n        return this;\n    }\n    bboxToClipBoxDropOperation(idx) {\n        if (this.#pendingBBoxIdx !== -1) {\n            this.#pendingBBoxIdx = -1;\n            this.#clipBox[0] = Math.max(this.#clipBox[0], this.#pendingBBox[0]);\n            this.#clipBox[1] = Math.max(this.#clipBox[1], this.#pendingBBox[1]);\n            this.#clipBox[2] = Math.min(this.#clipBox[2], this.#pendingBBox[2]);\n            this.#clipBox[3] = Math.min(this.#clipBox[3], this.#pendingBBox[3]);\n        }\n        this.#pendingDependencies.clear();\n        return this;\n    }\n    _takePendingDependencies() {\n        const pendingDependencies = this.#pendingDependencies;\n        this.#pendingDependencies = new Set();\n        return pendingDependencies;\n    }\n    _extractOperation(idx) {\n        const operation = this.#operations.get(idx);\n        this.#operations.delete(idx);\n        return operation;\n    }\n    _pushPendingDependencies(dependencies) {\n        for (const dep of dependencies){\n            this.#pendingDependencies.add(dep);\n        }\n    }\n    take() {\n        this.#fontBBoxTrustworthy.clear();\n        return Array.from(this.#operations, ([idx, { bbox, pairs, dependencies }])=>{\n            pairs.forEach((pair)=>pair.forEach(dependencies.add, dependencies));\n            dependencies.delete(idx);\n            return {\n                minX: (bbox?.minX ?? 0) / this.#canvasWidth,\n                maxX: (bbox?.maxX ?? this.#canvasWidth) / this.#canvasWidth,\n                minY: (bbox?.minY ?? 0) / this.#canvasHeight,\n                maxY: (bbox?.maxY ?? this.#canvasHeight) / this.#canvasHeight,\n                dependencies: Array.from(dependencies).sort((a, b)=>a - b),\n                idx\n            };\n        });\n    }\n}\nclass CanvasNestedDependencyTracker {\n    #dependencyTracker;\n    #opIdx;\n    #nestingLevel;\n    #outerDependencies;\n    #savesLevel;\n    constructor(dependencyTracker, opIdx){\n        this.#nestingLevel = 0;\n        this.#savesLevel = 0;\n        if (dependencyTracker instanceof CanvasNestedDependencyTracker) {\n            return dependencyTracker;\n        }\n        this.#dependencyTracker = dependencyTracker;\n        this.#outerDependencies = dependencyTracker._takePendingDependencies();\n        this.#opIdx = opIdx;\n    }\n    save(opIdx) {\n        this.#savesLevel++;\n        this.#dependencyTracker.save(this.#opIdx);\n        return this;\n    }\n    restore(opIdx) {\n        if (this.#savesLevel > 0) {\n            this.#dependencyTracker.restore(this.#opIdx);\n            this.#savesLevel--;\n        }\n        return this;\n    }\n    recordOpenMarker(idx) {\n        this.#nestingLevel++;\n        return this;\n    }\n    getOpenMarker() {\n        return this.#nestingLevel > 0 ? this.#opIdx : this.#dependencyTracker.getOpenMarker();\n    }\n    recordCloseMarker(idx) {\n        this.#nestingLevel--;\n        return this;\n    }\n    beginMarkedContent(opIdx) {\n        return this;\n    }\n    endMarkedContent(opIdx) {\n        return this;\n    }\n    pushBaseTransform(ctx) {\n        this.#dependencyTracker.pushBaseTransform(ctx);\n        return this;\n    }\n    popBaseTransform() {\n        this.#dependencyTracker.popBaseTransform();\n        return this;\n    }\n    recordSimpleData(name, idx) {\n        this.#dependencyTracker.recordSimpleData(name, this.#opIdx);\n        return this;\n    }\n    recordIncrementalData(name, idx) {\n        this.#dependencyTracker.recordIncrementalData(name, this.#opIdx);\n        return this;\n    }\n    resetIncrementalData(name, idx) {\n        this.#dependencyTracker.resetIncrementalData(name, this.#opIdx);\n        return this;\n    }\n    recordNamedData(name, idx) {\n        return this;\n    }\n    recordFutureForcedDependency(name, idx) {\n        this.#dependencyTracker.recordFutureForcedDependency(name, this.#opIdx);\n        return this;\n    }\n    inheritSimpleDataAsFutureForcedDependencies(names) {\n        this.#dependencyTracker.inheritSimpleDataAsFutureForcedDependencies(names);\n        return this;\n    }\n    inheritPendingDependenciesAsFutureForcedDependencies() {\n        this.#dependencyTracker.inheritPendingDependenciesAsFutureForcedDependencies();\n        return this;\n    }\n    resetBBox(idx) {\n        if (!this.#dependencyTracker.hasPendingBBox) {\n            this.#dependencyTracker.resetBBox(this.#opIdx);\n        }\n        return this;\n    }\n    get hasPendingBBox() {\n        return this.#dependencyTracker.hasPendingBBox;\n    }\n    recordClipBox(idx, ctx, minX, maxX, minY, maxY) {\n        this.#dependencyTracker.recordClipBox(this.#opIdx, ctx, minX, maxX, minY, maxY);\n        return this;\n    }\n    recordBBox(idx, ctx, minX, maxX, minY, maxY) {\n        this.#dependencyTracker.recordBBox(this.#opIdx, ctx, minX, maxX, minY, maxY);\n        return this;\n    }\n    recordCharacterBBox(idx, ctx, font, scale, x, y, getMeasure) {\n        this.#dependencyTracker.recordCharacterBBox(this.#opIdx, ctx, font, scale, x, y, getMeasure);\n        return this;\n    }\n    recordFullPageBBox(idx) {\n        this.#dependencyTracker.recordFullPageBBox(this.#opIdx);\n        return this;\n    }\n    getSimpleIndex(dependencyName) {\n        return this.#dependencyTracker.getSimpleIndex(dependencyName);\n    }\n    recordDependencies(idx, dependencyNames) {\n        this.#dependencyTracker.recordDependencies(this.#opIdx, dependencyNames);\n        return this;\n    }\n    copyDependenciesFromIncrementalOperation(idx, name) {\n        this.#dependencyTracker.copyDependenciesFromIncrementalOperation(this.#opIdx, name);\n        return this;\n    }\n    recordNamedDependency(idx, name) {\n        this.#dependencyTracker.recordNamedDependency(this.#opIdx, name);\n        return this;\n    }\n    recordOperation(idx) {\n        this.#dependencyTracker.recordOperation(this.#opIdx, true);\n        const operation = this.#dependencyTracker._extractOperation(this.#opIdx);\n        for (const depIdx of operation.dependencies){\n            this.#outerDependencies.add(depIdx);\n        }\n        this.#outerDependencies.delete(this.#opIdx);\n        this.#outerDependencies.delete(null);\n        return this;\n    }\n    bboxToClipBoxDropOperation(idx) {\n        this.#dependencyTracker.bboxToClipBoxDropOperation(this.#opIdx);\n        return this;\n    }\n    recordNestedDependencies() {\n        this.#dependencyTracker._pushPendingDependencies(this.#outerDependencies);\n    }\n    take() {\n        throw new Error(\"Unreachable\");\n    }\n}\nconst Dependencies = {\n    stroke: [\n        \"path\",\n        \"transform\",\n        \"filter\",\n        \"strokeColor\",\n        \"strokeAlpha\",\n        \"lineWidth\",\n        \"lineCap\",\n        \"lineJoin\",\n        \"miterLimit\",\n        \"dash\"\n    ],\n    fill: [\n        \"path\",\n        \"transform\",\n        \"filter\",\n        \"fillColor\",\n        \"fillAlpha\",\n        \"globalCompositeOperation\",\n        \"SMask\"\n    ],\n    imageXObject: [\n        \"transform\",\n        \"SMask\",\n        \"filter\",\n        \"fillAlpha\",\n        \"strokeAlpha\",\n        \"globalCompositeOperation\"\n    ],\n    rawFillPath: [\n        \"filter\",\n        \"fillColor\",\n        \"fillAlpha\"\n    ],\n    showText: [\n        \"transform\",\n        \"leading\",\n        \"charSpacing\",\n        \"wordSpacing\",\n        \"hScale\",\n        \"textRise\",\n        \"moveText\",\n        \"textMatrix\",\n        \"font\",\n        \"filter\",\n        \"fillColor\",\n        \"textRenderingMode\",\n        \"SMask\",\n        \"fillAlpha\",\n        \"strokeAlpha\",\n        \"globalCompositeOperation\"\n    ],\n    transform: [\n        \"transform\"\n    ],\n    transformAndFill: [\n        \"transform\",\n        \"fillColor\"\n    ]\n};\n; // ./src/display/pattern_helper.js\nconst PathType = {\n    FILL: \"Fill\",\n    STROKE: \"Stroke\",\n    SHADING: \"Shading\"\n};\nfunction applyBoundingBox(ctx, bbox) {\n    if (!bbox) {\n        return;\n    }\n    const width = bbox[2] - bbox[0];\n    const height = bbox[3] - bbox[1];\n    const region = new Path2D();\n    region.rect(bbox[0], bbox[1], width, height);\n    ctx.clip(region);\n}\nclass BaseShadingPattern {\n    isModifyingCurrentTransform() {\n        return false;\n    }\n    getPattern() {\n        unreachable(\"Abstract method `getPattern` called.\");\n    }\n}\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._type = IR[1];\n        this._bbox = IR[2];\n        this._colorStops = IR[3];\n        this._p0 = IR[4];\n        this._p1 = IR[5];\n        this._r0 = IR[6];\n        this._r1 = IR[7];\n        this.matrix = null;\n    }\n    _createGradient(ctx) {\n        let grad;\n        if (this._type === \"axial\") {\n            grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n        } else if (this._type === \"radial\") {\n            grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n        }\n        for (const colorStop of this._colorStops){\n            grad.addColorStop(colorStop[0], colorStop[1]);\n        }\n        return grad;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        let pattern;\n        if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n            const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [\n                0,\n                0,\n                0,\n                0\n            ];\n            const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n            const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n            const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.beginPath();\n            tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n            inverse = Util.transform(inverse, [\n                1,\n                0,\n                0,\n                1,\n                ownerBBox[0],\n                ownerBBox[1]\n            ]);\n            tmpCtx.transform(...owner.baseTransform);\n            if (this.matrix) {\n                tmpCtx.transform(...this.matrix);\n            }\n            applyBoundingBox(tmpCtx, this._bbox);\n            tmpCtx.fillStyle = this._createGradient(tmpCtx);\n            tmpCtx.fill();\n            pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n            const domMatrix = new DOMMatrix(inverse);\n            pattern.setTransform(domMatrix);\n        } else {\n            applyBoundingBox(ctx, this._bbox);\n            pattern = this._createGradient(ctx);\n        }\n        return pattern;\n    }\n}\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n    const coords = context.coords, colors = context.colors;\n    const bytes = data.data, rowSize = data.width * 4;\n    let tmp;\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    if (coords[p2 + 1] > coords[p3 + 1]) {\n        tmp = p2;\n        p2 = p3;\n        p3 = tmp;\n        tmp = c2;\n        c2 = c3;\n        c3 = tmp;\n    }\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n    const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n    const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n    const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n    const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n    const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n    if (y1 >= y3) {\n        return;\n    }\n    const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];\n    const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];\n    const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];\n    const minY = Math.round(y1), maxY = Math.round(y3);\n    let xa, car, cag, cab;\n    let xb, cbr, cbg, cbb;\n    for(let y = minY; y <= maxY; y++){\n        if (y < y2) {\n            const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n            xa = x1 - (x1 - x2) * k;\n            car = c1r - (c1r - c2r) * k;\n            cag = c1g - (c1g - c2g) * k;\n            cab = c1b - (c1b - c2b) * k;\n        } else {\n            let k;\n            if (y > y3) {\n                k = 1;\n            } else if (y2 === y3) {\n                k = 0;\n            } else {\n                k = (y2 - y) / (y2 - y3);\n            }\n            xa = x2 - (x2 - x3) * k;\n            car = c2r - (c2r - c3r) * k;\n            cag = c2g - (c2g - c3g) * k;\n            cab = c2b - (c2b - c3b) * k;\n        }\n        let k;\n        if (y < y1) {\n            k = 0;\n        } else if (y > y3) {\n            k = 1;\n        } else {\n            k = (y1 - y) / (y1 - y3);\n        }\n        xb = x1 - (x1 - x3) * k;\n        cbr = c1r - (c1r - c3r) * k;\n        cbg = c1g - (c1g - c3g) * k;\n        cbb = c1b - (c1b - c3b) * k;\n        const x1_ = Math.round(Math.min(xa, xb));\n        const x2_ = Math.round(Math.max(xa, xb));\n        let j = rowSize * y + x1_ * 4;\n        for(let x = x1_; x <= x2_; x++){\n            k = (xa - x) / (xa - xb);\n            if (k < 0) {\n                k = 0;\n            } else if (k > 1) {\n                k = 1;\n            }\n            bytes[j++] = car - (car - cbr) * k | 0;\n            bytes[j++] = cag - (cag - cbg) * k | 0;\n            bytes[j++] = cab - (cab - cbb) * k | 0;\n            bytes[j++] = 255;\n        }\n    }\n}\nfunction drawFigure(data, figure, context) {\n    const ps = figure.coords;\n    const cs = figure.colors;\n    let i, ii;\n    switch(figure.type){\n        case \"lattice\":\n            const verticesPerRow = figure.verticesPerRow;\n            const rows = Math.floor(ps.length / verticesPerRow) - 1;\n            const cols = verticesPerRow - 1;\n            for(i = 0; i < rows; i++){\n                let q = i * verticesPerRow;\n                for(let j = 0; j < cols; j++, q++){\n                    drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n                    drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n                }\n            }\n            break;\n        case \"triangles\":\n            for(i = 0, ii = ps.length; i < ii; i += 3){\n                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n            }\n            break;\n        default:\n            throw new Error(\"illegal figure\");\n    }\n}\nclass MeshShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._coords = IR[2];\n        this._colors = IR[3];\n        this._figures = IR[4];\n        this._bounds = IR[5];\n        this._bbox = IR[6];\n        this._background = IR[7];\n        this.matrix = null;\n    }\n    _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n        const EXPECTED_SCALE = 1.1;\n        const MAX_PATTERN_SIZE = 3000;\n        const BORDER_SIZE = 2;\n        const offsetX = Math.floor(this._bounds[0]);\n        const offsetY = Math.floor(this._bounds[1]);\n        const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n        const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n        const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const scaleX = boundsWidth / width;\n        const scaleY = boundsHeight / height;\n        const context = {\n            coords: this._coords,\n            colors: this._colors,\n            offsetX: -offsetX,\n            offsetY: -offsetY,\n            scaleX: 1 / scaleX,\n            scaleY: 1 / scaleY\n        };\n        const paddedWidth = width + BORDER_SIZE * 2;\n        const paddedHeight = height + BORDER_SIZE * 2;\n        const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight);\n        const tmpCtx = tmpCanvas.context;\n        const data = tmpCtx.createImageData(width, height);\n        if (backgroundColor) {\n            const bytes = data.data;\n            for(let i = 0, ii = bytes.length; i < ii; i += 4){\n                bytes[i] = backgroundColor[0];\n                bytes[i + 1] = backgroundColor[1];\n                bytes[i + 2] = backgroundColor[2];\n                bytes[i + 3] = 255;\n            }\n        }\n        for (const figure of this._figures){\n            drawFigure(data, figure, context);\n        }\n        tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n        const canvas = tmpCanvas.canvas;\n        return {\n            canvas,\n            offsetX: offsetX - BORDER_SIZE * scaleX,\n            offsetY: offsetY - BORDER_SIZE * scaleY,\n            scaleX,\n            scaleY\n        };\n    }\n    isModifyingCurrentTransform() {\n        return true;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        applyBoundingBox(ctx, this._bbox);\n        const scale = new Float32Array(2);\n        if (pathType === PathType.SHADING) {\n            Util.singularValueDecompose2dScale(getCurrentTransform(ctx), scale);\n        } else if (this.matrix) {\n            Util.singularValueDecompose2dScale(this.matrix, scale);\n            const [matrixScaleX, matrixScaleY] = scale;\n            Util.singularValueDecompose2dScale(owner.baseTransform, scale);\n            scale[0] *= matrixScaleX;\n            scale[1] *= matrixScaleY;\n        } else {\n            Util.singularValueDecompose2dScale(owner.baseTransform, scale);\n        }\n        const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n        if (pathType !== PathType.SHADING) {\n            ctx.setTransform(...owner.baseTransform);\n            if (this.matrix) {\n                ctx.transform(...this.matrix);\n            }\n        }\n        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n        return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n    }\n}\nclass DummyShadingPattern extends BaseShadingPattern {\n    getPattern() {\n        return \"hotpink\";\n    }\n}\nfunction getShadingPattern(IR) {\n    switch(IR[0]){\n        case \"RadialAxial\":\n            return new RadialAxialShadingPattern(IR);\n        case \"Mesh\":\n            return new MeshShadingPattern(IR);\n        case \"Dummy\":\n            return new DummyShadingPattern();\n    }\n    throw new Error(`Unknown IR type: ${IR[0]}`);\n}\nconst PaintType = {\n    COLORED: 1,\n    UNCOLORED: 2\n};\nclass TilingPattern {\n    static{\n        this.MAX_PATTERN_SIZE = 3000;\n    }\n    constructor(IR, ctx, canvasGraphicsFactory, baseTransform){\n        this.color = IR[1];\n        this.operatorList = IR[2];\n        this.matrix = IR[3];\n        this.bbox = IR[4];\n        this.xstep = IR[5];\n        this.ystep = IR[6];\n        this.paintType = IR[7];\n        this.tilingType = IR[8];\n        this.ctx = ctx;\n        this.canvasGraphicsFactory = canvasGraphicsFactory;\n        this.baseTransform = baseTransform;\n    }\n    createPatternCanvas(owner) {\n        const { bbox, operatorList, paintType, tilingType, color, canvasGraphicsFactory } = this;\n        let { xstep, ystep } = this;\n        xstep = Math.abs(xstep);\n        ystep = Math.abs(ystep);\n        info(\"TilingType: \" + tilingType);\n        const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];\n        const width = x1 - x0;\n        const height = y1 - y0;\n        const scale = new Float32Array(2);\n        Util.singularValueDecompose2dScale(this.matrix, scale);\n        const [matrixScaleX, matrixScaleY] = scale;\n        Util.singularValueDecompose2dScale(this.baseTransform, scale);\n        const combinedScaleX = matrixScaleX * scale[0];\n        const combinedScaleY = matrixScaleY * scale[1];\n        let canvasWidth = width, canvasHeight = height, redrawHorizontally = false, redrawVertically = false;\n        const xScaledStep = Math.ceil(xstep * combinedScaleX);\n        const yScaledStep = Math.ceil(ystep * combinedScaleY);\n        const xScaledWidth = Math.ceil(width * combinedScaleX);\n        const yScaledHeight = Math.ceil(height * combinedScaleY);\n        if (xScaledStep >= xScaledWidth) {\n            canvasWidth = xstep;\n        } else {\n            redrawHorizontally = true;\n        }\n        if (yScaledStep >= yScaledHeight) {\n            canvasHeight = ystep;\n        } else {\n            redrawVertically = true;\n        }\n        const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n        const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n        const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size);\n        const tmpCtx = tmpCanvas.context;\n        const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n        graphics.groupLevel = owner.groupLevel;\n        this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n        tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);\n        graphics.transform(0, dimx.scale, 0, 0, dimy.scale, 0, 0);\n        tmpCtx.save();\n        graphics.dependencyTracker?.save();\n        this.clipBbox(graphics, x0, y0, x1, y1);\n        graphics.baseTransform = getCurrentTransform(graphics.ctx);\n        graphics.executeOperatorList(operatorList);\n        graphics.endDrawing();\n        graphics.dependencyTracker?.restore().recordNestedDependencies?.();\n        tmpCtx.restore();\n        if (redrawHorizontally || redrawVertically) {\n            const image = tmpCanvas.canvas;\n            if (redrawHorizontally) {\n                canvasWidth = xstep;\n            }\n            if (redrawVertically) {\n                canvasHeight = ystep;\n            }\n            const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n            const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n            const xSize = dimx2.size;\n            const ySize = dimy2.size;\n            const tmpCanvas2 = owner.cachedCanvases.getCanvas(\"pattern-workaround\", xSize, ySize);\n            const tmpCtx2 = tmpCanvas2.context;\n            const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;\n            const jj = redrawVertically ? Math.floor(height / ystep) : 0;\n            for(let i = 0; i <= ii; i++){\n                for(let j = 0; j <= jj; j++){\n                    tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);\n                }\n            }\n            return {\n                canvas: tmpCanvas2.canvas,\n                scaleX: dimx2.scale,\n                scaleY: dimy2.scale,\n                offsetX: x0,\n                offsetY: y0\n            };\n        }\n        return {\n            canvas: tmpCanvas.canvas,\n            scaleX: dimx.scale,\n            scaleY: dimy.scale,\n            offsetX: x0,\n            offsetY: y0\n        };\n    }\n    getSizeAndScale(step, realOutputSize, scale) {\n        const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n        let size = Math.ceil(step * scale);\n        if (size >= maxSize) {\n            size = maxSize;\n        } else {\n            scale = size / step;\n        }\n        return {\n            scale,\n            size\n        };\n    }\n    clipBbox(graphics, x0, y0, x1, y1) {\n        const bboxWidth = x1 - x0;\n        const bboxHeight = y1 - y0;\n        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n        Util.axialAlignedBoundingBox([\n            x0,\n            y0,\n            x1,\n            y1\n        ], getCurrentTransform(graphics.ctx), graphics.current.minMax);\n        graphics.clip();\n        graphics.endPath();\n    }\n    setFillAndStrokeStyleToContext(graphics, paintType, color) {\n        const context = graphics.ctx, current = graphics.current;\n        switch(paintType){\n            case PaintType.COLORED:\n                const { fillStyle, strokeStyle } = this.ctx;\n                context.fillStyle = current.fillColor = fillStyle;\n                context.strokeStyle = current.strokeColor = strokeStyle;\n                break;\n            case PaintType.UNCOLORED:\n                context.fillStyle = context.strokeStyle = color;\n                current.fillColor = current.strokeColor = color;\n                break;\n            default:\n                throw new FormatError(`Unsupported paint type: ${paintType}`);\n        }\n    }\n    isModifyingCurrentTransform() {\n        return false;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        let matrix = inverse;\n        if (pathType !== PathType.SHADING) {\n            matrix = Util.transform(matrix, owner.baseTransform);\n            if (this.matrix) {\n                matrix = Util.transform(matrix, this.matrix);\n            }\n        }\n        const temporaryPatternCanvas = this.createPatternCanvas(owner);\n        let domMatrix = new DOMMatrix(matrix);\n        domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n        const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n        pattern.setTransform(domMatrix);\n        return pattern;\n    }\n}\n; // ./src/shared/image_utils.js\nfunction convertToRGBA(params) {\n    switch(params.kind){\n        case ImageKind.GRAYSCALE_1BPP:\n            return convertBlackAndWhiteToRGBA(params);\n        case ImageKind.RGB_24BPP:\n            return convertRGBToRGBA(params);\n    }\n    return null;\n}\nfunction convertBlackAndWhiteToRGBA({ src, srcPos = 0, dest, width, height, nonBlackColor = 0xffffffff, inverseDecode = false }) {\n    const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n    const [zeroMapping, oneMapping] = inverseDecode ? [\n        nonBlackColor,\n        black\n    ] : [\n        black,\n        nonBlackColor\n    ];\n    const widthInSource = width >> 3;\n    const widthRemainder = width & 7;\n    const srcLength = src.length;\n    dest = new Uint32Array(dest.buffer);\n    let destPos = 0;\n    for(let i = 0; i < height; i++){\n        for(const max = srcPos + widthInSource; srcPos < max; srcPos++){\n            const elem = srcPos < srcLength ? src[srcPos] : 255;\n            dest[destPos++] = elem & 128 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 64 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 32 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 16 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 8 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 4 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 2 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 1 ? oneMapping : zeroMapping;\n        }\n        if (widthRemainder === 0) {\n            continue;\n        }\n        const elem = srcPos < srcLength ? src[srcPos++] : 255;\n        for(let j = 0; j < widthRemainder; j++){\n            dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n        }\n    }\n    return {\n        srcPos,\n        destPos\n    };\n}\nfunction convertRGBToRGBA({ src, srcPos = 0, dest, destPos = 0, width, height }) {\n    let i = 0;\n    const len = width * height * 3;\n    const len32 = len >> 2;\n    const src32 = new Uint32Array(src.buffer, srcPos, len32);\n    if (FeatureTest.isLittleEndian) {\n        for(; i < len32 - 2; i += 3, destPos += 4){\n            const s1 = src32[i];\n            const s2 = src32[i + 1];\n            const s3 = src32[i + 2];\n            dest[destPos] = s1 | 0xff000000;\n            dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n            dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n            dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n        }\n        for(let j = i * 4, jj = srcPos + len; j < jj; j += 3){\n            dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n        }\n    } else {\n        for(; i < len32 - 2; i += 3, destPos += 4){\n            const s1 = src32[i];\n            const s2 = src32[i + 1];\n            const s3 = src32[i + 2];\n            dest[destPos] = s1 | 0xff;\n            dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n            dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n            dest[destPos + 3] = s3 << 8 | 0xff;\n        }\n        for(let j = i * 4, jj = srcPos + len; j < jj; j += 3){\n            dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n        }\n    }\n    return {\n        srcPos: srcPos + len,\n        destPos\n    };\n}\nfunction grayToRGBA(src, dest) {\n    if (FeatureTest.isLittleEndian) {\n        for(let i = 0, ii = src.length; i < ii; i++){\n            dest[i] = src[i] * 0x10101 | 0xff000000;\n        }\n    } else {\n        for(let i = 0, ii = src.length; i < ii; i++){\n            dest[i] = src[i] * 0x1010100 | 0x000000ff;\n        }\n    }\n}\n; // ./src/display/canvas.js\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst FULL_CHUNK_HEIGHT = 16;\nconst SCALE_MATRIX = new DOMMatrix();\nconst XY = new Float32Array(2);\nconst MIN_MAX_INIT = new Float32Array([\n    Infinity,\n    Infinity,\n    -Infinity,\n    -Infinity\n]);\nfunction mirrorContextOperations(ctx, destCtx) {\n    if (ctx._removeMirroring) {\n        throw new Error(\"Context is already forwarding operations.\");\n    }\n    ctx.__originalSave = ctx.save;\n    ctx.__originalRestore = ctx.restore;\n    ctx.__originalRotate = ctx.rotate;\n    ctx.__originalScale = ctx.scale;\n    ctx.__originalTranslate = ctx.translate;\n    ctx.__originalTransform = ctx.transform;\n    ctx.__originalSetTransform = ctx.setTransform;\n    ctx.__originalResetTransform = ctx.resetTransform;\n    ctx.__originalClip = ctx.clip;\n    ctx.__originalMoveTo = ctx.moveTo;\n    ctx.__originalLineTo = ctx.lineTo;\n    ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n    ctx.__originalRect = ctx.rect;\n    ctx.__originalClosePath = ctx.closePath;\n    ctx.__originalBeginPath = ctx.beginPath;\n    ctx._removeMirroring = ()=>{\n        ctx.save = ctx.__originalSave;\n        ctx.restore = ctx.__originalRestore;\n        ctx.rotate = ctx.__originalRotate;\n        ctx.scale = ctx.__originalScale;\n        ctx.translate = ctx.__originalTranslate;\n        ctx.transform = ctx.__originalTransform;\n        ctx.setTransform = ctx.__originalSetTransform;\n        ctx.resetTransform = ctx.__originalResetTransform;\n        ctx.clip = ctx.__originalClip;\n        ctx.moveTo = ctx.__originalMoveTo;\n        ctx.lineTo = ctx.__originalLineTo;\n        ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n        ctx.rect = ctx.__originalRect;\n        ctx.closePath = ctx.__originalClosePath;\n        ctx.beginPath = ctx.__originalBeginPath;\n        delete ctx._removeMirroring;\n    };\n    ctx.save = function() {\n        destCtx.save();\n        this.__originalSave();\n    };\n    ctx.restore = function() {\n        destCtx.restore();\n        this.__originalRestore();\n    };\n    ctx.translate = function(x, y) {\n        destCtx.translate(x, y);\n        this.__originalTranslate(x, y);\n    };\n    ctx.scale = function(x, y) {\n        destCtx.scale(x, y);\n        this.__originalScale(x, y);\n    };\n    ctx.transform = function(a, b, c, d, e, f) {\n        destCtx.transform(a, b, c, d, e, f);\n        this.__originalTransform(a, b, c, d, e, f);\n    };\n    ctx.setTransform = function(a, b, c, d, e, f) {\n        destCtx.setTransform(a, b, c, d, e, f);\n        this.__originalSetTransform(a, b, c, d, e, f);\n    };\n    ctx.resetTransform = function() {\n        destCtx.resetTransform();\n        this.__originalResetTransform();\n    };\n    ctx.rotate = function(angle) {\n        destCtx.rotate(angle);\n        this.__originalRotate(angle);\n    };\n    ctx.clip = function(rule) {\n        destCtx.clip(rule);\n        this.__originalClip(rule);\n    };\n    ctx.moveTo = function(x, y) {\n        destCtx.moveTo(x, y);\n        this.__originalMoveTo(x, y);\n    };\n    ctx.lineTo = function(x, y) {\n        destCtx.lineTo(x, y);\n        this.__originalLineTo(x, y);\n    };\n    ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n        destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n        this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    };\n    ctx.rect = function(x, y, width, height) {\n        destCtx.rect(x, y, width, height);\n        this.__originalRect(x, y, width, height);\n    };\n    ctx.closePath = function() {\n        destCtx.closePath();\n        this.__originalClosePath();\n    };\n    ctx.beginPath = function() {\n        destCtx.beginPath();\n        this.__originalBeginPath();\n    };\n}\nclass CachedCanvases {\n    constructor(canvasFactory){\n        this.canvasFactory = canvasFactory;\n        this.cache = Object.create(null);\n    }\n    getCanvas(id, width, height) {\n        let canvasEntry;\n        if (this.cache[id] !== undefined) {\n            canvasEntry = this.cache[id];\n            this.canvasFactory.reset(canvasEntry, width, height);\n        } else {\n            canvasEntry = this.canvasFactory.create(width, height);\n            this.cache[id] = canvasEntry;\n        }\n        return canvasEntry;\n    }\n    delete(id) {\n        delete this.cache[id];\n    }\n    clear() {\n        for(const id in this.cache){\n            const canvasEntry = this.cache[id];\n            this.canvasFactory.destroy(canvasEntry);\n            delete this.cache[id];\n        }\n    }\n}\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n    const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);\n    if (b === 0 && c === 0) {\n        const tlX = destX * a + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destY * d + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destX + destW) * a + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destY + destH) * d + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rWidth,\n            rHeight\n        ];\n    }\n    if (a === 0 && d === 0) {\n        const tlX = destY * c + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destX * b + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destY + destH) * c + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destX + destW) * b + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rHeight,\n            rWidth\n        ];\n    }\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n    const scaleX = Math.hypot(a, b);\n    const scaleY = Math.hypot(c, d);\n    return [\n        scaleX * destW,\n        scaleY * destH\n    ];\n}\nclass CanvasExtraState {\n    constructor(width, height, preInit){\n        this.alphaIsShape = false;\n        this.fontSize = 0;\n        this.fontSizeScale = 1;\n        this.textMatrix = null;\n        this.textMatrixScale = 1;\n        this.fontMatrix = FONT_IDENTITY_MATRIX;\n        this.leading = 0;\n        this.x = 0;\n        this.y = 0;\n        this.lineX = 0;\n        this.lineY = 0;\n        this.charSpacing = 0;\n        this.wordSpacing = 0;\n        this.textHScale = 1;\n        this.textRenderingMode = TextRenderingMode.FILL;\n        this.textRise = 0;\n        this.fillColor = \"#000000\";\n        this.strokeColor = \"#000000\";\n        this.patternFill = false;\n        this.patternStroke = false;\n        this.fillAlpha = 1;\n        this.strokeAlpha = 1;\n        this.lineWidth = 1;\n        this.activeSMask = null;\n        this.transferMaps = \"none\";\n        preInit?.(this);\n        this.clipBox = new Float32Array([\n            0,\n            0,\n            width,\n            height\n        ]);\n        this.minMax = MIN_MAX_INIT.slice();\n    }\n    clone() {\n        const clone = Object.create(this);\n        clone.clipBox = this.clipBox.slice();\n        clone.minMax = this.minMax.slice();\n        return clone;\n    }\n    getPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        const box = this.minMax.slice();\n        if (pathType === PathType.STROKE) {\n            if (!transform) {\n                unreachable(\"Stroke bounding box must include transform.\");\n            }\n            Util.singularValueDecompose2dScale(transform, XY);\n            const xStrokePad = XY[0] * this.lineWidth / 2;\n            const yStrokePad = XY[1] * this.lineWidth / 2;\n            box[0] -= xStrokePad;\n            box[1] -= yStrokePad;\n            box[2] += xStrokePad;\n            box[3] += yStrokePad;\n        }\n        return box;\n    }\n    updateClipFromPath() {\n        const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());\n        this.startNewPathAndClipBox(intersect || [\n            0,\n            0,\n            0,\n            0\n        ]);\n    }\n    isEmptyClip() {\n        return this.minMax[0] === Infinity;\n    }\n    startNewPathAndClipBox(box) {\n        this.clipBox.set(box, 0);\n        this.minMax.set(MIN_MAX_INIT, 0);\n    }\n    getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n    }\n}\nfunction putBinaryImageData(ctx, imgData) {\n    if (imgData instanceof ImageData) {\n        ctx.putImageData(imgData, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0, destPos;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    let i, j, thisChunkHeight, elemsInThisChunk;\n    if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {\n        const srcLength = src.byteLength;\n        const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n        const dest32DataLength = dest32.length;\n        const fullSrcDiff = width + 7 >> 3;\n        const white = 0xffffffff;\n        const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n        for(i = 0; i < totalChunks; i++){\n            thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n            destPos = 0;\n            for(j = 0; j < thisChunkHeight; j++){\n                const srcDiff = srcLength - srcPos;\n                let k = 0;\n                const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n                const kEndUnrolled = kEnd & ~7;\n                let mask = 0;\n                let srcByte = 0;\n                for(; k < kEndUnrolled; k += 8){\n                    srcByte = src[srcPos++];\n                    dest32[destPos++] = srcByte & 128 ? white : black;\n                    dest32[destPos++] = srcByte & 64 ? white : black;\n                    dest32[destPos++] = srcByte & 32 ? white : black;\n                    dest32[destPos++] = srcByte & 16 ? white : black;\n                    dest32[destPos++] = srcByte & 8 ? white : black;\n                    dest32[destPos++] = srcByte & 4 ? white : black;\n                    dest32[destPos++] = srcByte & 2 ? white : black;\n                    dest32[destPos++] = srcByte & 1 ? white : black;\n                }\n                for(; k < kEnd; k++){\n                    if (mask === 0) {\n                        srcByte = src[srcPos++];\n                        mask = 128;\n                    }\n                    dest32[destPos++] = srcByte & mask ? white : black;\n                    mask >>= 1;\n                }\n            }\n            while(destPos < dest32DataLength){\n                dest32[destPos++] = 0;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {\n        j = 0;\n        elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n        for(i = 0; i < fullChunks; i++){\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            srcPos += elemsInThisChunk;\n            ctx.putImageData(chunkImgData, 0, j);\n            j += FULL_CHUNK_HEIGHT;\n        }\n        if (i < totalChunks) {\n            elemsInThisChunk = width * partialChunkHeight * 4;\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            ctx.putImageData(chunkImgData, 0, j);\n        }\n    } else if (imgData.kind === util_ImageKind.RGB_24BPP) {\n        thisChunkHeight = FULL_CHUNK_HEIGHT;\n        elemsInThisChunk = width * thisChunkHeight;\n        for(i = 0; i < totalChunks; i++){\n            if (i >= fullChunks) {\n                thisChunkHeight = partialChunkHeight;\n                elemsInThisChunk = width * thisChunkHeight;\n            }\n            destPos = 0;\n            for(j = elemsInThisChunk; j--;){\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = 255;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else {\n        throw new Error(`bad image kind: ${imgData.kind}`);\n    }\n}\nfunction putBinaryImageMask(ctx, imgData) {\n    if (imgData.bitmap) {\n        ctx.drawImage(imgData.bitmap, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    for(let i = 0; i < totalChunks; i++){\n        const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n        ({ srcPos } = convertBlackAndWhiteToRGBA({\n            src,\n            srcPos,\n            dest,\n            width,\n            height: thisChunkHeight,\n            nonBlackColor: 0\n        }));\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n}\nfunction copyCtxState(sourceCtx, destCtx) {\n    const properties = [\n        \"strokeStyle\",\n        \"fillStyle\",\n        \"fillRule\",\n        \"globalAlpha\",\n        \"lineWidth\",\n        \"lineCap\",\n        \"lineJoin\",\n        \"miterLimit\",\n        \"globalCompositeOperation\",\n        \"font\",\n        \"filter\"\n    ];\n    for (const property of properties){\n        if (sourceCtx[property] !== undefined) {\n            destCtx[property] = sourceCtx[property];\n        }\n    }\n    if (sourceCtx.setLineDash !== undefined) {\n        destCtx.setLineDash(sourceCtx.getLineDash());\n        destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n    }\n}\nfunction resetCtxToDefault(ctx) {\n    ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n    ctx.fillRule = \"nonzero\";\n    ctx.globalAlpha = 1;\n    ctx.lineWidth = 1;\n    ctx.lineCap = \"butt\";\n    ctx.lineJoin = \"miter\";\n    ctx.miterLimit = 10;\n    ctx.globalCompositeOperation = \"source-over\";\n    ctx.font = \"10px sans-serif\";\n    if (ctx.setLineDash !== undefined) {\n        ctx.setLineDash([]);\n        ctx.lineDashOffset = 0;\n    }\n    const { filter } = ctx;\n    if (filter !== \"none\" && filter !== \"\") {\n        ctx.filter = \"none\";\n    }\n}\nfunction getImageSmoothingEnabled(transform, interpolate) {\n    if (interpolate) {\n        return true;\n    }\n    Util.singularValueDecompose2dScale(transform, XY);\n    const actualScale = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n    return XY[0] <= actualScale && XY[1] <= actualScale;\n}\nconst LINE_CAP_STYLES = [\n    \"butt\",\n    \"round\",\n    \"square\"\n];\nconst LINE_JOIN_STYLES = [\n    \"miter\",\n    \"round\",\n    \"bevel\"\n];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\nclass CanvasGraphics {\n    constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, { optionalContentConfig, markedContentStack = null }, annotationCanvasMap, pageColors, dependencyTracker){\n        this.ctx = canvasCtx;\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.stateStack = [];\n        this.pendingClip = null;\n        this.pendingEOFill = false;\n        this.res = null;\n        this.xobjs = null;\n        this.commonObjs = commonObjs;\n        this.objs = objs;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this.groupStack = [];\n        this.baseTransform = null;\n        this.baseTransformStack = [];\n        this.groupLevel = 0;\n        this.smaskStack = [];\n        this.smaskCounter = 0;\n        this.tempSMask = null;\n        this.suspendedCtx = null;\n        this.contentVisible = true;\n        this.markedContentStack = markedContentStack || [];\n        this.optionalContentConfig = optionalContentConfig;\n        this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n        this.cachedPatterns = new Map();\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.viewportScale = 1;\n        this.outputScaleX = 1;\n        this.outputScaleY = 1;\n        this.pageColors = pageColors;\n        this._cachedScaleForStroking = [\n            -1,\n            0\n        ];\n        this._cachedGetSinglePixelWidth = null;\n        this._cachedBitmapsMap = new Map();\n        this.dependencyTracker = dependencyTracker ?? null;\n    }\n    getObject(opIdx, data, fallback = null) {\n        if (typeof data === \"string\") {\n            this.dependencyTracker?.recordNamedDependency(opIdx, data);\n            return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n        }\n        return fallback;\n    }\n    beginDrawing({ transform, viewport, transparency = false, background = null }) {\n        const width = this.ctx.canvas.width;\n        const height = this.ctx.canvas.height;\n        const savedFillStyle = this.ctx.fillStyle;\n        this.ctx.fillStyle = background || \"#ffffff\";\n        this.ctx.fillRect(0, 0, width, height);\n        this.ctx.fillStyle = savedFillStyle;\n        if (transparency) {\n            const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n            this.compositeCtx = this.ctx;\n            this.transparentCanvas = transparentCanvas.canvas;\n            this.ctx = transparentCanvas.context;\n            this.ctx.save();\n            this.ctx.transform(...getCurrentTransform(this.compositeCtx));\n        }\n        this.ctx.save();\n        resetCtxToDefault(this.ctx);\n        if (transform) {\n            this.ctx.transform(...transform);\n            this.outputScaleX = transform[0];\n            this.outputScaleY = transform[0];\n        }\n        this.ctx.transform(...viewport.transform);\n        this.viewportScale = viewport.scale;\n        this.baseTransform = getCurrentTransform(this.ctx);\n    }\n    executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper, filteredOperationIndexes) {\n        const argsArray = operatorList.argsArray;\n        const fnArray = operatorList.fnArray;\n        let i = executionStartIdx || 0;\n        const argsArrayLen = argsArray.length;\n        if (argsArrayLen === i) {\n            return i;\n        }\n        const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n        const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n        let steps = 0;\n        const commonObjs = this.commonObjs;\n        const objs = this.objs;\n        let fnId, fnArgs;\n        while(true){\n            if (stepper !== undefined && i === stepper.nextBreakPoint) {\n                stepper.breakIt(i, continueCallback);\n                return i;\n            }\n            if (!filteredOperationIndexes || filteredOperationIndexes.has(i)) {\n                fnId = fnArray[i];\n                fnArgs = argsArray[i] ?? null;\n                if (fnId !== OPS.dependency) {\n                    if (fnArgs === null) {\n                        this[fnId](i);\n                    } else {\n                        this[fnId](i, ...fnArgs);\n                    }\n                } else {\n                    for (const depObjId of fnArgs){\n                        this.dependencyTracker?.recordNamedData(depObjId, i);\n                        const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n                        if (!objsPool.has(depObjId)) {\n                            objsPool.get(depObjId, continueCallback);\n                            return i;\n                        }\n                    }\n                }\n            }\n            i++;\n            if (i === argsArrayLen) {\n                return i;\n            }\n            if (chunkOperations && ++steps > EXECUTION_STEPS) {\n                if (Date.now() > endTime) {\n                    continueCallback();\n                    return i;\n                }\n                steps = 0;\n            }\n        }\n    }\n    #restoreInitialState() {\n        while(this.stateStack.length || this.inSMaskMode){\n            this.restore();\n        }\n        this.current.activeSMask = null;\n        this.ctx.restore();\n        if (this.transparentCanvas) {\n            this.ctx = this.compositeCtx;\n            this.ctx.save();\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n            this.ctx.drawImage(this.transparentCanvas, 0, 0);\n            this.ctx.restore();\n            this.transparentCanvas = null;\n        }\n    }\n    endDrawing() {\n        this.#restoreInitialState();\n        this.cachedCanvases.clear();\n        this.cachedPatterns.clear();\n        for (const cache of this._cachedBitmapsMap.values()){\n            for (const canvas of cache.values()){\n                if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n                    canvas.width = canvas.height = 0;\n                }\n            }\n            cache.clear();\n        }\n        this._cachedBitmapsMap.clear();\n        this.#drawFilter();\n    }\n    #drawFilter() {\n        if (this.pageColors) {\n            const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n            if (hcmFilterId !== \"none\") {\n                const savedFilter = this.ctx.filter;\n                this.ctx.filter = hcmFilterId;\n                this.ctx.drawImage(this.ctx.canvas, 0, 0);\n                this.ctx.filter = savedFilter;\n            }\n        }\n    }\n    _scaleImage(img, inverseTransform) {\n        const width = img.width ?? img.displayWidth;\n        const height = img.height ?? img.displayHeight;\n        let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n        let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n        let paintWidth = width, paintHeight = height;\n        let tmpCanvasId = \"prescale1\";\n        let tmpCanvas, tmpCtx;\n        while(widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1){\n            let newWidth = paintWidth, newHeight = paintHeight;\n            if (widthScale > 2 && paintWidth > 1) {\n                newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n                widthScale /= paintWidth / newWidth;\n            }\n            if (heightScale > 2 && paintHeight > 1) {\n                newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n                heightScale /= paintHeight / newHeight;\n            }\n            tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n            tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, newWidth, newHeight);\n            tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n            img = tmpCanvas.canvas;\n            paintWidth = newWidth;\n            paintHeight = newHeight;\n            tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n        }\n        return {\n            img,\n            paintWidth,\n            paintHeight\n        };\n    }\n    _createMaskCanvas(opIdx, img) {\n        const ctx = this.ctx;\n        const { width, height } = img;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        const currentTransform = getCurrentTransform(ctx);\n        let cache, cacheKey, scaled, maskCanvas;\n        if ((img.bitmap || img.data) && img.count > 1) {\n            const mainKey = img.bitmap || img.data.buffer;\n            cacheKey = JSON.stringify(isPatternFill ? currentTransform : [\n                currentTransform.slice(0, 4),\n                fillColor\n            ]);\n            cache = this._cachedBitmapsMap.get(mainKey);\n            if (!cache) {\n                cache = new Map();\n                this._cachedBitmapsMap.set(mainKey, cache);\n            }\n            const cachedImage = cache.get(cacheKey);\n            if (cachedImage && !isPatternFill) {\n                const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n                const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n                this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);\n                return {\n                    canvas: cachedImage,\n                    offsetX,\n                    offsetY\n                };\n            }\n            scaled = cachedImage;\n        }\n        if (!scaled) {\n            maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            putBinaryImageMask(maskCanvas.context, img);\n        }\n        let maskToCanvas = Util.transform(currentTransform, [\n            1 / width,\n            0,\n            0,\n            -1 / height,\n            0,\n            0\n        ]);\n        maskToCanvas = Util.transform(maskToCanvas, [\n            1,\n            0,\n            0,\n            1,\n            0,\n            -height\n        ]);\n        const minMax = MIN_MAX_INIT.slice();\n        Util.axialAlignedBoundingBox([\n            0,\n            0,\n            width,\n            height\n        ], maskToCanvas, minMax);\n        const [minX, minY, maxX, maxY] = minMax;\n        const drawnWidth = Math.round(maxX - minX) || 1;\n        const drawnHeight = Math.round(maxY - minY) || 1;\n        const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n        const fillCtx = fillCanvas.context;\n        const offsetX = minX;\n        const offsetY = minY;\n        fillCtx.translate(-offsetX, -offsetY);\n        fillCtx.transform(...maskToCanvas);\n        if (!scaled) {\n            scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));\n            scaled = scaled.img;\n            if (cache && isPatternFill) {\n                cache.set(cacheKey, scaled);\n            }\n        }\n        fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);\n        drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n        fillCtx.globalCompositeOperation = \"source-in\";\n        const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [\n            1,\n            0,\n            0,\n            1,\n            -offsetX,\n            -offsetY\n        ]);\n        fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL) : fillColor;\n        fillCtx.fillRect(0, 0, width, height);\n        if (cache && !isPatternFill) {\n            this.cachedCanvases.delete(\"fillCanvas\");\n            cache.set(cacheKey, fillCanvas.canvas);\n        }\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);\n        return {\n            canvas: fillCanvas.canvas,\n            offsetX: Math.round(offsetX),\n            offsetY: Math.round(offsetY)\n        };\n    }\n    setLineWidth(opIdx, width) {\n        this.dependencyTracker?.recordSimpleData(\"lineWidth\", opIdx);\n        if (width !== this.current.lineWidth) {\n            this._cachedScaleForStroking[0] = -1;\n        }\n        this.current.lineWidth = width;\n        this.ctx.lineWidth = width;\n    }\n    setLineCap(opIdx, style) {\n        this.dependencyTracker?.recordSimpleData(\"lineCap\", opIdx);\n        this.ctx.lineCap = LINE_CAP_STYLES[style];\n    }\n    setLineJoin(opIdx, style) {\n        this.dependencyTracker?.recordSimpleData(\"lineJoin\", opIdx);\n        this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n    }\n    setMiterLimit(opIdx, limit) {\n        this.dependencyTracker?.recordSimpleData(\"miterLimit\", opIdx);\n        this.ctx.miterLimit = limit;\n    }\n    setDash(opIdx, dashArray, dashPhase) {\n        this.dependencyTracker?.recordSimpleData(\"dash\", opIdx);\n        const ctx = this.ctx;\n        if (ctx.setLineDash !== undefined) {\n            ctx.setLineDash(dashArray);\n            ctx.lineDashOffset = dashPhase;\n        }\n    }\n    setRenderingIntent(opIdx, intent) {}\n    setFlatness(opIdx, flatness) {}\n    setGState(opIdx, states) {\n        for (const [key, value] of states){\n            switch(key){\n                case \"LW\":\n                    this.setLineWidth(opIdx, value);\n                    break;\n                case \"LC\":\n                    this.setLineCap(opIdx, value);\n                    break;\n                case \"LJ\":\n                    this.setLineJoin(opIdx, value);\n                    break;\n                case \"ML\":\n                    this.setMiterLimit(opIdx, value);\n                    break;\n                case \"D\":\n                    this.setDash(opIdx, value[0], value[1]);\n                    break;\n                case \"RI\":\n                    this.setRenderingIntent(opIdx, value);\n                    break;\n                case \"FL\":\n                    this.setFlatness(opIdx, value);\n                    break;\n                case \"Font\":\n                    this.setFont(opIdx, value[0], value[1]);\n                    break;\n                case \"CA\":\n                    this.dependencyTracker?.recordSimpleData(\"strokeAlpha\", opIdx);\n                    this.current.strokeAlpha = value;\n                    break;\n                case \"ca\":\n                    this.dependencyTracker?.recordSimpleData(\"fillAlpha\", opIdx);\n                    this.ctx.globalAlpha = this.current.fillAlpha = value;\n                    break;\n                case \"BM\":\n                    this.dependencyTracker?.recordSimpleData(\"globalCompositeOperation\", opIdx);\n                    this.ctx.globalCompositeOperation = value;\n                    break;\n                case \"SMask\":\n                    this.dependencyTracker?.recordSimpleData(\"SMask\", opIdx);\n                    this.current.activeSMask = value ? this.tempSMask : null;\n                    this.tempSMask = null;\n                    this.checkSMaskState();\n                    break;\n                case \"TR\":\n                    this.dependencyTracker?.recordSimpleData(\"filter\", opIdx);\n                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n                    break;\n            }\n        }\n    }\n    get inSMaskMode() {\n        return !!this.suspendedCtx;\n    }\n    checkSMaskState() {\n        const inSMaskMode = this.inSMaskMode;\n        if (this.current.activeSMask && !inSMaskMode) {\n            this.beginSMaskMode();\n        } else if (!this.current.activeSMask && inSMaskMode) {\n            this.endSMaskMode();\n        }\n    }\n    beginSMaskMode(opIdx) {\n        if (this.inSMaskMode) {\n            throw new Error(\"beginSMaskMode called while already in smask mode\");\n        }\n        const drawnWidth = this.ctx.canvas.width;\n        const drawnHeight = this.ctx.canvas.height;\n        const cacheId = \"smaskGroupAt\" + this.groupLevel;\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        this.suspendedCtx = this.ctx;\n        const ctx = this.ctx = scratchCanvas.context;\n        ctx.setTransform(this.suspendedCtx.getTransform());\n        copyCtxState(this.suspendedCtx, ctx);\n        mirrorContextOperations(ctx, this.suspendedCtx);\n        this.setGState(opIdx, [\n            [\n                \"BM\",\n                \"source-over\"\n            ]\n        ]);\n    }\n    endSMaskMode() {\n        if (!this.inSMaskMode) {\n            throw new Error(\"endSMaskMode called while not in smask mode\");\n        }\n        this.ctx._removeMirroring();\n        copyCtxState(this.ctx, this.suspendedCtx);\n        this.ctx = this.suspendedCtx;\n        this.suspendedCtx = null;\n    }\n    compose(dirtyBox) {\n        if (!this.current.activeSMask) {\n            return;\n        }\n        if (!dirtyBox) {\n            dirtyBox = [\n                0,\n                0,\n                this.ctx.canvas.width,\n                this.ctx.canvas.height\n            ];\n        } else {\n            dirtyBox[0] = Math.floor(dirtyBox[0]);\n            dirtyBox[1] = Math.floor(dirtyBox[1]);\n            dirtyBox[2] = Math.ceil(dirtyBox[2]);\n            dirtyBox[3] = Math.ceil(dirtyBox[3]);\n        }\n        const smask = this.current.activeSMask;\n        const suspendedCtx = this.suspendedCtx;\n        this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n        this.ctx.save();\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n        this.ctx.restore();\n    }\n    composeSMask(ctx, smask, layerCtx, layerBox) {\n        const layerOffsetX = layerBox[0];\n        const layerOffsetY = layerBox[1];\n        const layerWidth = layerBox[2] - layerOffsetX;\n        const layerHeight = layerBox[3] - layerOffsetY;\n        if (layerWidth === 0 || layerHeight === 0) {\n            return;\n        }\n        this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n        ctx.save();\n        ctx.globalAlpha = 1;\n        ctx.globalCompositeOperation = \"source-over\";\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(layerCtx.canvas, 0, 0);\n        ctx.restore();\n    }\n    genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n        let maskCanvas = maskCtx.canvas;\n        let maskX = layerOffsetX - maskOffsetX;\n        let maskY = layerOffsetY - maskOffsetY;\n        if (backdrop) {\n            if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {\n                const canvas = this.cachedCanvases.getCanvas(\"maskExtension\", width, height);\n                const ctx = canvas.context;\n                ctx.drawImage(maskCanvas, -maskX, -maskY);\n                ctx.globalCompositeOperation = \"destination-atop\";\n                ctx.fillStyle = backdrop;\n                ctx.fillRect(0, 0, width, height);\n                ctx.globalCompositeOperation = \"source-over\";\n                maskCanvas = canvas.canvas;\n                maskX = maskY = 0;\n            } else {\n                maskCtx.save();\n                maskCtx.globalAlpha = 1;\n                maskCtx.setTransform(1, 0, 0, 1, 0, 0);\n                const clip = new Path2D();\n                clip.rect(maskX, maskY, width, height);\n                maskCtx.clip(clip);\n                maskCtx.globalCompositeOperation = \"destination-atop\";\n                maskCtx.fillStyle = backdrop;\n                maskCtx.fillRect(maskX, maskY, width, height);\n                maskCtx.restore();\n            }\n        }\n        layerCtx.save();\n        layerCtx.globalAlpha = 1;\n        layerCtx.setTransform(1, 0, 0, 1, 0, 0);\n        if (subtype === \"Alpha\" && transferMap) {\n            layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);\n        } else if (subtype === \"Luminosity\") {\n            layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);\n        }\n        const clip = new Path2D();\n        clip.rect(layerOffsetX, layerOffsetY, width, height);\n        layerCtx.clip(clip);\n        layerCtx.globalCompositeOperation = \"destination-in\";\n        layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);\n        layerCtx.restore();\n    }\n    save(opIdx) {\n        if (this.inSMaskMode) {\n            copyCtxState(this.ctx, this.suspendedCtx);\n        }\n        this.ctx.save();\n        const old = this.current;\n        this.stateStack.push(old);\n        this.current = old.clone();\n        this.dependencyTracker?.save(opIdx);\n    }\n    restore(opIdx) {\n        this.dependencyTracker?.restore(opIdx);\n        if (this.stateStack.length === 0) {\n            if (this.inSMaskMode) {\n                this.endSMaskMode();\n            }\n            return;\n        }\n        this.current = this.stateStack.pop();\n        this.ctx.restore();\n        if (this.inSMaskMode) {\n            copyCtxState(this.suspendedCtx, this.ctx);\n        }\n        this.checkSMaskState();\n        this.pendingClip = null;\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n    }\n    transform(opIdx, a, b, c, d, e, f) {\n        this.dependencyTracker?.recordIncrementalData(\"transform\", opIdx);\n        this.ctx.transform(a, b, c, d, e, f);\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n    }\n    constructPath(opIdx, op, data, minMax) {\n        let [path] = data;\n        if (!minMax) {\n            path ||= data[0] = new Path2D();\n            this[op](opIdx, path);\n            return;\n        }\n        if (this.dependencyTracker !== null) {\n            const outerExtraSize = op === OPS.stroke ? this.current.lineWidth / 2 : 0;\n            this.dependencyTracker.resetBBox(opIdx).recordBBox(opIdx, this.ctx, minMax[0] - outerExtraSize, minMax[2] + outerExtraSize, minMax[1] - outerExtraSize, minMax[3] + outerExtraSize).recordDependencies(opIdx, [\n                \"transform\"\n            ]);\n        }\n        if (!(path instanceof Path2D)) {\n            const path2d = data[0] = new Path2D();\n            for(let i = 0, ii = path.length; i < ii;){\n                switch(path[i++]){\n                    case DrawOPS.moveTo:\n                        path2d.moveTo(path[i++], path[i++]);\n                        break;\n                    case DrawOPS.lineTo:\n                        path2d.lineTo(path[i++], path[i++]);\n                        break;\n                    case DrawOPS.curveTo:\n                        path2d.bezierCurveTo(path[i++], path[i++], path[i++], path[i++], path[i++], path[i++]);\n                        break;\n                    case DrawOPS.closePath:\n                        path2d.closePath();\n                        break;\n                    default:\n                        warn(`Unrecognized drawing path operator: ${path[i - 1]}`);\n                        break;\n                }\n            }\n            path = path2d;\n        }\n        Util.axialAlignedBoundingBox(minMax, getCurrentTransform(this.ctx), this.current.minMax);\n        this[op](opIdx, path);\n        this._pathStartIdx = opIdx;\n    }\n    closePath(opIdx) {\n        this.ctx.closePath();\n    }\n    stroke(opIdx, path, consumePath = true) {\n        const ctx = this.ctx;\n        const strokeColor = this.current.strokeColor;\n        ctx.globalAlpha = this.current.strokeAlpha;\n        if (this.contentVisible) {\n            if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n                const baseTransform = strokeColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;\n                ctx.save();\n                ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);\n                if (baseTransform) {\n                    const newPath = new Path2D();\n                    newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));\n                    path = newPath;\n                }\n                this.rescaleAndStroke(path, false);\n                ctx.restore();\n            } else {\n                this.rescaleAndStroke(path, true);\n            }\n        }\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.stroke);\n        if (consumePath) {\n            this.consumePath(opIdx, path, this.current.getClippedPathBoundingBox(PathType.STROKE, getCurrentTransform(this.ctx)));\n        }\n        ctx.globalAlpha = this.current.fillAlpha;\n    }\n    closeStroke(opIdx, path) {\n        this.stroke(opIdx, path);\n    }\n    fill(opIdx, path, consumePath = true) {\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        let needRestore = false;\n        if (isPatternFill) {\n            const baseTransform = fillColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;\n            this.dependencyTracker?.save(opIdx);\n            ctx.save();\n            ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);\n            if (baseTransform) {\n                const newPath = new Path2D();\n                newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));\n                path = newPath;\n            }\n            needRestore = true;\n        }\n        const intersect = this.current.getClippedPathBoundingBox();\n        if (this.contentVisible && intersect !== null) {\n            if (this.pendingEOFill) {\n                ctx.fill(path, \"evenodd\");\n                this.pendingEOFill = false;\n            } else {\n                ctx.fill(path);\n            }\n        }\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.fill);\n        if (needRestore) {\n            ctx.restore();\n            this.dependencyTracker?.restore(opIdx);\n        }\n        if (consumePath) {\n            this.consumePath(opIdx, path, intersect);\n        }\n    }\n    eoFill(opIdx, path) {\n        this.pendingEOFill = true;\n        this.fill(opIdx, path);\n    }\n    fillStroke(opIdx, path) {\n        this.fill(opIdx, path, false);\n        this.stroke(opIdx, path, false);\n        this.consumePath(opIdx, path);\n    }\n    eoFillStroke(opIdx, path) {\n        this.pendingEOFill = true;\n        this.fillStroke(opIdx, path);\n    }\n    closeFillStroke(opIdx, path) {\n        this.fillStroke(opIdx, path);\n    }\n    closeEOFillStroke(opIdx, path) {\n        this.pendingEOFill = true;\n        this.fillStroke(opIdx, path);\n    }\n    endPath(opIdx, path) {\n        this.consumePath(opIdx, path);\n    }\n    rawFillPath(opIdx, path) {\n        this.ctx.fill(path);\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.rawFillPath).recordOperation(opIdx);\n    }\n    clip(opIdx) {\n        this.dependencyTracker?.recordFutureForcedDependency(\"clipMode\", opIdx);\n        this.pendingClip = NORMAL_CLIP;\n    }\n    eoClip(opIdx) {\n        this.dependencyTracker?.recordFutureForcedDependency(\"clipMode\", opIdx);\n        this.pendingClip = EO_CLIP;\n    }\n    beginText(opIdx) {\n        this.current.textMatrix = null;\n        this.current.textMatrixScale = 1;\n        this.current.x = this.current.lineX = 0;\n        this.current.y = this.current.lineY = 0;\n        this.dependencyTracker?.recordOpenMarker(opIdx).resetIncrementalData(\"sameLineText\").resetIncrementalData(\"moveText\", opIdx);\n    }\n    endText(opIdx) {\n        const paths = this.pendingTextPaths;\n        const ctx = this.ctx;\n        if (this.dependencyTracker) {\n            const { dependencyTracker } = this;\n            if (paths !== undefined) {\n                dependencyTracker.recordFutureForcedDependency(\"textClip\", dependencyTracker.getOpenMarker()).recordFutureForcedDependency(\"textClip\", opIdx);\n            }\n            dependencyTracker.recordCloseMarker(opIdx);\n        }\n        if (paths !== undefined) {\n            const newPath = new Path2D();\n            const invTransf = ctx.getTransform().invertSelf();\n            for (const { transform, x, y, fontSize, path } of paths){\n                if (!path) {\n                    continue;\n                }\n                newPath.addPath(path, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x, y).scale(fontSize, -fontSize));\n            }\n            ctx.clip(newPath);\n        }\n        delete this.pendingTextPaths;\n    }\n    setCharSpacing(opIdx, spacing) {\n        this.dependencyTracker?.recordSimpleData(\"charSpacing\", opIdx);\n        this.current.charSpacing = spacing;\n    }\n    setWordSpacing(opIdx, spacing) {\n        this.dependencyTracker?.recordSimpleData(\"wordSpacing\", opIdx);\n        this.current.wordSpacing = spacing;\n    }\n    setHScale(opIdx, scale) {\n        this.dependencyTracker?.recordSimpleData(\"hScale\", opIdx);\n        this.current.textHScale = scale / 100;\n    }\n    setLeading(opIdx, leading) {\n        this.dependencyTracker?.recordSimpleData(\"leading\", opIdx);\n        this.current.leading = -leading;\n    }\n    setFont(opIdx, fontRefName, size) {\n        this.dependencyTracker?.recordSimpleData(\"font\", opIdx).recordNamedDependency(opIdx, fontRefName);\n        const fontObj = this.commonObjs.get(fontRefName);\n        const current = this.current;\n        if (!fontObj) {\n            throw new Error(`Can't find font for ${fontRefName}`);\n        }\n        current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;\n        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n            warn(\"Invalid font matrix for font \" + fontRefName);\n        }\n        if (size < 0) {\n            size = -size;\n            current.fontDirection = -1;\n        } else {\n            current.fontDirection = 1;\n        }\n        this.current.font = fontObj;\n        this.current.fontSize = size;\n        if (fontObj.isType3Font) {\n            return;\n        }\n        const name = fontObj.loadedName || \"sans-serif\";\n        const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n        let bold = \"normal\";\n        if (fontObj.black) {\n            bold = \"900\";\n        } else if (fontObj.bold) {\n            bold = \"bold\";\n        }\n        const italic = fontObj.italic ? \"italic\" : \"normal\";\n        let browserFontSize = size;\n        if (size < MIN_FONT_SIZE) {\n            browserFontSize = MIN_FONT_SIZE;\n        } else if (size > MAX_FONT_SIZE) {\n            browserFontSize = MAX_FONT_SIZE;\n        }\n        this.current.fontSizeScale = size / browserFontSize;\n        this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n    }\n    setTextRenderingMode(opIdx, mode) {\n        this.dependencyTracker?.recordSimpleData(\"textRenderingMode\", opIdx);\n        this.current.textRenderingMode = mode;\n    }\n    setTextRise(opIdx, rise) {\n        this.dependencyTracker?.recordSimpleData(\"textRise\", opIdx);\n        this.current.textRise = rise;\n    }\n    moveText(opIdx, x, y) {\n        this.dependencyTracker?.resetIncrementalData(\"sameLineText\").recordIncrementalData(\"moveText\", opIdx);\n        this.current.x = this.current.lineX += x;\n        this.current.y = this.current.lineY += y;\n    }\n    setLeadingMoveText(opIdx, x, y) {\n        this.setLeading(opIdx, -y);\n        this.moveText(opIdx, x, y);\n    }\n    setTextMatrix(opIdx, matrix) {\n        this.dependencyTracker?.recordSimpleData(\"textMatrix\", opIdx);\n        const { current } = this;\n        current.textMatrix = matrix;\n        current.textMatrixScale = Math.hypot(matrix[0], matrix[1]);\n        current.x = current.lineX = 0;\n        current.y = current.lineY = 0;\n    }\n    nextLine(opIdx) {\n        this.moveText(opIdx, 0, this.current.leading);\n        this.dependencyTracker?.recordIncrementalData(\"moveText\", this.dependencyTracker.getSimpleIndex(\"leading\") ?? opIdx);\n    }\n    #getScaledPath(path, currentTransform, transform) {\n        const newPath = new Path2D();\n        newPath.addPath(path, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));\n        return newPath;\n    }\n    paintChar(opIdx, character, x, y, patternFillTransform, patternStrokeTransform) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const textRenderingMode = current.textRenderingMode;\n        const fontSize = current.fontSize / current.fontSizeScale;\n        const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n        const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);\n        const patternFill = current.patternFill && !font.missingFile;\n        const patternStroke = current.patternStroke && !font.missingFile;\n        let path;\n        if ((font.disableFontFace || isAddToPathSet || patternFill || patternStroke) && !font.missingFile) {\n            path = font.getPathGenerator(this.commonObjs, character);\n        }\n        if (path && (font.disableFontFace || patternFill || patternStroke)) {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.scale(fontSize, -fontSize);\n            this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font);\n            let currentTransform;\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (patternFillTransform) {\n                    currentTransform = ctx.getTransform();\n                    ctx.setTransform(...patternFillTransform);\n                    const scaledPath = this.#getScaledPath(path, currentTransform, patternFillTransform);\n                    ctx.fill(scaledPath);\n                } else {\n                    ctx.fill(path);\n                }\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (patternStrokeTransform) {\n                    currentTransform ||= ctx.getTransform();\n                    ctx.setTransform(...patternStrokeTransform);\n                    const { a, b, c, d } = currentTransform;\n                    const invPatternTransform = Util.inverseTransform(patternStrokeTransform);\n                    const transf = Util.transform([\n                        a,\n                        b,\n                        c,\n                        d,\n                        0,\n                        0\n                    ], invPatternTransform);\n                    Util.singularValueDecompose2dScale(transf, XY);\n                    ctx.lineWidth *= Math.max(XY[0], XY[1]) / fontSize;\n                    ctx.stroke(this.#getScaledPath(path, currentTransform, patternStrokeTransform));\n                } else {\n                    ctx.lineWidth /= fontSize;\n                    ctx.stroke(path);\n                }\n            }\n            ctx.restore();\n        } else {\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.fillText(character, x, y);\n                this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, ()=>ctx.measureText(character));\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (this.dependencyTracker) {\n                    this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, ()=>ctx.measureText(character)).recordDependencies(opIdx, Dependencies.stroke);\n                }\n                ctx.strokeText(character, x, y);\n            }\n        }\n        if (isAddToPathSet) {\n            const paths = this.pendingTextPaths ||= [];\n            paths.push({\n                transform: getCurrentTransform(ctx),\n                x,\n                y,\n                fontSize,\n                path\n            });\n            this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y);\n        }\n    }\n    get isFontSubpixelAAEnabled() {\n        const { context: ctx } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n        ctx.scale(1.5, 1);\n        ctx.fillText(\"I\", 0, 10);\n        const data = ctx.getImageData(0, 0, 10, 10).data;\n        let enabled = false;\n        for(let i = 3; i < data.length; i += 4){\n            if (data[i] > 0 && data[i] < 255) {\n                enabled = true;\n                break;\n            }\n        }\n        return shadow(this, \"isFontSubpixelAAEnabled\", enabled);\n    }\n    showText(opIdx, glyphs) {\n        if (this.dependencyTracker) {\n            this.dependencyTracker.recordDependencies(opIdx, Dependencies.showText).copyDependenciesFromIncrementalOperation(opIdx, \"sameLineText\").resetBBox(opIdx);\n            if (this.current.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG) {\n                this.dependencyTracker.recordFutureForcedDependency(\"textClip\", opIdx).inheritPendingDependenciesAsFutureForcedDependencies();\n            }\n        }\n        const current = this.current;\n        const font = current.font;\n        if (font.isType3Font) {\n            this.showType3Text(opIdx, glyphs);\n            this.dependencyTracker?.recordOperation(opIdx).recordIncrementalData(\"sameLineText\", opIdx);\n            return undefined;\n        }\n        const fontSize = current.fontSize;\n        if (fontSize === 0) {\n            this.dependencyTracker?.recordOperation(opIdx);\n            return undefined;\n        }\n        const ctx = this.ctx;\n        const fontSizeScale = current.fontSizeScale;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const fontDirection = current.fontDirection;\n        const textHScale = current.textHScale * fontDirection;\n        const glyphsLength = glyphs.length;\n        const vertical = font.vertical;\n        const spacingDir = vertical ? 1 : -1;\n        const defaultVMetrics = font.defaultVMetrics;\n        const widthAdvanceScale = fontSize * current.fontMatrix[0];\n        const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n        ctx.save();\n        if (current.textMatrix) {\n            ctx.transform(...current.textMatrix);\n        }\n        ctx.translate(current.x, current.y + current.textRise);\n        if (fontDirection > 0) {\n            ctx.scale(textHScale, -1);\n        } else {\n            ctx.scale(textHScale, 1);\n        }\n        let patternFillTransform, patternStrokeTransform;\n        if (current.patternFill) {\n            ctx.save();\n            const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);\n            patternFillTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.fillStyle = pattern;\n        }\n        if (current.patternStroke) {\n            ctx.save();\n            const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);\n            patternStrokeTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.strokeStyle = pattern;\n        }\n        let lineWidth = current.lineWidth;\n        const scale = current.textMatrixScale;\n        if (scale === 0 || lineWidth === 0) {\n            const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                lineWidth = this.getSinglePixelWidth();\n            }\n        } else {\n            lineWidth /= scale;\n        }\n        if (fontSizeScale !== 1.0) {\n            ctx.scale(fontSizeScale, fontSizeScale);\n            lineWidth /= fontSizeScale;\n        }\n        ctx.lineWidth = lineWidth;\n        if (font.isInvalidPDFjsFont) {\n            const chars = [];\n            let width = 0;\n            for (const glyph of glyphs){\n                chars.push(glyph.unicode);\n                width += glyph.width;\n            }\n            const joinedChars = chars.join(\"\");\n            ctx.fillText(joinedChars, 0, 0);\n            if (this.dependencyTracker !== null) {\n                const measure = ctx.measureText(joinedChars);\n                this.dependencyTracker.recordBBox(opIdx, this.ctx, -measure.actualBoundingBoxLeft, measure.actualBoundingBoxRight, -measure.actualBoundingBoxAscent, measure.actualBoundingBoxDescent).recordOperation(opIdx).recordIncrementalData(\"sameLineText\", opIdx);\n            }\n            current.x += width * widthAdvanceScale * textHScale;\n            ctx.restore();\n            this.compose();\n            return undefined;\n        }\n        let x = 0, i;\n        for(i = 0; i < glyphsLength; ++i){\n            const glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                x += spacingDir * glyph * fontSize / 1000;\n                continue;\n            }\n            let restoreNeeded = false;\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const character = glyph.fontChar;\n            const accent = glyph.accent;\n            let scaledX, scaledY;\n            let width = glyph.width;\n            if (vertical) {\n                const vmetric = glyph.vmetric || defaultVMetrics;\n                const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n                const vy = vmetric[2] * widthAdvanceScale;\n                width = vmetric ? -vmetric[0] : width;\n                scaledX = vx / fontSizeScale;\n                scaledY = (x + vy) / fontSizeScale;\n            } else {\n                scaledX = x / fontSizeScale;\n                scaledY = 0;\n            }\n            let measure;\n            if (font.remeasure && width > 0) {\n                measure = ctx.measureText(character);\n                const measuredWidth = measure.width * 1000 / fontSize * fontSizeScale;\n                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n                    const characterScaleX = width / measuredWidth;\n                    restoreNeeded = true;\n                    ctx.save();\n                    ctx.scale(characterScaleX, 1);\n                    scaledX /= characterScaleX;\n                } else if (width !== measuredWidth) {\n                    scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n                }\n            }\n            if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n                if (simpleFillText && !accent) {\n                    ctx.fillText(character, scaledX, scaledY);\n                    this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, measure ? {\n                        bbox: null\n                    } : font, fontSize / fontSizeScale, scaledX, scaledY, ()=>measure ?? ctx.measureText(character));\n                } else {\n                    this.paintChar(opIdx, character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);\n                    if (accent) {\n                        const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n                        const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n                        this.paintChar(opIdx, accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);\n                    }\n                }\n            }\n            const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n            x += charWidth;\n            if (restoreNeeded) {\n                ctx.restore();\n            }\n        }\n        if (vertical) {\n            current.y -= x;\n        } else {\n            current.x += x * textHScale;\n        }\n        ctx.restore();\n        this.compose();\n        this.dependencyTracker?.recordOperation(opIdx).recordIncrementalData(\"sameLineText\", opIdx);\n        return undefined;\n    }\n    showType3Text(opIdx, glyphs) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const fontSize = current.fontSize;\n        const fontDirection = current.fontDirection;\n        const spacingDir = font.vertical ? 1 : -1;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const textHScale = current.textHScale * fontDirection;\n        const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;\n        const glyphsLength = glyphs.length;\n        const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;\n        let i, glyph, width, spacingLength;\n        if (isTextInvisible || fontSize === 0) {\n            return;\n        }\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n        ctx.save();\n        if (current.textMatrix) {\n            ctx.transform(...current.textMatrix);\n        }\n        ctx.translate(current.x, current.y + current.textRise);\n        ctx.scale(textHScale, fontDirection);\n        const dependencyTracker = this.dependencyTracker;\n        this.dependencyTracker = dependencyTracker ? new CanvasNestedDependencyTracker(dependencyTracker, opIdx) : null;\n        for(i = 0; i < glyphsLength; ++i){\n            glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                spacingLength = spacingDir * glyph * fontSize / 1000;\n                this.ctx.translate(spacingLength, 0);\n                current.x += spacingLength * textHScale;\n                continue;\n            }\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const operatorList = font.charProcOperatorList[glyph.operatorListId];\n            if (!operatorList) {\n                warn(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n            } else if (this.contentVisible) {\n                this.save();\n                ctx.scale(fontSize, fontSize);\n                ctx.transform(...fontMatrix);\n                this.executeOperatorList(operatorList);\n                this.restore();\n            }\n            const p = [\n                glyph.width,\n                0\n            ];\n            Util.applyTransform(p, fontMatrix);\n            width = p[0] * fontSize + spacing;\n            ctx.translate(width, 0);\n            current.x += width * textHScale;\n        }\n        ctx.restore();\n        if (dependencyTracker) {\n            this.dependencyTracker.recordNestedDependencies();\n            this.dependencyTracker = dependencyTracker;\n        }\n    }\n    setCharWidth(opIdx, xWidth, yWidth) {}\n    setCharWidthAndBounds(opIdx, xWidth, yWidth, llx, lly, urx, ury) {\n        const clip = new Path2D();\n        clip.rect(llx, lly, urx - llx, ury - lly);\n        this.ctx.clip(clip);\n        this.dependencyTracker?.recordBBox(opIdx, this.ctx, llx, urx, lly, ury).recordClipBox(opIdx, this.ctx, llx, urx, lly, ury);\n        this.endPath(opIdx);\n    }\n    getColorN_Pattern(opIdx, IR) {\n        let pattern;\n        if (IR[0] === \"TilingPattern\") {\n            const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);\n            const canvasGraphicsFactory = {\n                createCanvasGraphics: (ctx)=>new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                        optionalContentConfig: this.optionalContentConfig,\n                        markedContentStack: this.markedContentStack\n                    }, undefined, undefined, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, opIdx) : null)\n            };\n            pattern = new TilingPattern(IR, this.ctx, canvasGraphicsFactory, baseTransform);\n        } else {\n            pattern = this._getPattern(opIdx, IR[1], IR[2]);\n        }\n        return pattern;\n    }\n    setStrokeColorN(opIdx, ...args) {\n        this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n        this.current.strokeColor = this.getColorN_Pattern(opIdx, args);\n        this.current.patternStroke = true;\n    }\n    setFillColorN(opIdx, ...args) {\n        this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n        this.current.fillColor = this.getColorN_Pattern(opIdx, args);\n        this.current.patternFill = true;\n    }\n    setStrokeRGBColor(opIdx, color) {\n        this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n        this.ctx.strokeStyle = this.current.strokeColor = color;\n        this.current.patternStroke = false;\n    }\n    setStrokeTransparent(opIdx) {\n        this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n        this.ctx.strokeStyle = this.current.strokeColor = \"transparent\";\n        this.current.patternStroke = false;\n    }\n    setFillRGBColor(opIdx, color) {\n        this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n        this.ctx.fillStyle = this.current.fillColor = color;\n        this.current.patternFill = false;\n    }\n    setFillTransparent(opIdx) {\n        this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n        this.ctx.fillStyle = this.current.fillColor = \"transparent\";\n        this.current.patternFill = false;\n    }\n    _getPattern(opIdx, objId, matrix = null) {\n        let pattern;\n        if (this.cachedPatterns.has(objId)) {\n            pattern = this.cachedPatterns.get(objId);\n        } else {\n            pattern = getShadingPattern(this.getObject(opIdx, objId));\n            this.cachedPatterns.set(objId, pattern);\n        }\n        if (matrix) {\n            pattern.matrix = matrix;\n        }\n        return pattern;\n    }\n    shadingFill(opIdx, objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        this.save(opIdx);\n        const pattern = this._getPattern(opIdx, objId);\n        ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING);\n        const inv = getCurrentTransformInverse(ctx);\n        if (inv) {\n            const { width, height } = ctx.canvas;\n            const minMax = MIN_MAX_INIT.slice();\n            Util.axialAlignedBoundingBox([\n                0,\n                0,\n                width,\n                height\n            ], inv, minMax);\n            const [x0, y0, x1, y1] = minMax;\n            this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n        } else {\n            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n        }\n        this.dependencyTracker?.resetBBox(opIdx).recordFullPageBBox(opIdx).recordDependencies(opIdx, Dependencies.transform).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);\n        this.compose(this.current.getClippedPathBoundingBox());\n        this.restore(opIdx);\n    }\n    beginInlineImage() {\n        unreachable(\"Should not call beginInlineImage\");\n    }\n    beginImageData() {\n        unreachable(\"Should not call beginImageData\");\n    }\n    paintFormXObjectBegin(opIdx, matrix, bbox) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save(opIdx);\n        this.baseTransformStack.push(this.baseTransform);\n        if (matrix) {\n            this.transform(opIdx, ...matrix);\n        }\n        this.baseTransform = getCurrentTransform(this.ctx);\n        if (bbox) {\n            Util.axialAlignedBoundingBox(bbox, this.baseTransform, this.current.minMax);\n            const [x0, y0, x1, y1] = bbox;\n            const clip = new Path2D();\n            clip.rect(x0, y0, x1 - x0, y1 - y0);\n            this.ctx.clip(clip);\n            this.dependencyTracker?.recordClipBox(opIdx, this.ctx, x0, x1, y0, y1);\n            this.endPath(opIdx);\n        }\n    }\n    paintFormXObjectEnd(opIdx) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.restore(opIdx);\n        this.baseTransform = this.baseTransformStack.pop();\n    }\n    beginGroup(opIdx, group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save(opIdx);\n        if (this.inSMaskMode) {\n            this.endSMaskMode();\n            this.current.activeSMask = null;\n        }\n        const currentCtx = this.ctx;\n        if (!group.isolated) {\n            info(\"TODO: Support non-isolated groups.\");\n        }\n        if (group.knockout) {\n            warn(\"Knockout groups not supported.\");\n        }\n        const currentTransform = getCurrentTransform(currentCtx);\n        if (group.matrix) {\n            currentCtx.transform(...group.matrix);\n        }\n        if (!group.bbox) {\n            throw new Error(\"Bounding box is required.\");\n        }\n        let bounds = MIN_MAX_INIT.slice();\n        Util.axialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx), bounds);\n        const canvasBounds = [\n            0,\n            0,\n            currentCtx.canvas.width,\n            currentCtx.canvas.height\n        ];\n        bounds = Util.intersect(bounds, canvasBounds) || [\n            0,\n            0,\n            0,\n            0\n        ];\n        const offsetX = Math.floor(bounds[0]);\n        const offsetY = Math.floor(bounds[1]);\n        const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n        const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n        this.current.startNewPathAndClipBox([\n            0,\n            0,\n            drawnWidth,\n            drawnHeight\n        ]);\n        let cacheId = \"groupAt\" + this.groupLevel;\n        if (group.smask) {\n            cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n        }\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        const groupCtx = scratchCanvas.context;\n        groupCtx.translate(-offsetX, -offsetY);\n        groupCtx.transform(...currentTransform);\n        let clip = new Path2D();\n        const [x0, y0, x1, y1] = group.bbox;\n        clip.rect(x0, y0, x1 - x0, y1 - y0);\n        if (group.matrix) {\n            const path = new Path2D();\n            path.addPath(clip, new DOMMatrix(group.matrix));\n            clip = path;\n        }\n        groupCtx.clip(clip);\n        if (group.smask) {\n            this.smaskStack.push({\n                canvas: scratchCanvas.canvas,\n                context: groupCtx,\n                offsetX,\n                offsetY,\n                subtype: group.smask.subtype,\n                backdrop: group.smask.backdrop,\n                transferMap: group.smask.transferMap || null,\n                startTransformInverse: null\n            });\n        }\n        if (!group.smask || this.dependencyTracker) {\n            currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n            currentCtx.translate(offsetX, offsetY);\n            currentCtx.save();\n        }\n        copyCtxState(currentCtx, groupCtx);\n        this.ctx = groupCtx;\n        this.dependencyTracker?.inheritSimpleDataAsFutureForcedDependencies([\n            \"fillAlpha\",\n            \"strokeAlpha\",\n            \"globalCompositeOperation\"\n        ]).pushBaseTransform(currentCtx);\n        this.setGState(opIdx, [\n            [\n                \"BM\",\n                \"source-over\"\n            ],\n            [\n                \"ca\",\n                1\n            ],\n            [\n                \"CA\",\n                1\n            ]\n        ]);\n        this.groupStack.push(currentCtx);\n        this.groupLevel++;\n    }\n    endGroup(opIdx, group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.groupLevel--;\n        const groupCtx = this.ctx;\n        const ctx = this.groupStack.pop();\n        this.ctx = ctx;\n        this.ctx.imageSmoothingEnabled = false;\n        this.dependencyTracker?.popBaseTransform();\n        if (group.smask) {\n            this.tempSMask = this.smaskStack.pop();\n            this.restore(opIdx);\n            if (this.dependencyTracker) {\n                this.ctx.restore();\n            }\n        } else {\n            this.ctx.restore();\n            const currentMtx = getCurrentTransform(this.ctx);\n            this.restore(opIdx);\n            this.ctx.save();\n            this.ctx.setTransform(...currentMtx);\n            const dirtyBox = MIN_MAX_INIT.slice();\n            Util.axialAlignedBoundingBox([\n                0,\n                0,\n                groupCtx.canvas.width,\n                groupCtx.canvas.height\n            ], currentMtx, dirtyBox);\n            this.ctx.drawImage(groupCtx.canvas, 0, 0);\n            this.ctx.restore();\n            this.compose(dirtyBox);\n        }\n    }\n    beginAnnotation(opIdx, id, rect, transform, matrix, hasOwnCanvas) {\n        this.#restoreInitialState();\n        resetCtxToDefault(this.ctx);\n        this.ctx.save();\n        this.save(opIdx);\n        if (this.baseTransform) {\n            this.ctx.setTransform(...this.baseTransform);\n        }\n        if (rect) {\n            const width = rect[2] - rect[0];\n            const height = rect[3] - rect[1];\n            if (hasOwnCanvas && this.annotationCanvasMap) {\n                transform = transform.slice();\n                transform[4] -= rect[0];\n                transform[5] -= rect[1];\n                rect = rect.slice();\n                rect[0] = rect[1] = 0;\n                rect[2] = width;\n                rect[3] = height;\n                Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), XY);\n                const { viewportScale } = this;\n                const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n                const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n                this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n                const { canvas, context } = this.annotationCanvas;\n                this.annotationCanvasMap.set(id, canvas);\n                this.annotationCanvas.savedCtx = this.ctx;\n                this.ctx = context;\n                this.ctx.save();\n                this.ctx.setTransform(XY[0], 0, 0, -XY[1], 0, height * XY[1]);\n                resetCtxToDefault(this.ctx);\n            } else {\n                resetCtxToDefault(this.ctx);\n                this.endPath(opIdx);\n                const clip = new Path2D();\n                clip.rect(rect[0], rect[1], width, height);\n                this.ctx.clip(clip);\n            }\n        }\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.transform(opIdx, ...transform);\n        this.transform(opIdx, ...matrix);\n    }\n    endAnnotation(opIdx) {\n        if (this.annotationCanvas) {\n            this.ctx.restore();\n            this.#drawFilter();\n            this.ctx = this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas;\n        }\n    }\n    paintImageMaskXObject(opIdx, img) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const count = img.count;\n        img = this.getObject(opIdx, img.data, img);\n        img.count = count;\n        const ctx = this.ctx;\n        const mask = this._createMaskCanvas(opIdx, img);\n        const maskCanvas = mask.canvas;\n        ctx.save();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, mask.offsetX, mask.offsetX + maskCanvas.width, mask.offsetY, mask.offsetY + maskCanvas.height).recordOperation(opIdx);\n        ctx.restore();\n        this.compose();\n    }\n    paintImageMaskXObjectRepeat(opIdx, img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        img = this.getObject(opIdx, img.data, img);\n        const ctx = this.ctx;\n        ctx.save();\n        const currentTransform = getCurrentTransform(ctx);\n        ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n        const mask = this._createMaskCanvas(opIdx, img);\n        ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n        this.dependencyTracker?.resetBBox(opIdx);\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            const trans = Util.transform(currentTransform, [\n                scaleX,\n                skewX,\n                skewY,\n                scaleY,\n                positions[i],\n                positions[i + 1]\n            ]);\n            ctx.drawImage(mask.canvas, trans[4], trans[5]);\n            this.dependencyTracker?.recordBBox(opIdx, this.ctx, trans[4], trans[4] + mask.canvas.width, trans[5], trans[5] + mask.canvas.height);\n        }\n        ctx.restore();\n        this.compose();\n        this.dependencyTracker?.recordOperation(opIdx);\n    }\n    paintImageMaskXObjectGroup(opIdx, images) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        this.dependencyTracker?.resetBBox(opIdx).recordDependencies(opIdx, Dependencies.transformAndFill);\n        for (const image of images){\n            const { data, width, height, transform } = image;\n            const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            const maskCtx = maskCanvas.context;\n            maskCtx.save();\n            const img = this.getObject(opIdx, data, image);\n            putBinaryImageMask(maskCtx, img);\n            maskCtx.globalCompositeOperation = \"source-in\";\n            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL) : fillColor;\n            maskCtx.fillRect(0, 0, width, height);\n            maskCtx.restore();\n            ctx.save();\n            ctx.transform(...transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n            this.dependencyTracker?.recordBBox(opIdx, ctx, 0, width, 0, height);\n            ctx.restore();\n        }\n        this.compose();\n        this.dependencyTracker?.recordOperation(opIdx);\n    }\n    paintImageXObject(opIdx, objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(opIdx, objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        this.paintInlineImageXObject(opIdx, imgData);\n    }\n    paintImageXObjectRepeat(opIdx, objId, scaleX, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(opIdx, objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const map = [];\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            map.push({\n                transform: [\n                    scaleX,\n                    0,\n                    0,\n                    scaleY,\n                    positions[i],\n                    positions[i + 1]\n                ],\n                x: 0,\n                y: 0,\n                w: width,\n                h: height\n            });\n        }\n        this.paintInlineImageXObjectGroup(opIdx, imgData, map);\n    }\n    applyTransferMapsToCanvas(ctx) {\n        if (this.current.transferMaps !== \"none\") {\n            ctx.filter = this.current.transferMaps;\n            ctx.drawImage(ctx.canvas, 0, 0);\n            ctx.filter = \"none\";\n        }\n        return ctx.canvas;\n    }\n    applyTransferMapsToBitmap(imgData) {\n        if (this.current.transferMaps === \"none\") {\n            return imgData.bitmap;\n        }\n        const { bitmap, width, height } = imgData;\n        const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n        const tmpCtx = tmpCanvas.context;\n        tmpCtx.filter = this.current.transferMaps;\n        tmpCtx.drawImage(bitmap, 0, 0);\n        tmpCtx.filter = \"none\";\n        return tmpCanvas.canvas;\n    }\n    paintInlineImageXObject(opIdx, imgData) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const ctx = this.ctx;\n        this.save(opIdx);\n        const { filter } = ctx;\n        if (filter !== \"none\" && filter !== \"\") {\n            ctx.filter = \"none\";\n        }\n        ctx.scale(1 / width, -1 / height);\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = this.applyTransferMapsToBitmap(imgData);\n        } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n            imgToPaint = imgData;\n        } else {\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));\n        ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);\n        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, ctx, 0, width, -height, 0).recordDependencies(opIdx, Dependencies.imageXObject).recordOperation(opIdx);\n        drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n        this.compose();\n        this.restore(opIdx);\n    }\n    paintInlineImageXObjectGroup(opIdx, imgData, map) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = imgData.bitmap;\n        } else {\n            const w = imgData.width;\n            const h = imgData.height;\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        this.dependencyTracker?.resetBBox(opIdx);\n        for (const entry of map){\n            ctx.save();\n            ctx.transform(...entry.transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n            this.dependencyTracker?.recordBBox(opIdx, ctx, 0, 1, -1, 0);\n            ctx.restore();\n        }\n        this.dependencyTracker?.recordOperation(opIdx);\n        this.compose();\n    }\n    paintSolidColorImageMask(opIdx) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, 0, 1, 0, 1).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);\n        this.ctx.fillRect(0, 0, 1, 1);\n        this.compose();\n    }\n    markPoint(opIdx, tag) {}\n    markPointProps(opIdx, tag, properties) {}\n    beginMarkedContent(opIdx, tag) {\n        this.dependencyTracker?.beginMarkedContent(opIdx);\n        this.markedContentStack.push({\n            visible: true\n        });\n    }\n    beginMarkedContentProps(opIdx, tag, properties) {\n        this.dependencyTracker?.beginMarkedContent(opIdx);\n        if (tag === \"OC\") {\n            this.markedContentStack.push({\n                visible: this.optionalContentConfig.isVisible(properties)\n            });\n        } else {\n            this.markedContentStack.push({\n                visible: true\n            });\n        }\n        this.contentVisible = this.isContentVisible();\n    }\n    endMarkedContent(opIdx) {\n        this.dependencyTracker?.endMarkedContent(opIdx);\n        this.markedContentStack.pop();\n        this.contentVisible = this.isContentVisible();\n    }\n    beginCompat(opIdx) {}\n    endCompat(opIdx) {}\n    consumePath(opIdx, path, clipBox) {\n        const isEmpty = this.current.isEmptyClip();\n        if (this.pendingClip) {\n            this.current.updateClipFromPath();\n        }\n        if (!this.pendingClip) {\n            this.compose(clipBox);\n        }\n        const ctx = this.ctx;\n        if (this.pendingClip) {\n            if (!isEmpty) {\n                if (this.pendingClip === EO_CLIP) {\n                    ctx.clip(path, \"evenodd\");\n                } else {\n                    ctx.clip(path);\n                }\n            }\n            this.pendingClip = null;\n            this.dependencyTracker?.bboxToClipBoxDropOperation(opIdx).recordFutureForcedDependency(\"clipPath\", opIdx);\n        } else {\n            this.dependencyTracker?.recordOperation(opIdx);\n        }\n        this.current.startNewPathAndClipBox(this.current.clipBox);\n    }\n    getSinglePixelWidth() {\n        if (!this._cachedGetSinglePixelWidth) {\n            const m = getCurrentTransform(this.ctx);\n            if (m[1] === 0 && m[2] === 0) {\n                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n            } else {\n                const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n                const normX = Math.hypot(m[0], m[2]);\n                const normY = Math.hypot(m[1], m[3]);\n                this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n            }\n        }\n        return this._cachedGetSinglePixelWidth;\n    }\n    getScaleForStroking() {\n        if (this._cachedScaleForStroking[0] === -1) {\n            const { lineWidth } = this.current;\n            const { a, b, c, d } = this.ctx.getTransform();\n            let scaleX, scaleY;\n            if (b === 0 && c === 0) {\n                const normX = Math.abs(a);\n                const normY = Math.abs(d);\n                if (normX === normY) {\n                    if (lineWidth === 0) {\n                        scaleX = scaleY = 1 / normX;\n                    } else {\n                        const scaledLineWidth = normX * lineWidth;\n                        scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n                    }\n                } else if (lineWidth === 0) {\n                    scaleX = 1 / normX;\n                    scaleY = 1 / normY;\n                } else {\n                    const scaledXLineWidth = normX * lineWidth;\n                    const scaledYLineWidth = normY * lineWidth;\n                    scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n                    scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n                }\n            } else {\n                const absDet = Math.abs(a * d - b * c);\n                const normX = Math.hypot(a, b);\n                const normY = Math.hypot(c, d);\n                if (lineWidth === 0) {\n                    scaleX = normY / absDet;\n                    scaleY = normX / absDet;\n                } else {\n                    const baseArea = lineWidth * absDet;\n                    scaleX = normY > baseArea ? normY / baseArea : 1;\n                    scaleY = normX > baseArea ? normX / baseArea : 1;\n                }\n            }\n            this._cachedScaleForStroking[0] = scaleX;\n            this._cachedScaleForStroking[1] = scaleY;\n        }\n        return this._cachedScaleForStroking;\n    }\n    rescaleAndStroke(path, saveRestore) {\n        const { ctx, current: { lineWidth } } = this;\n        const [scaleX, scaleY] = this.getScaleForStroking();\n        if (scaleX === scaleY) {\n            ctx.lineWidth = (lineWidth || 1) * scaleX;\n            ctx.stroke(path);\n            return;\n        }\n        const dashes = ctx.getLineDash();\n        if (saveRestore) {\n            ctx.save();\n        }\n        ctx.scale(scaleX, scaleY);\n        SCALE_MATRIX.a = 1 / scaleX;\n        SCALE_MATRIX.d = 1 / scaleY;\n        const newPath = new Path2D();\n        newPath.addPath(path, SCALE_MATRIX);\n        if (dashes.length > 0) {\n            const scale = Math.max(scaleX, scaleY);\n            ctx.setLineDash(dashes.map((x)=>x / scale));\n            ctx.lineDashOffset /= scale;\n        }\n        ctx.lineWidth = lineWidth || 1;\n        ctx.stroke(newPath);\n        if (saveRestore) {\n            ctx.restore();\n        }\n    }\n    isContentVisible() {\n        for(let i = this.markedContentStack.length - 1; i >= 0; i--){\n            if (!this.markedContentStack[i].visible) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfor(const op in OPS){\n    if (CanvasGraphics.prototype[op] !== undefined) {\n        CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];\n    }\n}\n; // ./src/display/worker_options.js\nclass GlobalWorkerOptions {\n    static #port = null;\n    static #src = \"\";\n    static get workerPort() {\n        return this.#port;\n    }\n    static set workerPort(val) {\n        if (!(typeof Worker !== \"undefined\" && val instanceof Worker) && val !== null) {\n            throw new Error(\"Invalid `workerPort` type.\");\n        }\n        this.#port = val;\n    }\n    static get workerSrc() {\n        return this.#src;\n    }\n    static set workerSrc(val) {\n        if (typeof val !== \"string\") {\n            throw new Error(\"Invalid `workerSrc` type.\");\n        }\n        this.#src = val;\n    }\n}\n; // ./src/display/metadata.js\nclass Metadata {\n    #map;\n    #data;\n    constructor({ parsedData, rawData }){\n        this.#map = parsedData;\n        this.#data = rawData;\n    }\n    getRaw() {\n        return this.#data;\n    }\n    get(name) {\n        return this.#map.get(name) ?? null;\n    }\n    [Symbol.iterator]() {\n        return this.#map.entries();\n    }\n}\n; // ./src/display/optional_content_config.js\nconst INTERNAL = Symbol(\"INTERNAL\");\nclass OptionalContentGroup {\n    #isDisplay;\n    #isPrint;\n    #userSet;\n    #visible;\n    constructor(renderingIntent, { name, intent, usage, rbGroups }){\n        this.#isDisplay = false;\n        this.#isPrint = false;\n        this.#userSet = false;\n        this.#visible = true;\n        this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);\n        this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        this.name = name;\n        this.intent = intent;\n        this.usage = usage;\n        this.rbGroups = rbGroups;\n    }\n    get visible() {\n        if (this.#userSet) {\n            return this.#visible;\n        }\n        if (!this.#visible) {\n            return false;\n        }\n        const { print, view } = this.usage;\n        if (this.#isDisplay) {\n            return view?.viewState !== \"OFF\";\n        } else if (this.#isPrint) {\n            return print?.printState !== \"OFF\";\n        }\n        return true;\n    }\n    _setVisible(internal, visible, userSet = false) {\n        if (internal !== INTERNAL) {\n            unreachable(\"Internal method `_setVisible` called.\");\n        }\n        this.#userSet = userSet;\n        this.#visible = visible;\n    }\n}\nclass OptionalContentConfig {\n    #cachedGetHash;\n    #groups;\n    #initialHash;\n    #order;\n    constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY){\n        this.#cachedGetHash = null;\n        this.#groups = new Map();\n        this.#initialHash = null;\n        this.#order = null;\n        this.renderingIntent = renderingIntent;\n        this.name = null;\n        this.creator = null;\n        if (data === null) {\n            return;\n        }\n        this.name = data.name;\n        this.creator = data.creator;\n        this.#order = data.order;\n        for (const group of data.groups){\n            this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));\n        }\n        if (data.baseState === \"OFF\") {\n            for (const group of this.#groups.values()){\n                group._setVisible(INTERNAL, false);\n            }\n        }\n        for (const on of data.on){\n            this.#groups.get(on)._setVisible(INTERNAL, true);\n        }\n        for (const off of data.off){\n            this.#groups.get(off)._setVisible(INTERNAL, false);\n        }\n        this.#initialHash = this.getHash();\n    }\n    #evaluateVisibilityExpression(array) {\n        const length = array.length;\n        if (length < 2) {\n            return true;\n        }\n        const operator = array[0];\n        for(let i = 1; i < length; i++){\n            const element = array[i];\n            let state;\n            if (Array.isArray(element)) {\n                state = this.#evaluateVisibilityExpression(element);\n            } else if (this.#groups.has(element)) {\n                state = this.#groups.get(element).visible;\n            } else {\n                warn(`Optional content group not found: ${element}`);\n                return true;\n            }\n            switch(operator){\n                case \"And\":\n                    if (!state) {\n                        return false;\n                    }\n                    break;\n                case \"Or\":\n                    if (state) {\n                        return true;\n                    }\n                    break;\n                case \"Not\":\n                    return !state;\n                default:\n                    return true;\n            }\n        }\n        return operator === \"And\";\n    }\n    isVisible(group) {\n        if (this.#groups.size === 0) {\n            return true;\n        }\n        if (!group) {\n            info(\"Optional content group not defined.\");\n            return true;\n        }\n        if (group.type === \"OCG\") {\n            if (!this.#groups.has(group.id)) {\n                warn(`Optional content group not found: ${group.id}`);\n                return true;\n            }\n            return this.#groups.get(group.id).visible;\n        } else if (group.type === \"OCMD\") {\n            if (group.expression) {\n                return this.#evaluateVisibilityExpression(group.expression);\n            }\n            if (!group.policy || group.policy === \"AnyOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            } else if (group.policy === \"AnyOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            warn(`Unknown optional content policy ${group.policy}.`);\n            return true;\n        }\n        warn(`Unknown group type ${group.type}.`);\n        return true;\n    }\n    setVisibility(id, visible = true, preserveRB = true) {\n        const group = this.#groups.get(id);\n        if (!group) {\n            warn(`Optional content group not found: ${id}`);\n            return;\n        }\n        if (preserveRB && visible && group.rbGroups.length) {\n            for (const rbGroup of group.rbGroups){\n                for (const otherId of rbGroup){\n                    if (otherId !== id) {\n                        this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);\n                    }\n                }\n            }\n        }\n        group._setVisible(INTERNAL, !!visible, true);\n        this.#cachedGetHash = null;\n    }\n    setOCGState({ state, preserveRB }) {\n        let operator;\n        for (const elem of state){\n            switch(elem){\n                case \"ON\":\n                case \"OFF\":\n                case \"Toggle\":\n                    operator = elem;\n                    continue;\n            }\n            const group = this.#groups.get(elem);\n            if (!group) {\n                continue;\n            }\n            switch(operator){\n                case \"ON\":\n                    this.setVisibility(elem, true, preserveRB);\n                    break;\n                case \"OFF\":\n                    this.setVisibility(elem, false, preserveRB);\n                    break;\n                case \"Toggle\":\n                    this.setVisibility(elem, !group.visible, preserveRB);\n                    break;\n            }\n        }\n        this.#cachedGetHash = null;\n    }\n    get hasInitialVisibility() {\n        return this.#initialHash === null || this.getHash() === this.#initialHash;\n    }\n    getOrder() {\n        if (!this.#groups.size) {\n            return null;\n        }\n        if (this.#order) {\n            return this.#order.slice();\n        }\n        return [\n            ...this.#groups.keys()\n        ];\n    }\n    getGroup(id) {\n        return this.#groups.get(id) || null;\n    }\n    getHash() {\n        if (this.#cachedGetHash !== null) {\n            return this.#cachedGetHash;\n        }\n        const hash = new MurmurHash3_64();\n        for (const [id, group] of this.#groups){\n            hash.update(`${id}:${group.visible}`);\n        }\n        return this.#cachedGetHash = hash.hexdigest();\n    }\n    [Symbol.iterator]() {\n        return this.#groups.entries();\n    }\n}\n; // ./src/display/transport_stream.js\nclass PDFDataTransportStream {\n    constructor(pdfDataRangeTransport, { disableRange = false, disableStream = false }){\n        assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n        const { length, initialData, progressiveDone, contentDispositionFilename } = pdfDataRangeTransport;\n        this._queuedChunks = [];\n        this._progressiveDone = progressiveDone;\n        this._contentDispositionFilename = contentDispositionFilename;\n        if (initialData?.length > 0) {\n            const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n            this._queuedChunks.push(buffer);\n        }\n        this._pdfDataRangeTransport = pdfDataRangeTransport;\n        this._isStreamingSupported = !disableStream;\n        this._isRangeSupported = !disableRange;\n        this._contentLength = length;\n        this._fullRequestReader = null;\n        this._rangeReaders = [];\n        pdfDataRangeTransport.addRangeListener((begin, chunk)=>{\n            this._onReceiveData({\n                begin,\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressListener((loaded, total)=>{\n            this._onProgress({\n                loaded,\n                total\n            });\n        });\n        pdfDataRangeTransport.addProgressiveReadListener((chunk)=>{\n            this._onReceiveData({\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressiveDoneListener(()=>{\n            this._onProgressiveDone();\n        });\n        pdfDataRangeTransport.transportReady();\n    }\n    _onReceiveData({ begin, chunk }) {\n        const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n        if (begin === undefined) {\n            if (this._fullRequestReader) {\n                this._fullRequestReader._enqueue(buffer);\n            } else {\n                this._queuedChunks.push(buffer);\n            }\n        } else {\n            const found = this._rangeReaders.some(function(rangeReader) {\n                if (rangeReader._begin !== begin) {\n                    return false;\n                }\n                rangeReader._enqueue(buffer);\n                return true;\n            });\n            assert(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n        }\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    _onProgress(evt) {\n        if (evt.total === undefined) {\n            this._rangeReaders[0]?.onProgress?.({\n                loaded: evt.loaded\n            });\n        } else {\n            this._fullRequestReader?.onProgress?.({\n                loaded: evt.loaded,\n                total: evt.total\n            });\n        }\n    }\n    _onProgressiveDone() {\n        this._fullRequestReader?.progressiveDone();\n        this._progressiveDone = true;\n    }\n    _removeRangeReader(reader) {\n        const i = this._rangeReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n        const queuedChunks = this._queuedChunks;\n        this._queuedChunks = null;\n        return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n        this._pdfDataRangeTransport.requestDataRange(begin, end);\n        this._rangeReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeReaders.slice(0)){\n            reader.cancel(reason);\n        }\n        this._pdfDataRangeTransport.abort();\n    }\n}\nclass PDFDataTransportStreamReader {\n    constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null){\n        this._stream = stream;\n        this._done = progressiveDone || false;\n        this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;\n        this._queuedChunks = queuedChunks || [];\n        this._loaded = 0;\n        for (const chunk of this._queuedChunks){\n            this._loaded += chunk.byteLength;\n        }\n        this._requests = [];\n        this._headersReady = Promise.resolve();\n        stream._fullRequestReader = this;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunks.push(chunk);\n        }\n        this._loaded += chunk.byteLength;\n    }\n    get headersReady() {\n        return this._headersReady;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._stream._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._stream._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._stream._contentLength;\n    }\n    async read() {\n        if (this._queuedChunks.length > 0) {\n            const chunk = this._queuedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    progressiveDone() {\n        if (this._done) {\n            return;\n        }\n        this._done = true;\n    }\n}\nclass PDFDataTransportStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._begin = begin;\n        this._end = end;\n        this._queuedChunk = null;\n        this._requests = [];\n        this._done = false;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length === 0) {\n            this._queuedChunk = chunk;\n        } else {\n            const requestsCapability = this._requests.shift();\n            requestsCapability.resolve({\n                value: chunk,\n                done: false\n            });\n            for (const requestCapability of this._requests){\n                requestCapability.resolve({\n                    value: undefined,\n                    done: true\n                });\n            }\n            this._requests.length = 0;\n        }\n        this._done = true;\n        this._stream._removeRangeReader(this);\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._queuedChunk) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._stream._removeRangeReader(this);\n    }\n}\n; // ./src/display/content_disposition.js\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n    let needsEncodingFixup = true;\n    let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = unescape(filename);\n        filename = rfc5987decode(filename);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    tmp = rfc2231getparam(contentDisposition);\n    if (tmp) {\n        const filename = rfc2047decode(tmp);\n        return fixupEncoding(filename);\n    }\n    tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    function toParamRegExp(attributePattern, flags) {\n        return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n    }\n    function textdecode(encoding, value) {\n        if (encoding) {\n            if (!/^[\\x00-\\xFF]+$/.test(value)) {\n                return value;\n            }\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(value);\n                value = decoder.decode(buffer);\n                needsEncodingFixup = false;\n            } catch  {}\n        }\n        return value;\n    }\n    function fixupEncoding(value) {\n        if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n            value = textdecode(\"utf-8\", value);\n            if (needsEncodingFixup) {\n                value = textdecode(\"iso-8859-1\", value);\n            }\n        }\n        return value;\n    }\n    function rfc2231getparam(contentDispositionStr) {\n        const matches = [];\n        let match;\n        const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n        while((match = iter.exec(contentDispositionStr)) !== null){\n            let [, n, quot, part] = match;\n            n = parseInt(n, 10);\n            if (n in matches) {\n                if (n === 0) {\n                    break;\n                }\n                continue;\n            }\n            matches[n] = [\n                quot,\n                part\n            ];\n        }\n        const parts = [];\n        for(let n = 0; n < matches.length; ++n){\n            if (!(n in matches)) {\n                break;\n            }\n            let [quot, part] = matches[n];\n            part = rfc2616unquote(part);\n            if (quot) {\n                part = unescape(part);\n                if (n === 0) {\n                    part = rfc5987decode(part);\n                }\n            }\n            parts.push(part);\n        }\n        return parts.join(\"\");\n    }\n    function rfc2616unquote(value) {\n        if (value.startsWith('\"')) {\n            const parts = value.slice(1).split('\\\\\"');\n            for(let i = 0; i < parts.length; ++i){\n                const quotindex = parts[i].indexOf('\"');\n                if (quotindex !== -1) {\n                    parts[i] = parts[i].slice(0, quotindex);\n                    parts.length = i + 1;\n                }\n                parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n            }\n            value = parts.join('\"');\n        }\n        return value;\n    }\n    function rfc5987decode(extvalue) {\n        const encodingend = extvalue.indexOf(\"'\");\n        if (encodingend === -1) {\n            return extvalue;\n        }\n        const encoding = extvalue.slice(0, encodingend);\n        const langvalue = extvalue.slice(encodingend + 1);\n        const value = langvalue.replace(/^[^']*'/, \"\");\n        return textdecode(encoding, value);\n    }\n    function rfc2047decode(value) {\n        if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n            return value;\n        }\n        return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function(matches, charset, encoding, text) {\n            if (encoding === \"q\" || encoding === \"Q\") {\n                text = text.replaceAll(\"_\", \" \");\n                text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {\n                    return String.fromCharCode(parseInt(hex, 16));\n                });\n                return textdecode(charset, text);\n            }\n            try {\n                text = atob(text);\n            } catch  {}\n            return textdecode(charset, text);\n        });\n    }\n    return \"\";\n}\n; // ./src/display/network_utils.js\nfunction createHeaders(isHttp, httpHeaders) {\n    const headers = new Headers();\n    if (!isHttp || !httpHeaders || typeof httpHeaders !== \"object\") {\n        return headers;\n    }\n    for(const key in httpHeaders){\n        const val = httpHeaders[key];\n        if (val !== undefined) {\n            headers.append(key, val);\n        }\n    }\n    return headers;\n}\nfunction getResponseOrigin(url) {\n    return URL.parse(url)?.origin ?? null;\n}\nfunction validateRangeRequestCapabilities({ responseHeaders, isHttp, rangeChunkSize, disableRange }) {\n    const returnValues = {\n        allowRangeRequests: false,\n        suggestedLength: undefined\n    };\n    const length = parseInt(responseHeaders.get(\"Content-Length\"), 10);\n    if (!Number.isInteger(length)) {\n        return returnValues;\n    }\n    returnValues.suggestedLength = length;\n    if (length <= 2 * rangeChunkSize) {\n        return returnValues;\n    }\n    if (disableRange || !isHttp) {\n        return returnValues;\n    }\n    if (responseHeaders.get(\"Accept-Ranges\") !== \"bytes\") {\n        return returnValues;\n    }\n    const contentEncoding = responseHeaders.get(\"Content-Encoding\") || \"identity\";\n    if (contentEncoding !== \"identity\") {\n        return returnValues;\n    }\n    returnValues.allowRangeRequests = true;\n    return returnValues;\n}\nfunction extractFilenameFromHeader(responseHeaders) {\n    const contentDisposition = responseHeaders.get(\"Content-Disposition\");\n    if (contentDisposition) {\n        let filename = getFilenameFromContentDispositionHeader(contentDisposition);\n        if (filename.includes(\"%\")) {\n            try {\n                filename = decodeURIComponent(filename);\n            } catch  {}\n        }\n        if (isPdfFile(filename)) {\n            return filename;\n        }\n    }\n    return null;\n}\nfunction createResponseError(status, url) {\n    return new ResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status, status === 404 || status === 0 && url.startsWith(\"file:\"));\n}\nfunction validateResponseStatus(status) {\n    return status === 200 || status === 206;\n}\n; // ./src/display/fetch_stream.js\nfunction createFetchOptions(headers, withCredentials, abortController) {\n    return {\n        method: \"GET\",\n        headers,\n        signal: abortController.signal,\n        mode: \"cors\",\n        credentials: withCredentials ? \"include\" : \"same-origin\",\n        redirect: \"follow\"\n    };\n}\nfunction getArrayBuffer(val) {\n    if (val instanceof Uint8Array) {\n        return val.buffer;\n    }\n    if (val instanceof ArrayBuffer) {\n        return val;\n    }\n    warn(`getArrayBuffer - unexpected data format: ${val}`);\n    return new Uint8Array(val).buffer;\n}\nclass PDFFetchStream {\n    constructor(source){\n        this._responseOrigin = null;\n        this.source = source;\n        this.isHttp = /^https?:/i.test(source.url);\n        this.headers = createHeaders(this.isHttp, source.httpHeaders);\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFFetchStreamReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFFetchStreamRangeReader(this, begin, end);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFFetchStreamReader {\n    constructor(stream){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        this._filename = null;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._contentLength = source.length;\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._abortController = new AbortController();\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        const headers = new Headers(stream.headers);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            stream._responseOrigin = getResponseOrigin(response.url);\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseError(response.status, url);\n            }\n            this._reader = response.body.getReader();\n            this._headersCapability.resolve();\n            const responseHeaders = response.headers;\n            const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n                responseHeaders,\n                isHttp: stream.isHttp,\n                rangeChunkSize: this._rangeChunkSize,\n                disableRange: this._disableRange\n            });\n            this._isRangeSupported = allowRangeRequests;\n            this._contentLength = suggestedLength || this._contentLength;\n            this._filename = extractFilenameFromHeader(responseHeaders);\n            if (!this._isStreamingSupported && this._isRangeSupported) {\n                this.cancel(new AbortException(\"Streaming is disabled.\"));\n            }\n        }).catch(this._headersCapability.reject);\n        this.onProgress = null;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        const { value, done } = await this._reader.read();\n        if (done) {\n            return {\n                value,\n                done\n            };\n        }\n        this._loaded += value.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        return {\n            value: getArrayBuffer(value),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\nclass PDFFetchStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._readCapability = Promise.withResolvers();\n        this._isStreamingSupported = !source.disableStream;\n        this._abortController = new AbortController();\n        const headers = new Headers(stream.headers);\n        headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            const responseOrigin = getResponseOrigin(response.url);\n            if (responseOrigin !== stream._responseOrigin) {\n                throw new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${stream._responseOrigin}\".`);\n            }\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseError(response.status, url);\n            }\n            this._readCapability.resolve();\n            this._reader = response.body.getReader();\n        }).catch(this._readCapability.reject);\n        this.onProgress = null;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        const { value, done } = await this._reader.read();\n        if (done) {\n            return {\n                value,\n                done\n            };\n        }\n        this._loaded += value.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        return {\n            value: getArrayBuffer(value),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\n; // ./src/display/network.js\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\nfunction network_getArrayBuffer(xhr) {\n    const data = xhr.response;\n    if (typeof data !== \"string\") {\n        return data;\n    }\n    return stringToBytes(data).buffer;\n}\nclass NetworkManager {\n    constructor({ url, httpHeaders, withCredentials }){\n        this._responseOrigin = null;\n        this.url = url;\n        this.isHttp = /^https?:/i.test(url);\n        this.headers = createHeaders(this.isHttp, httpHeaders);\n        this.withCredentials = withCredentials || false;\n        this.currXhrId = 0;\n        this.pendingRequests = Object.create(null);\n    }\n    request(args) {\n        const xhr = new XMLHttpRequest();\n        const xhrId = this.currXhrId++;\n        const pendingRequest = this.pendingRequests[xhrId] = {\n            xhr\n        };\n        xhr.open(\"GET\", this.url);\n        xhr.withCredentials = this.withCredentials;\n        for (const [key, val] of this.headers){\n            xhr.setRequestHeader(key, val);\n        }\n        if (this.isHttp && \"begin\" in args && \"end\" in args) {\n            xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n            pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n        } else {\n            pendingRequest.expectedStatus = OK_RESPONSE;\n        }\n        xhr.responseType = \"arraybuffer\";\n        assert(args.onError, \"Expected `onError` callback to be provided.\");\n        xhr.onerror = ()=>{\n            args.onError(xhr.status);\n        };\n        xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n        xhr.onprogress = this.onProgress.bind(this, xhrId);\n        pendingRequest.onHeadersReceived = args.onHeadersReceived;\n        pendingRequest.onDone = args.onDone;\n        pendingRequest.onError = args.onError;\n        pendingRequest.onProgress = args.onProgress;\n        xhr.send(null);\n        return xhrId;\n    }\n    onProgress(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        pendingRequest.onProgress?.(evt);\n    }\n    onStateChange(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        const xhr = pendingRequest.xhr;\n        if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n            pendingRequest.onHeadersReceived();\n            delete pendingRequest.onHeadersReceived;\n        }\n        if (xhr.readyState !== 4) {\n            return;\n        }\n        if (!(xhrId in this.pendingRequests)) {\n            return;\n        }\n        delete this.pendingRequests[xhrId];\n        if (xhr.status === 0 && this.isHttp) {\n            pendingRequest.onError(xhr.status);\n            return;\n        }\n        const xhrStatus = xhr.status || OK_RESPONSE;\n        const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n        if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n            pendingRequest.onError(xhr.status);\n            return;\n        }\n        const chunk = network_getArrayBuffer(xhr);\n        if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n            const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n            const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n            if (matches) {\n                pendingRequest.onDone({\n                    begin: parseInt(matches[1], 10),\n                    chunk\n                });\n            } else {\n                warn(`Missing or invalid \"Content-Range\" header.`);\n                pendingRequest.onError(0);\n            }\n        } else if (chunk) {\n            pendingRequest.onDone({\n                begin: 0,\n                chunk\n            });\n        } else {\n            pendingRequest.onError(xhr.status);\n        }\n    }\n    getRequestXhr(xhrId) {\n        return this.pendingRequests[xhrId].xhr;\n    }\n    isPendingRequest(xhrId) {\n        return xhrId in this.pendingRequests;\n    }\n    abortRequest(xhrId) {\n        const xhr = this.pendingRequests[xhrId].xhr;\n        delete this.pendingRequests[xhrId];\n        xhr.abort();\n    }\n}\nclass PDFNetworkStream {\n    constructor(source){\n        this._source = source;\n        this._manager = new NetworkManager(source);\n        this._rangeChunkSize = source.rangeChunkSize;\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    _onRangeRequestReaderClosed(reader) {\n        const i = this._rangeRequestReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeRequestReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n        reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNetworkStreamFullRequestReader {\n    constructor(manager, source){\n        this._manager = manager;\n        this._url = source.url;\n        this._fullRequestId = manager.request({\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        });\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._contentLength = source.length;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = false;\n        this._isRangeSupported = false;\n        this._cachedChunks = [];\n        this._requests = [];\n        this._done = false;\n        this._storedError = undefined;\n        this._filename = null;\n        this.onProgress = null;\n    }\n    _onHeadersReceived() {\n        const fullRequestXhrId = this._fullRequestId;\n        const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n        this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);\n        const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();\n        const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\\S ]+$/, \"\").split(/[\\r\\n]+/).map((x)=>{\n            const [key, ...val] = x.split(\": \");\n            return [\n                key,\n                val.join(\": \")\n            ];\n        }) : []);\n        const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n            responseHeaders,\n            isHttp: this._manager.isHttp,\n            rangeChunkSize: this._rangeChunkSize,\n            disableRange: this._disableRange\n        });\n        if (allowRangeRequests) {\n            this._isRangeSupported = true;\n        }\n        this._contentLength = suggestedLength || this._contentLength;\n        this._filename = extractFilenameFromHeader(responseHeaders);\n        if (this._isRangeSupported) {\n            this._manager.abortRequest(fullRequestXhrId);\n        }\n        this._headersCapability.resolve();\n    }\n    _onDone(data) {\n        if (data) {\n            if (this._requests.length > 0) {\n                const requestCapability = this._requests.shift();\n                requestCapability.resolve({\n                    value: data.chunk,\n                    done: false\n                });\n            } else {\n                this._cachedChunks.push(data.chunk);\n            }\n        }\n        this._done = true;\n        if (this._cachedChunks.length > 0) {\n            return;\n        }\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    _onError(status) {\n        this._storedError = createResponseError(status, this._url);\n        this._headersCapability.reject(this._storedError);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._cachedChunks.length = 0;\n    }\n    _onProgress(evt) {\n        this.onProgress?.({\n            loaded: evt.loaded,\n            total: evt.lengthComputable ? evt.total : this._contentLength\n        });\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._cachedChunks.length > 0) {\n            const chunk = this._cachedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        this._headersCapability.reject(reason);\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._fullRequestId)) {\n            this._manager.abortRequest(this._fullRequestId);\n        }\n        this._fullRequestReader = null;\n    }\n}\nclass PDFNetworkStreamRangeRequestReader {\n    constructor(manager, begin, end){\n        this._manager = manager;\n        this._url = manager.url;\n        this._requestId = manager.request({\n            begin,\n            end,\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        });\n        this._requests = [];\n        this._queuedChunk = null;\n        this._done = false;\n        this._storedError = undefined;\n        this.onProgress = null;\n        this.onClosed = null;\n    }\n    _onHeadersReceived() {\n        const responseOrigin = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);\n        if (responseOrigin !== this._manager._responseOrigin) {\n            this._storedError = new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${this._manager._responseOrigin}\".`);\n            this._onError(0);\n        }\n    }\n    _close() {\n        this.onClosed?.(this);\n    }\n    _onDone(data) {\n        const chunk = data.chunk;\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunk = chunk;\n        }\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._close();\n    }\n    _onError(status) {\n        this._storedError ??= createResponseError(status, this._url);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._queuedChunk = null;\n    }\n    _onProgress(evt) {\n        if (!this.isStreamingSupported) {\n            this.onProgress?.({\n                loaded: evt.loaded\n            });\n        }\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._queuedChunk !== null) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._requestId)) {\n            this._manager.abortRequest(this._requestId);\n        }\n        this._close();\n    }\n}\n; // ./src/display/node_stream.js\nconst urlRegex = /^[a-z][a-z0-9\\-+.]+:/i;\nfunction parseUrlOrPath(sourceUrl) {\n    if (urlRegex.test(sourceUrl)) {\n        return new URL(sourceUrl);\n    }\n    const url = process.getBuiltinModule(\"url\");\n    return new URL(url.pathToFileURL(sourceUrl));\n}\nclass PDFNodeStream {\n    constructor(source){\n        this.source = source;\n        this.url = parseUrlOrPath(source.url);\n        assert(this.url.protocol === \"file:\", \"PDFNodeStream only supports file:// URLs.\");\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNodeStreamFsFullReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(start, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);\n        this._rangeRequestReaders.push(rangeReader);\n        return rangeReader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNodeStreamFsFullReader {\n    constructor(stream){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        const source = stream.source;\n        this._contentLength = source.length;\n        this._loaded = 0;\n        this._filename = null;\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        this._headersCapability = Promise.withResolvers();\n        const fs = process.getBuiltinModule(\"fs\");\n        fs.promises.lstat(this._url).then((stat)=>{\n            this._contentLength = stat.size;\n            this._setReadableStream(fs.createReadStream(this._url));\n            this._headersCapability.resolve();\n        }, (error)=>{\n            if (error.code === \"ENOENT\") {\n                error = createResponseError(0, this._url.href);\n            }\n            this._storedError = error;\n            this._headersCapability.reject(error);\n        });\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (!this._isStreamingSupported && this._isRangeSupported) {\n            this._error(new AbortException(\"streaming is disabled\"));\n        }\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\nclass PDFNodeStreamFsRangeReader {\n    constructor(stream, start, end){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        this._loaded = 0;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        const source = stream.source;\n        this._isStreamingSupported = !source.disableStream;\n        const fs = process.getBuiltinModule(\"fs\");\n        this._setReadableStream(fs.createReadStream(this._url, {\n            start,\n            end: end - 1\n        }));\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\n; // ./src/display/pdf_objects.js\nconst INITIAL_DATA = Symbol(\"INITIAL_DATA\");\nclass PDFObjects {\n    #objs;\n    #ensureObj(objId) {\n        return this.#objs[objId] ||= {\n            ...Promise.withResolvers(),\n            data: INITIAL_DATA\n        };\n    }\n    get(objId, callback = null) {\n        if (callback) {\n            const obj = this.#ensureObj(objId);\n            obj.promise.then(()=>callback(obj.data));\n            return null;\n        }\n        const obj = this.#objs[objId];\n        if (!obj || obj.data === INITIAL_DATA) {\n            throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n        }\n        return obj.data;\n    }\n    has(objId) {\n        const obj = this.#objs[objId];\n        return !!obj && obj.data !== INITIAL_DATA;\n    }\n    delete(objId) {\n        const obj = this.#objs[objId];\n        if (!obj || obj.data === INITIAL_DATA) {\n            return false;\n        }\n        delete this.#objs[objId];\n        return true;\n    }\n    resolve(objId, data = null) {\n        const obj = this.#ensureObj(objId);\n        obj.data = data;\n        obj.resolve();\n    }\n    clear() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            data?.bitmap?.close();\n        }\n        this.#objs = Object.create(null);\n    }\n    *[Symbol.iterator]() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            if (data === INITIAL_DATA) {\n                continue;\n            }\n            yield [\n                objId,\n                data\n            ];\n        }\n    }\n    constructor(){\n        this.#objs = Object.create(null);\n    }\n}\n; // ./src/display/text_layer.js\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nclass TextLayer {\n    #capability;\n    #container;\n    #disableProcessItems;\n    #fontInspectorEnabled;\n    #lang;\n    #layoutTextParams;\n    #pageHeight;\n    #pageWidth;\n    #reader;\n    #rootContainer;\n    #rotation;\n    #scale;\n    #styleCache;\n    #textContentItemsStr;\n    #textContentSource;\n    #textDivs;\n    #textDivProperties;\n    #transform;\n    static #ascentCache = new Map();\n    static #canvasContexts = new Map();\n    static #canvasCtxFonts = new WeakMap();\n    static #minFontSize = null;\n    static #pendingTextLayers = new Set();\n    constructor({ textContentSource, container, viewport }){\n        this.#capability = Promise.withResolvers();\n        this.#container = null;\n        this.#disableProcessItems = false;\n        this.#fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n        this.#lang = null;\n        this.#layoutTextParams = null;\n        this.#pageHeight = 0;\n        this.#pageWidth = 0;\n        this.#reader = null;\n        this.#rootContainer = null;\n        this.#rotation = 0;\n        this.#scale = 0;\n        this.#styleCache = Object.create(null);\n        this.#textContentItemsStr = [];\n        this.#textContentSource = null;\n        this.#textDivs = [];\n        this.#textDivProperties = new WeakMap();\n        this.#transform = null;\n        if (textContentSource instanceof ReadableStream) {\n            this.#textContentSource = textContentSource;\n        } else if (typeof textContentSource === \"object\") {\n            this.#textContentSource = new ReadableStream({\n                start (controller) {\n                    controller.enqueue(textContentSource);\n                    controller.close();\n                }\n            });\n        } else {\n            throw new Error('No \"textContentSource\" parameter specified.');\n        }\n        this.#container = this.#rootContainer = container;\n        this.#scale = viewport.scale * OutputScale.pixelRatio;\n        this.#rotation = viewport.rotation;\n        this.#layoutTextParams = {\n            div: null,\n            properties: null,\n            ctx: null\n        };\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        this.#transform = [\n            1,\n            0,\n            0,\n            -1,\n            -pageX,\n            pageY + pageHeight\n        ];\n        this.#pageWidth = pageWidth;\n        this.#pageHeight = pageHeight;\n        TextLayer.#ensureMinFontSizeComputed();\n        setLayerDimensions(container, viewport);\n        this.#capability.promise.finally(()=>{\n            TextLayer.#pendingTextLayers.delete(this);\n            this.#layoutTextParams = null;\n            this.#styleCache = null;\n        }).catch(()=>{});\n    }\n    static get fontFamilyMap() {\n        const { isWindows, isFirefox } = util_FeatureTest.platform;\n        return shadow(this, \"fontFamilyMap\", new Map([\n            [\n                \"sans-serif\",\n                `${isWindows && isFirefox ? \"Calibri, \" : \"\"}sans-serif`\n            ],\n            [\n                \"monospace\",\n                `${isWindows && isFirefox ? \"Lucida Console, \" : \"\"}monospace`\n            ]\n        ]));\n    }\n    render() {\n        const pump = ()=>{\n            this.#reader.read().then(({ value, done })=>{\n                if (done) {\n                    this.#capability.resolve();\n                    return;\n                }\n                this.#lang ??= value.lang;\n                Object.assign(this.#styleCache, value.styles);\n                this.#processItems(value.items);\n                pump();\n            }, this.#capability.reject);\n        };\n        this.#reader = this.#textContentSource.getReader();\n        TextLayer.#pendingTextLayers.add(this);\n        pump();\n        return this.#capability.promise;\n    }\n    update({ viewport, onBefore = null }) {\n        const scale = viewport.scale * OutputScale.pixelRatio;\n        const rotation = viewport.rotation;\n        if (rotation !== this.#rotation) {\n            onBefore?.();\n            this.#rotation = rotation;\n            setLayerDimensions(this.#rootContainer, {\n                rotation\n            });\n        }\n        if (scale !== this.#scale) {\n            onBefore?.();\n            this.#scale = scale;\n            const params = {\n                div: null,\n                properties: null,\n                ctx: TextLayer.#getCtx(this.#lang)\n            };\n            for (const div of this.#textDivs){\n                params.properties = this.#textDivProperties.get(div);\n                params.div = div;\n                this.#layout(params);\n            }\n        }\n    }\n    cancel() {\n        const abortEx = new AbortException(\"TextLayer task cancelled.\");\n        this.#reader?.cancel(abortEx).catch(()=>{});\n        this.#reader = null;\n        this.#capability.reject(abortEx);\n    }\n    get textDivs() {\n        return this.#textDivs;\n    }\n    get textContentItemsStr() {\n        return this.#textContentItemsStr;\n    }\n    #processItems(items) {\n        if (this.#disableProcessItems) {\n            return;\n        }\n        this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);\n        const textDivs = this.#textDivs, textContentItemsStr = this.#textContentItemsStr;\n        for (const item of items){\n            if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {\n                warn(\"Ignoring additional textDivs for performance reasons.\");\n                this.#disableProcessItems = true;\n                return;\n            }\n            if (item.str === undefined) {\n                if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n                    const parent = this.#container;\n                    this.#container = document.createElement(\"span\");\n                    this.#container.classList.add(\"markedContent\");\n                    if (item.id) {\n                        this.#container.setAttribute(\"id\", `${item.id}`);\n                    }\n                    parent.append(this.#container);\n                } else if (item.type === \"endMarkedContent\") {\n                    this.#container = this.#container.parentNode;\n                }\n                continue;\n            }\n            textContentItemsStr.push(item.str);\n            this.#appendText(item);\n        }\n    }\n    #appendText(geom) {\n        const textDiv = document.createElement(\"span\");\n        const textDivProperties = {\n            angle: 0,\n            canvasWidth: 0,\n            hasText: geom.str !== \"\",\n            hasEOL: geom.hasEOL,\n            fontSize: 0\n        };\n        this.#textDivs.push(textDiv);\n        const tx = Util.transform(this.#transform, geom.transform);\n        let angle = Math.atan2(tx[1], tx[0]);\n        const style = this.#styleCache[geom.fontName];\n        if (style.vertical) {\n            angle += Math.PI / 2;\n        }\n        let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;\n        fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n        const fontHeight = Math.hypot(tx[2], tx[3]);\n        const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, style, this.#lang);\n        let left, top;\n        if (angle === 0) {\n            left = tx[4];\n            top = tx[5] - fontAscent;\n        } else {\n            left = tx[4] + fontAscent * Math.sin(angle);\n            top = tx[5] - fontAscent * Math.cos(angle);\n        }\n        const scaleFactorStr = \"calc(var(--total-scale-factor) *\";\n        const divStyle = textDiv.style;\n        if (this.#container === this.#rootContainer) {\n            divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;\n            divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;\n        } else {\n            divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n            divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n        }\n        divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;\n        divStyle.fontFamily = fontFamily;\n        textDivProperties.fontSize = fontHeight;\n        textDiv.setAttribute(\"role\", \"presentation\");\n        textDiv.textContent = geom.str;\n        textDiv.dir = geom.dir;\n        if (this.#fontInspectorEnabled) {\n            textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;\n        }\n        if (angle !== 0) {\n            textDivProperties.angle = angle * (180 / Math.PI);\n        }\n        let shouldScaleText = false;\n        if (geom.str.length > 1) {\n            shouldScaleText = true;\n        } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n            const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);\n            if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n                shouldScaleText = true;\n            }\n        }\n        if (shouldScaleText) {\n            textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n        }\n        this.#textDivProperties.set(textDiv, textDivProperties);\n        this.#layoutTextParams.div = textDiv;\n        this.#layoutTextParams.properties = textDivProperties;\n        this.#layout(this.#layoutTextParams);\n        if (textDivProperties.hasText) {\n            this.#container.append(textDiv);\n        }\n        if (textDivProperties.hasEOL) {\n            const br = document.createElement(\"br\");\n            br.setAttribute(\"role\", \"presentation\");\n            this.#container.append(br);\n        }\n    }\n    #layout(params) {\n        const { div, properties, ctx } = params;\n        const { style } = div;\n        let transform = \"\";\n        if (TextLayer.#minFontSize > 1) {\n            transform = `scale(${1 / TextLayer.#minFontSize})`;\n        }\n        if (properties.canvasWidth !== 0 && properties.hasText) {\n            const { fontFamily } = style;\n            const { canvasWidth, fontSize } = properties;\n            TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);\n            const { width } = ctx.measureText(div.textContent);\n            if (width > 0) {\n                transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;\n            }\n        }\n        if (properties.angle !== 0) {\n            transform = `rotate(${properties.angle}deg) ${transform}`;\n        }\n        if (transform.length > 0) {\n            style.transform = transform;\n        }\n    }\n    static cleanup() {\n        if (this.#pendingTextLayers.size > 0) {\n            return;\n        }\n        this.#ascentCache.clear();\n        for (const { canvas } of this.#canvasContexts.values()){\n            canvas.remove();\n        }\n        this.#canvasContexts.clear();\n    }\n    static #getCtx(lang = null) {\n        let ctx = this.#canvasContexts.get(lang ||= \"\");\n        if (!ctx) {\n            const canvas = document.createElement(\"canvas\");\n            canvas.className = \"hiddenCanvasElement\";\n            canvas.lang = lang;\n            document.body.append(canvas);\n            ctx = canvas.getContext(\"2d\", {\n                alpha: false,\n                willReadFrequently: true\n            });\n            this.#canvasContexts.set(lang, ctx);\n            this.#canvasCtxFonts.set(ctx, {\n                size: 0,\n                family: \"\"\n            });\n        }\n        return ctx;\n    }\n    static #ensureCtxFont(ctx, size, family) {\n        const cached = this.#canvasCtxFonts.get(ctx);\n        if (size === cached.size && family === cached.family) {\n            return;\n        }\n        ctx.font = `${size}px ${family}`;\n        cached.size = size;\n        cached.family = family;\n    }\n    static #ensureMinFontSizeComputed() {\n        if (this.#minFontSize !== null) {\n            return;\n        }\n        const div = document.createElement(\"div\");\n        div.style.opacity = 0;\n        div.style.lineHeight = 1;\n        div.style.fontSize = \"1px\";\n        div.style.position = \"absolute\";\n        div.textContent = \"X\";\n        document.body.append(div);\n        this.#minFontSize = div.getBoundingClientRect().height;\n        div.remove();\n    }\n    static #getAscent(fontFamily, style, lang) {\n        const cachedAscent = this.#ascentCache.get(fontFamily);\n        if (cachedAscent) {\n            return cachedAscent;\n        }\n        const ctx = this.#getCtx(lang);\n        ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;\n        this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);\n        const metrics = ctx.measureText(\"\");\n        const ascent = metrics.fontBoundingBoxAscent;\n        const descent = Math.abs(metrics.fontBoundingBoxDescent);\n        ctx.canvas.width = ctx.canvas.height = 0;\n        let ratio = 0.8;\n        if (ascent) {\n            ratio = ascent / (ascent + descent);\n        } else {\n            if (util_FeatureTest.platform.isFirefox) {\n                warn(\"Enable the `dom.textMetrics.fontBoundingBox.enabled` preference \" + \"in `about:config` to improve TextLayer rendering.\");\n            }\n            if (style.ascent) {\n                ratio = style.ascent;\n            } else if (style.descent) {\n                ratio = 1 + style.descent;\n            }\n        }\n        this.#ascentCache.set(fontFamily, ratio);\n        return ratio;\n    }\n}\n; // ./src/display/xfa_text.js\nclass XfaText {\n    static textContent(xfa) {\n        const items = [];\n        const output = {\n            items,\n            styles: Object.create(null)\n        };\n        function walk(node) {\n            if (!node) {\n                return;\n            }\n            let str = null;\n            const name = node.name;\n            if (name === \"#text\") {\n                str = node.value;\n            } else if (!XfaText.shouldBuildText(name)) {\n                return;\n            } else if (node?.attributes?.textContent) {\n                str = node.attributes.textContent;\n            } else if (node.value) {\n                str = node.value;\n            }\n            if (str !== null) {\n                items.push({\n                    str\n                });\n            }\n            if (!node.children) {\n                return;\n            }\n            for (const child of node.children){\n                walk(child);\n            }\n        }\n        walk(xfa);\n        return output;\n    }\n    static shouldBuildText(name) {\n        return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n    }\n}\n; // ./src/display/api.js\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nfunction getDocument(src = {}) {\n    if (typeof src === \"string\" || src instanceof URL) {\n        src = {\n            url: src\n        };\n    } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {\n        src = {\n            data: src\n        };\n    }\n    const task = new PDFDocumentLoadingTask();\n    const { docId } = task;\n    const url = src.url ? getUrlProp(src.url) : null;\n    const data = src.data ? getDataProp(src.data) : null;\n    const httpHeaders = src.httpHeaders || null;\n    const withCredentials = src.withCredentials === true;\n    const password = src.password ?? null;\n    const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n    const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : 2 ** 16;\n    let worker = src.worker instanceof PDFWorker ? src.worker : null;\n    const verbosity = src.verbosity;\n    const docBaseUrl = typeof src.docBaseUrl === \"string\" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;\n    const cMapUrl = getFactoryUrlProp(src.cMapUrl);\n    const cMapPacked = src.cMapPacked !== false;\n    const CMapReaderFactory = src.CMapReaderFactory || (isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory);\n    const iccUrl = getFactoryUrlProp(src.iccUrl);\n    const standardFontDataUrl = getFactoryUrlProp(src.standardFontDataUrl);\n    const StandardFontDataFactory = src.StandardFontDataFactory || (isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory);\n    const wasmUrl = getFactoryUrlProp(src.wasmUrl);\n    const WasmFactory = src.WasmFactory || (isNodeJS ? NodeWasmFactory : DOMWasmFactory);\n    const ignoreErrors = src.stopAtErrors !== true;\n    const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n    const isEvalSupported = src.isEvalSupported !== false;\n    const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !isNodeJS;\n    const isImageDecoderSupported = typeof src.isImageDecoderSupported === \"boolean\" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);\n    const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n    const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : isNodeJS;\n    const fontExtraProperties = src.fontExtraProperties === true;\n    const enableXfa = src.enableXfa === true;\n    const ownerDocument = src.ownerDocument || globalThis.document;\n    const disableRange = src.disableRange === true;\n    const disableStream = src.disableStream === true;\n    const disableAutoFetch = src.disableAutoFetch === true;\n    const pdfBug = src.pdfBug === true;\n    const CanvasFactory = src.CanvasFactory || (isNodeJS ? NodeCanvasFactory : DOMCanvasFactory);\n    const FilterFactory = src.FilterFactory || (isNodeJS ? NodeFilterFactory : DOMFilterFactory);\n    const enableHWA = src.enableHWA === true;\n    const useWasm = src.useWasm !== false;\n    const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n    const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !isNodeJS && !disableFontFace;\n    const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : !!(CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && WasmFactory === DOMWasmFactory && cMapUrl && standardFontDataUrl && wasmUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI) && isValidFetchUrl(wasmUrl, document.baseURI));\n    const styleElement = null;\n    setVerbosityLevel(verbosity);\n    const transportFactory = {\n        canvasFactory: new CanvasFactory({\n            ownerDocument,\n            enableHWA\n        }),\n        filterFactory: new FilterFactory({\n            docId,\n            ownerDocument\n        }),\n        cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({\n            baseUrl: cMapUrl,\n            isCompressed: cMapPacked\n        }),\n        standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({\n            baseUrl: standardFontDataUrl\n        }),\n        wasmFactory: useWorkerFetch ? null : new WasmFactory({\n            baseUrl: wasmUrl\n        })\n    };\n    if (!worker) {\n        worker = PDFWorker.create({\n            verbosity,\n            port: GlobalWorkerOptions.workerPort\n        });\n        task._worker = worker;\n    }\n    const docParams = {\n        docId,\n        apiVersion: \"5.4.149\",\n        data,\n        password,\n        disableAutoFetch,\n        rangeChunkSize,\n        length,\n        docBaseUrl,\n        enableXfa,\n        evaluatorOptions: {\n            maxImageSize,\n            disableFontFace,\n            ignoreErrors,\n            isEvalSupported,\n            isOffscreenCanvasSupported,\n            isImageDecoderSupported,\n            canvasMaxAreaInBytes,\n            fontExtraProperties,\n            useSystemFonts,\n            useWasm,\n            useWorkerFetch,\n            cMapUrl,\n            iccUrl,\n            standardFontDataUrl,\n            wasmUrl\n        }\n    };\n    const transportParams = {\n        ownerDocument,\n        pdfBug,\n        styleElement,\n        loadingParams: {\n            disableAutoFetch,\n            enableXfa\n        }\n    };\n    worker.promise.then(function() {\n        if (task.destroyed) {\n            throw new Error(\"Loading aborted\");\n        }\n        if (worker.destroyed) {\n            throw new Error(\"Worker was destroyed\");\n        }\n        const workerIdPromise = worker.messageHandler.sendWithPromise(\"GetDocRequest\", docParams, data ? [\n            data.buffer\n        ] : null);\n        let networkStream;\n        if (rangeTransport) {\n            networkStream = new PDFDataTransportStream(rangeTransport, {\n                disableRange,\n                disableStream\n            });\n        } else if (!data) {\n            if (!url) {\n                throw new Error(\"getDocument - no `url` parameter provided.\");\n            }\n            const NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : isNodeJS ? PDFNodeStream : PDFNetworkStream;\n            networkStream = new NetworkStream({\n                url,\n                length,\n                httpHeaders,\n                withCredentials,\n                rangeChunkSize,\n                disableRange,\n                disableStream\n            });\n        }\n        return workerIdPromise.then((workerId)=>{\n            if (task.destroyed) {\n                throw new Error(\"Loading aborted\");\n            }\n            if (worker.destroyed) {\n                throw new Error(\"Worker was destroyed\");\n            }\n            const messageHandler = new MessageHandler(docId, workerId, worker.port);\n            const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory, enableHWA);\n            task._transport = transport;\n            messageHandler.send(\"Ready\", null);\n        });\n    }).catch(task._capability.reject);\n    return task;\n}\nclass PDFDocumentLoadingTask {\n    static #docId = 0;\n    get promise() {\n        return this._capability.promise;\n    }\n    async destroy() {\n        this.destroyed = true;\n        try {\n            if (this._worker?.port) {\n                this._worker._pendingDestroy = true;\n            }\n            await this._transport?.destroy();\n        } catch (ex) {\n            if (this._worker?.port) {\n                delete this._worker._pendingDestroy;\n            }\n            throw ex;\n        }\n        this._transport = null;\n        this._worker?.destroy();\n        this._worker = null;\n    }\n    async getData() {\n        return this._transport.getData();\n    }\n    constructor(){\n        this._capability = Promise.withResolvers();\n        this._transport = null;\n        this._worker = null;\n        this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n        this.destroyed = false;\n        this.onPassword = null;\n        this.onProgress = null;\n    }\n}\nclass PDFDataRangeTransport {\n    #capability;\n    #progressiveDoneListeners;\n    #progressiveReadListeners;\n    #progressListeners;\n    #rangeListeners;\n    constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null){\n        this.#capability = Promise.withResolvers();\n        this.#progressiveDoneListeners = [];\n        this.#progressiveReadListeners = [];\n        this.#progressListeners = [];\n        this.#rangeListeners = [];\n        this.length = length;\n        this.initialData = initialData;\n        this.progressiveDone = progressiveDone;\n        this.contentDispositionFilename = contentDispositionFilename;\n    }\n    addRangeListener(listener) {\n        this.#rangeListeners.push(listener);\n    }\n    addProgressListener(listener) {\n        this.#progressListeners.push(listener);\n    }\n    addProgressiveReadListener(listener) {\n        this.#progressiveReadListeners.push(listener);\n    }\n    addProgressiveDoneListener(listener) {\n        this.#progressiveDoneListeners.push(listener);\n    }\n    onDataRange(begin, chunk) {\n        for (const listener of this.#rangeListeners){\n            listener(begin, chunk);\n        }\n    }\n    onDataProgress(loaded, total) {\n        this.#capability.promise.then(()=>{\n            for (const listener of this.#progressListeners){\n                listener(loaded, total);\n            }\n        });\n    }\n    onDataProgressiveRead(chunk) {\n        this.#capability.promise.then(()=>{\n            for (const listener of this.#progressiveReadListeners){\n                listener(chunk);\n            }\n        });\n    }\n    onDataProgressiveDone() {\n        this.#capability.promise.then(()=>{\n            for (const listener of this.#progressiveDoneListeners){\n                listener();\n            }\n        });\n    }\n    transportReady() {\n        this.#capability.resolve();\n    }\n    requestDataRange(begin, end) {\n        unreachable(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n    }\n    abort() {}\n}\nclass PDFDocumentProxy {\n    constructor(pdfInfo, transport){\n        this._pdfInfo = pdfInfo;\n        this._transport = transport;\n    }\n    get annotationStorage() {\n        return this._transport.annotationStorage;\n    }\n    get canvasFactory() {\n        return this._transport.canvasFactory;\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get numPages() {\n        return this._pdfInfo.numPages;\n    }\n    get fingerprints() {\n        return this._pdfInfo.fingerprints;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    get allXfaHtml() {\n        return this._transport._htmlForXfa;\n    }\n    getPage(pageNumber) {\n        return this._transport.getPage(pageNumber);\n    }\n    getPageIndex(ref) {\n        return this._transport.getPageIndex(ref);\n    }\n    getDestinations() {\n        return this._transport.getDestinations();\n    }\n    getDestination(id) {\n        return this._transport.getDestination(id);\n    }\n    getPageLabels() {\n        return this._transport.getPageLabels();\n    }\n    getPageLayout() {\n        return this._transport.getPageLayout();\n    }\n    getPageMode() {\n        return this._transport.getPageMode();\n    }\n    getViewerPreferences() {\n        return this._transport.getViewerPreferences();\n    }\n    getOpenAction() {\n        return this._transport.getOpenAction();\n    }\n    getAttachments() {\n        return this._transport.getAttachments();\n    }\n    getAnnotationsByType(types, pageIndexesToSkip) {\n        return this._transport.getAnnotationsByType(types, pageIndexesToSkip);\n    }\n    getJSActions() {\n        return this._transport.getDocJSActions();\n    }\n    getOutline() {\n        return this._transport.getOutline();\n    }\n    getOptionalContentConfig({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getOptionalContentConfig(renderingIntent);\n    }\n    getPermissions() {\n        return this._transport.getPermissions();\n    }\n    getMetadata() {\n        return this._transport.getMetadata();\n    }\n    getMarkInfo() {\n        return this._transport.getMarkInfo();\n    }\n    getData() {\n        return this._transport.getData();\n    }\n    saveDocument() {\n        return this._transport.saveDocument();\n    }\n    getDownloadInfo() {\n        return this._transport.downloadInfoCapability.promise;\n    }\n    cleanup(keepLoadedFonts = false) {\n        return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n    }\n    destroy() {\n        return this.loadingTask.destroy();\n    }\n    cachedPageNumber(ref) {\n        return this._transport.cachedPageNumber(ref);\n    }\n    get loadingParams() {\n        return this._transport.loadingParams;\n    }\n    get loadingTask() {\n        return this._transport.loadingTask;\n    }\n    getFieldObjects() {\n        return this._transport.getFieldObjects();\n    }\n    hasJSActions() {\n        return this._transport.hasJSActions();\n    }\n    getCalculationOrderIds() {\n        return this._transport.getCalculationOrderIds();\n    }\n}\nclass PDFPageProxy {\n    #pendingCleanup;\n    constructor(pageIndex, pageInfo, transport, pdfBug = false){\n        this.#pendingCleanup = false;\n        this._pageIndex = pageIndex;\n        this._pageInfo = pageInfo;\n        this._transport = transport;\n        this._stats = pdfBug ? new StatTimer() : null;\n        this._pdfBug = pdfBug;\n        this.commonObjs = transport.commonObjs;\n        this.objs = new PDFObjects();\n        this._intentStates = new Map();\n        this.destroyed = false;\n        this.recordedGroups = null;\n    }\n    get pageNumber() {\n        return this._pageIndex + 1;\n    }\n    get rotate() {\n        return this._pageInfo.rotate;\n    }\n    get ref() {\n        return this._pageInfo.ref;\n    }\n    get userUnit() {\n        return this._pageInfo.userUnit;\n    }\n    get view() {\n        return this._pageInfo.view;\n    }\n    getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.view,\n            userUnit: this.userUnit,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    getAnnotations({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getAnnotations(this._pageIndex, renderingIntent);\n    }\n    getJSActions() {\n        return this._transport.getPageJSActions(this._pageIndex);\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    async getXfa() {\n        return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n    }\n    render({ canvasContext, canvas = canvasContext.canvas, viewport, intent = \"display\", annotationMode = AnnotationMode.ENABLE, transform = null, background = null, optionalContentConfigPromise = null, annotationCanvasMap = null, pageColors = null, printAnnotationStorage = null, isEditing = false, recordOperations = false, filteredOperationIndexes = null }) {\n        this._stats?.time(\"Overall\");\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);\n        const { renderingIntent, cacheKey } = intentArgs;\n        this.#pendingCleanup = false;\n        optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);\n        let intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(cacheKey, intentState);\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        if (!intentState.displayReadyCapability) {\n            intentState.displayReadyCapability = Promise.withResolvers();\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        const shouldRecordOperations = !this.recordedGroups && (recordOperations || this._pdfBug && globalThis.StepperManager?.enabled);\n        const complete = (error)=>{\n            intentState.renderTasks.delete(internalRenderTask);\n            if (shouldRecordOperations) {\n                const recordedGroups = internalRenderTask.gfx?.dependencyTracker.take();\n                if (recordedGroups) {\n                    internalRenderTask.stepper?.setOperatorGroups(recordedGroups);\n                    if (recordOperations) {\n                        this.recordedGroups = recordedGroups;\n                    }\n                } else if (recordOperations) {\n                    this.recordedGroups = [];\n                }\n            }\n            if (intentPrint) {\n                this.#pendingCleanup = true;\n            }\n            this.#tryCleanup();\n            if (error) {\n                internalRenderTask.capability.reject(error);\n                this._abortOperatorList({\n                    intentState,\n                    reason: error instanceof Error ? error : new Error(error)\n                });\n            } else {\n                internalRenderTask.capability.resolve();\n            }\n            if (this._stats) {\n                this._stats.timeEnd(\"Rendering\");\n                this._stats.timeEnd(\"Overall\");\n                if (globalThis.Stats?.enabled) {\n                    globalThis.Stats.add(this.pageNumber, this._stats);\n                }\n            }\n        };\n        const internalRenderTask = new InternalRenderTask({\n            callback: complete,\n            params: {\n                canvas,\n                canvasContext,\n                dependencyTracker: shouldRecordOperations ? new CanvasDependencyTracker(canvas) : null,\n                viewport,\n                transform,\n                background\n            },\n            objs: this.objs,\n            commonObjs: this.commonObjs,\n            annotationCanvasMap,\n            operatorList: intentState.operatorList,\n            pageIndex: this._pageIndex,\n            canvasFactory: this._transport.canvasFactory,\n            filterFactory: this._transport.filterFactory,\n            useRequestAnimationFrame: !intentPrint,\n            pdfBug: this._pdfBug,\n            pageColors,\n            enableHWA: this._transport.enableHWA,\n            filteredOperationIndexes\n        });\n        (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n        const renderTask = internalRenderTask.task;\n        Promise.all([\n            intentState.displayReadyCapability.promise,\n            optionalContentConfigPromise\n        ]).then(([transparency, optionalContentConfig])=>{\n            if (this.destroyed) {\n                complete();\n                return;\n            }\n            this._stats?.time(\"Rendering\");\n            if (!(optionalContentConfig.renderingIntent & renderingIntent)) {\n                throw new Error(\"Must use the same `intent`-argument when calling the `PDFPageProxy.render` \" + \"and `PDFDocumentProxy.getOptionalContentConfig` methods.\");\n            }\n            internalRenderTask.initializeGraphics({\n                transparency,\n                optionalContentConfig\n            });\n            internalRenderTask.operatorListChanged();\n        }).catch(complete);\n        return renderTask;\n    }\n    getOperatorList({ intent = \"display\", annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false } = {}) {\n        function operatorListChanged() {\n            if (intentState.operatorList.lastChunk) {\n                intentState.opListReadCapability.resolve(intentState.operatorList);\n                intentState.renderTasks.delete(opListTask);\n            }\n        }\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);\n        let intentState = this._intentStates.get(intentArgs.cacheKey);\n        if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(intentArgs.cacheKey, intentState);\n        }\n        let opListTask;\n        if (!intentState.opListReadCapability) {\n            opListTask = Object.create(null);\n            opListTask.operatorListChanged = operatorListChanged;\n            intentState.opListReadCapability = Promise.withResolvers();\n            (intentState.renderTasks ||= new Set()).add(opListTask);\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        return intentState.opListReadCapability.promise;\n    }\n    streamTextContent({ includeMarkedContent = false, disableNormalization = false } = {}) {\n        const TEXT_CONTENT_CHUNK_SIZE = 100;\n        return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n            pageIndex: this._pageIndex,\n            includeMarkedContent: includeMarkedContent === true,\n            disableNormalization: disableNormalization === true\n        }, {\n            highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n            size (textContent) {\n                return textContent.items.length;\n            }\n        });\n    }\n    getTextContent(params = {}) {\n        if (this._transport._htmlForXfa) {\n            return this.getXfa().then((xfa)=>XfaText.textContent(xfa));\n        }\n        const readableStream = this.streamTextContent(params);\n        return new Promise(function(resolve, reject) {\n            function pump() {\n                reader.read().then(function({ value, done }) {\n                    if (done) {\n                        resolve(textContent);\n                        return;\n                    }\n                    textContent.lang ??= value.lang;\n                    Object.assign(textContent.styles, value.styles);\n                    textContent.items.push(...value.items);\n                    pump();\n                }, reject);\n            }\n            const reader = readableStream.getReader();\n            const textContent = {\n                items: [],\n                styles: Object.create(null),\n                lang: null\n            };\n            pump();\n        });\n    }\n    getStructTree() {\n        return this._transport.getStructTree(this._pageIndex);\n    }\n    _destroy() {\n        this.destroyed = true;\n        const waitOn = [];\n        for (const intentState of this._intentStates.values()){\n            this._abortOperatorList({\n                intentState,\n                reason: new Error(\"Page was destroyed.\"),\n                force: true\n            });\n            if (intentState.opListReadCapability) {\n                continue;\n            }\n            for (const internalRenderTask of intentState.renderTasks){\n                waitOn.push(internalRenderTask.completed);\n                internalRenderTask.cancel();\n            }\n        }\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        return Promise.all(waitOn);\n    }\n    cleanup(resetStats = false) {\n        this.#pendingCleanup = true;\n        const success = this.#tryCleanup();\n        if (resetStats && success) {\n            this._stats &&= new StatTimer();\n        }\n        return success;\n    }\n    #tryCleanup() {\n        if (!this.#pendingCleanup || this.destroyed) {\n            return false;\n        }\n        for (const { renderTasks, operatorList } of this._intentStates.values()){\n            if (renderTasks.size > 0 || !operatorList.lastChunk) {\n                return false;\n            }\n        }\n        this._intentStates.clear();\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        return true;\n    }\n    _startRenderPage(transparency, cacheKey) {\n        const intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            return;\n        }\n        this._stats?.timeEnd(\"Page Request\");\n        intentState.displayReadyCapability?.resolve(transparency);\n    }\n    _renderPageChunk(operatorListChunk, intentState) {\n        for(let i = 0, ii = operatorListChunk.length; i < ii; i++){\n            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n        }\n        intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n        intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n        for (const internalRenderTask of intentState.renderTasks){\n            internalRenderTask.operatorListChanged();\n        }\n        if (operatorListChunk.lastChunk) {\n            this.#tryCleanup();\n        }\n    }\n    _pumpOperatorList({ renderingIntent, cacheKey, annotationStorageSerializable, modifiedIds }) {\n        const { map, transfer } = annotationStorageSerializable;\n        const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n            pageIndex: this._pageIndex,\n            intent: renderingIntent,\n            cacheKey,\n            annotationStorage: map,\n            modifiedIds\n        }, transfer);\n        const reader = readableStream.getReader();\n        const intentState = this._intentStates.get(cacheKey);\n        intentState.streamReader = reader;\n        const pump = ()=>{\n            reader.read().then(({ value, done })=>{\n                if (done) {\n                    intentState.streamReader = null;\n                    return;\n                }\n                if (this._transport.destroyed) {\n                    return;\n                }\n                this._renderPageChunk(value, intentState);\n                pump();\n            }, (reason)=>{\n                intentState.streamReader = null;\n                if (this._transport.destroyed) {\n                    return;\n                }\n                if (intentState.operatorList) {\n                    intentState.operatorList.lastChunk = true;\n                    for (const internalRenderTask of intentState.renderTasks){\n                        internalRenderTask.operatorListChanged();\n                    }\n                    this.#tryCleanup();\n                }\n                if (intentState.displayReadyCapability) {\n                    intentState.displayReadyCapability.reject(reason);\n                } else if (intentState.opListReadCapability) {\n                    intentState.opListReadCapability.reject(reason);\n                } else {\n                    throw reason;\n                }\n            });\n        };\n        pump();\n    }\n    _abortOperatorList({ intentState, reason, force = false }) {\n        if (!intentState.streamReader) {\n            return;\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        if (!force) {\n            if (intentState.renderTasks.size > 0) {\n                return;\n            }\n            if (reason instanceof RenderingCancelledException) {\n                let delay = RENDERING_CANCELLED_TIMEOUT;\n                if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n                    delay += reason.extraDelay;\n                }\n                intentState.streamReaderCancelTimeout = setTimeout(()=>{\n                    intentState.streamReaderCancelTimeout = null;\n                    this._abortOperatorList({\n                        intentState,\n                        reason,\n                        force: true\n                    });\n                }, delay);\n                return;\n            }\n        }\n        intentState.streamReader.cancel(new AbortException(reason.message)).catch(()=>{});\n        intentState.streamReader = null;\n        if (this._transport.destroyed) {\n            return;\n        }\n        for (const [curCacheKey, curIntentState] of this._intentStates){\n            if (curIntentState === intentState) {\n                this._intentStates.delete(curCacheKey);\n                break;\n            }\n        }\n        this.cleanup();\n    }\n    get stats() {\n        return this._stats;\n    }\n}\nclass PDFWorker {\n    #capability;\n    #messageHandler;\n    #port;\n    #webWorker;\n    static #fakeWorkerId = 0;\n    static #isWorkerDisabled = false;\n    static #workerPorts = new WeakMap();\n    static{\n        if (isNodeJS) {\n            this.#isWorkerDisabled = true;\n            GlobalWorkerOptions.workerSrc ||= \"./pdf.worker.mjs\";\n        }\n        this._isSameOrigin = (baseUrl, otherUrl)=>{\n            const base = URL.parse(baseUrl);\n            if (!base?.origin || base.origin === \"null\") {\n                return false;\n            }\n            const other = new URL(otherUrl, base);\n            return base.origin === other.origin;\n        };\n        this._createCDNWrapper = (url)=>{\n            const wrapper = `await import(\"${url}\");`;\n            return URL.createObjectURL(new Blob([\n                wrapper\n            ], {\n                type: \"text/javascript\"\n            }));\n        };\n        this.fromPort = (params)=>{\n            deprecated(\"`PDFWorker.fromPort` - please use `PDFWorker.create` instead.\");\n            if (!params?.port) {\n                throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n            }\n            return this.create(params);\n        };\n    }\n    constructor({ name = null, port = null, verbosity = getVerbosityLevel() } = {}){\n        this.#capability = Promise.withResolvers();\n        this.#messageHandler = null;\n        this.#port = null;\n        this.#webWorker = null;\n        this.name = name;\n        this.destroyed = false;\n        this.verbosity = verbosity;\n        if (port) {\n            if (PDFWorker.#workerPorts.has(port)) {\n                throw new Error(\"Cannot use more than one PDFWorker per port.\");\n            }\n            PDFWorker.#workerPorts.set(port, this);\n            this.#initializeFromPort(port);\n        } else {\n            this.#initialize();\n        }\n    }\n    get promise() {\n        return this.#capability.promise;\n    }\n    #resolve() {\n        this.#capability.resolve();\n        this.#messageHandler.send(\"configure\", {\n            verbosity: this.verbosity\n        });\n    }\n    get port() {\n        return this.#port;\n    }\n    get messageHandler() {\n        return this.#messageHandler;\n    }\n    #initializeFromPort(port) {\n        this.#port = port;\n        this.#messageHandler = new MessageHandler(\"main\", \"worker\", port);\n        this.#messageHandler.on(\"ready\", ()=>{});\n        this.#resolve();\n    }\n    #initialize() {\n        if (PDFWorker.#isWorkerDisabled || PDFWorker.#mainThreadWorkerMessageHandler) {\n            this.#setupFakeWorker();\n            return;\n        }\n        let { workerSrc } = PDFWorker;\n        try {\n            if (!PDFWorker._isSameOrigin(window.location, workerSrc)) {\n                workerSrc = PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);\n            }\n            const worker = new Worker(workerSrc, {\n                type: \"module\"\n            });\n            const messageHandler = new MessageHandler(\"main\", \"worker\", worker);\n            const terminateEarly = ()=>{\n                ac.abort();\n                messageHandler.destroy();\n                worker.terminate();\n                if (this.destroyed) {\n                    this.#capability.reject(new Error(\"Worker was destroyed\"));\n                } else {\n                    this.#setupFakeWorker();\n                }\n            };\n            const ac = new AbortController();\n            worker.addEventListener(\"error\", ()=>{\n                if (!this.#webWorker) {\n                    terminateEarly();\n                }\n            }, {\n                signal: ac.signal\n            });\n            messageHandler.on(\"test\", (data)=>{\n                ac.abort();\n                if (this.destroyed || !data) {\n                    terminateEarly();\n                    return;\n                }\n                this.#messageHandler = messageHandler;\n                this.#port = worker;\n                this.#webWorker = worker;\n                this.#resolve();\n            });\n            messageHandler.on(\"ready\", (data)=>{\n                ac.abort();\n                if (this.destroyed) {\n                    terminateEarly();\n                    return;\n                }\n                try {\n                    sendTest();\n                } catch  {\n                    this.#setupFakeWorker();\n                }\n            });\n            const sendTest = ()=>{\n                const testObj = new Uint8Array();\n                messageHandler.send(\"test\", testObj, [\n                    testObj.buffer\n                ]);\n            };\n            sendTest();\n            return;\n        } catch  {\n            info(\"The worker has been disabled.\");\n        }\n        this.#setupFakeWorker();\n    }\n    #setupFakeWorker() {\n        if (!PDFWorker.#isWorkerDisabled) {\n            warn(\"Setting up fake worker.\");\n            PDFWorker.#isWorkerDisabled = true;\n        }\n        PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler)=>{\n            if (this.destroyed) {\n                this.#capability.reject(new Error(\"Worker was destroyed\"));\n                return;\n            }\n            const port = new LoopbackPort();\n            this.#port = port;\n            const id = `fake${PDFWorker.#fakeWorkerId++}`;\n            const workerHandler = new MessageHandler(id + \"_worker\", id, port);\n            WorkerMessageHandler.setup(workerHandler, port);\n            this.#messageHandler = new MessageHandler(id, id + \"_worker\", port);\n            this.#resolve();\n        }).catch((reason)=>{\n            this.#capability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n        });\n    }\n    destroy() {\n        this.destroyed = true;\n        this.#webWorker?.terminate();\n        this.#webWorker = null;\n        PDFWorker.#workerPorts.delete(this.#port);\n        this.#port = null;\n        this.#messageHandler?.destroy();\n        this.#messageHandler = null;\n    }\n    static create(params) {\n        const cachedPort = this.#workerPorts.get(params?.port);\n        if (cachedPort) {\n            if (cachedPort._pendingDestroy) {\n                throw new Error(\"PDFWorker.create - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n            }\n            return cachedPort;\n        }\n        return new PDFWorker(params);\n    }\n    static get workerSrc() {\n        if (GlobalWorkerOptions.workerSrc) {\n            return GlobalWorkerOptions.workerSrc;\n        }\n        throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n    }\n    static get #mainThreadWorkerMessageHandler() {\n        try {\n            return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n        } catch  {\n            return null;\n        }\n    }\n    static get _setupFakeWorkerGlobal() {\n        const loader = async ()=>{\n            if (this.#mainThreadWorkerMessageHandler) {\n                return this.#mainThreadWorkerMessageHandler;\n            }\n            const worker = await import(/*webpackIgnore: true*/ /*@vite-ignore*/ this.workerSrc);\n            return worker.WorkerMessageHandler;\n        };\n        return shadow(this, \"_setupFakeWorkerGlobal\", loader());\n    }\n}\nclass WorkerTransport {\n    #methodPromises;\n    #pageCache;\n    #pagePromises;\n    #pageRefCache;\n    #passwordCapability;\n    constructor(messageHandler, loadingTask, networkStream, params, factory, enableHWA){\n        this.#methodPromises = new Map();\n        this.#pageCache = new Map();\n        this.#pagePromises = new Map();\n        this.#pageRefCache = new Map();\n        this.#passwordCapability = null;\n        this.messageHandler = messageHandler;\n        this.loadingTask = loadingTask;\n        this.commonObjs = new PDFObjects();\n        this.fontLoader = new FontLoader({\n            ownerDocument: params.ownerDocument,\n            styleElement: params.styleElement\n        });\n        this.loadingParams = params.loadingParams;\n        this._params = params;\n        this.canvasFactory = factory.canvasFactory;\n        this.filterFactory = factory.filterFactory;\n        this.cMapReaderFactory = factory.cMapReaderFactory;\n        this.standardFontDataFactory = factory.standardFontDataFactory;\n        this.wasmFactory = factory.wasmFactory;\n        this.destroyed = false;\n        this.destroyCapability = null;\n        this._networkStream = networkStream;\n        this._fullReader = null;\n        this._lastProgress = null;\n        this.downloadInfoCapability = Promise.withResolvers();\n        this.enableHWA = enableHWA;\n        this.setupMessageHandler();\n    }\n    #cacheSimpleMethod(name, data = null) {\n        const cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, data);\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    get annotationStorage() {\n        return shadow(this, \"annotationStorage\", new AnnotationStorage());\n    }\n    getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {\n        let renderingIntent = RenderingIntentFlag.DISPLAY;\n        let annotationStorageSerializable = SerializableEmpty;\n        switch(intent){\n            case \"any\":\n                renderingIntent = RenderingIntentFlag.ANY;\n                break;\n            case \"display\":\n                break;\n            case \"print\":\n                renderingIntent = RenderingIntentFlag.PRINT;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid intent: ${intent}`);\n        }\n        const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n        switch(annotationMode){\n            case AnnotationMode.DISABLE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;\n                break;\n            case AnnotationMode.ENABLE:\n                break;\n            case AnnotationMode.ENABLE_FORMS:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;\n                break;\n            case AnnotationMode.ENABLE_STORAGE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;\n                annotationStorageSerializable = annotationStorage.serializable;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n        }\n        if (isEditing) {\n            renderingIntent += RenderingIntentFlag.IS_EDITING;\n        }\n        if (isOpList) {\n            renderingIntent += RenderingIntentFlag.OPLIST;\n        }\n        const { ids: modifiedIds, hash: modifiedIdsHash } = annotationStorage.modifiedIds;\n        const cacheKeyBuf = [\n            renderingIntent,\n            annotationStorageSerializable.hash,\n            modifiedIdsHash\n        ];\n        return {\n            renderingIntent,\n            cacheKey: cacheKeyBuf.join(\"_\"),\n            annotationStorageSerializable,\n            modifiedIds\n        };\n    }\n    destroy() {\n        if (this.destroyCapability) {\n            return this.destroyCapability.promise;\n        }\n        this.destroyed = true;\n        this.destroyCapability = Promise.withResolvers();\n        this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n        const waitOn = [];\n        for (const page of this.#pageCache.values()){\n            waitOn.push(page._destroy());\n        }\n        this.#pageCache.clear();\n        this.#pagePromises.clear();\n        this.#pageRefCache.clear();\n        if (this.hasOwnProperty(\"annotationStorage\")) {\n            this.annotationStorage.resetModified();\n        }\n        const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n        waitOn.push(terminated);\n        Promise.all(waitOn).then(()=>{\n            this.commonObjs.clear();\n            this.fontLoader.clear();\n            this.#methodPromises.clear();\n            this.filterFactory.destroy();\n            TextLayer.cleanup();\n            this._networkStream?.cancelAllRequests(new AbortException(\"Worker was terminated.\"));\n            this.messageHandler?.destroy();\n            this.messageHandler = null;\n            this.destroyCapability.resolve();\n        }, this.destroyCapability.reject);\n        return this.destroyCapability.promise;\n    }\n    setupMessageHandler() {\n        const { messageHandler, loadingTask } = this;\n        messageHandler.on(\"GetReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n            this._fullReader = this._networkStream.getFullReader();\n            this._fullReader.onProgress = (evt)=>{\n                this._lastProgress = {\n                    loaded: evt.loaded,\n                    total: evt.total\n                };\n            };\n            sink.onPull = ()=>{\n                this._fullReader.read().then(function({ value, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [\n                        value\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                this._fullReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"ReaderHeadersReady\", async (data)=>{\n            await this._fullReader.headersReady;\n            const { isStreamingSupported, isRangeSupported, contentLength } = this._fullReader;\n            if (!isStreamingSupported || !isRangeSupported) {\n                if (this._lastProgress) {\n                    loadingTask.onProgress?.(this._lastProgress);\n                }\n                this._fullReader.onProgress = (evt)=>{\n                    loadingTask.onProgress?.({\n                        loaded: evt.loaded,\n                        total: evt.total\n                    });\n                };\n            }\n            return {\n                isStreamingSupported,\n                isRangeSupported,\n                contentLength\n            };\n        });\n        messageHandler.on(\"GetRangeReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n            const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n            if (!rangeReader) {\n                sink.close();\n                return;\n            }\n            sink.onPull = ()=>{\n                rangeReader.read().then(function({ value, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [\n                        value\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                rangeReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"GetDoc\", ({ pdfInfo })=>{\n            this._numPages = pdfInfo.numPages;\n            this._htmlForXfa = pdfInfo.htmlForXfa;\n            delete pdfInfo.htmlForXfa;\n            loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n        });\n        messageHandler.on(\"DocException\", (ex)=>{\n            loadingTask._capability.reject(wrapReason(ex));\n        });\n        messageHandler.on(\"PasswordRequest\", (ex)=>{\n            this.#passwordCapability = Promise.withResolvers();\n            try {\n                if (!loadingTask.onPassword) {\n                    throw wrapReason(ex);\n                }\n                const updatePassword = (password)=>{\n                    if (password instanceof Error) {\n                        this.#passwordCapability.reject(password);\n                    } else {\n                        this.#passwordCapability.resolve({\n                            password\n                        });\n                    }\n                };\n                loadingTask.onPassword(updatePassword, ex.code);\n            } catch (err) {\n                this.#passwordCapability.reject(err);\n            }\n            return this.#passwordCapability.promise;\n        });\n        messageHandler.on(\"DataLoaded\", (data)=>{\n            loadingTask.onProgress?.({\n                loaded: data.length,\n                total: data.length\n            });\n            this.downloadInfoCapability.resolve(data);\n        });\n        messageHandler.on(\"StartRenderPage\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            const page = this.#pageCache.get(data.pageIndex);\n            page._startRenderPage(data.transparency, data.cacheKey);\n        });\n        messageHandler.on(\"commonobj\", ([id, type, exportedData])=>{\n            if (this.destroyed) {\n                return null;\n            }\n            if (this.commonObjs.has(id)) {\n                return null;\n            }\n            switch(type){\n                case \"Font\":\n                    if (\"error\" in exportedData) {\n                        const exportedError = exportedData.error;\n                        warn(`Error during font loading: ${exportedError}`);\n                        this.commonObjs.resolve(id, exportedError);\n                        break;\n                    }\n                    const inspectFont = this._params.pdfBug && globalThis.FontInspector?.enabled ? (font, url)=>globalThis.FontInspector.fontAdded(font, url) : null;\n                    const font = new FontFaceObject(exportedData, inspectFont);\n                    this.fontLoader.bind(font).catch(()=>messageHandler.sendWithPromise(\"FontFallback\", {\n                            id\n                        })).finally(()=>{\n                        if (!font.fontExtraProperties && font.data) {\n                            font.data = null;\n                        }\n                        this.commonObjs.resolve(id, font);\n                    });\n                    break;\n                case \"CopyLocalImage\":\n                    const { imageRef } = exportedData;\n                    assert(imageRef, \"The imageRef must be defined.\");\n                    for (const pageProxy of this.#pageCache.values()){\n                        for (const [, data] of pageProxy.objs){\n                            if (data?.ref !== imageRef) {\n                                continue;\n                            }\n                            if (!data.dataLen) {\n                                return null;\n                            }\n                            this.commonObjs.resolve(id, structuredClone(data));\n                            return data.dataLen;\n                        }\n                    }\n                    break;\n                case \"FontPath\":\n                case \"Image\":\n                case \"Pattern\":\n                    this.commonObjs.resolve(id, exportedData);\n                    break;\n                default:\n                    throw new Error(`Got unknown common object type ${type}`);\n            }\n            return null;\n        });\n        messageHandler.on(\"obj\", ([id, pageIndex, type, imageData])=>{\n            if (this.destroyed) {\n                return;\n            }\n            const pageProxy = this.#pageCache.get(pageIndex);\n            if (pageProxy.objs.has(id)) {\n                return;\n            }\n            if (pageProxy._intentStates.size === 0) {\n                imageData?.bitmap?.close();\n                return;\n            }\n            switch(type){\n                case \"Image\":\n                case \"Pattern\":\n                    pageProxy.objs.resolve(id, imageData);\n                    break;\n                default:\n                    throw new Error(`Got unknown object type ${type}`);\n            }\n        });\n        messageHandler.on(\"DocProgress\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            loadingTask.onProgress?.({\n                loaded: data.loaded,\n                total: data.total\n            });\n        });\n        messageHandler.on(\"FetchBinaryData\", async (data)=>{\n            if (this.destroyed) {\n                throw new Error(\"Worker was destroyed.\");\n            }\n            const factory = this[data.type];\n            if (!factory) {\n                throw new Error(`${data.type} not initialized, see the \\`useWorkerFetch\\` parameter.`);\n            }\n            return factory.fetch(data);\n        });\n    }\n    getData() {\n        return this.messageHandler.sendWithPromise(\"GetData\", null);\n    }\n    saveDocument() {\n        if (this.annotationStorage.size <= 0) {\n            warn(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n        }\n        const { map, transfer } = this.annotationStorage.serializable;\n        return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n            isPureXfa: !!this._htmlForXfa,\n            numPages: this._numPages,\n            annotationStorage: map,\n            filename: this._fullReader?.filename ?? null\n        }, transfer).finally(()=>{\n            this.annotationStorage.resetModified();\n        });\n    }\n    getPage(pageNumber) {\n        if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n            return Promise.reject(new Error(\"Invalid page request.\"));\n        }\n        const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n            pageIndex\n        }).then((pageInfo)=>{\n            if (this.destroyed) {\n                throw new Error(\"Transport destroyed\");\n            }\n            if (pageInfo.refStr) {\n                this.#pageRefCache.set(pageInfo.refStr, pageNumber);\n            }\n            const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n            this.#pageCache.set(pageIndex, page);\n            return page;\n        });\n        this.#pagePromises.set(pageIndex, promise);\n        return promise;\n    }\n    getPageIndex(ref) {\n        if (!isRefProxy(ref)) {\n            return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n            num: ref.num,\n            gen: ref.gen\n        });\n    }\n    getAnnotations(pageIndex, intent) {\n        return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n            pageIndex,\n            intent\n        });\n    }\n    getFieldObjects() {\n        return this.#cacheSimpleMethod(\"GetFieldObjects\");\n    }\n    hasJSActions() {\n        return this.#cacheSimpleMethod(\"HasJSActions\");\n    }\n    getCalculationOrderIds() {\n        return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n    }\n    getDestinations() {\n        return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n    }\n    getDestination(id) {\n        if (typeof id !== \"string\") {\n            return Promise.reject(new Error(\"Invalid destination request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetDestination\", {\n            id\n        });\n    }\n    getPageLabels() {\n        return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n    }\n    getPageLayout() {\n        return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n    }\n    getPageMode() {\n        return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n    }\n    getViewerPreferences() {\n        return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n    }\n    getOpenAction() {\n        return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n    }\n    getAttachments() {\n        return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n    }\n    getAnnotationsByType(types, pageIndexesToSkip) {\n        return this.messageHandler.sendWithPromise(\"GetAnnotationsByType\", {\n            types,\n            pageIndexesToSkip\n        });\n    }\n    getDocJSActions() {\n        return this.#cacheSimpleMethod(\"GetDocJSActions\");\n    }\n    getPageJSActions(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n            pageIndex\n        });\n    }\n    getStructTree(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n            pageIndex\n        });\n    }\n    getOutline() {\n        return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n    }\n    getOptionalContentConfig(renderingIntent) {\n        return this.#cacheSimpleMethod(\"GetOptionalContentConfig\").then((data)=>new OptionalContentConfig(data, renderingIntent));\n    }\n    getPermissions() {\n        return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n    }\n    getMetadata() {\n        const name = \"GetMetadata\", cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, null).then((results)=>({\n                info: results[0],\n                metadata: results[1] ? new Metadata(results[1]) : null,\n                contentDispositionFilename: this._fullReader?.filename ?? null,\n                contentLength: this._fullReader?.contentLength ?? null\n            }));\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    getMarkInfo() {\n        return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n    }\n    async startCleanup(keepLoadedFonts = false) {\n        if (this.destroyed) {\n            return;\n        }\n        await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n        for (const page of this.#pageCache.values()){\n            const cleanupSuccessful = page.cleanup();\n            if (!cleanupSuccessful) {\n                throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n            }\n        }\n        this.commonObjs.clear();\n        if (!keepLoadedFonts) {\n            this.fontLoader.clear();\n        }\n        this.#methodPromises.clear();\n        this.filterFactory.destroy(true);\n        TextLayer.cleanup();\n    }\n    cachedPageNumber(ref) {\n        if (!isRefProxy(ref)) {\n            return null;\n        }\n        const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;\n        return this.#pageRefCache.get(refStr) ?? null;\n    }\n}\nclass RenderTask {\n    #internalRenderTask;\n    constructor(internalRenderTask){\n        this.#internalRenderTask = null;\n        this.onContinue = null;\n        this.onError = null;\n        this.#internalRenderTask = internalRenderTask;\n    }\n    get promise() {\n        return this.#internalRenderTask.capability.promise;\n    }\n    cancel(extraDelay = 0) {\n        this.#internalRenderTask.cancel(null, extraDelay);\n    }\n    get separateAnnots() {\n        const { separateAnnots } = this.#internalRenderTask.operatorList;\n        if (!separateAnnots) {\n            return false;\n        }\n        const { annotationCanvasMap } = this.#internalRenderTask;\n        return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n    }\n}\nclass InternalRenderTask {\n    #rAF;\n    static #canvasInUse = new WeakSet();\n    constructor({ callback, params, objs, commonObjs, annotationCanvasMap, operatorList, pageIndex, canvasFactory, filterFactory, useRequestAnimationFrame = false, pdfBug = false, pageColors = null, enableHWA = false, filteredOperationIndexes = null }){\n        this.#rAF = null;\n        this.callback = callback;\n        this.params = params;\n        this.objs = objs;\n        this.commonObjs = commonObjs;\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.operatorListIdx = null;\n        this.operatorList = operatorList;\n        this._pageIndex = pageIndex;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this._pdfBug = pdfBug;\n        this.pageColors = pageColors;\n        this.running = false;\n        this.graphicsReadyCallback = null;\n        this.graphicsReady = false;\n        this._useRequestAnimationFrame = useRequestAnimationFrame === true && \"undefined\" !== \"undefined\";\n        this.cancelled = false;\n        this.capability = Promise.withResolvers();\n        this.task = new RenderTask(this);\n        this._cancelBound = this.cancel.bind(this);\n        this._continueBound = this._continue.bind(this);\n        this._scheduleNextBound = this._scheduleNext.bind(this);\n        this._nextBound = this._next.bind(this);\n        this._canvas = params.canvas;\n        this._canvasContext = params.canvas ? null : params.canvasContext;\n        this._enableHWA = enableHWA;\n        this._dependencyTracker = params.dependencyTracker;\n        this._filteredOperationIndexes = filteredOperationIndexes;\n    }\n    get completed() {\n        return this.capability.promise.catch(function() {});\n    }\n    initializeGraphics({ transparency = false, optionalContentConfig }) {\n        if (this.cancelled) {\n            return;\n        }\n        if (this._canvas) {\n            if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n                throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n            }\n            InternalRenderTask.#canvasInUse.add(this._canvas);\n        }\n        if (this._pdfBug && globalThis.StepperManager?.enabled) {\n            this.stepper = globalThis.StepperManager.create(this._pageIndex);\n            this.stepper.init(this.operatorList);\n            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n        }\n        const { viewport, transform, background, dependencyTracker } = this.params;\n        const canvasContext = this._canvasContext || this._canvas.getContext(\"2d\", {\n            alpha: false,\n            willReadFrequently: !this._enableHWA\n        });\n        this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n            optionalContentConfig\n        }, this.annotationCanvasMap, this.pageColors, dependencyTracker);\n        this.gfx.beginDrawing({\n            transform,\n            viewport,\n            transparency,\n            background\n        });\n        this.operatorListIdx = 0;\n        this.graphicsReady = true;\n        this.graphicsReadyCallback?.();\n    }\n    cancel(error = null, extraDelay = 0) {\n        this.running = false;\n        this.cancelled = true;\n        this.gfx?.endDrawing();\n        if (this.#rAF) {\n            window.cancelAnimationFrame(this.#rAF);\n            this.#rAF = null;\n        }\n        InternalRenderTask.#canvasInUse.delete(this._canvas);\n        error ||= new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay);\n        this.callback(error);\n        this.task.onError?.(error);\n    }\n    operatorListChanged() {\n        if (!this.graphicsReady) {\n            this.graphicsReadyCallback ||= this._continueBound;\n            return;\n        }\n        this.stepper?.updateOperatorList(this.operatorList);\n        if (this.running) {\n            return;\n        }\n        this._continue();\n    }\n    _continue() {\n        this.running = true;\n        if (this.cancelled) {\n            return;\n        }\n        if (this.task.onContinue) {\n            this.task.onContinue(this._scheduleNextBound);\n        } else {\n            this._scheduleNext();\n        }\n    }\n    _scheduleNext() {\n        if (this._useRequestAnimationFrame) {\n            this.#rAF = window.requestAnimationFrame(()=>{\n                this.#rAF = null;\n                this._nextBound().catch(this._cancelBound);\n            });\n        } else {\n            Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n        }\n    }\n    async _next() {\n        if (this.cancelled) {\n            return;\n        }\n        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._filteredOperationIndexes);\n        if (this.operatorListIdx === this.operatorList.argsArray.length) {\n            this.running = false;\n            if (this.operatorList.lastChunk) {\n                this.gfx.endDrawing();\n                InternalRenderTask.#canvasInUse.delete(this._canvas);\n                this.callback();\n            }\n        }\n    }\n}\nconst version = \"5.4.149\";\nconst build = \"9e2e9e209\";\n; // ./src/display/editor/color_picker.js\nclass ColorPicker {\n    #button;\n    #buttonSwatch;\n    #defaultColor;\n    #dropdown;\n    #dropdownWasFromKeyboard;\n    #isMainColorPicker;\n    #editor;\n    #eventBus;\n    #openDropdownAC;\n    #uiManager;\n    static #l10nColor = null;\n    static get _keyboardManager() {\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                ColorPicker.prototype._hideDropdownFromKeyboard\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                ColorPicker.prototype._colorSelectFromKeyboard\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"ArrowRight\",\n                    \"mac+ArrowDown\",\n                    \"mac+ArrowRight\"\n                ],\n                ColorPicker.prototype._moveToNext\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"ArrowLeft\",\n                    \"mac+ArrowUp\",\n                    \"mac+ArrowLeft\"\n                ],\n                ColorPicker.prototype._moveToPrevious\n            ],\n            [\n                [\n                    \"Home\",\n                    \"mac+Home\"\n                ],\n                ColorPicker.prototype._moveToBeginning\n            ],\n            [\n                [\n                    \"End\",\n                    \"mac+End\"\n                ],\n                ColorPicker.prototype._moveToEnd\n            ]\n        ]));\n    }\n    constructor({ editor = null, uiManager = null }){\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown = null;\n        this.#dropdownWasFromKeyboard = false;\n        this.#isMainColorPicker = false;\n        this.#editor = null;\n        this.#openDropdownAC = null;\n        this.#uiManager = null;\n        if (editor) {\n            this.#isMainColorPicker = false;\n            this.#editor = editor;\n        } else {\n            this.#isMainColorPicker = true;\n        }\n        this.#uiManager = editor?._uiManager || uiManager;\n        this.#eventBus = this.#uiManager._eventBus;\n        this.#defaultColor = editor?.color?.toUpperCase() || this.#uiManager?.highlightColors.values().next().value || \"#FFFF98\";\n        ColorPicker.#l10nColor ||= Object.freeze({\n            blue: \"pdfjs-editor-colorpicker-blue\",\n            green: \"pdfjs-editor-colorpicker-green\",\n            pink: \"pdfjs-editor-colorpicker-pink\",\n            red: \"pdfjs-editor-colorpicker-red\",\n            yellow: \"pdfjs-editor-colorpicker-yellow\"\n        });\n    }\n    renderButton() {\n        const button = this.#button = document.createElement(\"button\");\n        button.className = \"colorPicker\";\n        button.tabIndex = \"0\";\n        button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-button\");\n        button.ariaHasPopup = \"true\";\n        if (this.#editor) {\n            button.ariaControls = `${this.#editor.id}_colorpicker_dropdown`;\n        }\n        const signal = this.#uiManager._signal;\n        button.addEventListener(\"click\", this.#openDropdown.bind(this), {\n            signal\n        });\n        button.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        const swatch = this.#buttonSwatch = document.createElement(\"span\");\n        swatch.className = \"swatch\";\n        swatch.ariaHidden = \"true\";\n        swatch.style.backgroundColor = this.#defaultColor;\n        button.append(swatch);\n        return button;\n    }\n    renderMainDropdown() {\n        const dropdown = this.#dropdown = this.#getDropdownRoot();\n        dropdown.ariaOrientation = \"horizontal\";\n        dropdown.ariaLabelledBy = \"highlightColorPickerLabel\";\n        return dropdown;\n    }\n    #getDropdownRoot() {\n        const div = document.createElement(\"div\");\n        const signal = this.#uiManager._signal;\n        div.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        div.className = \"dropdown\";\n        div.role = \"listbox\";\n        div.ariaMultiSelectable = \"false\";\n        div.ariaOrientation = \"vertical\";\n        div.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-dropdown\");\n        if (this.#editor) {\n            div.id = `${this.#editor.id}_colorpicker_dropdown`;\n        }\n        for (const [name, color] of this.#uiManager.highlightColors){\n            const button = document.createElement(\"button\");\n            button.tabIndex = \"0\";\n            button.role = \"option\";\n            button.setAttribute(\"data-color\", color);\n            button.title = name;\n            button.setAttribute(\"data-l10n-id\", ColorPicker.#l10nColor[name]);\n            const swatch = document.createElement(\"span\");\n            button.append(swatch);\n            swatch.className = \"swatch\";\n            swatch.style.backgroundColor = color;\n            button.ariaSelected = color === this.#defaultColor;\n            button.addEventListener(\"click\", this.#colorSelect.bind(this, color), {\n                signal\n            });\n            div.append(button);\n        }\n        div.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        return div;\n    }\n    #colorSelect(color, event) {\n        event.stopPropagation();\n        this.#eventBus.dispatch(\"switchannotationeditorparams\", {\n            source: this,\n            type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n            value: color\n        });\n        this.updateColor(color);\n    }\n    _colorSelectFromKeyboard(event) {\n        if (event.target === this.#button) {\n            this.#openDropdown(event);\n            return;\n        }\n        const color = event.target.getAttribute(\"data-color\");\n        if (!color) {\n            return;\n        }\n        this.#colorSelect(color, event);\n    }\n    _moveToNext(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        if (event.target === this.#button) {\n            this.#dropdown.firstChild?.focus();\n            return;\n        }\n        event.target.nextSibling?.focus();\n    }\n    _moveToPrevious(event) {\n        if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {\n            if (this.#isDropdownVisible) {\n                this._hideDropdownFromKeyboard();\n            }\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n        }\n        event.target.previousSibling?.focus();\n    }\n    _moveToBeginning(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.firstChild?.focus();\n    }\n    _moveToEnd(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.lastChild?.focus();\n    }\n    #keyDown(event) {\n        ColorPicker._keyboardManager.exec(this, event);\n    }\n    #openDropdown(event) {\n        if (this.#isDropdownVisible) {\n            this.hideDropdown();\n            return;\n        }\n        this.#dropdownWasFromKeyboard = event.detail === 0;\n        if (!this.#openDropdownAC) {\n            this.#openDropdownAC = new AbortController();\n            window.addEventListener(\"pointerdown\", this.#pointerDown.bind(this), {\n                signal: this.#uiManager.combinedSignal(this.#openDropdownAC)\n            });\n        }\n        this.#button.ariaExpanded = \"true\";\n        if (this.#dropdown) {\n            this.#dropdown.classList.remove(\"hidden\");\n            return;\n        }\n        const root = this.#dropdown = this.#getDropdownRoot();\n        this.#button.append(root);\n    }\n    #pointerDown(event) {\n        if (this.#dropdown?.contains(event.target)) {\n            return;\n        }\n        this.hideDropdown();\n    }\n    hideDropdown() {\n        this.#dropdown?.classList.add(\"hidden\");\n        this.#button.ariaExpanded = \"false\";\n        this.#openDropdownAC?.abort();\n        this.#openDropdownAC = null;\n    }\n    get #isDropdownVisible() {\n        return this.#dropdown && !this.#dropdown.classList.contains(\"hidden\");\n    }\n    _hideDropdownFromKeyboard() {\n        if (this.#isMainColorPicker) {\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#editor?.unselect();\n            return;\n        }\n        this.hideDropdown();\n        this.#button.focus({\n            preventScroll: true,\n            focusVisible: this.#dropdownWasFromKeyboard\n        });\n    }\n    updateColor(color) {\n        if (this.#buttonSwatch) {\n            this.#buttonSwatch.style.backgroundColor = color;\n        }\n        if (!this.#dropdown) {\n            return;\n        }\n        const i = this.#uiManager.highlightColors.values();\n        for (const child of this.#dropdown.children){\n            child.ariaSelected = i.next().value === color.toUpperCase();\n        }\n    }\n    destroy() {\n        this.#button?.remove();\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown?.remove();\n        this.#dropdown = null;\n    }\n}\nclass BasicColorPicker {\n    #input;\n    #editor;\n    #uiManager;\n    static #l10nColor = null;\n    constructor(editor){\n        this.#input = null;\n        this.#editor = null;\n        this.#uiManager = null;\n        this.#editor = editor;\n        this.#uiManager = editor._uiManager;\n        BasicColorPicker.#l10nColor ||= Object.freeze({\n            freetext: \"pdfjs-editor-color-picker-free-text-input\",\n            ink: \"pdfjs-editor-color-picker-ink-input\"\n        });\n    }\n    renderButton() {\n        if (this.#input) {\n            return this.#input;\n        }\n        const { editorType, colorType, colorValue } = this.#editor;\n        const input = this.#input = document.createElement(\"input\");\n        input.type = \"color\";\n        input.value = colorValue || \"#000000\";\n        input.className = \"basicColorPicker\";\n        input.tabIndex = 0;\n        input.setAttribute(\"data-l10n-id\", BasicColorPicker.#l10nColor[editorType]);\n        input.addEventListener(\"input\", ()=>{\n            this.#uiManager.updateParams(colorType, input.value);\n        }, {\n            signal: this.#uiManager._signal\n        });\n        return input;\n    }\n    update(value) {\n        if (!this.#input) {\n            return;\n        }\n        this.#input.value = value;\n    }\n    destroy() {\n        this.#input?.remove();\n        this.#input = null;\n    }\n    hideDropdown() {}\n}\n; // ./src/shared/scripting_utils.js\nfunction makeColorComp(n) {\n    return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\nfunction scaleAndClamp(x) {\n    return Math.max(0, Math.min(255, 255 * x));\n}\nclass ColorConverters {\n    static CMYK_G([c, y, m, k]) {\n        return [\n            \"G\",\n            1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)\n        ];\n    }\n    static G_CMYK([g]) {\n        return [\n            \"CMYK\",\n            0,\n            0,\n            0,\n            1 - g\n        ];\n    }\n    static G_RGB([g]) {\n        return [\n            \"RGB\",\n            g,\n            g,\n            g\n        ];\n    }\n    static G_rgb([g]) {\n        g = scaleAndClamp(g);\n        return [\n            g,\n            g,\n            g\n        ];\n    }\n    static G_HTML([g]) {\n        const G = makeColorComp(g);\n        return `#${G}${G}${G}`;\n    }\n    static RGB_G([r, g, b]) {\n        return [\n            \"G\",\n            0.3 * r + 0.59 * g + 0.11 * b\n        ];\n    }\n    static RGB_rgb(color) {\n        return color.map(scaleAndClamp);\n    }\n    static RGB_HTML(color) {\n        return `#${color.map(makeColorComp).join(\"\")}`;\n    }\n    static T_HTML() {\n        return \"#00000000\";\n    }\n    static T_rgb() {\n        return [\n            null\n        ];\n    }\n    static CMYK_RGB([c, y, m, k]) {\n        return [\n            \"RGB\",\n            1 - Math.min(1, c + k),\n            1 - Math.min(1, m + k),\n            1 - Math.min(1, y + k)\n        ];\n    }\n    static CMYK_rgb([c, y, m, k]) {\n        return [\n            scaleAndClamp(1 - Math.min(1, c + k)),\n            scaleAndClamp(1 - Math.min(1, m + k)),\n            scaleAndClamp(1 - Math.min(1, y + k))\n        ];\n    }\n    static CMYK_HTML(components) {\n        const rgb = this.CMYK_RGB(components).slice(1);\n        return this.RGB_HTML(rgb);\n    }\n    static RGB_CMYK([r, g, b]) {\n        const c = 1 - r;\n        const m = 1 - g;\n        const y = 1 - b;\n        const k = Math.min(c, m, y);\n        return [\n            \"CMYK\",\n            c,\n            m,\n            y,\n            k\n        ];\n    }\n}\nconst DateFormats = /* unused pure expression or super */ null && 0;\nconst TimeFormats = /* unused pure expression or super */ null && 0;\n; // ./src/display/svg_factory.js\nclass BaseSVGFactory {\n    create(width, height, skipDimensions = false) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid SVG dimensions\");\n        }\n        const svg = this._createSVG(\"svg:svg\");\n        svg.setAttribute(\"version\", \"1.1\");\n        if (!skipDimensions) {\n            svg.setAttribute(\"width\", `${width}px`);\n            svg.setAttribute(\"height\", `${height}px`);\n        }\n        svg.setAttribute(\"preserveAspectRatio\", \"none\");\n        svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n        return svg;\n    }\n    createElement(type) {\n        if (typeof type !== \"string\") {\n            throw new Error(\"Invalid SVG element type\");\n        }\n        return this._createSVG(type);\n    }\n    _createSVG(type) {\n        unreachable(\"Abstract method `_createSVG` called.\");\n    }\n}\nclass DOMSVGFactory extends BaseSVGFactory {\n    _createSVG(type) {\n        return document.createElementNS(SVG_NS, type);\n    }\n}\n; // ./src/display/xfa_layer.js\nclass XfaLayer {\n    static setupStorage(html, id, element, storage, intent) {\n        const storedData = storage.getValue(id, {\n            value: null\n        });\n        switch(element.name){\n            case \"textarea\":\n                if (storedData.value !== null) {\n                    html.textContent = storedData.value;\n                }\n                if (intent === \"print\") {\n                    break;\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    storage.setValue(id, {\n                        value: event.target.value\n                    });\n                });\n                break;\n            case \"input\":\n                if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n                    if (storedData.value === element.attributes.xfaOn) {\n                        html.setAttribute(\"checked\", true);\n                    } else if (storedData.value === element.attributes.xfaOff) {\n                        html.removeAttribute(\"checked\");\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"change\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n                        });\n                    });\n                } else {\n                    if (storedData.value !== null) {\n                        html.setAttribute(\"value\", storedData.value);\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"input\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.value\n                        });\n                    });\n                }\n                break;\n            case \"select\":\n                if (storedData.value !== null) {\n                    html.setAttribute(\"value\", storedData.value);\n                    for (const option of element.children){\n                        if (option.attributes.value === storedData.value) {\n                            option.attributes.selected = true;\n                        } else if (option.attributes.hasOwnProperty(\"selected\")) {\n                            delete option.attributes.selected;\n                        }\n                    }\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    const options = event.target.options;\n                    const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n                    storage.setValue(id, {\n                        value\n                    });\n                });\n                break;\n        }\n    }\n    static setAttributes({ html, element, storage = null, intent, linkService }) {\n        const { attributes } = element;\n        const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n        if (attributes.type === \"radio\") {\n            attributes.name = `${attributes.name}-${intent}`;\n        }\n        for (const [key, value] of Object.entries(attributes)){\n            if (value === null || value === undefined) {\n                continue;\n            }\n            switch(key){\n                case \"class\":\n                    if (value.length) {\n                        html.setAttribute(key, value.join(\" \"));\n                    }\n                    break;\n                case \"dataId\":\n                    break;\n                case \"id\":\n                    html.setAttribute(\"data-element-id\", value);\n                    break;\n                case \"style\":\n                    Object.assign(html.style, value);\n                    break;\n                case \"textContent\":\n                    html.textContent = value;\n                    break;\n                default:\n                    if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n                        html.setAttribute(key, value);\n                    }\n            }\n        }\n        if (isHTMLAnchorElement) {\n            linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n        }\n        if (storage && attributes.dataId) {\n            this.setupStorage(html, attributes.dataId, element, storage);\n        }\n    }\n    static render(parameters) {\n        const storage = parameters.annotationStorage;\n        const linkService = parameters.linkService;\n        const root = parameters.xfaHtml;\n        const intent = parameters.intent || \"display\";\n        const rootHtml = document.createElement(root.name);\n        if (root.attributes) {\n            this.setAttributes({\n                html: rootHtml,\n                element: root,\n                intent,\n                linkService\n            });\n        }\n        const isNotForRichText = intent !== \"richText\";\n        const rootDiv = parameters.div;\n        rootDiv.append(rootHtml);\n        if (parameters.viewport) {\n            const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n            rootDiv.style.transform = transform;\n        }\n        if (isNotForRichText) {\n            rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n        }\n        const textDivs = [];\n        if (root.children.length === 0) {\n            if (root.value) {\n                const node = document.createTextNode(root.value);\n                rootHtml.append(node);\n                if (isNotForRichText && XfaText.shouldBuildText(root.name)) {\n                    textDivs.push(node);\n                }\n            }\n            return {\n                textDivs\n            };\n        }\n        const stack = [\n            [\n                root,\n                -1,\n                rootHtml\n            ]\n        ];\n        while(stack.length > 0){\n            const [parent, i, html] = stack.at(-1);\n            if (i + 1 === parent.children.length) {\n                stack.pop();\n                continue;\n            }\n            const child = parent.children[++stack.at(-1)[1]];\n            if (child === null) {\n                continue;\n            }\n            const { name } = child;\n            if (name === \"#text\") {\n                const node = document.createTextNode(child.value);\n                textDivs.push(node);\n                html.append(node);\n                continue;\n            }\n            const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n            html.append(childHtml);\n            if (child.attributes) {\n                this.setAttributes({\n                    html: childHtml,\n                    element: child,\n                    storage,\n                    intent,\n                    linkService\n                });\n            }\n            if (child.children?.length > 0) {\n                stack.push([\n                    child,\n                    -1,\n                    childHtml\n                ]);\n            } else if (child.value) {\n                const node = document.createTextNode(child.value);\n                if (isNotForRichText && XfaText.shouldBuildText(name)) {\n                    textDivs.push(node);\n                }\n                childHtml.append(node);\n            }\n        }\n        for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")){\n            el.setAttribute(\"readOnly\", true);\n        }\n        return {\n            textDivs\n        };\n    }\n    static update(parameters) {\n        const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n        parameters.div.style.transform = transform;\n        parameters.div.hidden = false;\n    }\n}\n; // ./src/display/annotation_layer.js\nconst annotation_layer_DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = new WeakSet();\nconst TIMEZONE_OFFSET = new Date().getTimezoneOffset() * 60 * 1000;\nclass AnnotationElementFactory {\n    static create(parameters) {\n        const subtype = parameters.data.annotationType;\n        switch(subtype){\n            case AnnotationType.LINK:\n                return new LinkAnnotationElement(parameters);\n            case AnnotationType.TEXT:\n                return new TextAnnotationElement(parameters);\n            case AnnotationType.WIDGET:\n                const fieldType = parameters.data.fieldType;\n                switch(fieldType){\n                    case \"Tx\":\n                        return new TextWidgetAnnotationElement(parameters);\n                    case \"Btn\":\n                        if (parameters.data.radioButton) {\n                            return new RadioButtonWidgetAnnotationElement(parameters);\n                        } else if (parameters.data.checkBox) {\n                            return new CheckboxWidgetAnnotationElement(parameters);\n                        }\n                        return new PushButtonWidgetAnnotationElement(parameters);\n                    case \"Ch\":\n                        return new ChoiceWidgetAnnotationElement(parameters);\n                    case \"Sig\":\n                        return new SignatureWidgetAnnotationElement(parameters);\n                }\n                return new WidgetAnnotationElement(parameters);\n            case AnnotationType.POPUP:\n                return new PopupAnnotationElement(parameters);\n            case AnnotationType.FREETEXT:\n                return new FreeTextAnnotationElement(parameters);\n            case AnnotationType.LINE:\n                return new LineAnnotationElement(parameters);\n            case AnnotationType.SQUARE:\n                return new SquareAnnotationElement(parameters);\n            case AnnotationType.CIRCLE:\n                return new CircleAnnotationElement(parameters);\n            case AnnotationType.POLYLINE:\n                return new PolylineAnnotationElement(parameters);\n            case AnnotationType.CARET:\n                return new CaretAnnotationElement(parameters);\n            case AnnotationType.INK:\n                return new InkAnnotationElement(parameters);\n            case AnnotationType.POLYGON:\n                return new PolygonAnnotationElement(parameters);\n            case AnnotationType.HIGHLIGHT:\n                return new HighlightAnnotationElement(parameters);\n            case AnnotationType.UNDERLINE:\n                return new UnderlineAnnotationElement(parameters);\n            case AnnotationType.SQUIGGLY:\n                return new SquigglyAnnotationElement(parameters);\n            case AnnotationType.STRIKEOUT:\n                return new StrikeOutAnnotationElement(parameters);\n            case AnnotationType.STAMP:\n                return new StampAnnotationElement(parameters);\n            case AnnotationType.FILEATTACHMENT:\n                return new FileAttachmentAnnotationElement(parameters);\n            default:\n                return new AnnotationElement(parameters);\n        }\n    }\n}\nclass AnnotationElement {\n    #updates;\n    #hasBorder;\n    #popupElement;\n    constructor(parameters, { isRenderable = false, ignoreBorder = false, createQuadrilaterals = false } = {}){\n        this.#updates = null;\n        this.#hasBorder = false;\n        this.#popupElement = null;\n        this.isRenderable = isRenderable;\n        this.data = parameters.data;\n        this.layer = parameters.layer;\n        this.linkService = parameters.linkService;\n        this.downloadManager = parameters.downloadManager;\n        this.imageResourcesPath = parameters.imageResourcesPath;\n        this.renderForms = parameters.renderForms;\n        this.svgFactory = parameters.svgFactory;\n        this.annotationStorage = parameters.annotationStorage;\n        this.enableComment = parameters.enableComment;\n        this.enableScripting = parameters.enableScripting;\n        this.hasJSActions = parameters.hasJSActions;\n        this._fieldObjects = parameters.fieldObjects;\n        this.parent = parameters.parent;\n        if (isRenderable) {\n            this.container = this._createContainer(ignoreBorder);\n        }\n        if (createQuadrilaterals) {\n            this._createQuadrilaterals();\n        }\n    }\n    static _hasPopupData({ contentsObj, richText }) {\n        return !!(contentsObj?.str || richText?.str);\n    }\n    get _isEditable() {\n        return this.data.isEditable;\n    }\n    get hasPopupData() {\n        return AnnotationElement._hasPopupData(this.data);\n    }\n    get hasCommentButton() {\n        return this.enableComment && this._isEditable && this.hasPopupElement;\n    }\n    get commentButtonPosition() {\n        const { quadPoints, rect } = this.data;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        if (quadPoints?.length >= 8) {\n            for(let i = 0; i < quadPoints.length; i += 8){\n                if (quadPoints[i + 1] > maxY) {\n                    maxY = quadPoints[i + 1];\n                    maxX = quadPoints[i + 2];\n                } else if (quadPoints[i + 1] === maxY) {\n                    maxX = Math.max(maxX, quadPoints[i + 2]);\n                }\n            }\n            return [\n                maxX,\n                maxY\n            ];\n        }\n        if (rect) {\n            return [\n                rect[2],\n                rect[3]\n            ];\n        }\n        return null;\n    }\n    get commentButtonColor() {\n        if (!this.data.color) {\n            return null;\n        }\n        const [r, g, b] = this.data.color;\n        const opacity = this.data.opacity ?? 1;\n        const oppositeOpacity = 255 * (1 - opacity);\n        return this.#changeLightness(Math.min(r + oppositeOpacity, 255), Math.min(g + oppositeOpacity, 255), Math.min(b + oppositeOpacity, 255));\n    }\n    #changeLightness(r, g, b) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        const l = (max + min) / 2;\n        const newL = ((1 + Math.sqrt(l)) / 2 * 100).toFixed(2);\n        if (max === min) {\n            return `hsl(0, 0%, ${newL}%)`;\n        }\n        const d = max - min;\n        let h;\n        if (max === r) {\n            h = (g - b) / d + (g < b ? 6 : 0);\n        } else if (max === g) {\n            h = (b - r) / d + 2;\n        } else {\n            h = (r - g) / d + 4;\n        }\n        h = (h * 60).toFixed(2);\n        const s = (d / (1 - Math.abs(2 * l - 1)) * 100).toFixed(2);\n        return `hsl(${h}, ${s}%, ${newL}%)`;\n    }\n    _normalizePoint(point) {\n        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.parent;\n        point[1] = view[3] - point[1] + view[1];\n        point[0] = 100 * (point[0] - pageX) / pageWidth;\n        point[1] = 100 * (point[1] - pageY) / pageHeight;\n        return point;\n    }\n    updateEdited(params) {\n        if (!this.container) {\n            return;\n        }\n        if (params.rect) {\n            this.#updates ||= {\n                rect: this.data.rect.slice(0)\n            };\n        }\n        const { rect, popup: newPopup } = params;\n        if (rect) {\n            this.#setRectEdited(rect);\n        }\n        let popup = this.#popupElement?.popup || this.popup;\n        if (!popup && newPopup?.text) {\n            this._createPopup(newPopup);\n            popup = this.#popupElement.popup;\n        }\n        if (!popup) {\n            return;\n        }\n        popup.updateEdited(params);\n        if (newPopup?.deleted) {\n            popup.remove();\n            this.#popupElement = null;\n            this.popup = null;\n        }\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        this.#setRectEdited(this.#updates.rect);\n        this.#popupElement?.popup.resetEdited();\n        this.#updates = null;\n    }\n    #setRectEdited(rect) {\n        const { container: { style }, data: { rect: currentRect, rotation }, parent: { viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } } = this;\n        currentRect?.splice(0, 4, ...rect);\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;\n        if (rotation === 0) {\n            style.width = `${100 * (rect[2] - rect[0]) / pageWidth}%`;\n            style.height = `${100 * (rect[3] - rect[1]) / pageHeight}%`;\n        } else {\n            this.setRotation(rotation);\n        }\n    }\n    _createContainer(ignoreBorder) {\n        const { data, parent: { page, viewport } } = this;\n        const container = document.createElement(\"section\");\n        container.setAttribute(\"data-annotation-id\", data.id);\n        if (!(this instanceof WidgetAnnotationElement) && !(this instanceof LinkAnnotationElement)) {\n            container.tabIndex = 0;\n        }\n        const { style } = container;\n        style.zIndex = this.parent.zIndex;\n        this.parent.zIndex += 2;\n        if (data.alternativeText) {\n            container.title = data.alternativeText;\n        }\n        if (data.noRotate) {\n            container.classList.add(\"norotate\");\n        }\n        if (!data.rect || this instanceof PopupAnnotationElement) {\n            const { rotation } = data;\n            if (!data.hasOwnCanvas && rotation !== 0) {\n                this.setRotation(rotation, container);\n            }\n            return container;\n        }\n        const { width, height } = this;\n        if (!ignoreBorder && data.borderStyle.width > 0) {\n            style.borderWidth = `${data.borderStyle.width}px`;\n            const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n            const verticalRadius = data.borderStyle.verticalCornerRadius;\n            if (horizontalRadius > 0 || verticalRadius > 0) {\n                const radius = `calc(${horizontalRadius}px * var(--total-scale-factor)) / calc(${verticalRadius}px * var(--total-scale-factor))`;\n                style.borderRadius = radius;\n            } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n                const radius = `calc(${width}px * var(--total-scale-factor)) / calc(${height}px * var(--total-scale-factor))`;\n                style.borderRadius = radius;\n            }\n            switch(data.borderStyle.style){\n                case AnnotationBorderStyleType.SOLID:\n                    style.borderStyle = \"solid\";\n                    break;\n                case AnnotationBorderStyleType.DASHED:\n                    style.borderStyle = \"dashed\";\n                    break;\n                case AnnotationBorderStyleType.BEVELED:\n                    warn(\"Unimplemented border style: beveled\");\n                    break;\n                case AnnotationBorderStyleType.INSET:\n                    warn(\"Unimplemented border style: inset\");\n                    break;\n                case AnnotationBorderStyleType.UNDERLINE:\n                    style.borderBottomStyle = \"solid\";\n                    break;\n                default:\n                    break;\n            }\n            const borderColor = data.borderColor || null;\n            if (borderColor) {\n                this.#hasBorder = true;\n                style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n            } else {\n                style.borderWidth = 0;\n            }\n        }\n        const rect = Util.normalizeRect([\n            data.rect[0],\n            page.view[3] - data.rect[1] + page.view[1],\n            data.rect[2],\n            page.view[3] - data.rect[3] + page.view[1]\n        ]);\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n        const { rotation } = data;\n        if (data.hasOwnCanvas || rotation === 0) {\n            style.width = `${100 * width / pageWidth}%`;\n            style.height = `${100 * height / pageHeight}%`;\n        } else {\n            this.setRotation(rotation, container);\n        }\n        return container;\n    }\n    setRotation(angle, container = this.container) {\n        if (!this.data.rect) {\n            return;\n        }\n        const { pageWidth, pageHeight } = this.parent.viewport.rawDims;\n        let { width, height } = this;\n        if (angle % 180 !== 0) {\n            [width, height] = [\n                height,\n                width\n            ];\n        }\n        container.style.width = `${100 * width / pageWidth}%`;\n        container.style.height = `${100 * height / pageHeight}%`;\n        container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n    }\n    get _commonActions() {\n        const setColor = (jsName, styleName, event)=>{\n            const color = event.detail[jsName];\n            const colorType = color[0];\n            const colorArray = color.slice(1);\n            event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);\n            this.annotationStorage.setValue(this.data.id, {\n                [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)\n            });\n        };\n        return shadow(this, \"_commonActions\", {\n            display: (event)=>{\n                const { display } = event.detail;\n                const hidden = display % 2 === 1;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noView: hidden,\n                    noPrint: display === 1 || display === 2\n                });\n            },\n            print: (event)=>{\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: !event.detail.print\n                });\n            },\n            hidden: (event)=>{\n                const { hidden } = event.detail;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: hidden,\n                    noView: hidden\n                });\n            },\n            focus: (event)=>{\n                setTimeout(()=>event.target.focus({\n                        preventScroll: false\n                    }), 0);\n            },\n            userName: (event)=>{\n                event.target.title = event.detail.userName;\n            },\n            readonly: (event)=>{\n                event.target.disabled = event.detail.readonly;\n            },\n            required: (event)=>{\n                this._setRequired(event.target, event.detail.required);\n            },\n            bgColor: (event)=>{\n                setColor(\"bgColor\", \"backgroundColor\", event);\n            },\n            fillColor: (event)=>{\n                setColor(\"fillColor\", \"backgroundColor\", event);\n            },\n            fgColor: (event)=>{\n                setColor(\"fgColor\", \"color\", event);\n            },\n            textColor: (event)=>{\n                setColor(\"textColor\", \"color\", event);\n            },\n            borderColor: (event)=>{\n                setColor(\"borderColor\", \"borderColor\", event);\n            },\n            strokeColor: (event)=>{\n                setColor(\"strokeColor\", \"borderColor\", event);\n            },\n            rotation: (event)=>{\n                const angle = event.detail.rotation;\n                this.setRotation(angle);\n                this.annotationStorage.setValue(this.data.id, {\n                    rotation: angle\n                });\n            }\n        });\n    }\n    _dispatchEventFromSandbox(actions, jsEvent) {\n        const commonActions = this._commonActions;\n        for (const name of Object.keys(jsEvent.detail)){\n            const action = actions[name] || commonActions[name];\n            action?.(jsEvent);\n        }\n    }\n    _setDefaultPropertiesFromJS(element) {\n        if (!this.enableScripting) {\n            return;\n        }\n        const storedData = this.annotationStorage.getRawValue(this.data.id);\n        if (!storedData) {\n            return;\n        }\n        const commonActions = this._commonActions;\n        for (const [actionName, detail] of Object.entries(storedData)){\n            const action = commonActions[actionName];\n            if (action) {\n                const eventProxy = {\n                    detail: {\n                        [actionName]: detail\n                    },\n                    target: element\n                };\n                action(eventProxy);\n                delete storedData[actionName];\n            }\n        }\n    }\n    _createQuadrilaterals() {\n        if (!this.container) {\n            return;\n        }\n        const { quadPoints } = this.data;\n        if (!quadPoints) {\n            return;\n        }\n        const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map((x)=>Math.fround(x));\n        if (quadPoints.length === 8) {\n            const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);\n            if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n                return;\n            }\n        }\n        const { style } = this.container;\n        let svgBuffer;\n        if (this.#hasBorder) {\n            const { borderColor, borderWidth } = style;\n            style.borderWidth = 0;\n            svgBuffer = [\n                \"url('data:image/svg+xml;utf8,\",\n                `<svg xmlns=\"http://www.w3.org/2000/svg\"`,\n                ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`,\n                `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`\n            ];\n            this.container.classList.add(\"hasBorder\");\n        }\n        const width = rectTrX - rectBlX;\n        const height = rectTrY - rectBlY;\n        const { svgFactory } = this;\n        const svg = svgFactory.createElement(\"svg\");\n        svg.classList.add(\"quadrilateralsContainer\");\n        svg.setAttribute(\"width\", 0);\n        svg.setAttribute(\"height\", 0);\n        svg.role = \"none\";\n        const defs = svgFactory.createElement(\"defs\");\n        svg.append(defs);\n        const clipPath = svgFactory.createElement(\"clipPath\");\n        const id = `clippath_${this.data.id}`;\n        clipPath.setAttribute(\"id\", id);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        defs.append(clipPath);\n        for(let i = 2, ii = quadPoints.length; i < ii; i += 8){\n            const trX = quadPoints[i];\n            const trY = quadPoints[i + 1];\n            const blX = quadPoints[i + 2];\n            const blY = quadPoints[i + 3];\n            const rect = svgFactory.createElement(\"rect\");\n            const x = (blX - rectBlX) / width;\n            const y = (rectTrY - trY) / height;\n            const rectWidth = (trX - blX) / width;\n            const rectHeight = (trY - blY) / height;\n            rect.setAttribute(\"x\", x);\n            rect.setAttribute(\"y\", y);\n            rect.setAttribute(\"width\", rectWidth);\n            rect.setAttribute(\"height\", rectHeight);\n            clipPath.append(rect);\n            svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n        }\n        if (this.#hasBorder) {\n            svgBuffer.push(`</g></svg>')`);\n            style.backgroundImage = svgBuffer.join(\"\");\n        }\n        this.container.append(svg);\n        this.container.style.clipPath = `url(#${id})`;\n    }\n    _createPopup(popupData = null) {\n        const { data } = this;\n        let contentsObj, modificationDate;\n        if (popupData) {\n            contentsObj = {\n                str: popupData.text\n            };\n            modificationDate = popupData.date;\n        } else {\n            contentsObj = data.contentsObj;\n            modificationDate = data.modificationDate;\n        }\n        const popup = this.#popupElement = new PopupAnnotationElement({\n            data: {\n                color: data.color,\n                titleObj: data.titleObj,\n                modificationDate,\n                contentsObj,\n                richText: data.richText,\n                parentRect: data.rect,\n                borderStyle: 0,\n                id: `popup_${data.id}`,\n                rotation: data.rotation,\n                noRotate: true\n            },\n            linkService: this.linkService,\n            parent: this.parent,\n            elements: [\n                this\n            ]\n        });\n        this.parent.div.append(popup.render());\n    }\n    get hasPopupElement() {\n        return !!(this.#popupElement || this.popup || this.data.popupRef);\n    }\n    render() {\n        unreachable(\"Abstract method `AnnotationElement.render` called\");\n    }\n    _getElementsByName(name, skipId = null) {\n        const fields = [];\n        if (this._fieldObjects) {\n            const fieldObj = this._fieldObjects[name];\n            if (fieldObj) {\n                for (const { page, id, exportValues } of fieldObj){\n                    if (page === -1) {\n                        continue;\n                    }\n                    if (id === skipId) {\n                        continue;\n                    }\n                    const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n                    const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                    if (domElement && !GetElementsByNameSet.has(domElement)) {\n                        warn(`_getElementsByName - element not allowed: ${id}`);\n                        continue;\n                    }\n                    fields.push({\n                        id,\n                        exportValue,\n                        domElement\n                    });\n                }\n            }\n            return fields;\n        }\n        for (const domElement of document.getElementsByName(name)){\n            const { exportValue } = domElement;\n            const id = domElement.getAttribute(\"data-element-id\");\n            if (id === skipId) {\n                continue;\n            }\n            if (!GetElementsByNameSet.has(domElement)) {\n                continue;\n            }\n            fields.push({\n                id,\n                exportValue,\n                domElement\n            });\n        }\n        return fields;\n    }\n    show() {\n        if (this.container) {\n            this.container.hidden = false;\n        }\n        this.popup?.maybeShow();\n    }\n    hide() {\n        if (this.container) {\n            this.container.hidden = true;\n        }\n        this.popup?.forceHide();\n    }\n    getElementsToTriggerPopup() {\n        return this.container;\n    }\n    addHighlightArea() {\n        const triggers = this.getElementsToTriggerPopup();\n        if (Array.isArray(triggers)) {\n            for (const element of triggers){\n                element.classList.add(\"highlightArea\");\n            }\n        } else {\n            triggers.classList.add(\"highlightArea\");\n        }\n    }\n    _editOnDoubleClick() {\n        if (!this._isEditable) {\n            return;\n        }\n        const { annotationEditorType: mode, data: { id: editId } } = this;\n        this.container.addEventListener(\"dblclick\", ()=>{\n            this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n                source: this,\n                mode,\n                editId,\n                mustEnterInEditMode: true\n            });\n        });\n    }\n    get width() {\n        return this.data.rect[2] - this.data.rect[0];\n    }\n    get height() {\n        return this.data.rect[3] - this.data.rect[1];\n    }\n}\nclass LinkAnnotationElement extends AnnotationElement {\n    constructor(parameters, options = null){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: !!options?.ignoreBorder,\n            createQuadrilaterals: true\n        });\n        this.isTooltipOnly = parameters.data.isTooltipOnly;\n    }\n    render() {\n        const { data, linkService } = this;\n        const link = document.createElement(\"a\");\n        link.setAttribute(\"data-element-id\", data.id);\n        let isBound = false;\n        if (data.url) {\n            linkService.addLinkAttributes(link, data.url, data.newWindow);\n            isBound = true;\n        } else if (data.action) {\n            this._bindNamedAction(link, data.action, data.overlaidText);\n            isBound = true;\n        } else if (data.attachment) {\n            this.#bindAttachment(link, data.attachment, data.overlaidText, data.attachmentDest);\n            isBound = true;\n        } else if (data.setOCGState) {\n            this.#bindSetOCGState(link, data.setOCGState, data.overlaidText);\n            isBound = true;\n        } else if (data.dest) {\n            this._bindLink(link, data.dest, data.overlaidText);\n            isBound = true;\n        } else {\n            if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n                this._bindJSAction(link, data);\n                isBound = true;\n            }\n            if (data.resetForm) {\n                this._bindResetFormAction(link, data.resetForm);\n                isBound = true;\n            } else if (this.isTooltipOnly && !isBound) {\n                this._bindLink(link, \"\");\n                isBound = true;\n            }\n        }\n        this.container.classList.add(\"linkAnnotation\");\n        if (isBound) {\n            this.container.append(link);\n        }\n        return this.container;\n    }\n    #setInternalLink() {\n        this.container.setAttribute(\"data-internal-link\", \"\");\n    }\n    _bindLink(link, destination, overlaidText = \"\") {\n        link.href = this.linkService.getDestinationHash(destination);\n        link.onclick = ()=>{\n            if (destination) {\n                this.linkService.goToDestination(destination);\n            }\n            return false;\n        };\n        if (destination || destination === \"\") {\n            this.#setInternalLink();\n        }\n        if (overlaidText) {\n            link.title = overlaidText;\n        }\n    }\n    _bindNamedAction(link, action, overlaidText = \"\") {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeNamedAction(action);\n            return false;\n        };\n        if (overlaidText) {\n            link.title = overlaidText;\n        }\n        this.#setInternalLink();\n    }\n    #bindAttachment(link, attachment, overlaidText = \"\", dest = null) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        if (attachment.description) {\n            link.title = attachment.description;\n        } else if (overlaidText) {\n            link.title = overlaidText;\n        }\n        link.onclick = ()=>{\n            this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    #bindSetOCGState(link, action, overlaidText = \"\") {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeSetOCGState(action);\n            return false;\n        };\n        if (overlaidText) {\n            link.title = overlaidText;\n        }\n        this.#setInternalLink();\n    }\n    _bindJSAction(link, data) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        const map = new Map([\n            [\n                \"Action\",\n                \"onclick\"\n            ],\n            [\n                \"Mouse Up\",\n                \"onmouseup\"\n            ],\n            [\n                \"Mouse Down\",\n                \"onmousedown\"\n            ]\n        ]);\n        for (const name of Object.keys(data.actions)){\n            const jsName = map.get(name);\n            if (!jsName) {\n                continue;\n            }\n            link[jsName] = ()=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: data.id,\n                        name\n                    }\n                });\n                return false;\n            };\n        }\n        if (data.overlaidText) {\n            link.title = data.overlaidText;\n        }\n        if (!link.onclick) {\n            link.onclick = ()=>false;\n        }\n        this.#setInternalLink();\n    }\n    _bindResetFormAction(link, resetForm) {\n        const otherClickAction = link.onclick;\n        if (!otherClickAction) {\n            link.href = this.linkService.getAnchorUrl(\"\");\n        }\n        this.#setInternalLink();\n        if (!this._fieldObjects) {\n            warn(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n            if (!otherClickAction) {\n                link.onclick = ()=>false;\n            }\n            return;\n        }\n        link.onclick = ()=>{\n            otherClickAction?.();\n            const { fields: resetFormFields, refs: resetFormRefs, include } = resetForm;\n            const allFields = [];\n            if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n                const fieldIds = new Set(resetFormRefs);\n                for (const fieldName of resetFormFields){\n                    const fields = this._fieldObjects[fieldName] || [];\n                    for (const { id } of fields){\n                        fieldIds.add(id);\n                    }\n                }\n                for (const fields of Object.values(this._fieldObjects)){\n                    for (const field of fields){\n                        if (fieldIds.has(field.id) === include) {\n                            allFields.push(field);\n                        }\n                    }\n                }\n            } else {\n                for (const fields of Object.values(this._fieldObjects)){\n                    allFields.push(...fields);\n                }\n            }\n            const storage = this.annotationStorage;\n            const allIds = [];\n            for (const field of allFields){\n                const { id } = field;\n                allIds.push(id);\n                switch(field.type){\n                    case \"text\":\n                        {\n                            const value = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    case \"checkbox\":\n                    case \"radiobutton\":\n                        {\n                            const value = field.defaultValue === field.exportValues;\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    case \"combobox\":\n                    case \"listbox\":\n                        {\n                            const value = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    default:\n                        continue;\n                }\n                const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                if (!domElement) {\n                    continue;\n                } else if (!GetElementsByNameSet.has(domElement)) {\n                    warn(`_bindResetFormAction - element not allowed: ${id}`);\n                    continue;\n                }\n                domElement.dispatchEvent(new Event(\"resetform\"));\n            }\n            if (this.enableScripting) {\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: \"app\",\n                        ids: allIds,\n                        name: \"ResetForm\"\n                    }\n                });\n            }\n            return false;\n        };\n    }\n}\nclass TextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"textAnnotation\");\n        const image = document.createElement(\"img\");\n        image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n        image.setAttribute(\"data-l10n-id\", \"pdfjs-text-annotation-type\");\n        image.setAttribute(\"data-l10n-args\", JSON.stringify({\n            type: this.data.name\n        }));\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(image);\n        return this.container;\n    }\n}\nclass WidgetAnnotationElement extends AnnotationElement {\n    render() {\n        return this.container;\n    }\n    showElementAndHideCanvas(element) {\n        if (this.data.hasOwnCanvas) {\n            if (element.previousSibling?.nodeName === \"CANVAS\") {\n                element.previousSibling.hidden = true;\n            }\n            element.hidden = false;\n        }\n    }\n    _getKeyModifier(event) {\n        return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;\n    }\n    _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n        if (baseName.includes(\"mouse\")) {\n            element.addEventListener(baseName, (event)=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event),\n                        shift: event.shiftKey,\n                        modifier: this._getKeyModifier(event)\n                    }\n                });\n            });\n        } else {\n            element.addEventListener(baseName, (event)=>{\n                if (baseName === \"blur\") {\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    elementData.focused = false;\n                } else if (baseName === \"focus\") {\n                    if (elementData.focused) {\n                        return;\n                    }\n                    elementData.focused = true;\n                }\n                if (!valueGetter) {\n                    return;\n                }\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event)\n                    }\n                });\n            });\n        }\n    }\n    _setEventListeners(element, elementData, names, getter) {\n        for (const [baseName, eventName] of names){\n            if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n                if (eventName === \"Focus\" || eventName === \"Blur\") {\n                    elementData ||= {\n                        focused: false\n                    };\n                }\n                this._setEventListener(element, elementData, baseName, eventName, getter);\n                if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n                    this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n                } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n                    this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n                }\n            }\n        }\n    }\n    _setBackgroundColor(element) {\n        const color = this.data.backgroundColor || null;\n        element.style.backgroundColor = color === null ? \"transparent\" : Util.makeHexColor(color[0], color[1], color[2]);\n    }\n    _setTextStyle(element) {\n        const TEXT_ALIGNMENT = [\n            \"left\",\n            \"center\",\n            \"right\"\n        ];\n        const { fontColor } = this.data.defaultAppearanceData;\n        const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;\n        const style = element.style;\n        let computedFontSize;\n        const BORDER_SIZE = 2;\n        const roundToOneDecimal = (x)=>Math.round(10 * x) / 10;\n        if (this.data.multiLine) {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;\n            const lineHeight = height / numberOfLines;\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));\n        } else {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));\n        }\n        style.fontSize = `calc(${computedFontSize}px * var(--total-scale-factor))`;\n        style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n        if (this.data.textAlignment !== null) {\n            style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n        }\n    }\n    _setRequired(element, isRequired) {\n        if (isRequired) {\n            element.setAttribute(\"required\", true);\n        } else {\n            element.removeAttribute(\"required\");\n        }\n        element.setAttribute(\"aria-required\", isRequired);\n    }\n}\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n        super(parameters, {\n            isRenderable\n        });\n    }\n    setPropertyOnSiblings(base, key, value, keyInStorage) {\n        const storage = this.annotationStorage;\n        for (const element of this._getElementsByName(base.name, base.id)){\n            if (element.domElement) {\n                element.domElement[key] = value;\n            }\n            storage.setValue(element.id, {\n                [keyInStorage]: value\n            });\n        }\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        this.container.classList.add(\"textWidgetAnnotation\");\n        let element = null;\n        if (this.renderForms) {\n            const storedData = storage.getValue(id, {\n                value: this.data.fieldValue\n            });\n            let textContent = storedData.value || \"\";\n            const maxLen = storage.getValue(id, {\n                charLimit: this.data.maxLen\n            }).charLimit;\n            if (maxLen && textContent.length > maxLen) {\n                textContent = textContent.slice(0, maxLen);\n            }\n            let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n            if (fieldFormattedValues && this.data.comb) {\n                fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n            }\n            const elementData = {\n                userValue: textContent,\n                formattedValue: fieldFormattedValues,\n                lastCommittedValue: null,\n                commitKey: 1,\n                focused: false\n            };\n            if (this.data.multiLine) {\n                element = document.createElement(\"textarea\");\n                element.textContent = fieldFormattedValues ?? textContent;\n                if (this.data.doNotScroll) {\n                    element.style.overflowY = \"hidden\";\n                }\n            } else {\n                element = document.createElement(\"input\");\n                element.type = this.data.password ? \"password\" : \"text\";\n                element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n                if (this.data.doNotScroll) {\n                    element.style.overflowX = \"hidden\";\n                }\n            }\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n            GetElementsByNameSet.add(element);\n            element.setAttribute(\"data-element-id\", id);\n            element.disabled = this.data.readOnly;\n            element.name = this.data.fieldName;\n            element.tabIndex = 0;\n            const { datetimeFormat, datetimeType, timeStep } = this.data;\n            const hasDateOrTime = !!datetimeType && this.enableScripting;\n            if (datetimeFormat) {\n                element.title = datetimeFormat;\n            }\n            this._setRequired(element, this.data.required);\n            if (maxLen) {\n                element.maxLength = maxLen;\n            }\n            element.addEventListener(\"input\", (event)=>{\n                storage.setValue(id, {\n                    value: event.target.value\n                });\n                this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n                elementData.formattedValue = null;\n            });\n            element.addEventListener(\"resetform\", (event)=>{\n                const defaultValue = this.data.defaultFieldValue ?? \"\";\n                element.value = elementData.userValue = defaultValue;\n                elementData.formattedValue = null;\n            });\n            let blurListener = (event)=>{\n                const { formattedValue } = elementData;\n                if (formattedValue !== null && formattedValue !== undefined) {\n                    event.target.value = formattedValue;\n                }\n                event.target.scrollLeft = 0;\n            };\n            if (this.enableScripting && this.hasJSActions) {\n                element.addEventListener(\"focus\", (event)=>{\n                    if (elementData.focused) {\n                        return;\n                    }\n                    const { target } = event;\n                    if (hasDateOrTime) {\n                        target.type = datetimeType;\n                        if (timeStep) {\n                            target.step = timeStep;\n                        }\n                    }\n                    if (elementData.userValue) {\n                        const value = elementData.userValue;\n                        if (hasDateOrTime) {\n                            if (datetimeType === \"time\") {\n                                const date = new Date(value);\n                                const parts = [\n                                    date.getHours(),\n                                    date.getMinutes(),\n                                    date.getSeconds()\n                                ];\n                                target.value = parts.map((v)=>v.toString().padStart(2, \"0\")).join(\":\");\n                            } else {\n                                target.value = new Date(value - TIMEZONE_OFFSET).toISOString().split(datetimeType === \"date\" ? \"T\" : \".\", 1)[0];\n                            }\n                        } else {\n                            target.value = value;\n                        }\n                    }\n                    elementData.lastCommittedValue = target.value;\n                    elementData.commitKey = 1;\n                    if (!this.data.actions?.Focus) {\n                        elementData.focused = true;\n                    }\n                });\n                element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                    this.showElementAndHideCanvas(jsEvent.target);\n                    const actions = {\n                        value (event) {\n                            elementData.userValue = event.detail.value ?? \"\";\n                            if (!hasDateOrTime) {\n                                storage.setValue(id, {\n                                    value: elementData.userValue.toString()\n                                });\n                            }\n                            event.target.value = elementData.userValue;\n                        },\n                        formattedValue (event) {\n                            const { formattedValue } = event.detail;\n                            elementData.formattedValue = formattedValue;\n                            if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                                event.target.value = formattedValue;\n                            }\n                            const data = {\n                                formattedValue\n                            };\n                            if (hasDateOrTime) {\n                                data.value = formattedValue;\n                            }\n                            storage.setValue(id, data);\n                        },\n                        selRange (event) {\n                            event.target.setSelectionRange(...event.detail.selRange);\n                        },\n                        charLimit: (event)=>{\n                            const { charLimit } = event.detail;\n                            const { target } = event;\n                            if (charLimit === 0) {\n                                target.removeAttribute(\"maxLength\");\n                                return;\n                            }\n                            target.setAttribute(\"maxLength\", charLimit);\n                            let value = elementData.userValue;\n                            if (!value || value.length <= charLimit) {\n                                return;\n                            }\n                            value = value.slice(0, charLimit);\n                            target.value = elementData.userValue = value;\n                            storage.setValue(id, {\n                                value\n                            });\n                            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                source: this,\n                                detail: {\n                                    id,\n                                    name: \"Keystroke\",\n                                    value,\n                                    willCommit: true,\n                                    commitKey: 1,\n                                    selStart: target.selectionStart,\n                                    selEnd: target.selectionEnd\n                                }\n                            });\n                        }\n                    };\n                    this._dispatchEventFromSandbox(actions, jsEvent);\n                });\n                element.addEventListener(\"keydown\", (event)=>{\n                    elementData.commitKey = 1;\n                    let commitKey = -1;\n                    if (event.key === \"Escape\") {\n                        commitKey = 0;\n                    } else if (event.key === \"Enter\" && !this.data.multiLine) {\n                        commitKey = 2;\n                    } else if (event.key === \"Tab\") {\n                        elementData.commitKey = 3;\n                    }\n                    if (commitKey === -1) {\n                        return;\n                    }\n                    const { value } = event.target;\n                    if (elementData.lastCommittedValue === value) {\n                        return;\n                    }\n                    elementData.lastCommittedValue = value;\n                    elementData.userValue = value;\n                    this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                        source: this,\n                        detail: {\n                            id,\n                            name: \"Keystroke\",\n                            value,\n                            willCommit: true,\n                            commitKey,\n                            selStart: event.target.selectionStart,\n                            selEnd: event.target.selectionEnd\n                        }\n                    });\n                });\n                const _blurListener = blurListener;\n                blurListener = null;\n                element.addEventListener(\"blur\", (event)=>{\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    if (!this.data.actions?.Blur) {\n                        elementData.focused = false;\n                    }\n                    const { target } = event;\n                    let { value } = target;\n                    if (hasDateOrTime) {\n                        if (value && datetimeType === \"time\") {\n                            const parts = value.split(\":\").map((v)=>parseInt(v, 10));\n                            value = new Date(2000, 0, 1, parts[0], parts[1], parts[2] || 0).valueOf();\n                            target.step = \"\";\n                        } else {\n                            value = new Date(value).valueOf();\n                        }\n                        target.type = \"text\";\n                    }\n                    elementData.userValue = value;\n                    if (elementData.lastCommittedValue !== value) {\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value,\n                                willCommit: true,\n                                commitKey: elementData.commitKey,\n                                selStart: event.target.selectionStart,\n                                selEnd: event.target.selectionEnd\n                            }\n                        });\n                    }\n                    _blurListener(event);\n                });\n                if (this.data.actions?.Keystroke) {\n                    element.addEventListener(\"beforeinput\", (event)=>{\n                        elementData.lastCommittedValue = null;\n                        const { data, target } = event;\n                        const { value, selectionStart, selectionEnd } = target;\n                        let selStart = selectionStart, selEnd = selectionEnd;\n                        switch(event.inputType){\n                            case \"deleteWordBackward\":\n                                {\n                                    const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                                    if (match) {\n                                        selStart -= match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteWordForward\":\n                                {\n                                    const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                                    if (match) {\n                                        selEnd += match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteContentBackward\":\n                                if (selectionStart === selectionEnd) {\n                                    selStart -= 1;\n                                }\n                                break;\n                            case \"deleteContentForward\":\n                                if (selectionStart === selectionEnd) {\n                                    selEnd += 1;\n                                }\n                                break;\n                        }\n                        event.preventDefault();\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value,\n                                change: data || \"\",\n                                willCommit: false,\n                                selStart,\n                                selEnd\n                            }\n                        });\n                    });\n                }\n                this._setEventListeners(element, elementData, [\n                    [\n                        \"focus\",\n                        \"Focus\"\n                    ],\n                    [\n                        \"blur\",\n                        \"Blur\"\n                    ],\n                    [\n                        \"mousedown\",\n                        \"Mouse Down\"\n                    ],\n                    [\n                        \"mouseenter\",\n                        \"Mouse Enter\"\n                    ],\n                    [\n                        \"mouseleave\",\n                        \"Mouse Exit\"\n                    ],\n                    [\n                        \"mouseup\",\n                        \"Mouse Up\"\n                    ]\n                ], (event)=>event.target.value);\n            }\n            if (blurListener) {\n                element.addEventListener(\"blur\", blurListener);\n            }\n            if (this.data.comb) {\n                const fieldWidth = this.data.rect[2] - this.data.rect[0];\n                const combWidth = fieldWidth / maxLen;\n                element.classList.add(\"comb\");\n                element.style.letterSpacing = `calc(${combWidth}px * var(--total-scale-factor) - 1ch)`;\n            }\n        } else {\n            element = document.createElement(\"div\");\n            element.textContent = this.data.fieldValue;\n            element.style.verticalAlign = \"middle\";\n            element.style.display = \"table-cell\";\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n        }\n        this._setTextStyle(element);\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: !!parameters.data.hasOwnCanvas\n        });\n    }\n}\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value = storage.getValue(id, {\n            value: data.exportValue === data.fieldValue\n        }).value;\n        if (typeof value === \"string\") {\n            value = value !== \"Off\";\n            storage.setValue(id, {\n                value\n            });\n        }\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"checkbox\";\n        element.name = data.fieldName;\n        if (value) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.setAttribute(\"exportValue\", data.exportValue);\n        element.tabIndex = 0;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const checkbox of this._getElementsByName(name, id)){\n                const curChecked = checked && checkbox.exportValue === data.exportValue;\n                if (checkbox.domElement) {\n                    checkbox.domElement.checked = curChecked;\n                }\n                storage.setValue(checkbox.id, {\n                    value: curChecked\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue || \"Off\";\n            event.target.checked = defaultValue === data.exportValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        event.target.checked = event.detail.value !== \"Off\";\n                        storage.setValue(id, {\n                            value: event.target.checked\n                        });\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value = storage.getValue(id, {\n            value: data.fieldValue === data.buttonValue\n        }).value;\n        if (typeof value === \"string\") {\n            value = value !== data.buttonValue;\n            storage.setValue(id, {\n                value\n            });\n        }\n        if (value) {\n            for (const radio of this._getElementsByName(data.fieldName, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n        }\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"radio\";\n        element.name = data.fieldName;\n        if (value) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.tabIndex = 0;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const radio of this._getElementsByName(name, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue;\n            event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            const pdfButtonValue = data.buttonValue;\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value: (event)=>{\n                        const checked = pdfButtonValue === event.detail.value;\n                        for (const radio of this._getElementsByName(event.target.name)){\n                            const curChecked = checked && radio.id === id;\n                            if (radio.domElement) {\n                                radio.domElement.checked = curChecked;\n                            }\n                            storage.setValue(radio.id, {\n                                value: curChecked\n                            });\n                        }\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            ignoreBorder: parameters.data.hasAppearance\n        });\n    }\n    render() {\n        const container = super.render();\n        container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n        const linkElement = container.lastChild;\n        if (this.enableScripting && this.hasJSActions && linkElement) {\n            this._setDefaultPropertiesFromJS(linkElement);\n            linkElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                this._dispatchEventFromSandbox({}, jsEvent);\n            });\n        }\n        return container;\n    }\n}\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"choiceWidgetAnnotation\");\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        const storedData = storage.getValue(id, {\n            value: this.data.fieldValue\n        });\n        const selectElement = document.createElement(\"select\");\n        GetElementsByNameSet.add(selectElement);\n        selectElement.setAttribute(\"data-element-id\", id);\n        selectElement.disabled = this.data.readOnly;\n        this._setRequired(selectElement, this.data.required);\n        selectElement.name = this.data.fieldName;\n        selectElement.tabIndex = 0;\n        let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n        if (!this.data.combo) {\n            selectElement.size = this.data.options.length;\n            if (this.data.multiSelect) {\n                selectElement.multiple = true;\n            }\n        }\n        selectElement.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = this.data.defaultFieldValue;\n            for (const option of selectElement.options){\n                option.selected = option.value === defaultValue;\n            }\n        });\n        for (const option of this.data.options){\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = option.displayValue;\n            optionElement.value = option.exportValue;\n            if (storedData.value.includes(option.exportValue)) {\n                optionElement.setAttribute(\"selected\", true);\n                addAnEmptyEntry = false;\n            }\n            selectElement.append(optionElement);\n        }\n        let removeEmptyEntry = null;\n        if (addAnEmptyEntry) {\n            const noneOptionElement = document.createElement(\"option\");\n            noneOptionElement.value = \" \";\n            noneOptionElement.setAttribute(\"hidden\", true);\n            noneOptionElement.setAttribute(\"selected\", true);\n            selectElement.prepend(noneOptionElement);\n            removeEmptyEntry = ()=>{\n                noneOptionElement.remove();\n                selectElement.removeEventListener(\"input\", removeEmptyEntry);\n                removeEmptyEntry = null;\n            };\n            selectElement.addEventListener(\"input\", removeEmptyEntry);\n        }\n        const getValue = (isExport)=>{\n            const name = isExport ? \"value\" : \"textContent\";\n            const { options, multiple } = selectElement;\n            if (!multiple) {\n                return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n            }\n            return Array.prototype.filter.call(options, (option)=>option.selected).map((option)=>option[name]);\n        };\n        let selectedValues = getValue(false);\n        const getItems = (event)=>{\n            const options = event.target.options;\n            return Array.prototype.map.call(options, (option)=>({\n                    displayValue: option.textContent,\n                    exportValue: option.value\n                }));\n        };\n        if (this.enableScripting && this.hasJSActions) {\n            selectElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        removeEmptyEntry?.();\n                        const value = event.detail.value;\n                        const values = new Set(Array.isArray(value) ? value : [\n                            value\n                        ]);\n                        for (const option of selectElement.options){\n                            option.selected = values.has(option.value);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    multipleSelection (event) {\n                        selectElement.multiple = true;\n                    },\n                    remove (event) {\n                        const options = selectElement.options;\n                        const index = event.detail.remove;\n                        options[index].selected = false;\n                        selectElement.remove(index);\n                        if (options.length > 0) {\n                            const i = Array.prototype.findIndex.call(options, (option)=>option.selected);\n                            if (i === -1) {\n                                options[0].selected = true;\n                            }\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    clear (event) {\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        storage.setValue(id, {\n                            value: null,\n                            items: []\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    insert (event) {\n                        const { index, displayValue, exportValue } = event.detail.insert;\n                        const selectChild = selectElement.children[index];\n                        const optionElement = document.createElement(\"option\");\n                        optionElement.textContent = displayValue;\n                        optionElement.value = exportValue;\n                        if (selectChild) {\n                            selectChild.before(optionElement);\n                        } else {\n                            selectElement.append(optionElement);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    items (event) {\n                        const { items } = event.detail;\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        for (const item of items){\n                            const { displayValue, exportValue } = item;\n                            const optionElement = document.createElement(\"option\");\n                            optionElement.textContent = displayValue;\n                            optionElement.value = exportValue;\n                            selectElement.append(optionElement);\n                        }\n                        if (selectElement.options.length > 0) {\n                            selectElement.options[0].selected = true;\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    indices (event) {\n                        const indices = new Set(event.detail.indices);\n                        for (const option of event.target.options){\n                            option.selected = indices.has(option.index);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    editable (event) {\n                        event.target.disabled = !event.detail.editable;\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            selectElement.addEventListener(\"input\", (event)=>{\n                const exportValue = getValue(true);\n                const change = getValue(false);\n                storage.setValue(id, {\n                    value: exportValue\n                });\n                event.preventDefault();\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id,\n                        name: \"Keystroke\",\n                        value: selectedValues,\n                        change,\n                        changeEx: exportValue,\n                        willCommit: false,\n                        commitKey: 1,\n                        keyDown: false\n                    }\n                });\n            });\n            this._setEventListeners(selectElement, null, [\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ],\n                [\n                    \"input\",\n                    \"Action\"\n                ],\n                [\n                    \"input\",\n                    \"Validate\"\n                ]\n            ], (event)=>event.target.value);\n        } else {\n            selectElement.addEventListener(\"input\", function(event) {\n                storage.setValue(id, {\n                    value: getValue(true)\n                });\n            });\n        }\n        if (this.data.combo) {\n            this._setTextStyle(selectElement);\n        } else {}\n        this._setBackgroundColor(selectElement);\n        this._setDefaultPropertiesFromJS(selectElement);\n        this.container.append(selectElement);\n        return this.container;\n    }\n}\nclass PopupAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        const { data, elements } = parameters;\n        super(parameters, {\n            isRenderable: AnnotationElement._hasPopupData(data)\n        });\n        this.elements = elements;\n        this.popup = null;\n    }\n    render() {\n        const { container } = this;\n        container.classList.add(\"popupAnnotation\");\n        container.role = \"comment\";\n        const popup = this.popup = new PopupElement({\n            container: this.container,\n            color: this.data.color,\n            titleObj: this.data.titleObj,\n            modificationDate: this.data.modificationDate || this.data.creationDate,\n            contentsObj: this.data.contentsObj,\n            richText: this.data.richText,\n            rect: this.data.rect,\n            parentRect: this.data.parentRect || null,\n            parent: this.parent,\n            elements: this.elements,\n            open: this.data.open,\n            eventBus: this.linkService.eventBus\n        });\n        const elementIds = [];\n        for (const element of this.elements){\n            element.popup = popup;\n            element.container.ariaHasPopup = \"dialog\";\n            elementIds.push(element.data.id);\n            element.addHighlightArea();\n        }\n        this.container.setAttribute(\"aria-controls\", elementIds.map((id)=>`${AnnotationPrefix}${id}`).join(\",\"));\n        return this.container;\n    }\n}\nclass PopupElement {\n    #boundKeyDown;\n    #boundHide;\n    #boundShow;\n    #boundToggle;\n    #color;\n    #container;\n    #contentsObj;\n    #dateObj;\n    #elements;\n    #eventBus;\n    #parent;\n    #parentRect;\n    #pinned;\n    #popup;\n    #popupAbortController;\n    #position;\n    #commentButton;\n    #commentButtonPosition;\n    #commentButtonColor;\n    #rect;\n    #richText;\n    #titleObj;\n    #updates;\n    #wasVisible;\n    constructor({ container, color, elements, titleObj, modificationDate, contentsObj, richText, parent, rect, parentRect, open, eventBus = null }){\n        this.#boundKeyDown = this.#keyDown.bind(this);\n        this.#boundHide = this.#hide.bind(this);\n        this.#boundShow = this.#show.bind(this);\n        this.#boundToggle = this.#toggle.bind(this);\n        this.#color = null;\n        this.#container = null;\n        this.#contentsObj = null;\n        this.#dateObj = null;\n        this.#elements = null;\n        this.#eventBus = null;\n        this.#parent = null;\n        this.#parentRect = null;\n        this.#pinned = false;\n        this.#popup = null;\n        this.#popupAbortController = null;\n        this.#position = null;\n        this.#commentButton = null;\n        this.#commentButtonPosition = null;\n        this.#commentButtonColor = null;\n        this.#rect = null;\n        this.#richText = null;\n        this.#titleObj = null;\n        this.#updates = null;\n        this.#wasVisible = false;\n        this.#container = container;\n        this.#titleObj = titleObj;\n        this.#contentsObj = contentsObj;\n        this.#richText = richText;\n        this.#parent = parent;\n        this.#color = color;\n        this.#rect = rect;\n        this.#parentRect = parentRect;\n        this.#elements = elements;\n        this.#eventBus = eventBus;\n        this.#dateObj = PDFDateString.toDateObject(modificationDate);\n        this.trigger = elements.flatMap((e)=>e.getElementsToTriggerPopup());\n        this.#addEventListeners();\n        this.#container.hidden = true;\n        if (open) {\n            this.#toggle();\n        }\n    }\n    #addEventListeners() {\n        if (this.#popupAbortController) {\n            return;\n        }\n        this.#popupAbortController = new AbortController();\n        const { signal } = this.#popupAbortController;\n        for (const element of this.trigger){\n            element.addEventListener(\"click\", this.#boundToggle, {\n                signal\n            });\n            element.addEventListener(\"mouseenter\", this.#boundShow, {\n                signal\n            });\n            element.addEventListener(\"mouseleave\", this.#boundHide, {\n                signal\n            });\n            element.classList.add(\"popupTriggerArea\");\n        }\n        for (const element of this.#elements){\n            element.container?.addEventListener(\"keydown\", this.#boundKeyDown, {\n                signal\n            });\n        }\n        this.#renderCommentButton();\n    }\n    #setCommentButtonPosition() {\n        const element = this.#elements.find((e)=>e.hasCommentButton);\n        if (!element) {\n            return;\n        }\n        this.#commentButtonPosition = element._normalizePoint(element.commentButtonPosition);\n        this.#commentButtonColor = element.commentButtonColor;\n    }\n    #renderCommentButton() {\n        if (this.#commentButton) {\n            return;\n        }\n        if (!this.#commentButtonPosition) {\n            this.#setCommentButtonPosition();\n        }\n        if (!this.#commentButtonPosition) {\n            return;\n        }\n        const button = this.#commentButton = document.createElement(\"button\");\n        button.className = \"annotationCommentButton\";\n        const parentContainer = this.#elements[0].container;\n        button.style.zIndex = parentContainer.style.zIndex + 1;\n        button.tabIndex = 0;\n        const { signal } = this.#popupAbortController;\n        button.addEventListener(\"hover\", this.#boundToggle, {\n            signal\n        });\n        button.addEventListener(\"keydown\", this.#boundKeyDown, {\n            signal\n        });\n        button.addEventListener(\"click\", ()=>{\n            const [{ data: { id: editId }, annotationEditorType: mode }] = this.#elements;\n            this.#eventBus?.dispatch(\"switchannotationeditormode\", {\n                source: this,\n                editId,\n                mode,\n                editComment: true\n            });\n        }, {\n            signal\n        });\n        const { style } = button;\n        style.left = `calc(${this.#commentButtonPosition[0]}%)`;\n        style.top = `calc(${this.#commentButtonPosition[1]}% - var(--comment-button-dim))`;\n        if (this.#commentButtonColor) {\n            style.backgroundColor = this.#commentButtonColor;\n        }\n        parentContainer.after(button);\n    }\n    render() {\n        if (this.#popup) {\n            return;\n        }\n        const popup = this.#popup = document.createElement(\"div\");\n        popup.className = \"popup\";\n        if (this.#color) {\n            const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);\n            popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n        }\n        const header = document.createElement(\"span\");\n        header.className = \"header\";\n        if (this.#titleObj?.str) {\n            const title = document.createElement(\"span\");\n            title.className = \"title\";\n            header.append(title);\n            ({ dir: title.dir, str: title.textContent } = this.#titleObj);\n        }\n        popup.append(header);\n        if (this.#dateObj) {\n            const modificationDate = document.createElement(\"time\");\n            modificationDate.className = \"popupDate\";\n            modificationDate.setAttribute(\"data-l10n-id\", \"pdfjs-annotation-date-time-string\");\n            modificationDate.setAttribute(\"data-l10n-args\", JSON.stringify({\n                dateObj: this.#dateObj.valueOf()\n            }));\n            modificationDate.dateTime = this.#dateObj.toISOString();\n            header.append(modificationDate);\n        }\n        const html = this.#html;\n        if (html) {\n            XfaLayer.render({\n                xfaHtml: html,\n                intent: \"richText\",\n                div: popup\n            });\n            popup.lastChild.classList.add(\"richText\", \"popupContent\");\n        } else {\n            const contents = this._formatContents(this.#contentsObj);\n            popup.append(contents);\n        }\n        this.#container.append(popup);\n    }\n    get #html() {\n        const richText = this.#richText;\n        const contentsObj = this.#contentsObj;\n        if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n            return this.#richText.html || null;\n        }\n        return null;\n    }\n    get #fontSize() {\n        return this.#html?.attributes?.style?.fontSize || 0;\n    }\n    get #fontColor() {\n        return this.#html?.attributes?.style?.color || null;\n    }\n    #makePopupContent(text) {\n        const popupLines = [];\n        const popupContent = {\n            str: text,\n            html: {\n                name: \"div\",\n                attributes: {\n                    dir: \"auto\"\n                },\n                children: [\n                    {\n                        name: \"p\",\n                        children: popupLines\n                    }\n                ]\n            }\n        };\n        const lineAttributes = {\n            style: {\n                color: this.#fontColor,\n                fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--total-scale-factor))` : \"\"\n            }\n        };\n        for (const line of text.split(\"\\n\")){\n            popupLines.push({\n                name: \"span\",\n                value: line,\n                attributes: lineAttributes\n            });\n        }\n        return popupContent;\n    }\n    _formatContents({ str, dir }) {\n        const p = document.createElement(\"p\");\n        p.classList.add(\"popupContent\");\n        p.dir = dir;\n        const lines = str.split(/(?:\\r\\n?|\\n)/);\n        for(let i = 0, ii = lines.length; i < ii; ++i){\n            const line = lines[i];\n            p.append(document.createTextNode(line));\n            if (i < ii - 1) {\n                p.append(document.createElement(\"br\"));\n            }\n        }\n        return p;\n    }\n    #keyDown(event) {\n        if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n            return;\n        }\n        if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n            this.#toggle();\n        }\n    }\n    updateEdited({ rect, popup, deleted }) {\n        if (deleted || popup?.deleted) {\n            this.remove();\n            return;\n        }\n        this.#addEventListeners();\n        this.#updates ||= {\n            contentsObj: this.#contentsObj,\n            richText: this.#richText\n        };\n        if (rect) {\n            this.#position = null;\n        }\n        if (popup) {\n            this.#richText = this.#makePopupContent(popup.text);\n            this.#dateObj = PDFDateString.toDateObject(popup.date);\n            this.#contentsObj = null;\n        }\n        this.#popup?.remove();\n        this.#popup = null;\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        ({ contentsObj: this.#contentsObj, richText: this.#richText } = this.#updates);\n        this.#updates = null;\n        this.#popup?.remove();\n        this.#popup = null;\n        this.#position = null;\n    }\n    remove() {\n        this.#popupAbortController?.abort();\n        this.#popupAbortController = null;\n        this.#popup?.remove();\n        this.#popup = null;\n        this.#wasVisible = false;\n        this.#pinned = false;\n        for (const element of this.trigger){\n            element.classList.remove(\"popupTriggerArea\");\n        }\n    }\n    #setPosition() {\n        if (this.#position !== null) {\n            return;\n        }\n        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.#parent;\n        let useParentRect = !!this.#parentRect;\n        let rect = useParentRect ? this.#parentRect : this.#rect;\n        for (const element of this.#elements){\n            if (!rect || Util.intersect(element.data.rect, rect) !== null) {\n                rect = element.data.rect;\n                useParentRect = true;\n                break;\n            }\n        }\n        const normalizedRect = Util.normalizeRect([\n            rect[0],\n            view[3] - rect[1] + view[1],\n            rect[2],\n            view[3] - rect[3] + view[1]\n        ]);\n        const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n        const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n        const popupLeft = normalizedRect[0] + parentWidth;\n        const popupTop = normalizedRect[1];\n        this.#position = [\n            100 * (popupLeft - pageX) / pageWidth,\n            100 * (popupTop - pageY) / pageHeight\n        ];\n        const { style } = this.#container;\n        style.left = `${this.#position[0]}%`;\n        style.top = `${this.#position[1]}%`;\n    }\n    #toggle() {\n        this.#pinned = !this.#pinned;\n        if (this.#pinned) {\n            this.#show();\n            this.#container.addEventListener(\"click\", this.#boundToggle);\n            this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n        } else {\n            this.#hide();\n            this.#container.removeEventListener(\"click\", this.#boundToggle);\n            this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n        }\n    }\n    #show() {\n        if (!this.#popup) {\n            this.render();\n        }\n        if (!this.isVisible) {\n            this.#setPosition();\n            this.#container.hidden = false;\n            this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n        } else if (this.#pinned) {\n            this.#container.classList.add(\"focused\");\n        }\n    }\n    #hide() {\n        this.#container.classList.remove(\"focused\");\n        if (this.#pinned || !this.isVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n        this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n    }\n    forceHide() {\n        this.#wasVisible = this.isVisible;\n        if (!this.#wasVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n    }\n    maybeShow() {\n        this.#addEventListeners();\n        if (!this.#wasVisible) {\n            return;\n        }\n        if (!this.#popup) {\n            this.#show();\n        }\n        this.#wasVisible = false;\n        this.#container.hidden = false;\n    }\n    get isVisible() {\n        return this.#container.hidden === false;\n    }\n}\nclass FreeTextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.textContent = parameters.data.textContent;\n        this.textPosition = parameters.data.textPosition;\n        this.annotationEditorType = AnnotationEditorType.FREETEXT;\n    }\n    render() {\n        this.container.classList.add(\"freeTextAnnotation\");\n        if (this.textContent) {\n            const content = document.createElement(\"div\");\n            content.classList.add(\"annotationTextContent\");\n            content.setAttribute(\"role\", \"comment\");\n            for (const line of this.textContent){\n                const lineSpan = document.createElement(\"span\");\n                lineSpan.textContent = line;\n                content.append(lineSpan);\n            }\n            this.container.append(content);\n        }\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass LineAnnotationElement extends AnnotationElement {\n    #line;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#line = null;\n    }\n    render() {\n        this.container.classList.add(\"lineAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n        line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n        line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n        line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n        line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n        line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n        line.setAttribute(\"stroke\", \"transparent\");\n        line.setAttribute(\"fill\", \"transparent\");\n        svg.append(line);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#line;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass SquareAnnotationElement extends AnnotationElement {\n    #square;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#square = null;\n    }\n    render() {\n        this.container.classList.add(\"squareAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n        square.setAttribute(\"x\", borderWidth / 2);\n        square.setAttribute(\"y\", borderWidth / 2);\n        square.setAttribute(\"width\", width - borderWidth);\n        square.setAttribute(\"height\", height - borderWidth);\n        square.setAttribute(\"stroke-width\", borderWidth || 1);\n        square.setAttribute(\"stroke\", \"transparent\");\n        square.setAttribute(\"fill\", \"transparent\");\n        svg.append(square);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#square;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass CircleAnnotationElement extends AnnotationElement {\n    #circle;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#circle = null;\n    }\n    render() {\n        this.container.classList.add(\"circleAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n        circle.setAttribute(\"cx\", width / 2);\n        circle.setAttribute(\"cy\", height / 2);\n        circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n        circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n        circle.setAttribute(\"stroke-width\", borderWidth || 1);\n        circle.setAttribute(\"stroke\", \"transparent\");\n        circle.setAttribute(\"fill\", \"transparent\");\n        svg.append(circle);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#circle;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolylineAnnotationElement extends AnnotationElement {\n    #polyline;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polyline = null;\n        this.containerClassName = \"polylineAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, vertices, borderStyle, popupRef }, width, height } = this;\n        if (!vertices) {\n            return this.container;\n        }\n        const svg = this.svgFactory.create(width, height, true);\n        let points = [];\n        for(let i = 0, ii = vertices.length; i < ii; i += 2){\n            const x = vertices[i] - rect[0];\n            const y = rect[3] - vertices[i + 1];\n            points.push(`${x},${y}`);\n        }\n        points = points.join(\" \");\n        const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n        polyline.setAttribute(\"points\", points);\n        polyline.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        polyline.setAttribute(\"stroke\", \"transparent\");\n        polyline.setAttribute(\"fill\", \"transparent\");\n        svg.append(polyline);\n        this.container.append(svg);\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#polyline;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n    constructor(parameters){\n        super(parameters);\n        this.containerClassName = \"polygonAnnotation\";\n        this.svgElementName = \"svg:polygon\";\n    }\n}\nclass CaretAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"caretAnnotation\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n}\nclass InkAnnotationElement extends AnnotationElement {\n    #polylinesGroupElement;\n    #polylines;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polylinesGroupElement = null;\n        this.#polylines = [];\n        this.containerClassName = \"inkAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n        this.annotationEditorType = this.data.it === \"InkHighlight\" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;\n    }\n    #getTransform(rotation, rect) {\n        switch(rotation){\n            case 90:\n                return {\n                    transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,\n                    width: rect[3] - rect[1],\n                    height: rect[2] - rect[0]\n                };\n            case 180:\n                return {\n                    transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,\n                    width: rect[2] - rect[0],\n                    height: rect[3] - rect[1]\n                };\n            case 270:\n                return {\n                    transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,\n                    width: rect[3] - rect[1],\n                    height: rect[2] - rect[0]\n                };\n            default:\n                return {\n                    transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,\n                    width: rect[2] - rect[0],\n                    height: rect[3] - rect[1]\n                };\n        }\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, rotation, inkLists, borderStyle, popupRef } } = this;\n        const { transform, width, height } = this.#getTransform(rotation, rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const g = this.#polylinesGroupElement = this.svgFactory.createElement(\"svg:g\");\n        svg.append(g);\n        g.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        g.setAttribute(\"stroke-linecap\", \"round\");\n        g.setAttribute(\"stroke-linejoin\", \"round\");\n        g.setAttribute(\"stroke-miterlimit\", 10);\n        g.setAttribute(\"stroke\", \"transparent\");\n        g.setAttribute(\"fill\", \"transparent\");\n        g.setAttribute(\"transform\", transform);\n        for(let i = 0, ii = inkLists.length; i < ii; i++){\n            const polyline = this.svgFactory.createElement(this.svgElementName);\n            this.#polylines.push(polyline);\n            polyline.setAttribute(\"points\", inkLists[i].join(\",\"));\n            g.append(polyline);\n        }\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(svg);\n        this._editOnDoubleClick();\n        return this.container;\n    }\n    updateEdited(params) {\n        super.updateEdited(params);\n        const { thickness, points, rect } = params;\n        const g = this.#polylinesGroupElement;\n        if (thickness >= 0) {\n            g.setAttribute(\"stroke-width\", thickness || 1);\n        }\n        if (points) {\n            for(let i = 0, ii = this.#polylines.length; i < ii; i++){\n                this.#polylines[i].setAttribute(\"points\", points[i].join(\",\"));\n            }\n        }\n        if (rect) {\n            const { transform, width, height } = this.#getTransform(this.data.rotation, rect);\n            const root = g.parentElement;\n            root.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n            g.setAttribute(\"transform\", transform);\n        }\n    }\n    getElementsToTriggerPopup() {\n        return this.#polylines;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n    get commentButtonPosition() {\n        const { inkLists, rect } = this.data;\n        if (inkLists?.length >= 1) {\n            let maxX = -Infinity;\n            let maxY = -Infinity;\n            for (const inkList of inkLists){\n                for(let i = 0, ii = inkList.length; i < ii; i += 2){\n                    if (inkList[i + 1] > maxY) {\n                        maxY = inkList[i + 1];\n                        maxX = inkList[i];\n                    } else if (inkList[i + 1] === maxY) {\n                        maxX = Math.max(maxX, inkList[i]);\n                    }\n                }\n            }\n            if (maxX !== Infinity) {\n                return [\n                    maxX,\n                    maxY\n                ];\n            }\n        }\n        if (rect) {\n            return [\n                rect[2],\n                rect[3]\n            ];\n        }\n        return null;\n    }\n}\nclass HighlightAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n        this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"highlightAnnotation\");\n        this._editOnDoubleClick();\n        if (overlaidText) {\n            const mark = document.createElement(\"mark\");\n            mark.classList.add(\"overlaidText\");\n            mark.textContent = overlaidText;\n            this.container.append(mark);\n        }\n        return this.container;\n    }\n}\nclass UnderlineAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"underlineAnnotation\");\n        if (overlaidText) {\n            const underline = document.createElement(\"u\");\n            underline.classList.add(\"overlaidText\");\n            underline.textContent = overlaidText;\n            this.container.append(underline);\n        }\n        return this.container;\n    }\n}\nclass SquigglyAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"squigglyAnnotation\");\n        if (overlaidText) {\n            const underline = document.createElement(\"u\");\n            underline.classList.add(\"overlaidText\");\n            underline.textContent = overlaidText;\n            this.container.append(underline);\n        }\n        return this.container;\n    }\n}\nclass StrikeOutAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"strikeoutAnnotation\");\n        if (overlaidText) {\n            const strikeout = document.createElement(\"s\");\n            strikeout.classList.add(\"overlaidText\");\n            strikeout.textContent = overlaidText;\n            this.container.append(strikeout);\n        }\n        return this.container;\n    }\n}\nclass StampAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.annotationEditorType = AnnotationEditorType.STAMP;\n    }\n    render() {\n        this.container.classList.add(\"stampAnnotation\");\n        this.container.setAttribute(\"role\", \"img\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n    #trigger;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n        this.#trigger = null;\n        const { file } = this.data;\n        this.filename = file.filename;\n        this.content = file.content;\n        this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n            source: this,\n            ...file\n        });\n    }\n    render() {\n        this.container.classList.add(\"fileAttachmentAnnotation\");\n        const { container, data } = this;\n        let trigger;\n        if (data.hasAppearance || data.fillAlpha === 0) {\n            trigger = document.createElement(\"div\");\n        } else {\n            trigger = document.createElement(\"img\");\n            trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n            if (data.fillAlpha && data.fillAlpha < 1) {\n                trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n            }\n        }\n        trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n        this.#trigger = trigger;\n        const { isMac } = util_FeatureTest.platform;\n        container.addEventListener(\"keydown\", (evt)=>{\n            if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n                this.#download();\n            }\n        });\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        } else {\n            trigger.classList.add(\"popupTriggerArea\");\n        }\n        container.append(trigger);\n        return container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#trigger;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n    #download() {\n        this.downloadManager?.openOrDownloadData(this.content, this.filename);\n    }\n}\nclass AnnotationLayer {\n    #accessibilityManager;\n    #annotationCanvasMap;\n    #editableAnnotations;\n    #structTreeLayer;\n    constructor({ div, accessibilityManager, annotationCanvasMap, annotationEditorUIManager, page, viewport, structTreeLayer }){\n        this.#accessibilityManager = null;\n        this.#annotationCanvasMap = null;\n        this.#editableAnnotations = new Map();\n        this.#structTreeLayer = null;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationCanvasMap = annotationCanvasMap;\n        this.#structTreeLayer = structTreeLayer || null;\n        this.page = page;\n        this.viewport = viewport;\n        this.zIndex = 0;\n        this._annotationEditorUIManager = annotationEditorUIManager;\n    }\n    hasEditableAnnotations() {\n        return this.#editableAnnotations.size > 0;\n    }\n    async #appendElement(element, id, popupElements) {\n        const contentElement = element.firstChild || element;\n        const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;\n        const ariaAttributes = await this.#structTreeLayer?.getAriaAttributes(annotationId);\n        if (ariaAttributes) {\n            for (const [key, value] of ariaAttributes){\n                contentElement.setAttribute(key, value);\n            }\n        }\n        if (popupElements) {\n            popupElements.at(-1).container.after(element);\n        } else {\n            this.div.append(element);\n            this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n        }\n    }\n    async render(params) {\n        const { annotations } = params;\n        const layer = this.div;\n        setLayerDimensions(layer, this.viewport);\n        const popupToElements = new Map();\n        const elementParams = {\n            data: null,\n            layer,\n            linkService: params.linkService,\n            downloadManager: params.downloadManager,\n            imageResourcesPath: params.imageResourcesPath || \"\",\n            renderForms: params.renderForms !== false,\n            svgFactory: new DOMSVGFactory(),\n            annotationStorage: params.annotationStorage || new AnnotationStorage(),\n            enableComment: params.enableComment === true,\n            enableScripting: params.enableScripting === true,\n            hasJSActions: params.hasJSActions,\n            fieldObjects: params.fieldObjects,\n            parent: this,\n            elements: null\n        };\n        for (const data of annotations){\n            if (data.noHTML) {\n                continue;\n            }\n            const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;\n            if (!isPopupAnnotation) {\n                if (data.rect[2] === data.rect[0] || data.rect[3] === data.rect[1]) {\n                    continue;\n                }\n            } else {\n                const elements = popupToElements.get(data.id);\n                if (!elements) {\n                    continue;\n                }\n                elementParams.elements = elements;\n            }\n            elementParams.data = data;\n            const element = AnnotationElementFactory.create(elementParams);\n            if (!element.isRenderable) {\n                continue;\n            }\n            if (!isPopupAnnotation && data.popupRef) {\n                const elements = popupToElements.get(data.popupRef);\n                if (!elements) {\n                    popupToElements.set(data.popupRef, [\n                        element\n                    ]);\n                } else {\n                    elements.push(element);\n                }\n            }\n            const rendered = element.render();\n            if (data.hidden) {\n                rendered.style.visibility = \"hidden\";\n            }\n            await this.#appendElement(rendered, data.id, elementParams.elements);\n            if (element._isEditable) {\n                this.#editableAnnotations.set(element.data.id, element);\n                this._annotationEditorUIManager?.renderAnnotationElement(element);\n            }\n        }\n        this.#setAnnotationCanvasMap();\n    }\n    async addLinkAnnotations(annotations, linkService) {\n        const elementParams = {\n            data: null,\n            layer: this.div,\n            linkService,\n            svgFactory: new DOMSVGFactory(),\n            parent: this\n        };\n        for (const data of annotations){\n            data.borderStyle ||= AnnotationLayer._defaultBorderStyle;\n            elementParams.data = data;\n            const element = AnnotationElementFactory.create(elementParams);\n            if (!element.isRenderable) {\n                continue;\n            }\n            const rendered = element.render();\n            await this.#appendElement(rendered, data.id, null);\n        }\n    }\n    update({ viewport }) {\n        const layer = this.div;\n        this.viewport = viewport;\n        setLayerDimensions(layer, {\n            rotation: viewport.rotation\n        });\n        this.#setAnnotationCanvasMap();\n        layer.hidden = false;\n    }\n    #setAnnotationCanvasMap() {\n        if (!this.#annotationCanvasMap) {\n            return;\n        }\n        const layer = this.div;\n        for (const [id, canvas] of this.#annotationCanvasMap){\n            const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n            if (!element) {\n                continue;\n            }\n            canvas.className = \"annotationContent\";\n            const { firstChild } = element;\n            if (!firstChild) {\n                element.append(canvas);\n            } else if (firstChild.nodeName === \"CANVAS\") {\n                firstChild.replaceWith(canvas);\n            } else if (!firstChild.classList.contains(\"annotationContent\")) {\n                firstChild.before(canvas);\n            } else {\n                firstChild.after(canvas);\n            }\n            const editableAnnotation = this.#editableAnnotations.get(id);\n            if (!editableAnnotation) {\n                continue;\n            }\n            if (editableAnnotation._hasNoCanvas) {\n                this._annotationEditorUIManager?.setMissingCanvas(id, element.id, canvas);\n                editableAnnotation._hasNoCanvas = false;\n            } else {\n                editableAnnotation.canvas = canvas;\n            }\n        }\n        this.#annotationCanvasMap.clear();\n    }\n    getEditableAnnotations() {\n        return Array.from(this.#editableAnnotations.values());\n    }\n    getEditableAnnotation(id) {\n        return this.#editableAnnotations.get(id);\n    }\n    static get _defaultBorderStyle() {\n        return shadow(this, \"_defaultBorderStyle\", Object.freeze({\n            width: 1,\n            rawWidth: 1,\n            style: AnnotationBorderStyleType.SOLID,\n            dashArray: [\n                3\n            ],\n            horizontalCornerRadius: 0,\n            verticalCornerRadius: 0\n        }));\n    }\n}\n; // ./src/display/editor/freetext.js\nconst EOL_PATTERN = /\\r\\n?|\\n/g;\nclass FreeTextEditor extends AnnotationEditor {\n    #color;\n    #content;\n    #editorDivId;\n    #editModeAC;\n    #fontSize;\n    static{\n        this._freeTextDefaultContent = \"\";\n    }\n    static{\n        this._internalPadding = 0;\n    }\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultFontSize = 10;\n    }\n    static get _keyboardManager() {\n        const proto = FreeTextEditor.prototype;\n        const arrowChecker = (self)=>self.isEmpty();\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+s\",\n                    \"mac+meta+s\",\n                    \"ctrl+p\",\n                    \"mac+meta+p\"\n                ],\n                proto.commitOrRemove,\n                {\n                    bubbles: true\n                }\n            ],\n            [\n                [\n                    \"ctrl+Enter\",\n                    \"mac+meta+Enter\",\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.commitOrRemove\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    static{\n        this._type = \"freetext\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.FREETEXT;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"freeTextEditor\"\n        });\n        this.#content = \"\";\n        this.#editorDivId = `${this.id}-editor`;\n        this.#editModeAC = null;\n        this._colorPicker = null;\n        this.#color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;\n        this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(\"pdfjs-editor-freetext-added-alert\");\n        }\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        const style = getComputedStyle(document.documentElement);\n        this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                FreeTextEditor._defaultFontSize = value;\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                FreeTextEditor._defaultColor = value;\n                break;\n        }\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                this.#updateFontSize(value);\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                this.#updateColor(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                FreeTextEditor._defaultFontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                this.#fontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                this.#color\n            ]\n        ];\n    }\n    get toolbarButtons() {\n        this._colorPicker ||= new BasicColorPicker(this);\n        return [\n            [\n                \"colorPicker\",\n                this._colorPicker\n            ]\n        ];\n    }\n    get colorType() {\n        return AnnotationEditorParamsType.FREETEXT_COLOR;\n    }\n    get colorValue() {\n        return this.#color;\n    }\n    #updateFontSize(fontSize) {\n        const setFontsize = (size)=>{\n            this.editorDiv.style.fontSize = `calc(${size}px * var(--total-scale-factor))`;\n            this.translate(0, -(size - this.#fontSize) * this.parentScale);\n            this.#fontSize = size;\n            this.#setEditorDimensions();\n        };\n        const savedFontsize = this.#fontSize;\n        this.addCommands({\n            cmd: setFontsize.bind(this, fontSize),\n            undo: setFontsize.bind(this, savedFontsize),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_SIZE,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    #updateColor(color) {\n        const setColor = (col)=>{\n            this.#color = this.editorDiv.style.color = col;\n            this._colorPicker?.update(col);\n        };\n        const savedColor = this.#color;\n        this.addCommands({\n            cmd: setColor.bind(this, color),\n            undo: setColor.bind(this, savedColor),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _translateEmpty(x, y) {\n        this._uiManager.translateSelectedEditors(x, y, true);\n    }\n    getInitialTranslation() {\n        const scale = this.parentScale;\n        return [\n            -FreeTextEditor._internalPadding * scale,\n            -(FreeTextEditor._internalPadding + this.#fontSize) * scale\n        ];\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    enableEditMode() {\n        if (!super.enableEditMode()) {\n            return false;\n        }\n        this.overlayDiv.classList.remove(\"enabled\");\n        this.editorDiv.contentEditable = true;\n        this._isDraggable = false;\n        this.div.removeAttribute(\"aria-activedescendant\");\n        this.#editModeAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#editModeAC);\n        this.editorDiv.addEventListener(\"keydown\", this.editorDivKeydown.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"focus\", this.editorDivFocus.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"blur\", this.editorDivBlur.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"input\", this.editorDivInput.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"paste\", this.editorDivPaste.bind(this), {\n            signal\n        });\n        return true;\n    }\n    disableEditMode() {\n        if (!super.disableEditMode()) {\n            return false;\n        }\n        this.overlayDiv.classList.add(\"enabled\");\n        this.editorDiv.contentEditable = false;\n        this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n        this._isDraggable = true;\n        this.#editModeAC?.abort();\n        this.#editModeAC = null;\n        this.div.focus({\n            preventScroll: true\n        });\n        this.isEditing = false;\n        this.parent.div.classList.add(\"freetextEditing\");\n        return true;\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        super.focusin(event);\n        if (event.target !== this.editorDiv) {\n            this.editorDiv.focus();\n        }\n    }\n    onceAdded(focus) {\n        if (this.width) {\n            return;\n        }\n        this.enableEditMode();\n        if (focus) {\n            this.editorDiv.focus();\n        }\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        }\n        this._initialOptions = null;\n    }\n    isEmpty() {\n        return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n    }\n    remove() {\n        this.isEditing = false;\n        if (this.parent) {\n            this.parent.setEditingState(true);\n            this.parent.div.classList.add(\"freetextEditing\");\n        }\n        super.remove();\n    }\n    #extractText() {\n        const buffer = [];\n        this.editorDiv.normalize();\n        let prevChild = null;\n        for (const child of this.editorDiv.childNodes){\n            if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === \"BR\") {\n                continue;\n            }\n            buffer.push(FreeTextEditor.#getNodeContent(child));\n            prevChild = child;\n        }\n        return buffer.join(\"\\n\");\n    }\n    #setEditorDimensions() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        let rect;\n        if (this.isAttachedToDOM) {\n            rect = this.div.getBoundingClientRect();\n        } else {\n            const { currentLayer, div } = this;\n            const savedDisplay = div.style.display;\n            const savedVisibility = div.classList.contains(\"hidden\");\n            div.classList.remove(\"hidden\");\n            div.style.display = \"hidden\";\n            currentLayer.div.append(this.div);\n            rect = div.getBoundingClientRect();\n            div.remove();\n            div.style.display = savedDisplay;\n            div.classList.toggle(\"hidden\", savedVisibility);\n        }\n        if (this.rotation % 180 === this.parentRotation % 180) {\n            this.width = rect.width / parentWidth;\n            this.height = rect.height / parentHeight;\n        } else {\n            this.width = rect.height / parentWidth;\n            this.height = rect.width / parentHeight;\n        }\n        this.fixAndSetPosition();\n    }\n    commit() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        super.commit();\n        this.disableEditMode();\n        const savedText = this.#content;\n        const newText = this.#content = this.#extractText().trimEnd();\n        if (savedText === newText) {\n            return;\n        }\n        const setText = (text)=>{\n            this.#content = text;\n            if (!text) {\n                this.remove();\n                return;\n            }\n            this.#setContent();\n            this._uiManager.rebuild(this);\n            this.#setEditorDimensions();\n        };\n        this.addCommands({\n            cmd: ()=>{\n                setText(newText);\n            },\n            undo: ()=>{\n                setText(savedText);\n            },\n            mustExec: false\n        });\n        this.#setEditorDimensions();\n    }\n    shouldGetKeyboardEvents() {\n        return this.isInEditMode();\n    }\n    enterInEditMode() {\n        this.enableEditMode();\n        this.editorDiv.focus();\n    }\n    keydown(event) {\n        if (event.target === this.div && event.key === \"Enter\") {\n            this.enterInEditMode();\n            event.preventDefault();\n        }\n    }\n    editorDivKeydown(event) {\n        FreeTextEditor._keyboardManager.exec(this, event);\n    }\n    editorDivFocus(event) {\n        this.isEditing = true;\n    }\n    editorDivBlur(event) {\n        this.isEditing = false;\n    }\n    editorDivInput(event) {\n        this.parent.div.classList.toggle(\"freetextEditing\", this.isEmpty());\n    }\n    disableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"comment\");\n        this.editorDiv.removeAttribute(\"aria-multiline\");\n    }\n    enableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"textbox\");\n        this.editorDiv.setAttribute(\"aria-multiline\", true);\n    }\n    get canChangeContent() {\n        return true;\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy || this.annotationElementId) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.editorDiv = document.createElement(\"div\");\n        this.editorDiv.className = \"internal\";\n        this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n        this.editorDiv.setAttribute(\"data-l10n-id\", \"pdfjs-free-text2\");\n        this.editorDiv.setAttribute(\"data-l10n-attrs\", \"default-content\");\n        this.enableEditing();\n        this.editorDiv.contentEditable = true;\n        const { style } = this.editorDiv;\n        style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;\n        style.color = this.#color;\n        this.div.append(this.editorDiv);\n        this.overlayDiv = document.createElement(\"div\");\n        this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n        this.div.append(this.overlayDiv);\n        if (this._isCopy || this.annotationElementId) {\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            if (this.annotationElementId) {\n                const { position } = this._initialData;\n                let [tx, ty] = this.getInitialTranslation();\n                [tx, ty] = this.pageTranslationToScreen(tx, ty);\n                const [pageWidth, pageHeight] = this.pageDimensions;\n                const [pageX, pageY] = this.pageTranslation;\n                let posX, posY;\n                switch(this.rotation){\n                    case 0:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n                        break;\n                    case 90:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            ty,\n                            -tx\n                        ];\n                        break;\n                    case 180:\n                        posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            -tx,\n                            -ty\n                        ];\n                        break;\n                    case 270:\n                        posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n                        posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n                        [tx, ty] = [\n                            -ty,\n                            tx\n                        ];\n                        break;\n                }\n                this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n            } else {\n                this._moveAfterPaste(baseX, baseY);\n            }\n            this.#setContent();\n            this._isDraggable = true;\n            this.editorDiv.contentEditable = false;\n        } else {\n            this._isDraggable = false;\n            this.editorDiv.contentEditable = true;\n        }\n        return this.div;\n    }\n    static #getNodeContent(node) {\n        return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, \"\");\n    }\n    editorDivPaste(event) {\n        const clipboardData = event.clipboardData || window.clipboardData;\n        const { types } = clipboardData;\n        if (types.length === 1 && types[0] === \"text/plain\") {\n            return;\n        }\n        event.preventDefault();\n        const paste = FreeTextEditor.#deserializeContent(clipboardData.getData(\"text\") || \"\").replaceAll(EOL_PATTERN, \"\\n\");\n        if (!paste) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (!selection.rangeCount) {\n            return;\n        }\n        this.editorDiv.normalize();\n        selection.deleteFromDocument();\n        const range = selection.getRangeAt(0);\n        if (!paste.includes(\"\\n\")) {\n            range.insertNode(document.createTextNode(paste));\n            this.editorDiv.normalize();\n            selection.collapseToStart();\n            return;\n        }\n        const { startContainer, startOffset } = range;\n        const bufferBefore = [];\n        const bufferAfter = [];\n        if (startContainer.nodeType === Node.TEXT_NODE) {\n            const parent = startContainer.parentElement;\n            bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, \"\"));\n            if (parent !== this.editorDiv) {\n                let buffer = bufferBefore;\n                for (const child of this.editorDiv.childNodes){\n                    if (child === parent) {\n                        buffer = bufferAfter;\n                        continue;\n                    }\n                    buffer.push(FreeTextEditor.#getNodeContent(child));\n                }\n            }\n            bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, \"\"));\n        } else if (startContainer === this.editorDiv) {\n            let buffer = bufferBefore;\n            let i = 0;\n            for (const child of this.editorDiv.childNodes){\n                if (i++ === startOffset) {\n                    buffer = bufferAfter;\n                }\n                buffer.push(FreeTextEditor.#getNodeContent(child));\n            }\n        }\n        this.#content = `${bufferBefore.join(\"\\n\")}${paste}${bufferAfter.join(\"\\n\")}`;\n        this.#setContent();\n        const newRange = new Range();\n        let beforeLength = Math.sumPrecise(bufferBefore.map((line)=>line.length));\n        for (const { firstChild } of this.editorDiv.childNodes){\n            if (firstChild.nodeType === Node.TEXT_NODE) {\n                const length = firstChild.nodeValue.length;\n                if (beforeLength <= length) {\n                    newRange.setStart(firstChild, beforeLength);\n                    newRange.setEnd(firstChild, beforeLength);\n                    break;\n                }\n                beforeLength -= length;\n            }\n        }\n        selection.removeAllRanges();\n        selection.addRange(newRange);\n    }\n    #setContent() {\n        this.editorDiv.replaceChildren();\n        if (!this.#content) {\n            return;\n        }\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            this.editorDiv.append(div);\n        }\n    }\n    #serializeContent() {\n        return this.#content.replaceAll(\"\\xa0\", \" \");\n    }\n    static #deserializeContent(content) {\n        return content.replaceAll(\" \", \"\\xa0\");\n    }\n    get contentDiv() {\n        return this.editorDiv;\n    }\n    getPDFRect() {\n        const padding = FreeTextEditor._internalPadding * this.parentScale;\n        return this.getRect(padding, padding);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof FreeTextAnnotationElement) {\n            const { data: { defaultAppearanceData: { fontSize, fontColor }, rect, rotation, id, popupRef, contentsObj }, textContent, textPosition, parent: { page: { pageNumber } } } = data;\n            if (!textContent || textContent.length === 0) {\n                return null;\n            }\n            initialData = data = {\n                annotationType: AnnotationEditorType.FREETEXT,\n                color: Array.from(fontColor),\n                fontSize,\n                value: textContent.join(\"\\n\"),\n                position: textPosition,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                comment: contentsObj?.str || null\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.#fontSize = data.fontSize;\n        editor.#color = Util.makeHexColor(...data.color);\n        editor.#content = FreeTextEditor.#deserializeContent(data.value);\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data.comment);\n        }\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const rect = this.getPDFRect();\n        const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);\n        const serialized = {\n            annotationType: AnnotationEditorType.FREETEXT,\n            color,\n            fontSize: this.#fontSize,\n            value: this.#serializeContent(),\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId\n        };\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.isCopy = true;\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { value, fontSize, color, pageIndex } = this._initialData;\n        return this.hasEditedComment || this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i)=>c !== color[i]) || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        const content = super.renderAnnotationElement(annotation);\n        if (!content) {\n            return null;\n        }\n        const { style } = content;\n        style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;\n        style.color = this.#color;\n        content.replaceChildren();\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            content.append(div);\n        }\n        const params = {\n            rect: this.getPDFRect()\n        };\n        params.popup = this.hasEditedComment ? this.comment : {\n            text: this.#content\n        };\n        annotation.updateEdited(params);\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        super.resetAnnotationElement(annotation);\n        annotation.resetEdited();\n    }\n}\n; // ./src/display/editor/drawers/outline.js\nclass Outline {\n    static{\n        this.PRECISION = 1e-4;\n    }\n    toSVGPath() {\n        unreachable(\"Abstract method `toSVGPath` must be implemented.\");\n    }\n    get box() {\n        unreachable(\"Abstract getter `box` must be implemented.\");\n    }\n    serialize(_bbox, _rotation) {\n        unreachable(\"Abstract method `serialize` must be implemented.\");\n    }\n    static _rescale(src, tx, ty, sx, sy, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i] * sx;\n            dest[i + 1] = ty + src[i + 1] * sy;\n        }\n        return dest;\n    }\n    static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i + 1] * sx;\n            dest[i + 1] = ty + src[i] * sy;\n        }\n        return dest;\n    }\n    static _translate(src, tx, ty, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i];\n            dest[i + 1] = ty + src[i + 1];\n        }\n        return dest;\n    }\n    static svgRound(x) {\n        return Math.round(x * 10000);\n    }\n    static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y / parentWidth,\n                    x / parentHeight\n                ];\n            case 180:\n                return [\n                    1 - x / parentWidth,\n                    1 - y / parentHeight\n                ];\n            case 270:\n                return [\n                    y / parentWidth,\n                    1 - x / parentHeight\n                ];\n            default:\n                return [\n                    x / parentWidth,\n                    y / parentHeight\n                ];\n        }\n    }\n    static _normalizePagePoint(x, y, rotation) {\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y,\n                    x\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    static createBezierPoints(x1, y1, x2, y2, x3, y3) {\n        return [\n            (x1 + 5 * x2) / 6,\n            (y1 + 5 * y2) / 6,\n            (5 * x2 + x3) / 6,\n            (5 * y2 + y3) / 6,\n            (x2 + x3) / 2,\n            (y2 + y3) / 2\n        ];\n    }\n}\n; // ./src/display/editor/drawers/freedraw.js\nclass FreeDrawOutliner {\n    #box;\n    #bottom;\n    #innerMargin;\n    #isLTR;\n    #top;\n    #last;\n    #lastX;\n    #lastY;\n    #min;\n    #min_dist;\n    #scaleFactor;\n    #thickness;\n    #points;\n    static #MIN_DIST = 8;\n    static #MIN_DIFF = 2;\n    static #MIN = FreeDrawOutliner.#MIN_DIST + FreeDrawOutliner.#MIN_DIFF;\n    constructor({ x, y }, box, scaleFactor, thickness, isLTR, innerMargin = 0){\n        this.#bottom = [];\n        this.#top = [];\n        this.#last = new Float32Array(18);\n        this.#points = [];\n        this.#box = box;\n        this.#thickness = thickness * scaleFactor;\n        this.#isLTR = isLTR;\n        this.#last.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ], 6);\n        this.#innerMargin = innerMargin;\n        this.#min_dist = FreeDrawOutliner.#MIN_DIST * scaleFactor;\n        this.#min = FreeDrawOutliner.#MIN * scaleFactor;\n        this.#scaleFactor = scaleFactor;\n        this.#points.push(x, y);\n    }\n    isEmpty() {\n        return isNaN(this.#last[8]);\n    }\n    #getLastCoords() {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [x, y, width, height] = this.#box;\n        return [\n            (this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width,\n            (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height,\n            (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width,\n            (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height\n        ];\n    }\n    add({ x, y }) {\n        this.#lastX = x;\n        this.#lastY = y;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        let [x1, y1, x2, y2] = this.#last.subarray(8, 12);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(diffX, diffY);\n        if (d < this.#min) {\n            return false;\n        }\n        const diffD = d - this.#min_dist;\n        const K = diffD / d;\n        const shiftX = K * diffX;\n        const shiftY = K * diffY;\n        let x0 = x1;\n        let y0 = y1;\n        x1 = x2;\n        y1 = y2;\n        x2 += shiftX;\n        y2 += shiftY;\n        this.#points?.push(x, y);\n        const nX = -shiftY / diffD;\n        const nY = shiftX / diffD;\n        const thX = nX * this.#thickness;\n        const thY = nY * this.#thickness;\n        this.#last.set(this.#last.subarray(2, 8), 0);\n        this.#last.set([\n            x2 + thX,\n            y2 + thY\n        ], 4);\n        this.#last.set(this.#last.subarray(14, 18), 12);\n        this.#last.set([\n            x2 - thX,\n            y2 - thY\n        ], 16);\n        if (isNaN(this.#last[6])) {\n            if (this.#top.length === 0) {\n                this.#last.set([\n                    x1 + thX,\n                    y1 + thY\n                ], 2);\n                this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);\n                this.#last.set([\n                    x1 - thX,\n                    y1 - thY\n                ], 14);\n                this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);\n            }\n            this.#last.set([\n                x0,\n                y0,\n                x1,\n                y1,\n                x2,\n                y2\n            ], 6);\n            return !this.isEmpty();\n        }\n        this.#last.set([\n            x0,\n            y0,\n            x1,\n            y1,\n            x2,\n            y2\n        ], 6);\n        const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));\n        if (angle < Math.PI / 2) {\n            [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n            this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n            [x1, y1, x0, y0] = this.#last.subarray(14, 18);\n            this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);\n            return true;\n        }\n        [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);\n        this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);\n        this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        return true;\n    }\n    toSVGPath() {\n        if (this.isEmpty()) {\n            return \"\";\n        }\n        const top = this.#top;\n        const bottom = this.#bottom;\n        if (isNaN(this.#last[6]) && !this.isEmpty()) {\n            return this.#toSVGPathTwoPoints();\n        }\n        const buffer = [];\n        buffer.push(`M${top[4]} ${top[5]}`);\n        for(let i = 6; i < top.length; i += 6){\n            if (isNaN(top[i])) {\n                buffer.push(`L${top[i + 4]} ${top[i + 5]}`);\n            } else {\n                buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);\n            }\n        }\n        this.#toSVGPathEnd(buffer);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            if (isNaN(bottom[i])) {\n                buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);\n            } else {\n                buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);\n            }\n        }\n        this.#toSVGPathStart(buffer);\n        return buffer.join(\" \");\n    }\n    #toSVGPathTwoPoints() {\n        const [x, y, width, height] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;\n    }\n    #toSVGPathStart(buffer) {\n        const bottom = this.#bottom;\n        buffer.push(`L${bottom[4]} ${bottom[5]} Z`);\n    }\n    #toSVGPathEnd(buffer) {\n        const [x, y, width, height] = this.#box;\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);\n    }\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n    getOutlines() {\n        const top = this.#top;\n        const bottom = this.#bottom;\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const points = new Float32Array((this.#points?.length ?? 0) + 2);\n        for(let i = 0, ii = points.length - 2; i < ii; i += 2){\n            points[i] = (this.#points[i] - layerX) / layerWidth;\n            points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;\n        }\n        points[points.length - 2] = (this.#lastX - layerX) / layerWidth;\n        points[points.length - 1] = (this.#lastY - layerY) / layerHeight;\n        if (isNaN(last[6]) && !this.isEmpty()) {\n            return this.#getOutlineTwoPoints(points);\n        }\n        const outline = new Float32Array(this.#top.length + 24 + this.#bottom.length);\n        let N = top.length;\n        for(let i = 0; i < N; i += 2){\n            if (isNaN(top[i])) {\n                outline[i] = outline[i + 1] = NaN;\n                continue;\n            }\n            outline[i] = top[i];\n            outline[i + 1] = top[i + 1];\n        }\n        N = this.#getOutlineEnd(outline, N);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            for(let j = 0; j < 6; j += 2){\n                if (isNaN(bottom[i + j])) {\n                    outline[N] = outline[N + 1] = NaN;\n                    N += 2;\n                    continue;\n                }\n                outline[N] = bottom[i + j];\n                outline[N + 1] = bottom[i + j + 1];\n                N += 2;\n            }\n        }\n        this.#getOutlineStart(outline, N);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineTwoPoints(points) {\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        const outline = new Float32Array(36);\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[2] - layerX) / layerWidth,\n            (last[3] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[4] - layerX) / layerWidth,\n            (last[5] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[16] - layerX) / layerWidth,\n            (last[17] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[14] - layerX) / layerWidth,\n            (last[15] - layerY) / layerHeight\n        ], 0);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineStart(outline, pos) {\n        const bottom = this.#bottom;\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            bottom[4],\n            bottom[5]\n        ], pos);\n        return pos += 6;\n    }\n    #getOutlineEnd(outline, pos) {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastTop[0] - layerX) / layerWidth,\n            (lastTop[1] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastBottom[0] - layerX) / layerWidth,\n            (lastBottom[1] - layerY) / layerHeight\n        ], pos);\n        return pos += 24;\n    }\n}\nclass FreeDrawOutline extends Outline {\n    #box;\n    #bbox;\n    #innerMargin;\n    #isLTR;\n    #points;\n    #scaleFactor;\n    #outline;\n    constructor(outline, points, box, scaleFactor, innerMargin, isLTR){\n        super();\n        this.#bbox = new Float32Array(4);\n        this.#outline = outline;\n        this.#points = points;\n        this.#box = box;\n        this.#scaleFactor = scaleFactor;\n        this.#innerMargin = innerMargin;\n        this.#isLTR = isLTR;\n        this.lastPoint = [\n            NaN,\n            NaN\n        ];\n        this.#computeMinMax(isLTR);\n        const [x, y, width, height] = this.#bbox;\n        for(let i = 0, ii = outline.length; i < ii; i += 2){\n            outline[i] = (outline[i] - x) / width;\n            outline[i + 1] = (outline[i + 1] - y) / height;\n        }\n        for(let i = 0, ii = points.length; i < ii; i += 2){\n            points[i] = (points[i] - x) / width;\n            points[i + 1] = (points[i + 1] - y) / height;\n        }\n    }\n    toSVGPath() {\n        const buffer = [\n            `M${this.#outline[4]} ${this.#outline[5]}`\n        ];\n        for(let i = 6, ii = this.#outline.length; i < ii; i += 6){\n            if (isNaN(this.#outline[i])) {\n                buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n                continue;\n            }\n            buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n        }\n        buffer.push(\"Z\");\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], rotation) {\n        const width = trX - blX;\n        const height = trY - blY;\n        let outline;\n        let points;\n        switch(rotation){\n            case 0:\n                outline = Outline._rescale(this.#outline, blX, trY, width, -height);\n                points = Outline._rescale(this.#points, blX, trY, width, -height);\n                break;\n            case 90:\n                outline = Outline._rescaleAndSwap(this.#outline, blX, blY, width, height);\n                points = Outline._rescaleAndSwap(this.#points, blX, blY, width, height);\n                break;\n            case 180:\n                outline = Outline._rescale(this.#outline, trX, blY, -width, height);\n                points = Outline._rescale(this.#points, trX, blY, -width, height);\n                break;\n            case 270:\n                outline = Outline._rescaleAndSwap(this.#outline, trX, trY, -width, -height);\n                points = Outline._rescaleAndSwap(this.#points, trX, trY, -width, -height);\n                break;\n        }\n        return {\n            outline: Array.from(outline),\n            points: [\n                Array.from(points)\n            ]\n        };\n    }\n    #computeMinMax(isLTR) {\n        const outline = this.#outline;\n        let lastX = outline[4];\n        let lastY = outline[5];\n        const minMax = [\n            lastX,\n            lastY,\n            lastX,\n            lastY\n        ];\n        let lastPointX = lastX;\n        let lastPointY = lastY;\n        const ltrCallback = isLTR ? Math.max : Math.min;\n        for(let i = 6, ii = outline.length; i < ii; i += 6){\n            const x = outline[i + 4], y = outline[i + 5];\n            if (isNaN(outline[i])) {\n                Util.pointBoundingBox(x, y, minMax);\n                if (lastPointY < y) {\n                    lastPointX = x;\n                    lastPointY = y;\n                } else if (lastPointY === y) {\n                    lastPointX = ltrCallback(lastPointX, x);\n                }\n            } else {\n                const bbox = [\n                    Infinity,\n                    Infinity,\n                    -Infinity,\n                    -Infinity\n                ];\n                Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6), bbox);\n                Util.rectBoundingBox(...bbox, minMax);\n                if (lastPointY < bbox[3]) {\n                    lastPointX = bbox[2];\n                    lastPointY = bbox[3];\n                } else if (lastPointY === bbox[3]) {\n                    lastPointX = ltrCallback(lastPointX, bbox[2]);\n                }\n            }\n            lastX = x;\n            lastY = y;\n        }\n        const bbox = this.#bbox;\n        bbox[0] = minMax[0] - this.#innerMargin;\n        bbox[1] = minMax[1] - this.#innerMargin;\n        bbox[2] = minMax[2] - minMax[0] + 2 * this.#innerMargin;\n        bbox[3] = minMax[3] - minMax[1] + 2 * this.#innerMargin;\n        this.lastPoint = [\n            lastPointX,\n            lastPointY\n        ];\n    }\n    get box() {\n        return this.#bbox;\n    }\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n    getNewOutline(thickness, innerMargin) {\n        const [x, y, width, height] = this.#bbox;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const sx = width * layerWidth;\n        const sy = height * layerHeight;\n        const tx = x * layerWidth + layerX;\n        const ty = y * layerHeight + layerY;\n        const outliner = this.newOutliner({\n            x: this.#points[0] * sx + tx,\n            y: this.#points[1] * sy + ty\n        }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);\n        for(let i = 2; i < this.#points.length; i += 2){\n            outliner.add({\n                x: this.#points[i] * sx + tx,\n                y: this.#points[i + 1] * sy + ty\n            });\n        }\n        return outliner.getOutlines();\n    }\n}\n; // ./src/display/editor/drawers/highlight.js\nclass HighlightOutliner {\n    #box;\n    #lastPoint;\n    #verticalEdges;\n    #intervals;\n    constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true){\n        this.#verticalEdges = [];\n        this.#intervals = [];\n        const minMax = [\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ];\n        const NUMBER_OF_DIGITS = 4;\n        const EPSILON = 10 ** -NUMBER_OF_DIGITS;\n        for (const { x, y, width, height } of boxes){\n            const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;\n            const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;\n            const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;\n            const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;\n            const left = [\n                x1,\n                y1,\n                y2,\n                true\n            ];\n            const right = [\n                x2,\n                y1,\n                y2,\n                false\n            ];\n            this.#verticalEdges.push(left, right);\n            Util.rectBoundingBox(x1, y1, x2, y2, minMax);\n        }\n        const bboxWidth = minMax[2] - minMax[0] + 2 * innerMargin;\n        const bboxHeight = minMax[3] - minMax[1] + 2 * innerMargin;\n        const shiftedMinX = minMax[0] - innerMargin;\n        const shiftedMinY = minMax[1] - innerMargin;\n        const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);\n        const lastPoint = [\n            lastEdge[0],\n            lastEdge[2]\n        ];\n        for (const edge of this.#verticalEdges){\n            const [x, y1, y2] = edge;\n            edge[0] = (x - shiftedMinX) / bboxWidth;\n            edge[1] = (y1 - shiftedMinY) / bboxHeight;\n            edge[2] = (y2 - shiftedMinY) / bboxHeight;\n        }\n        this.#box = new Float32Array([\n            shiftedMinX,\n            shiftedMinY,\n            bboxWidth,\n            bboxHeight\n        ]);\n        this.#lastPoint = lastPoint;\n    }\n    getOutlines() {\n        this.#verticalEdges.sort((a, b)=>a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);\n        const outlineVerticalEdges = [];\n        for (const edge of this.#verticalEdges){\n            if (edge[3]) {\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n                this.#insert(edge);\n            } else {\n                this.#remove(edge);\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n            }\n        }\n        return this.#getOutlines(outlineVerticalEdges);\n    }\n    #getOutlines(outlineVerticalEdges) {\n        const edges = [];\n        const allEdges = new Set();\n        for (const edge of outlineVerticalEdges){\n            const [x, y1, y2] = edge;\n            edges.push([\n                x,\n                y1,\n                edge\n            ], [\n                x,\n                y2,\n                edge\n            ]);\n        }\n        edges.sort((a, b)=>a[1] - b[1] || a[0] - b[0]);\n        for(let i = 0, ii = edges.length; i < ii; i += 2){\n            const edge1 = edges[i][2];\n            const edge2 = edges[i + 1][2];\n            edge1.push(edge2);\n            edge2.push(edge1);\n            allEdges.add(edge1);\n            allEdges.add(edge2);\n        }\n        const outlines = [];\n        let outline;\n        while(allEdges.size > 0){\n            const edge = allEdges.values().next().value;\n            let [x, y1, y2, edge1, edge2] = edge;\n            allEdges.delete(edge);\n            let lastPointX = x;\n            let lastPointY = y1;\n            outline = [\n                x,\n                y2\n            ];\n            outlines.push(outline);\n            while(true){\n                let e;\n                if (allEdges.has(edge1)) {\n                    e = edge1;\n                } else if (allEdges.has(edge2)) {\n                    e = edge2;\n                } else {\n                    break;\n                }\n                allEdges.delete(e);\n                [x, y1, y2, edge1, edge2] = e;\n                if (lastPointX !== x) {\n                    outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);\n                    lastPointX = x;\n                }\n                lastPointY = lastPointY === y1 ? y2 : y1;\n            }\n            outline.push(lastPointX, lastPointY);\n        }\n        return new HighlightOutline(outlines, this.#box, this.#lastPoint);\n    }\n    #binarySearch(y) {\n        const array = this.#intervals;\n        let start = 0;\n        let end = array.length - 1;\n        while(start <= end){\n            const middle = start + end >> 1;\n            const y1 = array[middle][0];\n            if (y1 === y) {\n                return middle;\n            }\n            if (y1 < y) {\n                start = middle + 1;\n            } else {\n                end = middle - 1;\n            }\n        }\n        return end + 1;\n    }\n    #insert([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        this.#intervals.splice(index, 0, [\n            y1,\n            y2\n        ]);\n    }\n    #remove([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        for(let i = index; i < this.#intervals.length; i++){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n        for(let i = index - 1; i >= 0; i--){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n    }\n    #breakEdge(edge) {\n        const [x, y1, y2] = edge;\n        const results = [\n            [\n                x,\n                y1,\n                y2\n            ]\n        ];\n        const index = this.#binarySearch(y2);\n        for(let i = 0; i < index; i++){\n            const [start, end] = this.#intervals[i];\n            for(let j = 0, jj = results.length; j < jj; j++){\n                const [, y3, y4] = results[j];\n                if (end <= y3 || y4 <= start) {\n                    continue;\n                }\n                if (y3 >= start) {\n                    if (y4 > end) {\n                        results[j][1] = end;\n                    } else {\n                        if (jj === 1) {\n                            return [];\n                        }\n                        results.splice(j, 1);\n                        j--;\n                        jj--;\n                    }\n                    continue;\n                }\n                results[j][2] = start;\n                if (y4 > end) {\n                    results.push([\n                        x,\n                        end,\n                        y4\n                    ]);\n                }\n            }\n        }\n        return results;\n    }\n}\nclass HighlightOutline extends Outline {\n    #box;\n    #outlines;\n    constructor(outlines, box, lastPoint){\n        super();\n        this.#outlines = outlines;\n        this.#box = box;\n        this.lastPoint = lastPoint;\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const polygon of this.#outlines){\n            let [prevX, prevY] = polygon;\n            buffer.push(`M${prevX} ${prevY}`);\n            for(let i = 2; i < polygon.length; i += 2){\n                const x = polygon[i];\n                const y = polygon[i + 1];\n                if (x === prevX) {\n                    buffer.push(`V${y}`);\n                    prevY = y;\n                } else if (y === prevY) {\n                    buffer.push(`H${x}`);\n                    prevX = x;\n                }\n            }\n            buffer.push(\"Z\");\n        }\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], _rotation) {\n        const outlines = [];\n        const width = trX - blX;\n        const height = trY - blY;\n        for (const outline of this.#outlines){\n            const points = new Array(outline.length);\n            for(let i = 0; i < outline.length; i += 2){\n                points[i] = blX + outline[i] * width;\n                points[i + 1] = trY - outline[i + 1] * height;\n            }\n            outlines.push(points);\n        }\n        return outlines;\n    }\n    get box() {\n        return this.#box;\n    }\n    get classNamesForOutlining() {\n        return [\n            \"highlightOutline\"\n        ];\n    }\n}\nclass FreeHighlightOutliner extends FreeDrawOutliner {\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n}\nclass FreeHighlightOutline extends FreeDrawOutline {\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n}\n; // ./src/display/editor/highlight.js\nclass HighlightEditor extends AnnotationEditor {\n    #anchorNode;\n    #anchorOffset;\n    #boxes;\n    #clipPathId;\n    #colorPicker;\n    #focusOutlines;\n    #focusNode;\n    #focusOffset;\n    #highlightDiv;\n    #highlightOutlines;\n    #id;\n    #isFreeHighlight;\n    #lastPoint;\n    #opacity;\n    #outlineId;\n    #text;\n    #thickness;\n    #methodOfCreation;\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultOpacity = 1;\n    }\n    static{\n        this._defaultThickness = 12;\n    }\n    static{\n        this._type = \"highlight\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    static{\n        this._freeHighlightId = -1;\n    }\n    static{\n        this._freeHighlight = null;\n    }\n    static{\n        this._freeHighlightClipId = \"\";\n    }\n    static get _keyboardManager() {\n        const proto = HighlightEditor.prototype;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        1\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        2\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        3\n                    ]\n                }\n            ]\n        ]));\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"highlightEditor\"\n        });\n        this.#anchorNode = null;\n        this.#anchorOffset = 0;\n        this.#clipPathId = null;\n        this.#colorPicker = null;\n        this.#focusOutlines = null;\n        this.#focusNode = null;\n        this.#focusOffset = 0;\n        this.#highlightDiv = null;\n        this.#highlightOutlines = null;\n        this.#id = null;\n        this.#isFreeHighlight = false;\n        this.#lastPoint = null;\n        this.#outlineId = null;\n        this.#text = \"\";\n        this.#methodOfCreation = \"\";\n        this.color = params.color || HighlightEditor._defaultColor;\n        this.#thickness = params.thickness || HighlightEditor._defaultThickness;\n        this.#opacity = params.opacity || HighlightEditor._defaultOpacity;\n        this.#boxes = params.boxes || null;\n        this.#methodOfCreation = params.methodOfCreation || \"\";\n        this.#text = params.text || \"\";\n        this._isDraggable = false;\n        this.defaultL10nId = \"pdfjs-editor-highlight-editor\";\n        if (params.highlightId > -1) {\n            this.#isFreeHighlight = true;\n            this.#createFreeOutlines(params);\n            this.#addToDrawLayer();\n        } else if (this.#boxes) {\n            this.#anchorNode = params.anchorNode;\n            this.#anchorOffset = params.anchorOffset;\n            this.#focusNode = params.focusNode;\n            this.#focusOffset = params.focusOffset;\n            this.#createOutlines();\n            this.#addToDrawLayer();\n            this.rotate(this.rotation);\n        }\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(\"pdfjs-editor-highlight-added-alert\");\n        }\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\",\n            type: this.#isFreeHighlight ? \"free_highlight\" : \"highlight\",\n            color: this._uiManager.getNonHCMColorName(this.color),\n            thickness: this.#thickness,\n            methodOfCreation: this.#methodOfCreation\n        };\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"highlight\",\n            color: this._uiManager.getNonHCMColorName(this.color)\n        };\n    }\n    get commentColor() {\n        return this.color;\n    }\n    static computeTelemetryFinalData(data) {\n        return {\n            numberOfColors: data.get(\"color\").size\n        };\n    }\n    #createOutlines() {\n        const outliner = new HighlightOutliner(this.#boxes, 0.001);\n        this.#highlightOutlines = outliner.getOutlines();\n        [this.x, this.y, this.width, this.height] = this.#highlightOutlines.box;\n        const outlinerForOutline = new HighlightOutliner(this.#boxes, 0.0025, 0.001, this._uiManager.direction === \"ltr\");\n        this.#focusOutlines = outlinerForOutline.getOutlines();\n        const { lastPoint } = this.#focusOutlines;\n        this.#lastPoint = [\n            (lastPoint[0] - this.x) / this.width,\n            (lastPoint[1] - this.y) / this.height\n        ];\n    }\n    #createFreeOutlines({ highlightOutlines, highlightId, clipPathId }) {\n        this.#highlightOutlines = highlightOutlines;\n        const extraThickness = 1.5;\n        this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 0.0025);\n        if (highlightId >= 0) {\n            this.#id = highlightId;\n            this.#clipPathId = clipPathId;\n            this.parent.drawLayer.finalizeDraw(highlightId, {\n                bbox: highlightOutlines.box,\n                path: {\n                    d: highlightOutlines.toSVGPath()\n                }\n            });\n            this.#outlineId = this.parent.drawLayer.drawOutline({\n                rootClass: {\n                    highlightOutline: true,\n                    free: true\n                },\n                bbox: this.#focusOutlines.box,\n                path: {\n                    d: this.#focusOutlines.toSVGPath()\n                }\n            }, true);\n        } else if (this.parent) {\n            const angle = this.parent.viewport.rotation;\n            this.parent.drawLayer.updateProperties(this.#id, {\n                bbox: HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360),\n                path: {\n                    d: highlightOutlines.toSVGPath()\n                }\n            });\n            this.parent.drawLayer.updateProperties(this.#outlineId, {\n                bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n                path: {\n                    d: this.#focusOutlines.toSVGPath()\n                }\n            });\n        }\n        const [x, y, width, height] = highlightOutlines.box;\n        switch(this.rotation){\n            case 0:\n                this.x = x;\n                this.y = y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = y;\n                    this.y = 1 - x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n            case 180:\n                this.x = 1 - x;\n                this.y = 1 - y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = 1 - y;\n                    this.y = x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n        }\n        const { lastPoint } = this.#focusOutlines;\n        this.#lastPoint = [\n            (lastPoint[0] - x) / width,\n            (lastPoint[1] - y) / height\n        ];\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || \"#fff066\";\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n                HighlightEditor._defaultColor = value;\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                HighlightEditor._defaultThickness = value;\n                break;\n        }\n    }\n    translateInPage(x, y) {}\n    get toolbarPosition() {\n        return this.#lastPoint;\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n                this.#updateColor(value);\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                this.#updateThickness(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n                HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                HighlightEditor._defaultThickness\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n                this.color || HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                this.#thickness || HighlightEditor._defaultThickness\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                this.#isFreeHighlight\n            ]\n        ];\n    }\n    #updateColor(color) {\n        const setColorAndOpacity = (col, opa)=>{\n            this.color = col;\n            this.#opacity = opa;\n            this.parent?.drawLayer.updateProperties(this.#id, {\n                root: {\n                    fill: col,\n                    \"fill-opacity\": opa\n                }\n            });\n            this.#colorPicker?.updateColor(col);\n        };\n        const savedColor = this.color;\n        const savedOpacity = this.#opacity;\n        this.addCommands({\n            cmd: setColorAndOpacity.bind(this, color, HighlightEditor._defaultOpacity),\n            undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"color_changed\",\n            color: this._uiManager.getNonHCMColorName(color)\n        }, true);\n    }\n    #updateThickness(thickness) {\n        const savedThickness = this.#thickness;\n        const setThickness = (th)=>{\n            this.#thickness = th;\n            this.#changeThickness(th);\n        };\n        this.addCommands({\n            cmd: setThickness.bind(this, thickness),\n            undo: setThickness.bind(this, savedThickness),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.INK_THICKNESS,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"thickness_changed\",\n            thickness\n        }, true);\n    }\n    get toolbarButtons() {\n        if (this._uiManager.highlightColors) {\n            const colorPicker = this.#colorPicker = new ColorPicker({\n                editor: this\n            });\n            return [\n                [\n                    \"colorPicker\",\n                    colorPicker\n                ]\n            ];\n        }\n        return super.toolbarButtons;\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    fixAndSetPosition() {\n        return super.fixAndSetPosition(this.#getRotation());\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    getRect(tx, ty) {\n        return super.getRect(tx, ty, this.#getRotation());\n    }\n    onceAdded(focus) {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        if (focus) {\n            this.div.focus();\n        }\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        this._reportTelemetry({\n            action: \"deleted\"\n        });\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        this.show(this._isVisible);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #changeThickness(thickness) {\n        if (!this.#isFreeHighlight) {\n            return;\n        }\n        this.#createFreeOutlines({\n            highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)\n        });\n        this.fixAndSetPosition();\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(this.width * parentWidth, this.height * parentHeight);\n    }\n    #cleanDrawLayer() {\n        if (this.#id === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this.#id);\n        this.#id = null;\n        this.parent.drawLayer.remove(this.#outlineId);\n        this.#outlineId = null;\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this.#id !== null) {\n            return;\n        }\n        ({ id: this.#id, clipPathId: this.#clipPathId } = parent.drawLayer.draw({\n            bbox: this.#highlightOutlines.box,\n            root: {\n                viewBox: \"0 0 1 1\",\n                fill: this.color,\n                \"fill-opacity\": this.#opacity\n            },\n            rootClass: {\n                highlight: true,\n                free: this.#isFreeHighlight\n            },\n            path: {\n                d: this.#highlightOutlines.toSVGPath()\n            }\n        }, false, true));\n        this.#outlineId = parent.drawLayer.drawOutline({\n            rootClass: {\n                highlightOutline: true,\n                free: this.#isFreeHighlight\n            },\n            bbox: this.#focusOutlines.box,\n            path: {\n                d: this.#focusOutlines.toSVGPath()\n            }\n        }, this.#isFreeHighlight);\n        if (this.#highlightDiv) {\n            this.#highlightDiv.style.clipPath = this.#clipPathId;\n        }\n    }\n    static #rotateBbox([x, y, width, height], angle) {\n        switch(angle){\n            case 90:\n                return [\n                    1 - y - height,\n                    x,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    1 - x - width,\n                    1 - y - height,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x - width,\n                    height,\n                    width\n                ];\n        }\n        return [\n            x,\n            y,\n            width,\n            height\n        ];\n    }\n    rotate(angle) {\n        const { drawLayer } = this.parent;\n        let box;\n        if (this.#isFreeHighlight) {\n            angle = (angle - this.rotation + 360) % 360;\n            box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);\n        } else {\n            box = HighlightEditor.#rotateBbox([\n                this.x,\n                this.y,\n                this.width,\n                this.height\n            ], angle);\n        }\n        drawLayer.updateProperties(this.#id, {\n            bbox: box,\n            root: {\n                \"data-main-rotation\": angle\n            }\n        });\n        drawLayer.updateProperties(this.#outlineId, {\n            bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n            root: {\n                \"data-main-rotation\": angle\n            }\n        });\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        const div = super.render();\n        if (this.#text) {\n            div.setAttribute(\"aria-label\", this.#text);\n            div.setAttribute(\"role\", \"mark\");\n        }\n        if (this.#isFreeHighlight) {\n            div.classList.add(\"free\");\n        } else {\n            this.div.addEventListener(\"keydown\", this.#keydown.bind(this), {\n                signal: this._uiManager._signal\n            });\n        }\n        const highlightDiv = this.#highlightDiv = document.createElement(\"div\");\n        div.append(highlightDiv);\n        highlightDiv.setAttribute(\"aria-hidden\", \"true\");\n        highlightDiv.className = \"internal\";\n        highlightDiv.style.clipPath = this.#clipPathId;\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(this.width * parentWidth, this.height * parentHeight);\n        bindEvents(this, this.#highlightDiv, [\n            \"pointerover\",\n            \"pointerleave\"\n        ]);\n        this.enableEditing();\n        return div;\n    }\n    pointerover() {\n        if (!this.isSelected) {\n            this.parent?.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hovered: true\n                }\n            });\n        }\n    }\n    pointerleave() {\n        if (!this.isSelected) {\n            this.parent?.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hovered: false\n                }\n            });\n        }\n    }\n    #keydown(event) {\n        HighlightEditor._keyboardManager.exec(this, event);\n    }\n    _moveCaret(direction) {\n        this.parent.unselect(this);\n        switch(direction){\n            case 0:\n            case 2:\n                this.#setCaret(true);\n                break;\n            case 1:\n            case 3:\n                this.#setCaret(false);\n                break;\n        }\n    }\n    #setCaret(start) {\n        if (!this.#anchorNode) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (start) {\n            selection.setPosition(this.#anchorNode, this.#anchorOffset);\n        } else {\n            selection.setPosition(this.#focusNode, this.#focusOffset);\n        }\n    }\n    select() {\n        super.select();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.updateProperties(this.#outlineId, {\n            rootClass: {\n                hovered: false,\n                selected: true\n            }\n        });\n    }\n    unselect() {\n        super.unselect();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.updateProperties(this.#outlineId, {\n            rootClass: {\n                selected: false\n            }\n        });\n        if (!this.#isFreeHighlight) {\n            this.#setCaret(false);\n        }\n    }\n    get _mustFixPosition() {\n        return !this.#isFreeHighlight;\n    }\n    show(visible = this._isVisible) {\n        super.show(visible);\n        if (this.parent) {\n            this.parent.drawLayer.updateProperties(this.#id, {\n                rootClass: {\n                    hidden: !visible\n                }\n            });\n            this.parent.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hidden: !visible\n                }\n            });\n        }\n    }\n    #getRotation() {\n        return this.#isFreeHighlight ? this.rotation : 0;\n    }\n    #serializeBoxes() {\n        if (this.#isFreeHighlight) {\n            return null;\n        }\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const boxes = this.#boxes;\n        const quadPoints = new Float32Array(boxes.length * 8);\n        let i = 0;\n        for (const { x, y, width, height } of boxes){\n            const sx = x * pageWidth + pageX;\n            const sy = (1 - y) * pageHeight + pageY;\n            quadPoints[i] = quadPoints[i + 4] = sx;\n            quadPoints[i + 1] = quadPoints[i + 3] = sy;\n            quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;\n            quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;\n            i += 8;\n        }\n        return quadPoints;\n    }\n    #serializeOutlines(rect) {\n        return this.#highlightOutlines.serialize(rect, this.#getRotation());\n    }\n    static startHighlighting(parent, isLTR, { target: textLayer, x, y }) {\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        const ac = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        const pointerUpCallback = (e)=>{\n            ac.abort();\n            this.#endHighlight(parent, e);\n        };\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", stopEvent, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        textLayer.addEventListener(\"pointermove\", this.#highlightMove.bind(this, parent), {\n            signal\n        });\n        this._freeHighlight = new FreeHighlightOutliner({\n            x,\n            y\n        }, [\n            layerX,\n            layerY,\n            parentWidth,\n            parentHeight\n        ], parent.scale, this._defaultThickness / 2, isLTR, 0.001);\n        ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = parent.drawLayer.draw({\n            bbox: [\n                0,\n                0,\n                1,\n                1\n            ],\n            root: {\n                viewBox: \"0 0 1 1\",\n                fill: this._defaultColor,\n                \"fill-opacity\": this._defaultOpacity\n            },\n            rootClass: {\n                highlight: true,\n                free: true\n            },\n            path: {\n                d: this._freeHighlight.toSVGPath()\n            }\n        }, true, true));\n    }\n    static #highlightMove(parent, event) {\n        if (this._freeHighlight.add(event)) {\n            parent.drawLayer.updateProperties(this._freeHighlightId, {\n                path: {\n                    d: this._freeHighlight.toSVGPath()\n                }\n            });\n        }\n    }\n    static #endHighlight(parent, event) {\n        if (!this._freeHighlight.isEmpty()) {\n            parent.createAndAddNewEditor(event, false, {\n                highlightId: this._freeHighlightId,\n                highlightOutlines: this._freeHighlight.getOutlines(),\n                clipPathId: this._freeHighlightClipId,\n                methodOfCreation: \"main_toolbar\"\n            });\n        } else {\n            parent.drawLayer.remove(this._freeHighlightId);\n        }\n        this._freeHighlightId = -1;\n        this._freeHighlight = null;\n        this._freeHighlightClipId = \"\";\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof HighlightAnnotationElement) {\n            const { data: { quadPoints, rect, rotation, id, color, opacity, popupRef, contentsObj }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color),\n                opacity,\n                quadPoints,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                comment: contentsObj?.str || null\n            };\n        } else if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists, rect, rotation, id, color, borderStyle: { rawWidth: thickness }, popupRef, contentsObj }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color),\n                thickness,\n                inkLists,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                comment: contentsObj?.str || null\n            };\n        }\n        const { color, quadPoints, inkLists, opacity } = data;\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.color = Util.makeHexColor(...color);\n        editor.#opacity = opacity || 1;\n        if (inkLists) {\n            editor.#thickness = data.thickness;\n        }\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data.comment);\n        }\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [pageX, pageY] = editor.pageTranslation;\n        if (quadPoints) {\n            const boxes = editor.#boxes = [];\n            for(let i = 0; i < quadPoints.length; i += 8){\n                boxes.push({\n                    x: (quadPoints[i] - pageX) / pageWidth,\n                    y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,\n                    width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,\n                    height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight\n                });\n            }\n            editor.#createOutlines();\n            editor.#addToDrawLayer();\n            editor.rotate(editor.rotation);\n        } else if (inkLists) {\n            editor.#isFreeHighlight = true;\n            const points = inkLists[0];\n            const point = {\n                x: points[0] - pageX,\n                y: pageHeight - (points[1] - pageY)\n            };\n            const outliner = new FreeHighlightOutliner(point, [\n                0,\n                0,\n                pageWidth,\n                pageHeight\n            ], 1, editor.#thickness / 2, true, 0.001);\n            for(let i = 0, ii = points.length; i < ii; i += 2){\n                point.x = points[i] - pageX;\n                point.y = pageHeight - (points[i + 1] - pageY);\n                outliner.add(point);\n            }\n            const { id, clipPathId } = parent.drawLayer.draw({\n                bbox: [\n                    0,\n                    0,\n                    1,\n                    1\n                ],\n                root: {\n                    viewBox: \"0 0 1 1\",\n                    fill: editor.color,\n                    \"fill-opacity\": editor._defaultOpacity\n                },\n                rootClass: {\n                    highlight: true,\n                    free: true\n                },\n                path: {\n                    d: outliner.toSVGPath()\n                }\n            }, true, true);\n            editor.#createFreeOutlines({\n                highlightOutlines: outliner.getOutlines(),\n                highlightId: id,\n                clipPathId\n            });\n            editor.#addToDrawLayer();\n            editor.rotate(editor.parentRotation);\n        }\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty() || isForCopying) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const rect = this.getPDFRect();\n        const color = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));\n        const serialized = {\n            annotationType: AnnotationEditorType.HIGHLIGHT,\n            color,\n            opacity: this.#opacity,\n            thickness: this.#thickness,\n            quadPoints: this.#serializeBoxes(),\n            outlines: this.#serializeOutlines(rect),\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.#getRotation(),\n            structTreeParentId: this._structTreeParentId\n        };\n        this.addComment(serialized);\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color } = this._initialData;\n        return this.hasEditedComment || serialized.color.some((c, i)=>c !== color[i]);\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        const params = {\n            rect: this.getPDFRect()\n        };\n        if (this.hasEditedComment) {\n            params.popup = this.comment;\n        }\n        annotation.updateEdited(params);\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\n; // ./src/display/editor/draw.js\nclass DrawingOptions {\n    #svgProperties;\n    updateProperty(name, value) {\n        this[name] = value;\n        this.updateSVGProperty(name, value);\n    }\n    updateProperties(properties) {\n        if (!properties) {\n            return;\n        }\n        for (const [name, value] of Object.entries(properties)){\n            if (!name.startsWith(\"_\")) {\n                this.updateProperty(name, value);\n            }\n        }\n    }\n    updateSVGProperty(name, value) {\n        this.#svgProperties[name] = value;\n    }\n    toSVGProperties() {\n        const root = this.#svgProperties;\n        this.#svgProperties = Object.create(null);\n        return {\n            root\n        };\n    }\n    reset() {\n        this.#svgProperties = Object.create(null);\n    }\n    updateAll(options = this) {\n        this.updateProperties(options);\n    }\n    clone() {\n        unreachable(\"Not implemented\");\n    }\n    constructor(){\n        this.#svgProperties = Object.create(null);\n    }\n}\nclass DrawingEditor extends AnnotationEditor {\n    #drawOutlines;\n    #mustBeCommitted;\n    static{\n        this._currentDrawId = -1;\n    }\n    static{\n        this._currentParent = null;\n    }\n    static #currentDraw = null;\n    static #currentDrawingAC = null;\n    static #currentDrawingOptions = null;\n    static #currentPointerId = NaN;\n    static #currentPointerType = null;\n    static #currentPointerIds = null;\n    static #currentMoveTimestamp = NaN;\n    static{\n        this._INNER_MARGIN = 3;\n    }\n    constructor(params){\n        super(params);\n        this.#drawOutlines = null;\n        this._colorPicker = null;\n        this._drawId = null;\n        this.#mustBeCommitted = params.mustBeCommitted || false;\n        this._addOutlines(params);\n    }\n    _addOutlines(params) {\n        if (params.drawOutlines) {\n            this.#createDrawOutlines(params);\n            this.#addToDrawLayer();\n        }\n    }\n    #createDrawOutlines({ drawOutlines, drawId, drawingOptions }) {\n        this.#drawOutlines = drawOutlines;\n        this._drawingOptions ||= drawingOptions;\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`);\n        }\n        if (drawId >= 0) {\n            this._drawId = drawId;\n            this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);\n        } else {\n            this._drawId = this.#createDrawing(drawOutlines, this.parent);\n        }\n        this.#updateBbox(drawOutlines.box);\n    }\n    #createDrawing(drawOutlines, parent) {\n        const { id } = parent.drawLayer.draw(DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);\n        return id;\n    }\n    static _mergeSVGProperties(p1, p2) {\n        const p1Keys = new Set(Object.keys(p1));\n        for (const [key, value] of Object.entries(p2)){\n            if (p1Keys.has(key)) {\n                Object.assign(p1[key], value);\n            } else {\n                p1[key] = value;\n            }\n        }\n        return p1;\n    }\n    static getDefaultDrawingOptions(_options) {\n        unreachable(\"Not implemented\");\n    }\n    static get typesMap() {\n        unreachable(\"Not implemented\");\n    }\n    static get isDrawer() {\n        return true;\n    }\n    static get supportMultipleDrawings() {\n        return false;\n    }\n    static updateDefaultParams(type, value) {\n        const propertyName = this.typesMap.get(type);\n        if (propertyName) {\n            this._defaultDrawingOptions.updateProperty(propertyName, value);\n        }\n        if (this._currentParent) {\n            DrawingEditor.#currentDraw.updateProperty(propertyName, value);\n            this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n        }\n    }\n    updateParams(type, value) {\n        const propertyName = this.constructor.typesMap.get(type);\n        if (propertyName) {\n            this._updateProperty(type, propertyName, value);\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        const properties = [];\n        const options = this._defaultDrawingOptions;\n        for (const [type, name] of this.typesMap){\n            properties.push([\n                type,\n                options[name]\n            ]);\n        }\n        return properties;\n    }\n    get propertiesToUpdate() {\n        const properties = [];\n        const { _drawingOptions } = this;\n        for (const [type, name] of this.constructor.typesMap){\n            properties.push([\n                type,\n                _drawingOptions[name]\n            ]);\n        }\n        return properties;\n    }\n    _updateProperty(type, name, value) {\n        const options = this._drawingOptions;\n        const savedValue = options[name];\n        const setter = (val)=>{\n            options.updateProperty(name, val);\n            const bbox = this.#drawOutlines.updateProperty(name, val);\n            if (bbox) {\n                this.#updateBbox(bbox);\n            }\n            this.parent?.drawLayer.updateProperties(this._drawId, options.toSVGProperties());\n            if (type === this.colorType) {\n                this._colorPicker?.update(val);\n            }\n        };\n        this.addCommands({\n            cmd: setter.bind(this, value),\n            undo: setter.bind(this, savedValue),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _onResizing() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizingSVGProperties(this.#convertToDrawSpace()), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onResized() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizedSVGProperties(this.#convertToDrawSpace()), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onTranslating(_x, _y) {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            bbox: this.#rotateBox()\n        });\n    }\n    _onTranslated() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathTranslatedSVGProperties(this.#convertToDrawSpace(), this.parentDimensions), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onStartDragging() {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            rootClass: {\n                moving: true\n            }\n        });\n    }\n    _onStopDragging() {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            rootClass: {\n                moving: false\n            }\n        });\n    }\n    commit() {\n        super.commit();\n        this.disableEditMode();\n        this.disableEditing();\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    get isResizable() {\n        return true;\n    }\n    onceAdded(focus) {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        this._isDraggable = true;\n        if (this.#mustBeCommitted) {\n            this.#mustBeCommitted = false;\n            this.commit();\n            this.parent.setSelected(this);\n            if (focus && this.isOnScreen) {\n                this.div.focus();\n            }\n        }\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        this.#updateBbox(this.#drawOutlines.box);\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this._uiManager.removeShouldRescale(this);\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this._uiManager.addShouldRescale(this);\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #cleanDrawLayer() {\n        if (this._drawId === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this._drawId);\n        this._drawId = null;\n        this._drawingOptions.reset();\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this._drawId !== null && this.parent === parent) {\n            return;\n        }\n        if (this._drawId !== null) {\n            this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);\n            return;\n        }\n        this._drawingOptions.updateAll();\n        this._drawId = this.#createDrawing(this.#drawOutlines, parent);\n    }\n    #convertToParentSpace([x, y, width, height]) {\n        const { parentDimensions: [pW, pH], rotation } = this;\n        switch(rotation){\n            case 90:\n                return [\n                    y,\n                    1 - x,\n                    width * (pH / pW),\n                    height * (pW / pH)\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    1 - y,\n                    x,\n                    width * (pH / pW),\n                    height * (pW / pH)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    #convertToDrawSpace() {\n        const { x, y, width, height, parentDimensions: [pW, pH], rotation } = this;\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y,\n                    x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    #updateBbox(bbox) {\n        [this.x, this.y, this.width, this.height] = this.#convertToParentSpace(bbox);\n        if (this.div) {\n            this.fixAndSetPosition();\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            this.setDims(this.width * parentWidth, this.height * parentHeight);\n        }\n        this._onResized();\n    }\n    #rotateBox() {\n        const { x, y, width, height, rotation, parentRotation, parentDimensions: [pW, pH] } = this;\n        switch((rotation * 4 + parentRotation) / 90){\n            case 1:\n                return [\n                    1 - y - height,\n                    x,\n                    height,\n                    width\n                ];\n            case 2:\n                return [\n                    1 - x - width,\n                    1 - y - height,\n                    width,\n                    height\n                ];\n            case 3:\n                return [\n                    y,\n                    1 - x - width,\n                    height,\n                    width\n                ];\n            case 4:\n                return [\n                    x,\n                    y - width * (pW / pH),\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 5:\n                return [\n                    1 - y,\n                    x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 6:\n                return [\n                    1 - x - height * (pH / pW),\n                    1 - y,\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 7:\n                return [\n                    y - width * (pW / pH),\n                    1 - x - height * (pH / pW),\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 8:\n                return [\n                    x - width,\n                    y - height,\n                    width,\n                    height\n                ];\n            case 9:\n                return [\n                    1 - y,\n                    x - width,\n                    height,\n                    width\n                ];\n            case 10:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 11:\n                return [\n                    y - height,\n                    1 - x,\n                    height,\n                    width\n                ];\n            case 12:\n                return [\n                    x - height * (pH / pW),\n                    y,\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 13:\n                return [\n                    1 - y - width * (pW / pH),\n                    x - height * (pH / pW),\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 14:\n                return [\n                    1 - x,\n                    1 - y - width * (pW / pH),\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 15:\n                return [\n                    y,\n                    1 - x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    rotate() {\n        if (!this.parent) {\n            return;\n        }\n        this.parent.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties({\n            bbox: this.#rotateBox()\n        }, this.#drawOutlines.updateRotation((this.parentRotation - this.rotation + 360) % 360)));\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        this.#updateBbox(this.#drawOutlines.updateParentDimensions(this.parentDimensions, this.parent.scale));\n    }\n    static onScaleChangingWhenDrawing() {}\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        const div = super.render();\n        div.classList.add(\"draw\");\n        const drawDiv = document.createElement(\"div\");\n        div.append(drawDiv);\n        drawDiv.setAttribute(\"aria-hidden\", \"true\");\n        drawDiv.className = \"internal\";\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(this.width * parentWidth, this.height * parentHeight);\n        this._uiManager.addShouldRescale(this);\n        this.disableEditing();\n        if (this._isCopy) {\n            this._moveAfterPaste(baseX, baseY);\n        }\n        return div;\n    }\n    static createDrawerInstance(_x, _y, _parentWidth, _parentHeight, _rotation) {\n        unreachable(\"Not implemented\");\n    }\n    static startDrawing(parent, uiManager, _isLTR, event) {\n        const { target, offsetX: x, offsetY: y, pointerId, pointerType } = event;\n        if (DrawingEditor.#currentPointerType && DrawingEditor.#currentPointerType !== pointerType) {\n            return;\n        }\n        const { viewport: { rotation } } = parent;\n        const { width: parentWidth, height: parentHeight } = target.getBoundingClientRect();\n        const ac = DrawingEditor.#currentDrawingAC = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        DrawingEditor.#currentPointerId ||= pointerId;\n        DrawingEditor.#currentPointerType ??= pointerType;\n        window.addEventListener(\"pointerup\", (e)=>{\n            if (DrawingEditor.#currentPointerId === e.pointerId) {\n                this._endDraw(e);\n            } else {\n                DrawingEditor.#currentPointerIds?.delete(e.pointerId);\n            }\n        }, {\n            signal\n        });\n        window.addEventListener(\"pointercancel\", (e)=>{\n            if (DrawingEditor.#currentPointerId === e.pointerId) {\n                this._currentParent.endDrawingSession();\n            } else {\n                DrawingEditor.#currentPointerIds?.delete(e.pointerId);\n            }\n        }, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", (e)=>{\n            if (DrawingEditor.#currentPointerType !== e.pointerType) {\n                return;\n            }\n            (DrawingEditor.#currentPointerIds ||= new Set()).add(e.pointerId);\n            if (DrawingEditor.#currentDraw.isCancellable()) {\n                DrawingEditor.#currentDraw.removeLastElement();\n                if (DrawingEditor.#currentDraw.isEmpty()) {\n                    this._currentParent.endDrawingSession(true);\n                } else {\n                    this._endDraw(null);\n                }\n            }\n        }, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        target.addEventListener(\"pointermove\", this._drawMove.bind(this), {\n            signal\n        });\n        target.addEventListener(\"touchmove\", (e)=>{\n            if (e.timeStamp === DrawingEditor.#currentMoveTimestamp) {\n                stopEvent(e);\n            }\n        }, {\n            signal\n        });\n        parent.toggleDrawing();\n        uiManager._editorUndoBar?.hide();\n        if (DrawingEditor.#currentDraw) {\n            parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.startNew(x, y, parentWidth, parentHeight, rotation));\n            return;\n        }\n        uiManager.updateUIForDefaultProperties(this);\n        DrawingEditor.#currentDraw = this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation);\n        DrawingEditor.#currentDrawingOptions = this.getDefaultDrawingOptions();\n        this._currentParent = parent;\n        ({ id: this._currentDrawId } = parent.drawLayer.draw(this._mergeSVGProperties(DrawingEditor.#currentDrawingOptions.toSVGProperties(), DrawingEditor.#currentDraw.defaultSVGProperties), true, false));\n    }\n    static _drawMove(event) {\n        DrawingEditor.#currentMoveTimestamp = -1;\n        if (!DrawingEditor.#currentDraw) {\n            return;\n        }\n        const { offsetX, offsetY, pointerId } = event;\n        if (DrawingEditor.#currentPointerId !== pointerId) {\n            return;\n        }\n        if (DrawingEditor.#currentPointerIds?.size >= 1) {\n            this._endDraw(event);\n            return;\n        }\n        this._currentParent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.add(offsetX, offsetY));\n        DrawingEditor.#currentMoveTimestamp = event.timeStamp;\n        stopEvent(event);\n    }\n    static _cleanup(all) {\n        if (all) {\n            this._currentDrawId = -1;\n            this._currentParent = null;\n            DrawingEditor.#currentDraw = null;\n            DrawingEditor.#currentDrawingOptions = null;\n            DrawingEditor.#currentPointerType = null;\n            DrawingEditor.#currentMoveTimestamp = NaN;\n        }\n        if (DrawingEditor.#currentDrawingAC) {\n            DrawingEditor.#currentDrawingAC.abort();\n            DrawingEditor.#currentDrawingAC = null;\n            DrawingEditor.#currentPointerId = NaN;\n            DrawingEditor.#currentPointerIds = null;\n        }\n    }\n    static _endDraw(event) {\n        const parent = this._currentParent;\n        if (!parent) {\n            return;\n        }\n        parent.toggleDrawing(true);\n        this._cleanup(false);\n        if (event?.target === parent.div) {\n            parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.end(event.offsetX, event.offsetY));\n        }\n        if (this.supportMultipleDrawings) {\n            const draw = DrawingEditor.#currentDraw;\n            const drawId = this._currentDrawId;\n            const lastElement = draw.getLastElement();\n            parent.addCommands({\n                cmd: ()=>{\n                    parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));\n                },\n                undo: ()=>{\n                    parent.drawLayer.updateProperties(drawId, draw.removeLastElement());\n                },\n                mustExec: false,\n                type: AnnotationEditorParamsType.DRAW_STEP\n            });\n            return;\n        }\n        this.endDrawing(false);\n    }\n    static endDrawing(isAborted) {\n        const parent = this._currentParent;\n        if (!parent) {\n            return null;\n        }\n        parent.toggleDrawing(true);\n        parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);\n        if (!DrawingEditor.#currentDraw.isEmpty()) {\n            const { pageDimensions: [pageWidth, pageHeight], scale } = parent;\n            const editor = parent.createAndAddNewEditor({\n                offsetX: 0,\n                offsetY: 0\n            }, false, {\n                drawId: this._currentDrawId,\n                drawOutlines: DrawingEditor.#currentDraw.getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),\n                drawingOptions: DrawingEditor.#currentDrawingOptions,\n                mustBeCommitted: !isAborted\n            });\n            this._cleanup(true);\n            return editor;\n        }\n        parent.drawLayer.remove(this._currentDrawId);\n        this._cleanup(true);\n        return null;\n    }\n    createDrawingOptions(_data) {}\n    static deserializeDraw(_pageX, _pageY, _pageWidth, _pageHeight, _innerWidth, _data) {\n        unreachable(\"Not implemented\");\n    }\n    static async deserialize(data, parent, uiManager) {\n        const { rawDims: { pageWidth, pageHeight, pageX, pageY } } = parent.viewport;\n        const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.createDrawingOptions(data);\n        editor.#createDrawOutlines({\n            drawOutlines\n        });\n        editor.#addToDrawLayer();\n        editor.onScaleChanging();\n        editor.rotate();\n        return editor;\n    }\n    serializeDraw(isForCopying) {\n        const [pageX, pageY] = this.pageTranslation;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        return this.#drawOutlines.serialize([\n            pageX,\n            pageY,\n            pageWidth,\n            pageHeight\n        ], isForCopying);\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getPDFRect()\n        });\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\n; // ./src/display/editor/drawers/inkdraw.js\nclass InkDrawOutliner {\n    #last;\n    #line;\n    #lines;\n    #rotation;\n    #thickness;\n    #points;\n    #lastSVGPath;\n    #lastIndex;\n    #outlines;\n    #parentWidth;\n    #parentHeight;\n    constructor(x, y, parentWidth, parentHeight, rotation, thickness){\n        this.#last = new Float64Array(6);\n        this.#lastSVGPath = \"\";\n        this.#lastIndex = 0;\n        this.#outlines = new InkDrawOutline();\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#rotation = rotation;\n        this.#thickness = thickness;\n        [x, y] = this.#normalizePoint(x, y);\n        const line = this.#line = [\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ];\n        this.#points = [\n            x,\n            y\n        ];\n        this.#lines = [\n            {\n                line,\n                points: this.#points\n            }\n        ];\n        this.#last.set(line, 0);\n    }\n    updateProperty(name, value) {\n        if (name === \"stroke-width\") {\n            this.#thickness = value;\n        }\n    }\n    #normalizePoint(x, y) {\n        return Outline._normalizePoint(x, y, this.#parentWidth, this.#parentHeight, this.#rotation);\n    }\n    isEmpty() {\n        return !this.#lines || this.#lines.length === 0;\n    }\n    isCancellable() {\n        return this.#points.length <= 10;\n    }\n    add(x, y) {\n        [x, y] = this.#normalizePoint(x, y);\n        const [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(this.#parentWidth * diffX, this.#parentHeight * diffY);\n        if (d <= 2) {\n            return null;\n        }\n        this.#points.push(x, y);\n        if (isNaN(x1)) {\n            this.#last.set([\n                x2,\n                y2,\n                x,\n                y\n            ], 2);\n            this.#line.push(NaN, NaN, NaN, NaN, x, y);\n            return {\n                path: {\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        if (isNaN(this.#last[0])) {\n            this.#line.splice(6, 6);\n        }\n        this.#last.set([\n            x1,\n            y1,\n            x2,\n            y2,\n            x,\n            y\n        ], 0);\n        this.#line.push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    end(x, y) {\n        const change = this.add(x, y);\n        if (change) {\n            return change;\n        }\n        if (this.#points.length === 2) {\n            return {\n                path: {\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        return null;\n    }\n    startNew(x, y, parentWidth, parentHeight, rotation) {\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#rotation = rotation;\n        [x, y] = this.#normalizePoint(x, y);\n        const line = this.#line = [\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ];\n        this.#points = [\n            x,\n            y\n        ];\n        const last = this.#lines.at(-1);\n        if (last) {\n            last.line = new Float32Array(last.line);\n            last.points = new Float32Array(last.points);\n        }\n        this.#lines.push({\n            line,\n            points: this.#points\n        });\n        this.#last.set(line, 0);\n        this.#lastIndex = 0;\n        this.toSVGPath();\n        return null;\n    }\n    getLastElement() {\n        return this.#lines.at(-1);\n    }\n    setLastElement(element) {\n        if (!this.#lines) {\n            return this.#outlines.setLastElement(element);\n        }\n        this.#lines.push(element);\n        this.#line = element.line;\n        this.#points = element.points;\n        this.#lastIndex = 0;\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    removeLastElement() {\n        if (!this.#lines) {\n            return this.#outlines.removeLastElement();\n        }\n        this.#lines.pop();\n        this.#lastSVGPath = \"\";\n        for(let i = 0, ii = this.#lines.length; i < ii; i++){\n            const { line, points } = this.#lines[i];\n            this.#line = line;\n            this.#points = points;\n            this.#lastIndex = 0;\n            this.toSVGPath();\n        }\n        return {\n            path: {\n                d: this.#lastSVGPath\n            }\n        };\n    }\n    toSVGPath() {\n        const firstX = Outline.svgRound(this.#line[4]);\n        const firstY = Outline.svgRound(this.#line[5]);\n        if (this.#points.length === 2) {\n            this.#lastSVGPath = `${this.#lastSVGPath} M ${firstX} ${firstY} Z`;\n            return this.#lastSVGPath;\n        }\n        if (this.#points.length <= 6) {\n            const i = this.#lastSVGPath.lastIndexOf(\"M\");\n            this.#lastSVGPath = `${this.#lastSVGPath.slice(0, i)} M ${firstX} ${firstY}`;\n            this.#lastIndex = 6;\n        }\n        if (this.#points.length === 4) {\n            const secondX = Outline.svgRound(this.#line[10]);\n            const secondY = Outline.svgRound(this.#line[11]);\n            this.#lastSVGPath = `${this.#lastSVGPath} L ${secondX} ${secondY}`;\n            this.#lastIndex = 12;\n            return this.#lastSVGPath;\n        }\n        const buffer = [];\n        if (this.#lastIndex === 0) {\n            buffer.push(`M ${firstX} ${firstY}`);\n            this.#lastIndex = 6;\n        }\n        for(let i = this.#lastIndex, ii = this.#line.length; i < ii; i += 6){\n            const [c1x, c1y, c2x, c2y, x, y] = this.#line.slice(i, i + 6).map(Outline.svgRound);\n            buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n        }\n        this.#lastSVGPath += buffer.join(\" \");\n        this.#lastIndex = this.#line.length;\n        return this.#lastSVGPath;\n    }\n    getOutlines(parentWidth, parentHeight, scale, innerMargin) {\n        const last = this.#lines.at(-1);\n        last.line = new Float32Array(last.line);\n        last.points = new Float32Array(last.points);\n        this.#outlines.build(this.#lines, parentWidth, parentHeight, scale, this.#rotation, this.#thickness, innerMargin);\n        this.#last = null;\n        this.#line = null;\n        this.#lines = null;\n        this.#lastSVGPath = null;\n        return this.#outlines;\n    }\n    get defaultSVGProperties() {\n        return {\n            root: {\n                viewBox: \"0 0 10000 10000\"\n            },\n            rootClass: {\n                draw: true\n            },\n            bbox: [\n                0,\n                0,\n                1,\n                1\n            ]\n        };\n    }\n}\nclass InkDrawOutline extends Outline {\n    #bbox;\n    #currentRotation;\n    #innerMargin;\n    #lines;\n    #parentWidth;\n    #parentHeight;\n    #parentScale;\n    #rotation;\n    #thickness;\n    build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#parentScale = parentScale;\n        this.#rotation = rotation;\n        this.#thickness = thickness;\n        this.#innerMargin = innerMargin ?? 0;\n        this.#lines = lines;\n        this.#computeBbox();\n    }\n    get thickness() {\n        return this.#thickness;\n    }\n    setLastElement(element) {\n        this.#lines.push(element);\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    removeLastElement() {\n        this.#lines.pop();\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const { line } of this.#lines){\n            buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);\n            if (line.length === 6) {\n                buffer.push(\"Z\");\n                continue;\n            }\n            if (line.length === 12 && isNaN(line[6])) {\n                buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);\n                continue;\n            }\n            for(let i = 6, ii = line.length; i < ii; i += 6){\n                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);\n                buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n            }\n        }\n        return buffer.join(\"\");\n    }\n    serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {\n        const serializedLines = [];\n        const serializedPoints = [];\n        const [x, y, width, height] = this.#getBBoxWithNoMargin();\n        let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;\n        switch(this.#rotation){\n            case 0:\n                rescaleFn = Outline._rescale;\n                tx = pageX;\n                ty = pageY + pageHeight;\n                sx = pageWidth;\n                sy = -pageHeight;\n                x1 = pageX + x * pageWidth;\n                y1 = pageY + (1 - y - height) * pageHeight;\n                x2 = pageX + (x + width) * pageWidth;\n                y2 = pageY + (1 - y) * pageHeight;\n                break;\n            case 90:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageX;\n                ty = pageY;\n                sx = pageWidth;\n                sy = pageHeight;\n                x1 = pageX + y * pageWidth;\n                y1 = pageY + x * pageHeight;\n                x2 = pageX + (y + height) * pageWidth;\n                y2 = pageY + (x + width) * pageHeight;\n                break;\n            case 180:\n                rescaleFn = Outline._rescale;\n                tx = pageX + pageWidth;\n                ty = pageY;\n                sx = -pageWidth;\n                sy = pageHeight;\n                x1 = pageX + (1 - x - width) * pageWidth;\n                y1 = pageY + y * pageHeight;\n                x2 = pageX + (1 - x) * pageWidth;\n                y2 = pageY + (y + height) * pageHeight;\n                break;\n            case 270:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageX + pageWidth;\n                ty = pageY + pageHeight;\n                sx = -pageWidth;\n                sy = -pageHeight;\n                x1 = pageX + (1 - y - height) * pageWidth;\n                y1 = pageY + (1 - x - width) * pageHeight;\n                x2 = pageX + (1 - y) * pageWidth;\n                y2 = pageY + (1 - x) * pageHeight;\n                break;\n        }\n        for (const { line, points } of this.#lines){\n            serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));\n            serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));\n        }\n        return {\n            lines: serializedLines,\n            points: serializedPoints,\n            rect: [\n                x1,\n                y1,\n                x2,\n                y2\n            ]\n        };\n    }\n    static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, { paths: { lines, points }, rotation, thickness }) {\n        const newLines = [];\n        let tx, ty, sx, sy, rescaleFn;\n        switch(rotation){\n            case 0:\n                rescaleFn = Outline._rescale;\n                tx = -pageX / pageWidth;\n                ty = pageY / pageHeight + 1;\n                sx = 1 / pageWidth;\n                sy = -1 / pageHeight;\n                break;\n            case 90:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = -pageY / pageHeight;\n                ty = -pageX / pageWidth;\n                sx = 1 / pageHeight;\n                sy = 1 / pageWidth;\n                break;\n            case 180:\n                rescaleFn = Outline._rescale;\n                tx = pageX / pageWidth + 1;\n                ty = -pageY / pageHeight;\n                sx = -1 / pageWidth;\n                sy = 1 / pageHeight;\n                break;\n            case 270:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageY / pageHeight + 1;\n                ty = pageX / pageWidth + 1;\n                sx = -1 / pageHeight;\n                sy = -1 / pageWidth;\n                break;\n        }\n        if (!lines) {\n            lines = [];\n            for (const point of points){\n                const len = point.length;\n                if (len === 2) {\n                    lines.push(new Float32Array([\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[0],\n                        point[1]\n                    ]));\n                    continue;\n                }\n                if (len === 4) {\n                    lines.push(new Float32Array([\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[0],\n                        point[1],\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[2],\n                        point[3]\n                    ]));\n                    continue;\n                }\n                const line = new Float32Array(3 * (len - 2));\n                lines.push(line);\n                let [x1, y1, x2, y2] = point.subarray(0, 4);\n                line.set([\n                    NaN,\n                    NaN,\n                    NaN,\n                    NaN,\n                    x1,\n                    y1\n                ], 0);\n                for(let i = 4; i < len; i += 2){\n                    const x = point[i];\n                    const y = point[i + 1];\n                    line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n                    [x1, y1, x2, y2] = [\n                        x2,\n                        y2,\n                        x,\n                        y\n                    ];\n                }\n            }\n        }\n        for(let i = 0, ii = lines.length; i < ii; i++){\n            newLines.push({\n                line: rescaleFn(lines[i].map((x)=>x ?? NaN), tx, ty, sx, sy),\n                points: rescaleFn(points[i].map((x)=>x ?? NaN), tx, ty, sx, sy)\n            });\n        }\n        const outlines = new this.prototype.constructor();\n        outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);\n        return outlines;\n    }\n    #getMarginComponents(thickness = this.#thickness) {\n        const margin = this.#innerMargin + thickness / 2 * this.#parentScale;\n        return this.#rotation % 180 === 0 ? [\n            margin / this.#parentWidth,\n            margin / this.#parentHeight\n        ] : [\n            margin / this.#parentHeight,\n            margin / this.#parentWidth\n        ];\n    }\n    #getBBoxWithNoMargin() {\n        const [x, y, width, height] = this.#bbox;\n        const [marginX, marginY] = this.#getMarginComponents(0);\n        return [\n            x + marginX,\n            y + marginY,\n            width - 2 * marginX,\n            height - 2 * marginY\n        ];\n    }\n    #computeBbox() {\n        const bbox = this.#bbox = new Float32Array([\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ]);\n        for (const { line } of this.#lines){\n            if (line.length <= 12) {\n                for(let i = 4, ii = line.length; i < ii; i += 6){\n                    Util.pointBoundingBox(line[i], line[i + 1], bbox);\n                }\n                continue;\n            }\n            let lastX = line[4], lastY = line[5];\n            for(let i = 6, ii = line.length; i < ii; i += 6){\n                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);\n                Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);\n                lastX = x;\n                lastY = y;\n            }\n        }\n        const [marginX, marginY] = this.#getMarginComponents();\n        bbox[0] = MathClamp(bbox[0] - marginX, 0, 1);\n        bbox[1] = MathClamp(bbox[1] - marginY, 0, 1);\n        bbox[2] = MathClamp(bbox[2] + marginX, 0, 1);\n        bbox[3] = MathClamp(bbox[3] + marginY, 0, 1);\n        bbox[2] -= bbox[0];\n        bbox[3] -= bbox[1];\n    }\n    get box() {\n        return this.#bbox;\n    }\n    updateProperty(name, value) {\n        if (name === \"stroke-width\") {\n            return this.#updateThickness(value);\n        }\n        return null;\n    }\n    #updateThickness(thickness) {\n        const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n        this.#thickness = thickness;\n        const [newMarginX, newMarginY] = this.#getMarginComponents();\n        const [diffMarginX, diffMarginY] = [\n            newMarginX - oldMarginX,\n            newMarginY - oldMarginY\n        ];\n        const bbox = this.#bbox;\n        bbox[0] -= diffMarginX;\n        bbox[1] -= diffMarginY;\n        bbox[2] += 2 * diffMarginX;\n        bbox[3] += 2 * diffMarginY;\n        return bbox;\n    }\n    updateParentDimensions([width, height], scale) {\n        const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n        this.#parentWidth = width;\n        this.#parentHeight = height;\n        this.#parentScale = scale;\n        const [newMarginX, newMarginY] = this.#getMarginComponents();\n        const diffMarginX = newMarginX - oldMarginX;\n        const diffMarginY = newMarginY - oldMarginY;\n        const bbox = this.#bbox;\n        bbox[0] -= diffMarginX;\n        bbox[1] -= diffMarginY;\n        bbox[2] += 2 * diffMarginX;\n        bbox[3] += 2 * diffMarginY;\n        return bbox;\n    }\n    updateRotation(rotation) {\n        this.#currentRotation = rotation;\n        return {\n            path: {\n                transform: this.rotationTransform\n            }\n        };\n    }\n    get viewBox() {\n        return this.#bbox.map(Outline.svgRound).join(\" \");\n    }\n    get defaultProperties() {\n        const [x, y] = this.#bbox;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`\n            }\n        };\n    }\n    get rotationTransform() {\n        const [, , width, height] = this.#bbox;\n        let a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;\n        switch(this.#currentRotation){\n            case 90:\n                b = height / width;\n                c = -width / height;\n                e = width;\n                break;\n            case 180:\n                a = -1;\n                d = -1;\n                e = width;\n                f = height;\n                break;\n            case 270:\n                b = -height / width;\n                c = width / height;\n                f = height;\n                break;\n            default:\n                return \"\";\n        }\n        return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;\n    }\n    getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {\n        const [marginX, marginY] = this.#getMarginComponents();\n        const [x, y, width, height] = this.#bbox;\n        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n            const tx = newX + newWidth / 2 - (x + width / 2);\n            const ty = newY + newHeight / 2 - (y + height / 2);\n            return {\n                path: {\n                    \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                    transform: `${this.rotationTransform} translate(${tx} ${ty})`\n                }\n            };\n        }\n        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n        const s2x = width / newWidth;\n        const s2y = height / newHeight;\n        return {\n            path: {\n                \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,\n                transform: `${this.rotationTransform} scale(${s2x} ${s2y}) ` + `translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) ` + `translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`\n            }\n        };\n    }\n    getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {\n        const [marginX, marginY] = this.#getMarginComponents();\n        const bbox = this.#bbox;\n        const [x, y, width, height] = bbox;\n        bbox[0] = newX;\n        bbox[1] = newY;\n        bbox[2] = newWidth;\n        bbox[3] = newHeight;\n        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n            const tx = newX + newWidth / 2 - (x + width / 2);\n            const ty = newY + newHeight / 2 - (y + height / 2);\n            for (const { line, points } of this.#lines){\n                Outline._translate(line, tx, ty, line);\n                Outline._translate(points, tx, ty, points);\n            }\n            return {\n                root: {\n                    viewBox: this.viewBox\n                },\n                path: {\n                    \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                    transform: this.rotationTransform || null,\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n        const tx = -s1x * (x + marginX) + newX + marginX;\n        const ty = -s1y * (y + marginY) + newY + marginY;\n        if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {\n            for (const { line, points } of this.#lines){\n                Outline._rescale(line, tx, ty, s1x, s1y, line);\n                Outline._rescale(points, tx, ty, s1x, s1y, points);\n            }\n        }\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                transform: this.rotationTransform || null,\n                d: this.toSVGPath()\n            }\n        };\n    }\n    getPathTranslatedSVGProperties([newX, newY], parentDimensions) {\n        const [newParentWidth, newParentHeight] = parentDimensions;\n        const bbox = this.#bbox;\n        const tx = newX - bbox[0];\n        const ty = newY - bbox[1];\n        if (this.#parentWidth === newParentWidth && this.#parentHeight === newParentHeight) {\n            for (const { line, points } of this.#lines){\n                Outline._translate(line, tx, ty, line);\n                Outline._translate(points, tx, ty, points);\n            }\n        } else {\n            const sx = this.#parentWidth / newParentWidth;\n            const sy = this.#parentHeight / newParentHeight;\n            this.#parentWidth = newParentWidth;\n            this.#parentHeight = newParentHeight;\n            for (const { line, points } of this.#lines){\n                Outline._rescale(line, tx, ty, sx, sy, line);\n                Outline._rescale(points, tx, ty, sx, sy, points);\n            }\n            bbox[2] *= sx;\n            bbox[3] *= sy;\n        }\n        bbox[0] = newX;\n        bbox[1] = newY;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                d: this.toSVGPath(),\n                \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`\n            }\n        };\n    }\n    get defaultSVGProperties() {\n        const bbox = this.#bbox;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            rootClass: {\n                draw: true\n            },\n            path: {\n                d: this.toSVGPath(),\n                \"transform-origin\": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,\n                transform: this.rotationTransform || null\n            },\n            bbox\n        };\n    }\n    constructor(...args){\n        super(...args);\n        this.#currentRotation = 0;\n    }\n}\n; // ./src/display/editor/ink.js\nclass InkDrawingOptions extends DrawingOptions {\n    constructor(viewerParameters){\n        super();\n        this._viewParameters = viewerParameters;\n        super.updateProperties({\n            fill: \"none\",\n            stroke: AnnotationEditor._defaultLineColor,\n            \"stroke-opacity\": 1,\n            \"stroke-width\": 1,\n            \"stroke-linecap\": \"round\",\n            \"stroke-linejoin\": \"round\",\n            \"stroke-miterlimit\": 10\n        });\n    }\n    updateSVGProperty(name, value) {\n        if (name === \"stroke-width\") {\n            value ??= this[\"stroke-width\"];\n            value *= this._viewParameters.realScale;\n        }\n        super.updateSVGProperty(name, value);\n    }\n    clone() {\n        const clone = new InkDrawingOptions(this._viewParameters);\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass InkEditor extends DrawingEditor {\n    static{\n        this._type = \"ink\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.INK;\n    }\n    static{\n        this._defaultDrawingOptions = null;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"inkEditor\"\n        });\n        this._willKeepAspectRatio = true;\n        this.defaultL10nId = \"pdfjs-editor-ink-editor\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);\n    }\n    static getDefaultDrawingOptions(options) {\n        const clone = this._defaultDrawingOptions.clone();\n        clone.updateProperties(options);\n        return clone;\n    }\n    static get supportMultipleDrawings() {\n        return true;\n    }\n    static get typesMap() {\n        return shadow(this, \"typesMap\", new Map([\n            [\n                AnnotationEditorParamsType.INK_THICKNESS,\n                \"stroke-width\"\n            ],\n            [\n                AnnotationEditorParamsType.INK_COLOR,\n                \"stroke\"\n            ],\n            [\n                AnnotationEditorParamsType.INK_OPACITY,\n                \"stroke-opacity\"\n            ]\n        ]));\n    }\n    static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {\n        return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions[\"stroke-width\"]);\n    }\n    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists, rect, rotation, id, color, opacity, borderStyle: { rawWidth: thickness }, popupRef, contentsObj }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.INK,\n                color: Array.from(color),\n                thickness,\n                opacity,\n                paths: {\n                    points: inkLists\n                },\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                comment: contentsObj?.str || null\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data.comment);\n        }\n        return editor;\n    }\n    get toolbarButtons() {\n        this._colorPicker ||= new BasicColorPicker(this);\n        return [\n            [\n                \"colorPicker\",\n                this._colorPicker\n            ]\n        ];\n    }\n    get colorType() {\n        return AnnotationEditorParamsType.INK_COLOR;\n    }\n    get colorValue() {\n        return this._drawingOptions.stroke;\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        super.onScaleChanging();\n        const { _drawId, _drawingOptions, parent } = this;\n        _drawingOptions.updateSVGProperty(\"stroke-width\");\n        parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());\n    }\n    static onScaleChangingWhenDrawing() {\n        const parent = this._currentParent;\n        if (!parent) {\n            return;\n        }\n        super.onScaleChangingWhenDrawing();\n        this._defaultDrawingOptions.updateSVGProperty(\"stroke-width\");\n        parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n    }\n    createDrawingOptions({ color, thickness, opacity }) {\n        this._drawingOptions = InkEditor.getDefaultDrawingOptions({\n            stroke: Util.makeHexColor(...color),\n            \"stroke-width\": thickness,\n            \"stroke-opacity\": opacity\n        });\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const { lines, points, rect } = this.serializeDraw(isForCopying);\n        const { _drawingOptions: { stroke, \"stroke-opacity\": opacity, \"stroke-width\": thickness } } = this;\n        const serialized = {\n            annotationType: AnnotationEditorType.INK,\n            color: AnnotationEditor._colorManager.convert(stroke),\n            opacity,\n            thickness,\n            paths: {\n                lines,\n                points\n            },\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId\n        };\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.isCopy = true;\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color, thickness, opacity, pageIndex } = this._initialData;\n        return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i)=>c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        const { points, rect } = this.serializeDraw(false);\n        const params = {\n            rect,\n            thickness: this._drawingOptions[\"stroke-width\"],\n            points\n        };\n        if (this.hasEditedComment) {\n            params.popup = this.comment;\n        }\n        annotation.updateEdited(params);\n        return null;\n    }\n}\n; // ./src/display/editor/drawers/contour.js\nclass ContourDrawOutline extends InkDrawOutline {\n    toSVGPath() {\n        let path = super.toSVGPath();\n        if (!path.endsWith(\"Z\")) {\n            path += \"Z\";\n        }\n        return path;\n    }\n}\n; // ./src/display/editor/drawers/signaturedraw.js\nconst BASE_HEADER_LENGTH = 8;\nconst POINTS_PROPERTIES_NUMBER = 3;\nclass SignatureExtractor {\n    static #PARAMETERS = {\n        maxDim: 512,\n        sigmaSFactor: 0.02,\n        sigmaR: 25,\n        kernelSize: 16\n    };\n    static #neighborIndexToId(i0, j0, i, j) {\n        i -= i0;\n        j -= j0;\n        if (i === 0) {\n            return j > 0 ? 0 : 4;\n        }\n        if (i === 1) {\n            return j + 6;\n        }\n        return 2 - j;\n    }\n    static #neighborIdToIndex = new Int32Array([\n        0,\n        1,\n        -1,\n        1,\n        -1,\n        0,\n        -1,\n        -1,\n        0,\n        -1,\n        1,\n        -1,\n        1,\n        0,\n        1,\n        1\n    ]);\n    static #clockwiseNonZero(buf, width, i0, j0, i, j, offset) {\n        const id = this.#neighborIndexToId(i0, j0, i, j);\n        for(let k = 0; k < 8; k++){\n            const kk = (-k + id - offset + 16) % 8;\n            const shiftI = this.#neighborIdToIndex[2 * kk];\n            const shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n            if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {\n                return kk;\n            }\n        }\n        return -1;\n    }\n    static #counterClockwiseNonZero(buf, width, i0, j0, i, j, offset) {\n        const id = this.#neighborIndexToId(i0, j0, i, j);\n        for(let k = 0; k < 8; k++){\n            const kk = (k + id + offset + 16) % 8;\n            const shiftI = this.#neighborIdToIndex[2 * kk];\n            const shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n            if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {\n                return kk;\n            }\n        }\n        return -1;\n    }\n    static #findContours(buf, width, height, threshold) {\n        const N = buf.length;\n        const types = new Int32Array(N);\n        for(let i = 0; i < N; i++){\n            types[i] = buf[i] <= threshold ? 1 : 0;\n        }\n        for(let i = 1; i < height - 1; i++){\n            types[i * width] = types[i * width + width - 1] = 0;\n        }\n        for(let i = 0; i < width; i++){\n            types[i] = types[width * height - 1 - i] = 0;\n        }\n        let nbd = 1;\n        let lnbd;\n        const contours = [];\n        for(let i = 1; i < height - 1; i++){\n            lnbd = 1;\n            for(let j = 1; j < width - 1; j++){\n                const ij = i * width + j;\n                const pix = types[ij];\n                if (pix === 0) {\n                    continue;\n                }\n                let i2 = i;\n                let j2 = j;\n                if (pix === 1 && types[ij - 1] === 0) {\n                    nbd += 1;\n                    j2 -= 1;\n                } else if (pix >= 1 && types[ij + 1] === 0) {\n                    nbd += 1;\n                    j2 += 1;\n                    if (pix > 1) {\n                        lnbd = pix;\n                    }\n                } else {\n                    if (pix !== 1) {\n                        lnbd = Math.abs(pix);\n                    }\n                    continue;\n                }\n                const points = [\n                    j,\n                    i\n                ];\n                const isHole = j2 === j + 1;\n                const contour = {\n                    isHole,\n                    points,\n                    id: nbd,\n                    parent: 0\n                };\n                contours.push(contour);\n                let contour0;\n                for (const c of contours){\n                    if (c.id === lnbd) {\n                        contour0 = c;\n                        break;\n                    }\n                }\n                if (!contour0) {\n                    contour.parent = isHole ? lnbd : 0;\n                } else if (contour0.isHole) {\n                    contour.parent = isHole ? contour0.parent : lnbd;\n                } else {\n                    contour.parent = isHole ? lnbd : contour0.parent;\n                }\n                const k = this.#clockwiseNonZero(types, width, i, j, i2, j2, 0);\n                if (k === -1) {\n                    types[ij] = -nbd;\n                    if (types[ij] !== 1) {\n                        lnbd = Math.abs(types[ij]);\n                    }\n                    continue;\n                }\n                let shiftI = this.#neighborIdToIndex[2 * k];\n                let shiftJ = this.#neighborIdToIndex[2 * k + 1];\n                const i1 = i + shiftI;\n                const j1 = j + shiftJ;\n                i2 = i1;\n                j2 = j1;\n                let i3 = i;\n                let j3 = j;\n                while(true){\n                    const kk = this.#counterClockwiseNonZero(types, width, i3, j3, i2, j2, 1);\n                    shiftI = this.#neighborIdToIndex[2 * kk];\n                    shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n                    const i4 = i3 + shiftI;\n                    const j4 = j3 + shiftJ;\n                    points.push(j4, i4);\n                    const ij3 = i3 * width + j3;\n                    if (types[ij3 + 1] === 0) {\n                        types[ij3] = -nbd;\n                    } else if (types[ij3] === 1) {\n                        types[ij3] = nbd;\n                    }\n                    if (i4 === i && j4 === j && i3 === i1 && j3 === j1) {\n                        if (types[ij] !== 1) {\n                            lnbd = Math.abs(types[ij]);\n                        }\n                        break;\n                    } else {\n                        i2 = i3;\n                        j2 = j3;\n                        i3 = i4;\n                        j3 = j4;\n                    }\n                }\n            }\n        }\n        return contours;\n    }\n    static #douglasPeuckerHelper(points, start, end, output) {\n        if (end - start <= 4) {\n            for(let i = start; i < end - 2; i += 2){\n                output.push(points[i], points[i + 1]);\n            }\n            return;\n        }\n        const ax = points[start];\n        const ay = points[start + 1];\n        const abx = points[end - 4] - ax;\n        const aby = points[end - 3] - ay;\n        const dist = Math.hypot(abx, aby);\n        const nabx = abx / dist;\n        const naby = aby / dist;\n        const aa = nabx * ay - naby * ax;\n        const m = aby / abx;\n        const invS = 1 / dist;\n        const phi = Math.atan(m);\n        const cosPhi = Math.cos(phi);\n        const sinPhi = Math.sin(phi);\n        const tmax = invS * (Math.abs(cosPhi) + Math.abs(sinPhi));\n        const poly = invS * (1 - tmax + tmax ** 2);\n        const partialPhi = Math.max(Math.atan(Math.abs(sinPhi + cosPhi) * poly), Math.atan(Math.abs(sinPhi - cosPhi) * poly));\n        let dmax = 0;\n        let index = start;\n        for(let i = start + 2; i < end - 2; i += 2){\n            const d = Math.abs(aa - nabx * points[i + 1] + naby * points[i]);\n            if (d > dmax) {\n                index = i;\n                dmax = d;\n            }\n        }\n        if (dmax > (dist * partialPhi) ** 2) {\n            this.#douglasPeuckerHelper(points, start, index + 2, output);\n            this.#douglasPeuckerHelper(points, index, end, output);\n        } else {\n            output.push(ax, ay);\n        }\n    }\n    static #douglasPeucker(points) {\n        const output = [];\n        const len = points.length;\n        this.#douglasPeuckerHelper(points, 0, len, output);\n        output.push(points[len - 2], points[len - 1]);\n        return output.length <= 4 ? null : output;\n    }\n    static #bilateralFilter(buf, width, height, sigmaS, sigmaR, kernelSize) {\n        const kernel = new Float32Array(kernelSize ** 2);\n        const sigmaS2 = -2 * sigmaS ** 2;\n        const halfSize = kernelSize >> 1;\n        for(let i = 0; i < kernelSize; i++){\n            const x = (i - halfSize) ** 2;\n            for(let j = 0; j < kernelSize; j++){\n                kernel[i * kernelSize + j] = Math.exp((x + (j - halfSize) ** 2) / sigmaS2);\n            }\n        }\n        const rangeValues = new Float32Array(256);\n        const sigmaR2 = -2 * sigmaR ** 2;\n        for(let i = 0; i < 256; i++){\n            rangeValues[i] = Math.exp(i ** 2 / sigmaR2);\n        }\n        const N = buf.length;\n        const out = new Uint8Array(N);\n        const histogram = new Uint32Array(256);\n        for(let i = 0; i < height; i++){\n            for(let j = 0; j < width; j++){\n                const ij = i * width + j;\n                const center = buf[ij];\n                let sum = 0;\n                let norm = 0;\n                for(let k = 0; k < kernelSize; k++){\n                    const y = i + k - halfSize;\n                    if (y < 0 || y >= height) {\n                        continue;\n                    }\n                    for(let l = 0; l < kernelSize; l++){\n                        const x = j + l - halfSize;\n                        if (x < 0 || x >= width) {\n                            continue;\n                        }\n                        const neighbour = buf[y * width + x];\n                        const w = kernel[k * kernelSize + l] * rangeValues[Math.abs(neighbour - center)];\n                        sum += neighbour * w;\n                        norm += w;\n                    }\n                }\n                const pix = out[ij] = Math.round(sum / norm);\n                histogram[pix]++;\n            }\n        }\n        return [\n            out,\n            histogram\n        ];\n    }\n    static #getHistogram(buf) {\n        const histogram = new Uint32Array(256);\n        for (const g of buf){\n            histogram[g]++;\n        }\n        return histogram;\n    }\n    static #toUint8(buf) {\n        const N = buf.length;\n        const out = new Uint8ClampedArray(N >> 2);\n        let max = -Infinity;\n        let min = Infinity;\n        for(let i = 0, ii = out.length; i < ii; i++){\n            const pix = out[i] = buf[i << 2];\n            max = Math.max(max, pix);\n            min = Math.min(min, pix);\n        }\n        const ratio = 255 / (max - min);\n        for(let i = 0, ii = out.length; i < ii; i++){\n            out[i] = (out[i] - min) * ratio;\n        }\n        return out;\n    }\n    static #guessThreshold(histogram) {\n        let i;\n        let M = -Infinity;\n        let L = -Infinity;\n        const min = histogram.findIndex((v)=>v !== 0);\n        let pos = min;\n        let spos = min;\n        for(i = min; i < 256; i++){\n            const v = histogram[i];\n            if (v > M) {\n                if (i - pos > L) {\n                    L = i - pos;\n                    spos = i - 1;\n                }\n                M = v;\n                pos = i;\n            }\n        }\n        for(i = spos - 1; i >= 0; i--){\n            if (histogram[i] > histogram[i + 1]) {\n                break;\n            }\n        }\n        return i;\n    }\n    static #getGrayPixels(bitmap) {\n        const originalBitmap = bitmap;\n        const { width, height } = bitmap;\n        const { maxDim } = this.#PARAMETERS;\n        let newWidth = width;\n        let newHeight = height;\n        if (width > maxDim || height > maxDim) {\n            let prevWidth = width;\n            let prevHeight = height;\n            let steps = Math.log2(Math.max(width, height) / maxDim);\n            const isteps = Math.floor(steps);\n            steps = steps === isteps ? isteps - 1 : isteps;\n            for(let i = 0; i < steps; i++){\n                newWidth = Math.ceil(prevWidth / 2);\n                newHeight = Math.ceil(prevHeight / 2);\n                const offscreen = new OffscreenCanvas(newWidth, newHeight);\n                const ctx = offscreen.getContext(\"2d\");\n                ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n                prevWidth = newWidth;\n                prevHeight = newHeight;\n                if (bitmap !== originalBitmap) {\n                    bitmap.close();\n                }\n                bitmap = offscreen.transferToImageBitmap();\n            }\n            const ratio = Math.min(maxDim / newWidth, maxDim / newHeight);\n            newWidth = Math.round(newWidth * ratio);\n            newHeight = Math.round(newHeight * ratio);\n        }\n        const offscreen = new OffscreenCanvas(newWidth, newHeight);\n        const ctx = offscreen.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        ctx.fillStyle = \"white\";\n        ctx.fillRect(0, 0, newWidth, newHeight);\n        ctx.filter = \"grayscale(1)\";\n        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, newWidth, newHeight);\n        const grayImage = ctx.getImageData(0, 0, newWidth, newHeight).data;\n        const uint8Buf = this.#toUint8(grayImage);\n        return [\n            uint8Buf,\n            newWidth,\n            newHeight\n        ];\n    }\n    static extractContoursFromText(text, { fontFamily, fontStyle, fontWeight }, pageWidth, pageHeight, rotation, innerMargin) {\n        let canvas = new OffscreenCanvas(1, 1);\n        let ctx = canvas.getContext(\"2d\", {\n            alpha: false\n        });\n        const fontSize = 200;\n        const font = ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n        const { actualBoundingBoxLeft, actualBoundingBoxRight, actualBoundingBoxAscent, actualBoundingBoxDescent, fontBoundingBoxAscent, fontBoundingBoxDescent, width } = ctx.measureText(text);\n        const SCALE = 1.5;\n        const canvasWidth = Math.ceil(Math.max(Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) || 0, width) * SCALE);\n        const canvasHeight = Math.ceil(Math.max(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent) || fontSize, Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || fontSize) * SCALE);\n        canvas = new OffscreenCanvas(canvasWidth, canvasHeight);\n        ctx = canvas.getContext(\"2d\", {\n            alpha: true,\n            willReadFrequently: true\n        });\n        ctx.font = font;\n        ctx.filter = \"grayscale(1)\";\n        ctx.fillStyle = \"white\";\n        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n        ctx.fillStyle = \"black\";\n        ctx.fillText(text, canvasWidth * (SCALE - 1) / 2, canvasHeight * (3 - SCALE) / 2);\n        const uint8Buf = this.#toUint8(ctx.getImageData(0, 0, canvasWidth, canvasHeight).data);\n        const histogram = this.#getHistogram(uint8Buf);\n        const threshold = this.#guessThreshold(histogram);\n        const contourList = this.#findContours(uint8Buf, canvasWidth, canvasHeight, threshold);\n        return this.processDrawnLines({\n            lines: {\n                curves: contourList,\n                width: canvasWidth,\n                height: canvasHeight\n            },\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin,\n            mustSmooth: true,\n            areContours: true\n        });\n    }\n    static process(bitmap, pageWidth, pageHeight, rotation, innerMargin) {\n        const [uint8Buf, width, height] = this.#getGrayPixels(bitmap);\n        const [buffer, histogram] = this.#bilateralFilter(uint8Buf, width, height, Math.hypot(width, height) * this.#PARAMETERS.sigmaSFactor, this.#PARAMETERS.sigmaR, this.#PARAMETERS.kernelSize);\n        const threshold = this.#guessThreshold(histogram);\n        const contourList = this.#findContours(buffer, width, height, threshold);\n        return this.processDrawnLines({\n            lines: {\n                curves: contourList,\n                width,\n                height\n            },\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin,\n            mustSmooth: true,\n            areContours: true\n        });\n    }\n    static processDrawnLines({ lines, pageWidth, pageHeight, rotation, innerMargin, mustSmooth, areContours }) {\n        if (rotation % 180 !== 0) {\n            [pageWidth, pageHeight] = [\n                pageHeight,\n                pageWidth\n            ];\n        }\n        const { curves, width, height } = lines;\n        const thickness = lines.thickness ?? 0;\n        const linesAndPoints = [];\n        const ratio = Math.min(pageWidth / width, pageHeight / height);\n        const xScale = ratio / pageWidth;\n        const yScale = ratio / pageHeight;\n        const newCurves = [];\n        for (const { points } of curves){\n            const reducedPoints = mustSmooth ? this.#douglasPeucker(points) : points;\n            if (!reducedPoints) {\n                continue;\n            }\n            newCurves.push(reducedPoints);\n            const len = reducedPoints.length;\n            const newPoints = new Float32Array(len);\n            const line = new Float32Array(3 * (len === 2 ? 2 : len - 2));\n            linesAndPoints.push({\n                line,\n                points: newPoints\n            });\n            if (len === 2) {\n                newPoints[0] = reducedPoints[0] * xScale;\n                newPoints[1] = reducedPoints[1] * yScale;\n                line.set([\n                    NaN,\n                    NaN,\n                    NaN,\n                    NaN,\n                    newPoints[0],\n                    newPoints[1]\n                ], 0);\n                continue;\n            }\n            let [x1, y1, x2, y2] = reducedPoints;\n            x1 *= xScale;\n            y1 *= yScale;\n            x2 *= xScale;\n            y2 *= yScale;\n            newPoints.set([\n                x1,\n                y1,\n                x2,\n                y2\n            ], 0);\n            line.set([\n                NaN,\n                NaN,\n                NaN,\n                NaN,\n                x1,\n                y1\n            ], 0);\n            for(let i = 4; i < len; i += 2){\n                const x = newPoints[i] = reducedPoints[i] * xScale;\n                const y = newPoints[i + 1] = reducedPoints[i + 1] * yScale;\n                line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n                [x1, y1, x2, y2] = [\n                    x2,\n                    y2,\n                    x,\n                    y\n                ];\n            }\n        }\n        if (linesAndPoints.length === 0) {\n            return null;\n        }\n        const outline = areContours ? new ContourDrawOutline() : new InkDrawOutline();\n        outline.build(linesAndPoints, pageWidth, pageHeight, 1, rotation, areContours ? 0 : thickness, innerMargin);\n        return {\n            outline,\n            newCurves,\n            areContours,\n            thickness,\n            width,\n            height\n        };\n    }\n    static async compressSignature({ outlines, areContours, thickness, width, height }) {\n        let minDiff = Infinity;\n        let maxDiff = -Infinity;\n        let outlinesLength = 0;\n        for (const points of outlines){\n            outlinesLength += points.length;\n            for(let i = 2, ii = points.length; i < ii; i++){\n                const dx = points[i] - points[i - 2];\n                minDiff = Math.min(minDiff, dx);\n                maxDiff = Math.max(maxDiff, dx);\n            }\n        }\n        let bufferType;\n        if (minDiff >= -128 && maxDiff <= 127) {\n            bufferType = Int8Array;\n        } else if (minDiff >= -32768 && maxDiff <= 32767) {\n            bufferType = Int16Array;\n        } else {\n            bufferType = Int32Array;\n        }\n        const len = outlines.length;\n        const headerLength = BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * len;\n        const header = new Uint32Array(headerLength);\n        let offset = 0;\n        header[offset++] = headerLength * Uint32Array.BYTES_PER_ELEMENT + (outlinesLength - 2 * len) * bufferType.BYTES_PER_ELEMENT;\n        header[offset++] = 0;\n        header[offset++] = width;\n        header[offset++] = height;\n        header[offset++] = areContours ? 0 : 1;\n        header[offset++] = Math.max(0, Math.floor(thickness ?? 0));\n        header[offset++] = len;\n        header[offset++] = bufferType.BYTES_PER_ELEMENT;\n        for (const points of outlines){\n            header[offset++] = points.length - 2;\n            header[offset++] = points[0];\n            header[offset++] = points[1];\n        }\n        const cs = new CompressionStream(\"deflate-raw\");\n        const writer = cs.writable.getWriter();\n        await writer.ready;\n        writer.write(header);\n        const BufferCtor = bufferType.prototype.constructor;\n        for (const points of outlines){\n            const diffs = new BufferCtor(points.length - 2);\n            for(let i = 2, ii = points.length; i < ii; i++){\n                diffs[i - 2] = points[i] - points[i - 2];\n            }\n            writer.write(diffs);\n        }\n        writer.close();\n        const buf = await new Response(cs.readable).arrayBuffer();\n        const bytes = new Uint8Array(buf);\n        return toBase64Util(bytes);\n    }\n    static async decompressSignature(signatureData) {\n        try {\n            const bytes = fromBase64Util(signatureData);\n            const { readable, writable } = new DecompressionStream(\"deflate-raw\");\n            const writer = writable.getWriter();\n            await writer.ready;\n            writer.write(bytes).then(async ()=>{\n                await writer.ready;\n                await writer.close();\n            }).catch(()=>{});\n            let data = null;\n            let offset = 0;\n            for await (const chunk of readable){\n                data ||= new Uint8Array(new Uint32Array(chunk.buffer, 0, 4)[0]);\n                data.set(chunk, offset);\n                offset += chunk.length;\n            }\n            const header = new Uint32Array(data.buffer, 0, data.length >> 2);\n            const version = header[1];\n            if (version !== 0) {\n                throw new Error(`Invalid version: ${version}`);\n            }\n            const width = header[2];\n            const height = header[3];\n            const areContours = header[4] === 0;\n            const thickness = header[5];\n            const numberOfDrawings = header[6];\n            const bufferType = header[7];\n            const outlines = [];\n            const diffsOffset = (BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * numberOfDrawings) * Uint32Array.BYTES_PER_ELEMENT;\n            let diffs;\n            switch(bufferType){\n                case Int8Array.BYTES_PER_ELEMENT:\n                    diffs = new Int8Array(data.buffer, diffsOffset);\n                    break;\n                case Int16Array.BYTES_PER_ELEMENT:\n                    diffs = new Int16Array(data.buffer, diffsOffset);\n                    break;\n                case Int32Array.BYTES_PER_ELEMENT:\n                    diffs = new Int32Array(data.buffer, diffsOffset);\n                    break;\n            }\n            offset = 0;\n            for(let i = 0; i < numberOfDrawings; i++){\n                const len = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH];\n                const points = new Float32Array(len + 2);\n                outlines.push(points);\n                for(let j = 0; j < POINTS_PROPERTIES_NUMBER - 1; j++){\n                    points[j] = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH + j + 1];\n                }\n                for(let j = 0; j < len; j++){\n                    points[j + 2] = points[j] + diffs[offset++];\n                }\n            }\n            return {\n                areContours,\n                thickness,\n                outlines,\n                width,\n                height\n            };\n        } catch (e) {\n            warn(`decompressSignature: ${e}`);\n            return null;\n        }\n    }\n}\n; // ./src/display/editor/signature.js\nclass SignatureOptions extends DrawingOptions {\n    constructor(){\n        super();\n        super.updateProperties({\n            fill: AnnotationEditor._defaultLineColor,\n            \"stroke-width\": 0\n        });\n    }\n    clone() {\n        const clone = new SignatureOptions();\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass DrawnSignatureOptions extends InkDrawingOptions {\n    constructor(viewerParameters){\n        super(viewerParameters);\n        super.updateProperties({\n            stroke: AnnotationEditor._defaultLineColor,\n            \"stroke-width\": 1\n        });\n    }\n    clone() {\n        const clone = new DrawnSignatureOptions(this._viewParameters);\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass SignatureEditor extends DrawingEditor {\n    #isExtracted;\n    #description;\n    #signatureData;\n    #signatureUUID;\n    static{\n        this._type = \"signature\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.SIGNATURE;\n    }\n    static{\n        this._defaultDrawingOptions = null;\n    }\n    constructor(params){\n        super({\n            ...params,\n            mustBeCommitted: true,\n            name: \"signatureEditor\"\n        });\n        this.#isExtracted = false;\n        this.#description = null;\n        this.#signatureData = null;\n        this.#signatureUUID = null;\n        this._willKeepAspectRatio = true;\n        this.#signatureData = params.signatureData || null;\n        this.#description = null;\n        this.defaultL10nId = \"pdfjs-editor-signature-editor1\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        this._defaultDrawingOptions = new SignatureOptions();\n        this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(uiManager.viewParameters);\n    }\n    static getDefaultDrawingOptions(options) {\n        const clone = this._defaultDrawingOptions.clone();\n        clone.updateProperties(options);\n        return clone;\n    }\n    static get supportMultipleDrawings() {\n        return false;\n    }\n    static get typesMap() {\n        return shadow(this, \"typesMap\", new Map());\n    }\n    static get isDrawer() {\n        return false;\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"signature\",\n            hasDescription: !!this.#description\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        const hasDescriptionStats = data.get(\"hasDescription\");\n        return {\n            hasAltText: hasDescriptionStats.get(true) ?? 0,\n            hasNoAltText: hasDescriptionStats.get(false) ?? 0\n        };\n    }\n    get isResizable() {\n        return true;\n    }\n    onScaleChanging() {\n        if (this._drawId === null) {\n            return;\n        }\n        super.onScaleChanging();\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        const { _isCopy } = this;\n        if (_isCopy) {\n            this._isCopy = false;\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        if (this._drawId === null) {\n            if (this.#signatureData) {\n                const { lines, mustSmooth, areContours, description, uuid, heightInPage } = this.#signatureData;\n                const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n                const outline = SignatureExtractor.processDrawnLines({\n                    lines,\n                    pageWidth,\n                    pageHeight,\n                    rotation,\n                    innerMargin: SignatureEditor._INNER_MARGIN,\n                    mustSmooth,\n                    areContours\n                });\n                this.addSignature(outline, heightInPage, description, uuid);\n            } else {\n                this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n                    description: \"\"\n                }));\n                this.div.hidden = true;\n                this._uiManager.getSignature(this);\n            }\n        } else {\n            this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n                description: this.#description || \"\"\n            }));\n        }\n        if (_isCopy) {\n            this._isCopy = true;\n            this._moveAfterPaste(baseX, baseY);\n        }\n        return this.div;\n    }\n    setUuid(uuid) {\n        this.#signatureUUID = uuid;\n        this.addEditToolbar();\n    }\n    getUuid() {\n        return this.#signatureUUID;\n    }\n    get description() {\n        return this.#description;\n    }\n    set description(description) {\n        this.#description = description;\n        if (!this.div) {\n            return;\n        }\n        this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n            description\n        }));\n        super.addEditToolbar().then((toolbar)=>{\n            toolbar?.updateEditSignatureButton(description);\n        });\n    }\n    getSignaturePreview() {\n        const { newCurves, areContours, thickness, width, height } = this.#signatureData;\n        const maxDim = Math.max(width, height);\n        const outlineData = SignatureExtractor.processDrawnLines({\n            lines: {\n                curves: newCurves.map((points)=>({\n                        points\n                    })),\n                thickness,\n                width,\n                height\n            },\n            pageWidth: maxDim,\n            pageHeight: maxDim,\n            rotation: 0,\n            innerMargin: 0,\n            mustSmooth: false,\n            areContours\n        });\n        return {\n            areContours,\n            outline: outlineData.outline\n        };\n    }\n    get toolbarButtons() {\n        if (this._uiManager.signatureManager) {\n            return [\n                [\n                    \"editSignature\",\n                    this._uiManager.signatureManager\n                ]\n            ];\n        }\n        return super.toolbarButtons;\n    }\n    addSignature(data, heightInPage, description, uuid) {\n        const { x: savedX, y: savedY } = this;\n        const { outline } = this.#signatureData = data;\n        this.#isExtracted = outline instanceof ContourDrawOutline;\n        this.description = description;\n        let drawingOptions;\n        if (this.#isExtracted) {\n            drawingOptions = SignatureEditor.getDefaultDrawingOptions();\n        } else {\n            drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();\n            drawingOptions.updateProperties({\n                \"stroke-width\": outline.thickness\n            });\n        }\n        this._addOutlines({\n            drawOutlines: outline,\n            drawingOptions\n        });\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const [, pageHeight] = this.pageDimensions;\n        let newHeight = heightInPage / pageHeight;\n        newHeight = newHeight >= 1 ? 0.5 : newHeight;\n        this.width *= newHeight / this.height;\n        if (this.width >= 1) {\n            newHeight *= 0.9 / this.width;\n            this.width = 0.9;\n        }\n        this.height = newHeight;\n        this.setDims(parentWidth * this.width, parentHeight * this.height);\n        this.x = savedX;\n        this.y = savedY;\n        this.center();\n        this._onResized();\n        this.onScaleChanging();\n        this.rotate();\n        this._uiManager.addToAnnotationStorage(this);\n        this.setUuid(uuid);\n        this._reportTelemetry({\n            action: \"pdfjs.signature.inserted\",\n            data: {\n                hasBeenSaved: !!uuid,\n                hasDescription: !!description\n            }\n        });\n        this.div.hidden = false;\n    }\n    getFromImage(bitmap) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.process(bitmap, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);\n    }\n    getFromText(text, fontInfo) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.extractContoursFromText(text, fontInfo, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);\n    }\n    getDrawnSignature(curves) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.processDrawnLines({\n            lines: curves,\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin: SignatureEditor._INNER_MARGIN,\n            mustSmooth: false,\n            areContours: false\n        });\n    }\n    createDrawingOptions({ areContours, thickness }) {\n        if (areContours) {\n            this._drawingOptions = SignatureEditor.getDefaultDrawingOptions();\n        } else {\n            this._drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();\n            this._drawingOptions.updateProperties({\n                \"stroke-width\": thickness\n            });\n        }\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        const { lines, points, rect } = this.serializeDraw(isForCopying);\n        const { _drawingOptions: { \"stroke-width\": thickness } } = this;\n        const serialized = {\n            annotationType: AnnotationEditorType.SIGNATURE,\n            isSignature: true,\n            areContours: this.#isExtracted,\n            color: [\n                0,\n                0,\n                0\n            ],\n            thickness: this.#isExtracted ? 0 : thickness,\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId\n        };\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.paths = {\n                lines,\n                points\n            };\n            serialized.uuid = this.#signatureUUID;\n            serialized.isCopy = true;\n        } else {\n            serialized.lines = lines;\n        }\n        if (this.#description) {\n            serialized.accessibilityData = {\n                type: \"Figure\",\n                alt: this.#description\n            };\n        }\n        return serialized;\n    }\n    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n        if (data.areContours) {\n            return ContourDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n        }\n        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n    }\n    static async deserialize(data, parent, uiManager) {\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.#isExtracted = data.areContours;\n        editor.description = data.accessibilityData?.alt || \"\";\n        editor.#signatureUUID = data.uuid;\n        return editor;\n    }\n}\n; // ./src/display/editor/stamp.js\nclass StampEditor extends AnnotationEditor {\n    #bitmap;\n    #bitmapId;\n    #bitmapPromise;\n    #bitmapUrl;\n    #bitmapFile;\n    #bitmapFileName;\n    #canvas;\n    #missingCanvas;\n    #resizeTimeoutId;\n    #isSvg;\n    #hasBeenAddedInUndoStack;\n    static{\n        this._type = \"stamp\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.STAMP;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"stampEditor\"\n        });\n        this.#bitmap = null;\n        this.#bitmapId = null;\n        this.#bitmapPromise = null;\n        this.#bitmapUrl = null;\n        this.#bitmapFile = null;\n        this.#bitmapFileName = \"\";\n        this.#canvas = null;\n        this.#missingCanvas = false;\n        this.#resizeTimeoutId = null;\n        this.#isSvg = false;\n        this.#hasBeenAddedInUndoStack = false;\n        this.#bitmapUrl = params.bitmapUrl;\n        this.#bitmapFile = params.bitmapFile;\n        this.defaultL10nId = \"pdfjs-editor-stamp-editor\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n    }\n    static isHandlingMimeForPasting(mime) {\n        return SupportedImageMimeTypes.includes(mime);\n    }\n    static paste(item, parent) {\n        parent.pasteEditor({\n            mode: AnnotationEditorType.STAMP\n        }, {\n            bitmapFile: item.getAsFile()\n        });\n    }\n    altTextFinish() {\n        if (this._uiManager.useNewAltTextFlow) {\n            this.div.hidden = false;\n        }\n        super.altTextFinish();\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"stamp\",\n            hasAltText: !!this.altTextData?.altText\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        const hasAltTextStats = data.get(\"hasAltText\");\n        return {\n            hasAltText: hasAltTextStats.get(true) ?? 0,\n            hasNoAltText: hasAltTextStats.get(false) ?? 0\n        };\n    }\n    #getBitmapFetched(data, fromId = false) {\n        if (!data) {\n            this.remove();\n            return;\n        }\n        this.#bitmap = data.bitmap;\n        if (!fromId) {\n            this.#bitmapId = data.id;\n            this.#isSvg = data.isSvg;\n        }\n        if (data.file) {\n            this.#bitmapFileName = data.file.name;\n        }\n        this.#createCanvas();\n    }\n    #getBitmapDone() {\n        this.#bitmapPromise = null;\n        this._uiManager.enableWaiting(false);\n        if (!this.#canvas) {\n            return;\n        }\n        if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this.addEditToolbar().then(()=>{\n                this._editToolbar.hide();\n                this._uiManager.editAltText(this, true);\n            });\n            return;\n        }\n        if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this._reportTelemetry({\n                action: \"pdfjs.image.image_added\",\n                data: {\n                    alt_text_modal: false,\n                    alt_text_type: \"empty\"\n                }\n            });\n            try {\n                this.mlGuessAltText();\n            } catch  {}\n        }\n        this.div.focus();\n    }\n    async mlGuessAltText(imageData = null, updateAltTextData = true) {\n        if (this.hasAltTextData()) {\n            return null;\n        }\n        const { mlManager } = this._uiManager;\n        if (!mlManager) {\n            throw new Error(\"No ML.\");\n        }\n        if (!await mlManager.isEnabledFor(\"altText\")) {\n            throw new Error(\"ML isn't enabled for alt text.\");\n        }\n        const { data, width, height } = imageData || this.copyCanvas(null, null, true).imageData;\n        const response = await mlManager.guess({\n            name: \"altText\",\n            request: {\n                data,\n                width,\n                height,\n                channels: data.length / (width * height)\n            }\n        });\n        if (!response) {\n            throw new Error(\"No response from the AI service.\");\n        }\n        if (response.error) {\n            throw new Error(\"Error from the AI service.\");\n        }\n        if (response.cancel) {\n            return null;\n        }\n        if (!response.output) {\n            throw new Error(\"No valid response from the AI service.\");\n        }\n        const altText = response.output;\n        await this.setGuessedAltText(altText);\n        if (updateAltTextData && !this.hasAltTextData()) {\n            this.altTextData = {\n                alt: altText,\n                decorative: false\n            };\n        }\n        return altText;\n    }\n    #getBitmap() {\n        if (this.#bitmapId) {\n            this._uiManager.enableWaiting(true);\n            this._uiManager.imageManager.getFromId(this.#bitmapId).then((data)=>this.#getBitmapFetched(data, true)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapUrl) {\n            const url = this.#bitmapUrl;\n            this.#bitmapUrl = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapFile) {\n            const file = this.#bitmapFile;\n            this.#bitmapFile = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        const input = document.createElement(\"input\");\n        input.type = \"file\";\n        input.accept = SupportedImageMimeTypes.join(\",\");\n        const signal = this._uiManager._signal;\n        this.#bitmapPromise = new Promise((resolve)=>{\n            input.addEventListener(\"change\", async ()=>{\n                if (!input.files || input.files.length === 0) {\n                    this.remove();\n                } else {\n                    this._uiManager.enableWaiting(true);\n                    const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n                    this._reportTelemetry({\n                        action: \"pdfjs.image.image_selected\",\n                        data: {\n                            alt_text_modal: this._uiManager.useNewAltTextFlow\n                        }\n                    });\n                    this.#getBitmapFetched(data);\n                }\n                resolve();\n            }, {\n                signal\n            });\n            input.addEventListener(\"cancel\", ()=>{\n                this.remove();\n                resolve();\n            }, {\n                signal\n            });\n        }).finally(()=>this.#getBitmapDone());\n        input.click();\n    }\n    remove() {\n        if (this.#bitmapId) {\n            this.#bitmap = null;\n            this._uiManager.imageManager.deleteId(this.#bitmapId);\n            this.#canvas?.remove();\n            this.#canvas = null;\n            if (this.#resizeTimeoutId) {\n                clearTimeout(this.#resizeTimeoutId);\n                this.#resizeTimeoutId = null;\n            }\n        }\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            if (this.#bitmapId) {\n                this.#getBitmap();\n            }\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (this.#bitmapId && this.#canvas === null) {\n            this.#getBitmap();\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    onceAdded(focus) {\n        this._isDraggable = true;\n        if (focus) {\n            this.div.focus();\n        }\n    }\n    isEmpty() {\n        return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId || this.#missingCanvas);\n    }\n    get toolbarButtons() {\n        return [\n            [\n                \"altText\",\n                this.createAltText()\n            ]\n        ];\n    }\n    get isResizable() {\n        return true;\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.div.hidden = true;\n        this.createAltText();\n        if (!this.#missingCanvas) {\n            if (this.#bitmap) {\n                this.#createCanvas();\n            } else {\n                this.#getBitmap();\n            }\n        }\n        if (this._isCopy) {\n            this._moveAfterPaste(baseX, baseY);\n        }\n        this._uiManager.addShouldRescale(this);\n        return this.div;\n    }\n    setCanvas(annotationElementId, canvas) {\n        const { id: bitmapId, bitmap } = this._uiManager.imageManager.getFromCanvas(annotationElementId, canvas);\n        canvas.remove();\n        if (bitmapId && this._uiManager.imageManager.isValidId(bitmapId)) {\n            this.#bitmapId = bitmapId;\n            if (bitmap) {\n                this.#bitmap = bitmap;\n            }\n            this.#missingCanvas = false;\n            this.#createCanvas();\n        }\n    }\n    _onResized() {\n        this.onScaleChanging();\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        if (this.#resizeTimeoutId !== null) {\n            clearTimeout(this.#resizeTimeoutId);\n        }\n        const TIME_TO_WAIT = 200;\n        this.#resizeTimeoutId = setTimeout(()=>{\n            this.#resizeTimeoutId = null;\n            this.#drawBitmap();\n        }, TIME_TO_WAIT);\n    }\n    #createCanvas() {\n        const { div } = this;\n        let { width, height } = this.#bitmap;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const MAX_RATIO = 0.75;\n        if (this.width) {\n            width = this.width * pageWidth;\n            height = this.height * pageHeight;\n        } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n            const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n            width *= factor;\n            height *= factor;\n        }\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);\n        this._uiManager.enableWaiting(false);\n        const canvas = this.#canvas = document.createElement(\"canvas\");\n        canvas.setAttribute(\"role\", \"img\");\n        this.addContainer(canvas);\n        this.width = width / pageWidth;\n        this.height = height / pageHeight;\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        } else {\n            this.fixAndSetPosition();\n        }\n        this._initialOptions = null;\n        if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {\n            div.hidden = false;\n        }\n        this.#drawBitmap();\n        if (!this.#hasBeenAddedInUndoStack) {\n            this.parent.addUndoableEditor(this);\n            this.#hasBeenAddedInUndoStack = true;\n        }\n        this._reportTelemetry({\n            action: \"inserted_image\"\n        });\n        if (this.#bitmapFileName) {\n            this.div.setAttribute(\"aria-description\", this.#bitmapFileName);\n        }\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(\"pdfjs-editor-stamp-added-alert\");\n        }\n    }\n    copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {\n        if (!maxDataDimension) {\n            maxDataDimension = 224;\n        }\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        const outputScale = new OutputScale();\n        let bitmap = this.#bitmap;\n        let width = bitmapWidth, height = bitmapHeight;\n        let canvas = null;\n        if (maxPreviewDimension) {\n            if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {\n                const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);\n                width = Math.floor(bitmapWidth * ratio);\n                height = Math.floor(bitmapHeight * ratio);\n            }\n            canvas = document.createElement(\"canvas\");\n            const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);\n            const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);\n            if (!this.#isSvg) {\n                bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);\n            }\n            const ctx = canvas.getContext(\"2d\");\n            ctx.filter = this._uiManager.hcmFilter;\n            let white = \"white\", black = \"#cfcfd8\";\n            if (this._uiManager.hcmFilter !== \"none\") {\n                black = \"black\";\n            } else if (window.matchMedia?.(\"(prefers-color-scheme: dark)\").matches) {\n                white = \"#8f8f9d\";\n                black = \"#42414d\";\n            }\n            const boxDim = 15;\n            const boxDimWidth = boxDim * outputScale.sx;\n            const boxDimHeight = boxDim * outputScale.sy;\n            const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);\n            const patternCtx = pattern.getContext(\"2d\");\n            patternCtx.fillStyle = white;\n            patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);\n            patternCtx.fillStyle = black;\n            patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);\n            patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);\n            ctx.fillStyle = ctx.createPattern(pattern, \"repeat\");\n            ctx.fillRect(0, 0, scaledWidth, scaledHeight);\n            ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n        }\n        let imageData = null;\n        if (createImageData) {\n            let dataWidth, dataHeight;\n            if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {\n                dataWidth = bitmap.width;\n                dataHeight = bitmap.height;\n            } else {\n                bitmap = this.#bitmap;\n                if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {\n                    const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);\n                    dataWidth = Math.floor(bitmapWidth * ratio);\n                    dataHeight = Math.floor(bitmapHeight * ratio);\n                    if (!this.#isSvg) {\n                        bitmap = this.#scaleBitmap(dataWidth, dataHeight);\n                    }\n                }\n            }\n            const offscreen = new OffscreenCanvas(dataWidth, dataHeight);\n            const offscreenCtx = offscreen.getContext(\"2d\", {\n                willReadFrequently: true\n            });\n            offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);\n            imageData = {\n                width: dataWidth,\n                height: dataHeight,\n                data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data\n            };\n        }\n        return {\n            canvas,\n            width,\n            height,\n            imageData\n        };\n    }\n    #scaleBitmap(width, height) {\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        let newWidth = bitmapWidth;\n        let newHeight = bitmapHeight;\n        let bitmap = this.#bitmap;\n        while(newWidth > 2 * width || newHeight > 2 * height){\n            const prevWidth = newWidth;\n            const prevHeight = newHeight;\n            if (newWidth > 2 * width) {\n                newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n            }\n            if (newHeight > 2 * height) {\n                newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n            }\n            const offscreen = new OffscreenCanvas(newWidth, newHeight);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n            bitmap = offscreen.transferToImageBitmap();\n        }\n        return bitmap;\n    }\n    #drawBitmap() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { width, height } = this;\n        const outputScale = new OutputScale();\n        const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);\n        const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);\n        const canvas = this.#canvas;\n        if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {\n            return;\n        }\n        canvas.width = scaledWidth;\n        canvas.height = scaledHeight;\n        const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);\n        const ctx = canvas.getContext(\"2d\");\n        ctx.filter = this._uiManager.hcmFilter;\n        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n    }\n    #serializeBitmap(toUrl) {\n        if (toUrl) {\n            if (this.#isSvg) {\n                const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n                if (url) {\n                    return url;\n                }\n            }\n            const canvas = document.createElement(\"canvas\");\n            ({ width: canvas.width, height: canvas.height } = this.#bitmap);\n            const ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0);\n            return canvas.toDataURL();\n        }\n        if (this.#isSvg) {\n            const [pageWidth, pageHeight] = this.pageDimensions;\n            const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const offscreen = new OffscreenCanvas(width, height);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n            return offscreen.transferToImageBitmap();\n        }\n        return structuredClone(this.#bitmap);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        let missingCanvas = false;\n        if (data instanceof StampAnnotationElement) {\n            const { data: { rect, rotation, id, structParent, popupRef, contentsObj }, container, parent: { page: { pageNumber } }, canvas } = data;\n            let bitmapId, bitmap;\n            if (canvas) {\n                delete data.canvas;\n                ({ id: bitmapId, bitmap } = uiManager.imageManager.getFromCanvas(container.id, canvas));\n                canvas.remove();\n            } else {\n                missingCanvas = true;\n                data._hasNoCanvas = true;\n            }\n            const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get(\"aria-label\") || \"\";\n            initialData = data = {\n                annotationType: AnnotationEditorType.STAMP,\n                bitmapId,\n                bitmap,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                accessibilityData: {\n                    decorative: false,\n                    altText\n                },\n                isSvg: false,\n                structParent,\n                popupRef,\n                comment: contentsObj?.str || null\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        const { rect, bitmap, bitmapUrl, bitmapId, isSvg, accessibilityData } = data;\n        if (missingCanvas) {\n            uiManager.addMissingCanvas(data.id, editor);\n            editor.#missingCanvas = true;\n        } else if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n            editor.#bitmapId = bitmapId;\n            if (bitmap) {\n                editor.#bitmap = bitmap;\n            }\n        } else {\n            editor.#bitmapUrl = bitmapUrl;\n        }\n        editor.#isSvg = isSvg;\n        const [parentWidth, parentHeight] = editor.pageDimensions;\n        editor.width = (rect[2] - rect[0]) / parentWidth;\n        editor.height = (rect[3] - rect[1]) / parentHeight;\n        if (accessibilityData) {\n            editor.altTextData = accessibilityData;\n        }\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data.comment);\n        }\n        editor.#hasBeenAddedInUndoStack = !!initialData;\n        return editor;\n    }\n    serialize(isForCopying = false, context = null) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const serialized = {\n            annotationType: AnnotationEditorType.STAMP,\n            bitmapId: this.#bitmapId,\n            pageIndex: this.pageIndex,\n            rect: this.getPDFRect(),\n            rotation: this.rotation,\n            isSvg: this.#isSvg,\n            structTreeParentId: this._structTreeParentId\n        };\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.bitmapUrl = this.#serializeBitmap(true);\n            serialized.accessibilityData = this.serializeAltText(true);\n            serialized.isCopy = true;\n            return serialized;\n        }\n        const { decorative, altText } = this.serializeAltText(false);\n        if (!decorative && altText) {\n            serialized.accessibilityData = {\n                type: \"Figure\",\n                alt: altText\n            };\n        }\n        if (this.annotationElementId) {\n            const changes = this.#hasElementChanged(serialized);\n            if (changes.isSame) {\n                return null;\n            }\n            if (changes.isSameAltText) {\n                delete serialized.accessibilityData;\n            } else {\n                serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;\n            }\n        }\n        serialized.id = this.annotationElementId;\n        if (context === null) {\n            return serialized;\n        }\n        context.stamps ||= new Map();\n        const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n        if (!context.stamps.has(this.#bitmapId)) {\n            context.stamps.set(this.#bitmapId, {\n                area,\n                serialized\n            });\n            serialized.bitmap = this.#serializeBitmap(false);\n        } else if (this.#isSvg) {\n            const prevData = context.stamps.get(this.#bitmapId);\n            if (area > prevData.area) {\n                prevData.area = area;\n                prevData.serialized.bitmap.close();\n                prevData.serialized.bitmap = this.#serializeBitmap(false);\n            }\n        }\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { pageIndex, accessibilityData: { altText } } = this._initialData;\n        const isSamePageIndex = serialized.pageIndex === pageIndex;\n        const isSameAltText = (serialized.accessibilityData?.alt || \"\") === altText;\n        return {\n            isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,\n            isSameAltText\n        };\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        const params = {\n            rect: this.getPDFRect()\n        };\n        if (this.hasEditedComment) {\n            params.popup = this.comment;\n        }\n        annotation.updateEdited(params);\n        return null;\n    }\n}\n; // ./src/display/editor/annotation_editor_layer.js\nclass AnnotationEditorLayer {\n    #accessibilityManager;\n    #allowClick;\n    #annotationLayer;\n    #clickAC;\n    #editorFocusTimeoutId;\n    #editors;\n    #hadPointerDown;\n    #isDisabling;\n    #isEnabling;\n    #drawingAC;\n    #focusedElement;\n    #textLayer;\n    #textSelectionAC;\n    #textLayerDblClickAC;\n    #lastPointerDownTimestamp;\n    #uiManager;\n    static{\n        this._initialized = false;\n    }\n    static #editorTypes = new Map([\n        FreeTextEditor,\n        InkEditor,\n        StampEditor,\n        HighlightEditor,\n        SignatureEditor\n    ].map((type)=>[\n            type._editorType,\n            type\n        ]));\n    constructor({ uiManager, pageIndex, div, structTreeLayer, accessibilityManager, annotationLayer, drawLayer, textLayer, viewport, l10n }){\n        this.#allowClick = false;\n        this.#annotationLayer = null;\n        this.#clickAC = null;\n        this.#editorFocusTimeoutId = null;\n        this.#editors = new Map();\n        this.#hadPointerDown = false;\n        this.#isDisabling = false;\n        this.#isEnabling = false;\n        this.#drawingAC = null;\n        this.#focusedElement = null;\n        this.#textLayer = null;\n        this.#textSelectionAC = null;\n        this.#textLayerDblClickAC = null;\n        this.#lastPointerDownTimestamp = -1;\n        const editorTypes = [\n            ...AnnotationEditorLayer.#editorTypes.values()\n        ];\n        if (!AnnotationEditorLayer._initialized) {\n            AnnotationEditorLayer._initialized = true;\n            for (const editorType of editorTypes){\n                editorType.initialize(l10n, uiManager);\n            }\n        }\n        uiManager.registerEditorTypes(editorTypes);\n        this.#uiManager = uiManager;\n        this.pageIndex = pageIndex;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationLayer = annotationLayer;\n        this.viewport = viewport;\n        this.#textLayer = textLayer;\n        this.drawLayer = drawLayer;\n        this._structTree = structTreeLayer;\n        this.#uiManager.addLayer(this);\n    }\n    get isEmpty() {\n        return this.#editors.size === 0;\n    }\n    get isInvisible() {\n        return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;\n    }\n    updateToolbar(options) {\n        this.#uiManager.updateToolbar(options);\n    }\n    updateMode(mode = this.#uiManager.getMode()) {\n        this.#cleanup();\n        switch(mode){\n            case AnnotationEditorType.NONE:\n                this.disableTextSelection();\n                this.togglePointerEvents(false);\n                this.toggleAnnotationLayerPointerEvents(true);\n                this.disableClick();\n                return;\n            case AnnotationEditorType.INK:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n                break;\n            case AnnotationEditorType.HIGHLIGHT:\n                this.enableTextSelection();\n                this.togglePointerEvents(false);\n                this.disableClick();\n                break;\n            default:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n        }\n        this.toggleAnnotationLayerPointerEvents(false);\n        const { classList } = this.div;\n        for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n            classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);\n        }\n        this.div.hidden = false;\n    }\n    hasTextLayer(textLayer) {\n        return textLayer === this.#textLayer?.div;\n    }\n    setEditingState(isEditing) {\n        this.#uiManager.setEditingState(isEditing);\n    }\n    addCommands(params) {\n        this.#uiManager.addCommands(params);\n    }\n    cleanUndoStack(type) {\n        this.#uiManager.cleanUndoStack(type);\n    }\n    toggleDrawing(enabled = false) {\n        this.div.classList.toggle(\"drawing\", !enabled);\n    }\n    togglePointerEvents(enabled = false) {\n        this.div.classList.toggle(\"disabled\", !enabled);\n    }\n    toggleAnnotationLayerPointerEvents(enabled = false) {\n        this.#annotationLayer?.div.classList.toggle(\"disabled\", !enabled);\n    }\n    async enable() {\n        this.#isEnabling = true;\n        this.div.tabIndex = 0;\n        this.togglePointerEvents(true);\n        this.#textLayerDblClickAC?.abort();\n        this.#textLayerDblClickAC = null;\n        const annotationElementIds = new Set();\n        for (const editor of this.#editors.values()){\n            editor.enableEditing();\n            editor.show(true);\n            if (editor.annotationElementId) {\n                this.#uiManager.removeChangedExistingAnnotation(editor);\n                annotationElementIds.add(editor.annotationElementId);\n            }\n        }\n        if (!this.#annotationLayer) {\n            this.#isEnabling = false;\n            return;\n        }\n        const editables = this.#annotationLayer.getEditableAnnotations();\n        for (const editable of editables){\n            editable.hide();\n            if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n                continue;\n            }\n            if (annotationElementIds.has(editable.data.id)) {\n                continue;\n            }\n            const editor = await this.deserialize(editable);\n            if (!editor) {\n                continue;\n            }\n            this.addOrRebuild(editor);\n            editor.enableEditing();\n        }\n        this.#isEnabling = false;\n    }\n    disable() {\n        this.#isDisabling = true;\n        this.div.tabIndex = -1;\n        this.togglePointerEvents(false);\n        if (this.#textLayer && !this.#textLayerDblClickAC) {\n            this.#textLayerDblClickAC = new AbortController();\n            const signal = this.#uiManager.combinedSignal(this.#textLayerDblClickAC);\n            this.#textLayer.div.addEventListener(\"pointerdown\", (e)=>{\n                const DBL_CLICK_THRESHOLD = 500;\n                const { clientX, clientY, timeStamp } = e;\n                const lastPointerDownTimestamp = this.#lastPointerDownTimestamp;\n                if (timeStamp - lastPointerDownTimestamp > DBL_CLICK_THRESHOLD) {\n                    this.#lastPointerDownTimestamp = timeStamp;\n                    return;\n                }\n                this.#lastPointerDownTimestamp = -1;\n                const { classList } = this.div;\n                classList.toggle(\"getElements\", true);\n                const elements = document.elementsFromPoint(clientX, clientY);\n                classList.toggle(\"getElements\", false);\n                if (!this.div.contains(elements[0])) {\n                    return;\n                }\n                let id;\n                const regex = new RegExp(`^${AnnotationEditorPrefix}[0-9]+$`);\n                for (const element of elements){\n                    if (regex.test(element.id)) {\n                        id = element.id;\n                        break;\n                    }\n                }\n                if (!id) {\n                    return;\n                }\n                const editor = this.#editors.get(id);\n                if (editor?.annotationElementId === null) {\n                    e.stopPropagation();\n                    e.preventDefault();\n                    editor.dblclick();\n                }\n            }, {\n                signal,\n                capture: true\n            });\n        }\n        const changedAnnotations = new Map();\n        const resetAnnotations = new Map();\n        for (const editor of this.#editors.values()){\n            editor.disableEditing();\n            if (!editor.annotationElementId) {\n                continue;\n            }\n            if (editor.serialize() !== null) {\n                changedAnnotations.set(editor.annotationElementId, editor);\n                continue;\n            } else {\n                resetAnnotations.set(editor.annotationElementId, editor);\n            }\n            this.getEditableAnnotation(editor.annotationElementId)?.show();\n            editor.remove();\n        }\n        if (this.#annotationLayer) {\n            const editables = this.#annotationLayer.getEditableAnnotations();\n            for (const editable of editables){\n                const { id } = editable.data;\n                if (this.#uiManager.isDeletedAnnotationElement(id)) {\n                    editable.updateEdited({\n                        deleted: true\n                    });\n                    continue;\n                }\n                let editor = resetAnnotations.get(id);\n                if (editor) {\n                    editor.resetAnnotationElement(editable);\n                    editor.show(false);\n                    editable.show();\n                    continue;\n                }\n                editor = changedAnnotations.get(id);\n                if (editor) {\n                    this.#uiManager.addChangedExistingAnnotation(editor);\n                    if (editor.renderAnnotationElement(editable)) {\n                        editor.show(false);\n                    }\n                }\n                editable.show();\n            }\n        }\n        this.#cleanup();\n        if (this.isEmpty) {\n            this.div.hidden = true;\n        }\n        const { classList } = this.div;\n        for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n            classList.remove(`${editorType._type}Editing`);\n        }\n        this.disableTextSelection();\n        this.toggleAnnotationLayerPointerEvents(true);\n        this.#isDisabling = false;\n    }\n    getEditableAnnotation(id) {\n        return this.#annotationLayer?.getEditableAnnotation(id) || null;\n    }\n    setActiveEditor(editor) {\n        const currentActive = this.#uiManager.getActive();\n        if (currentActive === editor) {\n            return;\n        }\n        this.#uiManager.setActiveEditor(editor);\n    }\n    enableTextSelection() {\n        this.div.tabIndex = -1;\n        if (this.#textLayer?.div && !this.#textSelectionAC) {\n            this.#textSelectionAC = new AbortController();\n            const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);\n            this.#textLayer.div.addEventListener(\"pointerdown\", this.#textLayerPointerDown.bind(this), {\n                signal\n            });\n            this.#textLayer.div.classList.add(\"highlighting\");\n        }\n    }\n    disableTextSelection() {\n        this.div.tabIndex = 0;\n        if (this.#textLayer?.div && this.#textSelectionAC) {\n            this.#textSelectionAC.abort();\n            this.#textSelectionAC = null;\n            this.#textLayer.div.classList.remove(\"highlighting\");\n        }\n    }\n    #textLayerPointerDown(event) {\n        this.#uiManager.unselectAll();\n        const { target } = event;\n        if (target === this.#textLayer.div || (target.getAttribute(\"role\") === \"img\" || target.classList.contains(\"endOfContent\")) && this.#textLayer.div.contains(target)) {\n            const { isMac } = util_FeatureTest.platform;\n            if (event.button !== 0 || event.ctrlKey && isMac) {\n                return;\n            }\n            this.#uiManager.showAllEditors(\"highlight\", true, true);\n            this.#textLayer.div.classList.add(\"free\");\n            this.toggleDrawing();\n            HighlightEditor.startHighlighting(this, this.#uiManager.direction === \"ltr\", {\n                target: this.#textLayer.div,\n                x: event.x,\n                y: event.y\n            });\n            this.#textLayer.div.addEventListener(\"pointerup\", ()=>{\n                this.#textLayer.div.classList.remove(\"free\");\n                this.toggleDrawing(true);\n            }, {\n                once: true,\n                signal: this.#uiManager._signal\n            });\n            event.preventDefault();\n        }\n    }\n    enableClick() {\n        if (this.#clickAC) {\n            return;\n        }\n        this.#clickAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#clickAC);\n        this.div.addEventListener(\"pointerdown\", this.pointerdown.bind(this), {\n            signal\n        });\n        const pointerup = this.pointerup.bind(this);\n        this.div.addEventListener(\"pointerup\", pointerup, {\n            signal\n        });\n        this.div.addEventListener(\"pointercancel\", pointerup, {\n            signal\n        });\n    }\n    disableClick() {\n        this.#clickAC?.abort();\n        this.#clickAC = null;\n    }\n    attach(editor) {\n        this.#editors.set(editor.id, editor);\n        const { annotationElementId } = editor;\n        if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n            this.#uiManager.removeDeletedAnnotationElement(editor);\n        }\n    }\n    detach(editor) {\n        this.#editors.delete(editor.id);\n        this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n        if (!this.#isDisabling && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor);\n        }\n    }\n    remove(editor) {\n        this.detach(editor);\n        this.#uiManager.removeEditor(editor);\n        editor.div.remove();\n        editor.isAttachedToDOM = false;\n    }\n    changeParent(editor) {\n        if (editor.parent === this) {\n            return;\n        }\n        if (editor.parent && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n            AnnotationEditor.deleteAnnotationElement(editor);\n            editor.annotationElementId = null;\n        }\n        this.attach(editor);\n        editor.parent?.detach(editor);\n        editor.setParent(this);\n        if (editor.div && editor.isAttachedToDOM) {\n            editor.div.remove();\n            this.div.append(editor.div);\n        }\n    }\n    add(editor) {\n        if (editor.parent === this && editor.isAttachedToDOM) {\n            return;\n        }\n        this.changeParent(editor);\n        this.#uiManager.addEditor(editor);\n        this.attach(editor);\n        if (!editor.isAttachedToDOM) {\n            const div = editor.render();\n            this.div.append(div);\n            editor.isAttachedToDOM = true;\n        }\n        editor.fixAndSetPosition();\n        editor.onceAdded(!this.#isEnabling);\n        this.#uiManager.addToAnnotationStorage(editor);\n        editor._reportTelemetry(editor.telemetryInitialData);\n    }\n    moveEditorInDOM(editor) {\n        if (!editor.isAttachedToDOM) {\n            return;\n        }\n        const { activeElement } = document;\n        if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {\n            editor._focusEventsAllowed = false;\n            this.#editorFocusTimeoutId = setTimeout(()=>{\n                this.#editorFocusTimeoutId = null;\n                if (!editor.div.contains(document.activeElement)) {\n                    editor.div.addEventListener(\"focusin\", ()=>{\n                        editor._focusEventsAllowed = true;\n                    }, {\n                        once: true,\n                        signal: this.#uiManager._signal\n                    });\n                    activeElement.focus();\n                } else {\n                    editor._focusEventsAllowed = true;\n                }\n            }, 0);\n        }\n        editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n    }\n    addOrRebuild(editor) {\n        if (editor.needsToBeRebuilt()) {\n            editor.parent ||= this;\n            editor.rebuild();\n            editor.show();\n        } else {\n            this.add(editor);\n        }\n    }\n    addUndoableEditor(editor) {\n        const cmd = ()=>editor._uiManager.rebuild(editor);\n        const undo = ()=>{\n            editor.remove();\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: false\n        });\n    }\n    getNextId() {\n        return this.#uiManager.getId();\n    }\n    get #currentEditorType() {\n        return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());\n    }\n    combinedSignal(ac) {\n        return this.#uiManager.combinedSignal(ac);\n    }\n    #createNewEditor(params) {\n        const editorType = this.#currentEditorType;\n        return editorType ? new editorType.prototype.constructor(params) : null;\n    }\n    canCreateNewEmptyEditor() {\n        return this.#currentEditorType?.canCreateNewEmptyEditor();\n    }\n    async pasteEditor(options, params) {\n        this.updateToolbar(options);\n        await this.#uiManager.updateMode(options.mode);\n        const { offsetX, offsetY } = this.#getCenterPoint();\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: offsetX,\n            y: offsetY,\n            uiManager: this.#uiManager,\n            isCentered: true,\n            ...params\n        });\n        if (editor) {\n            this.add(editor);\n        }\n    }\n    async deserialize(data) {\n        return await AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager) || null;\n    }\n    createAndAddNewEditor(event, isCentered, data = {}) {\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: event.offsetX,\n            y: event.offsetY,\n            uiManager: this.#uiManager,\n            isCentered,\n            ...data\n        });\n        if (editor) {\n            this.add(editor);\n        }\n        return editor;\n    }\n    #getCenterPoint() {\n        const { x, y, width, height } = this.div.getBoundingClientRect();\n        const tlX = Math.max(0, x);\n        const tlY = Math.max(0, y);\n        const brX = Math.min(window.innerWidth, x + width);\n        const brY = Math.min(window.innerHeight, y + height);\n        const centerX = (tlX + brX) / 2 - x;\n        const centerY = (tlY + brY) / 2 - y;\n        const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [\n            centerX,\n            centerY\n        ] : [\n            centerY,\n            centerX\n        ];\n        return {\n            offsetX,\n            offsetY\n        };\n    }\n    addNewEditor(data = {}) {\n        this.createAndAddNewEditor(this.#getCenterPoint(), true, data);\n    }\n    setSelected(editor) {\n        this.#uiManager.setSelected(editor);\n    }\n    toggleSelected(editor) {\n        this.#uiManager.toggleSelected(editor);\n    }\n    unselect(editor) {\n        this.#uiManager.unselect(editor);\n    }\n    pointerup(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        if (!this.#hadPointerDown) {\n            return;\n        }\n        this.#hadPointerDown = false;\n        if (this.#currentEditorType?.isDrawer && this.#currentEditorType.supportMultipleDrawings) {\n            return;\n        }\n        if (!this.#allowClick) {\n            this.#allowClick = true;\n            return;\n        }\n        const currentMode = this.#uiManager.getMode();\n        if (currentMode === AnnotationEditorType.STAMP || currentMode === AnnotationEditorType.SIGNATURE) {\n            this.#uiManager.unselectAll();\n            return;\n        }\n        this.createAndAddNewEditor(event, false);\n    }\n    pointerdown(event) {\n        if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {\n            this.enableTextSelection();\n        }\n        if (this.#hadPointerDown) {\n            this.#hadPointerDown = false;\n            return;\n        }\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        this.#hadPointerDown = true;\n        if (this.#currentEditorType?.isDrawer) {\n            this.startDrawingSession(event);\n            return;\n        }\n        const editor = this.#uiManager.getActive();\n        this.#allowClick = !editor || editor.isEmpty();\n    }\n    startDrawingSession(event) {\n        this.div.focus({\n            preventScroll: true\n        });\n        if (this.#drawingAC) {\n            this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n            return;\n        }\n        this.#uiManager.setCurrentDrawingSession(this);\n        this.#drawingAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#drawingAC);\n        this.div.addEventListener(\"blur\", ({ relatedTarget })=>{\n            if (relatedTarget && !this.div.contains(relatedTarget)) {\n                this.#focusedElement = null;\n                this.commitOrRemove();\n            }\n        }, {\n            signal\n        });\n        this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n    }\n    pause(on) {\n        if (on) {\n            const { activeElement } = document;\n            if (this.div.contains(activeElement)) {\n                this.#focusedElement = activeElement;\n            }\n            return;\n        }\n        if (this.#focusedElement) {\n            setTimeout(()=>{\n                this.#focusedElement?.focus();\n                this.#focusedElement = null;\n            }, 0);\n        }\n    }\n    endDrawingSession(isAborted = false) {\n        if (!this.#drawingAC) {\n            return null;\n        }\n        this.#uiManager.setCurrentDrawingSession(null);\n        this.#drawingAC.abort();\n        this.#drawingAC = null;\n        this.#focusedElement = null;\n        return this.#currentEditorType.endDrawing(isAborted);\n    }\n    findNewParent(editor, x, y) {\n        const layer = this.#uiManager.findParent(x, y);\n        if (layer === null || layer === this) {\n            return false;\n        }\n        layer.changeParent(editor);\n        return true;\n    }\n    commitOrRemove() {\n        if (this.#drawingAC) {\n            this.endDrawingSession();\n            return true;\n        }\n        return false;\n    }\n    onScaleChanging() {\n        if (!this.#drawingAC) {\n            return;\n        }\n        this.#currentEditorType.onScaleChangingWhenDrawing(this);\n    }\n    destroy() {\n        this.commitOrRemove();\n        if (this.#uiManager.getActive()?.parent === this) {\n            this.#uiManager.commitOrRemove();\n            this.#uiManager.setActiveEditor(null);\n        }\n        if (this.#editorFocusTimeoutId) {\n            clearTimeout(this.#editorFocusTimeoutId);\n            this.#editorFocusTimeoutId = null;\n        }\n        for (const editor of this.#editors.values()){\n            this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n            editor.setParent(null);\n            editor.isAttachedToDOM = false;\n            editor.div.remove();\n        }\n        this.div = null;\n        this.#editors.clear();\n        this.#uiManager.removeLayer(this);\n    }\n    #cleanup() {\n        for (const editor of this.#editors.values()){\n            if (editor.isEmpty()) {\n                editor.remove();\n            }\n        }\n    }\n    render({ viewport }) {\n        this.viewport = viewport;\n        setLayerDimensions(this.div, viewport);\n        for (const editor of this.#uiManager.getEditors(this.pageIndex)){\n            this.add(editor);\n            editor.rebuild();\n        }\n        this.updateMode();\n    }\n    update({ viewport }) {\n        this.#uiManager.commitOrRemove();\n        this.#cleanup();\n        const oldRotation = this.viewport.rotation;\n        const rotation = viewport.rotation;\n        this.viewport = viewport;\n        setLayerDimensions(this.div, {\n            rotation\n        });\n        if (oldRotation !== rotation) {\n            for (const editor of this.#editors.values()){\n                editor.rotate(rotation);\n            }\n        }\n    }\n    get pageDimensions() {\n        const { pageWidth, pageHeight } = this.viewport.rawDims;\n        return [\n            pageWidth,\n            pageHeight\n        ];\n    }\n    get scale() {\n        return this.#uiManager.viewParameters.realScale;\n    }\n}\n; // ./src/display/draw_layer.js\nclass DrawLayer {\n    #parent;\n    #mapping;\n    #toUpdate;\n    static #id = 0;\n    constructor({ pageIndex }){\n        this.#parent = null;\n        this.#mapping = new Map();\n        this.#toUpdate = new Map();\n        this.pageIndex = pageIndex;\n    }\n    setParent(parent) {\n        if (!this.#parent) {\n            this.#parent = parent;\n            return;\n        }\n        if (this.#parent !== parent) {\n            if (this.#mapping.size > 0) {\n                for (const root of this.#mapping.values()){\n                    root.remove();\n                    parent.append(root);\n                }\n            }\n            this.#parent = parent;\n        }\n    }\n    static get _svgFactory() {\n        return shadow(this, \"_svgFactory\", new DOMSVGFactory());\n    }\n    static #setBox(element, [x, y, width, height]) {\n        const { style } = element;\n        style.top = `${100 * y}%`;\n        style.left = `${100 * x}%`;\n        style.width = `${100 * width}%`;\n        style.height = `${100 * height}%`;\n    }\n    #createSVG() {\n        const svg = DrawLayer._svgFactory.create(1, 1, true);\n        this.#parent.append(svg);\n        svg.setAttribute(\"aria-hidden\", true);\n        return svg;\n    }\n    #createClipPath(defs, pathId) {\n        const clipPath = DrawLayer._svgFactory.createElement(\"clipPath\");\n        defs.append(clipPath);\n        const clipPathId = `clip_${pathId}`;\n        clipPath.setAttribute(\"id\", clipPathId);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        const clipPathUse = DrawLayer._svgFactory.createElement(\"use\");\n        clipPath.append(clipPathUse);\n        clipPathUse.setAttribute(\"href\", `#${pathId}`);\n        clipPathUse.classList.add(\"clip\");\n        return clipPathId;\n    }\n    #updateProperties(element, properties) {\n        for (const [key, value] of Object.entries(properties)){\n            if (value === null) {\n                element.removeAttribute(key);\n            } else {\n                element.setAttribute(key, value);\n            }\n        }\n    }\n    draw(properties, isPathUpdatable = false, hasClip = false) {\n        const id = DrawLayer.#id++;\n        const root = this.#createSVG();\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        if (isPathUpdatable) {\n            this.#toUpdate.set(id, path);\n        }\n        const clipPathId = hasClip ? this.#createClipPath(defs, pathId) : null;\n        const use = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use);\n        use.setAttribute(\"href\", `#${pathId}`);\n        this.updateProperties(root, properties);\n        this.#mapping.set(id, root);\n        return {\n            id,\n            clipPathId: `url(#${clipPathId})`\n        };\n    }\n    drawOutline(properties, mustRemoveSelfIntersections) {\n        const id = DrawLayer.#id++;\n        const root = this.#createSVG();\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        let maskId;\n        if (mustRemoveSelfIntersections) {\n            const mask = DrawLayer._svgFactory.createElement(\"mask\");\n            defs.append(mask);\n            maskId = `mask_p${this.pageIndex}_${id}`;\n            mask.setAttribute(\"id\", maskId);\n            mask.setAttribute(\"maskUnits\", \"objectBoundingBox\");\n            const rect = DrawLayer._svgFactory.createElement(\"rect\");\n            mask.append(rect);\n            rect.setAttribute(\"width\", \"1\");\n            rect.setAttribute(\"height\", \"1\");\n            rect.setAttribute(\"fill\", \"white\");\n            const use = DrawLayer._svgFactory.createElement(\"use\");\n            mask.append(use);\n            use.setAttribute(\"href\", `#${pathId}`);\n            use.setAttribute(\"stroke\", \"none\");\n            use.setAttribute(\"fill\", \"black\");\n            use.setAttribute(\"fill-rule\", \"nonzero\");\n            use.classList.add(\"mask\");\n        }\n        const use1 = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use1);\n        use1.setAttribute(\"href\", `#${pathId}`);\n        if (maskId) {\n            use1.setAttribute(\"mask\", `url(#${maskId})`);\n        }\n        const use2 = use1.cloneNode();\n        root.append(use2);\n        use1.classList.add(\"mainOutline\");\n        use2.classList.add(\"secondaryOutline\");\n        this.updateProperties(root, properties);\n        this.#mapping.set(id, root);\n        return id;\n    }\n    finalizeDraw(id, properties) {\n        this.#toUpdate.delete(id);\n        this.updateProperties(id, properties);\n    }\n    updateProperties(elementOrId, properties) {\n        if (!properties) {\n            return;\n        }\n        const { root, bbox, rootClass, path } = properties;\n        const element = typeof elementOrId === \"number\" ? this.#mapping.get(elementOrId) : elementOrId;\n        if (!element) {\n            return;\n        }\n        if (root) {\n            this.#updateProperties(element, root);\n        }\n        if (bbox) {\n            DrawLayer.#setBox(element, bbox);\n        }\n        if (rootClass) {\n            const { classList } = element;\n            for (const [className, value] of Object.entries(rootClass)){\n                classList.toggle(className, value);\n            }\n        }\n        if (path) {\n            const defs = element.firstChild;\n            const pathElement = defs.firstChild;\n            this.#updateProperties(pathElement, path);\n        }\n    }\n    updateParent(id, layer) {\n        if (layer === this) {\n            return;\n        }\n        const root = this.#mapping.get(id);\n        if (!root) {\n            return;\n        }\n        layer.#parent.append(root);\n        this.#mapping.delete(id);\n        layer.#mapping.set(id, root);\n    }\n    remove(id) {\n        this.#toUpdate.delete(id);\n        if (this.#parent === null) {\n            return;\n        }\n        this.#mapping.get(id).remove();\n        this.#mapping.delete(id);\n    }\n    destroy() {\n        this.#parent = null;\n        for (const root of this.#mapping.values()){\n            root.remove();\n        }\n        this.#mapping.clear();\n        this.#toUpdate.clear();\n    }\n}\n; // ./src/pdf.js\n{\n    globalThis._pdfjsTestingUtils = {\n        HighlightOutliner: HighlightOutliner\n    };\n}globalThis.pdfjsLib = {\n    AbortException: AbortException,\n    AnnotationEditorLayer: AnnotationEditorLayer,\n    AnnotationEditorParamsType: AnnotationEditorParamsType,\n    AnnotationEditorType: AnnotationEditorType,\n    AnnotationEditorUIManager: AnnotationEditorUIManager,\n    AnnotationLayer: AnnotationLayer,\n    AnnotationMode: AnnotationMode,\n    AnnotationType: AnnotationType,\n    build: build,\n    ColorPicker: ColorPicker,\n    createValidAbsoluteUrl: createValidAbsoluteUrl,\n    DOMSVGFactory: DOMSVGFactory,\n    DrawLayer: DrawLayer,\n    FeatureTest: util_FeatureTest,\n    fetchData: fetchData,\n    getDocument: getDocument,\n    getFilenameFromUrl: getFilenameFromUrl,\n    getPdfFilenameFromUrl: getPdfFilenameFromUrl,\n    getRGB: getRGB,\n    getUuid: getUuid,\n    getXfaPageViewport: getXfaPageViewport,\n    GlobalWorkerOptions: GlobalWorkerOptions,\n    ImageKind: util_ImageKind,\n    InvalidPDFException: InvalidPDFException,\n    isDataScheme: isDataScheme,\n    isPdfFile: isPdfFile,\n    isValidExplicitDest: isValidExplicitDest,\n    MathClamp: MathClamp,\n    noContextMenu: noContextMenu,\n    normalizeUnicode: normalizeUnicode,\n    OPS: OPS,\n    OutputScale: OutputScale,\n    PasswordResponses: PasswordResponses,\n    PDFDataRangeTransport: PDFDataRangeTransport,\n    PDFDateString: PDFDateString,\n    PDFWorker: PDFWorker,\n    PermissionFlag: PermissionFlag,\n    PixelsPerInch: PixelsPerInch,\n    RenderingCancelledException: RenderingCancelledException,\n    ResponseException: ResponseException,\n    setLayerDimensions: setLayerDimensions,\n    shadow: shadow,\n    SignatureExtractor: SignatureExtractor,\n    stopEvent: stopEvent,\n    SupportedImageMimeTypes: SupportedImageMimeTypes,\n    TextLayer: TextLayer,\n    TouchManager: TouchManager,\n    updateUrlHash: updateUrlHash,\n    Util: Util,\n    VerbosityLevel: VerbosityLevel,\n    version: version,\n    XfaLayer: XfaLayer\n};\n //# sourceMappingURL=pdf.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQkMsR0FFRDs7O0NBR0MsR0FDRCxNQUFNLEdBQUcsb0JBQW9CO0FBQzdCLE1BQU0sR0FBRyxJQUFJQSw4QkFBbUJBLEdBQUcsQ0FBQztBQUNwQyxNQUFNLEdBQ04sd0VBQXdFLEdBQ3hFLE1BQU0sR0FBRywyQ0FBMkMsR0FDcEQsTUFBTSxHQUFJO0lBQ1YsTUFBTSxHQUFJLDhDQUE4QztJQUN4RCxNQUFNLEdBQUlBLDhCQUFtQkEsQ0FBQ0MsQ0FBQyxHQUFHLENBQUNDLFNBQVNDO1FBQzVDLE1BQU0sR0FBSyxJQUFJLElBQUlDLE9BQU9ELFdBQVk7WUFDdEMsTUFBTSxHQUFNLElBQUdILDhCQUFtQkEsQ0FBQ0ssQ0FBQyxDQUFDRixZQUFZQyxRQUFRLENBQUNKLDhCQUFtQkEsQ0FBQ0ssQ0FBQyxDQUFDSCxTQUFTRSxNQUFNO2dCQUMvRixNQUFNLEdBQU9FLE9BQU9DLGNBQWMsQ0FBQ0wsU0FBU0UsS0FBSztvQkFBRUksWUFBWTtvQkFBTUMsS0FBS04sVUFBVSxDQUFDQyxJQUFJO2dCQUFDO1lBQzFGLE1BQU0sR0FBTTtRQUNaLE1BQU0sR0FBSztJQUNYLE1BQU0sR0FBSTtBQUNWLE1BQU0sR0FBRztBQUNULE1BQU0sR0FDTixNQUFNLEdBQUcsNENBQTRDLEdBQ3JELE1BQU0sR0FBSTtJQUNWLE1BQU0sR0FBSUosOEJBQW1CQSxDQUFDSyxDQUFDLEdBQUcsQ0FBQ0ssS0FBS0MsT0FBVUwsT0FBT00sU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osS0FBS0M7QUFDNUYsTUFBTSxHQUFHO0FBQ1QsTUFBTSxHQUNOLHdFQUF3RSxHQUN4RSxJQUFJSSxzQkFBc0IsQ0FBQztFQUUxQix1QkFBdUI7QUFDeEIs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QjJXLG9CQUFvQkE7SUFDcEIxWCxRQUFRQTtJQUNSczRHLG9CQUFvQkE7SUFDcEJ6akcsV0FBV0E7SUFDWDhFLHlCQUF5QkE7SUFDekIwN0QsV0FBV0E7SUFDWHo0QyxjQUFjQTtJQUNkbDlCLGVBQWVBO0lBQ2ZnRixNQUFNQTtJQUNObk4sZ0JBQWdCQTtJQUNoQjZ4RixTQUFTQTtJQUNUc0UsVUFBVUE7QUFDWjtBQUV5MkIsQ0FFejJCLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXRpbWV0YWJsZS1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYubWpzPzgzZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljc3RhcnQgVGhlIGZvbGxvd2luZyBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFTY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAyNCBNb3ppbGxhIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQGxpY2VuZCBUaGUgYWJvdmUgaXMgdGhlIGVudGlyZSBsaWNlbnNlIG5vdGljZSBmb3IgdGhlXG4gKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlXG4gKi9cblxuLyoqXG4gKiBwZGZqc1ZlcnNpb24gPSA1LjQuMTQ5XG4gKiBwZGZqc0J1aWxkID0gOWUyZTllMjA5XG4gKi9cbi8qKioqKiovIC8vIFRoZSByZXF1aXJlIHNjb3BlXG4vKioqKioqLyB2YXIgX193ZWJwYWNrX3JlcXVpcmVfXyA9IHt9O1xuLyoqKioqKi8gXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyAoKCkgPT4ge1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG5cbjsvLyAuL3NyYy9zaGFyZWQvdXRpbC5qc1xuY29uc3QgaXNOb2RlSlMgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICsgXCJcIiA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgIXByb2Nlc3MudmVyc2lvbnMubncgJiYgIShwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uICYmIHByb2Nlc3MudHlwZSAmJiBwcm9jZXNzLnR5cGUgIT09IFwiYnJvd3NlclwiKTtcbmNvbnN0IEZPTlRfSURFTlRJVFlfTUFUUklYID0gWzAuMDAxLCAwLCAwLCAwLjAwMSwgMCwgMF07XG5jb25zdCBMSU5FX0ZBQ1RPUiA9IDEuMzU7XG5jb25zdCBMSU5FX0RFU0NFTlRfRkFDVE9SID0gMC4zNTtcbmNvbnN0IEJBU0VMSU5FX0ZBQ1RPUiA9IExJTkVfREVTQ0VOVF9GQUNUT1IgLyBMSU5FX0ZBQ1RPUjtcbmNvbnN0IFJlbmRlcmluZ0ludGVudEZsYWcgPSB7XG4gIEFOWTogMHgwMSxcbiAgRElTUExBWTogMHgwMixcbiAgUFJJTlQ6IDB4MDQsXG4gIFNBVkU6IDB4MDgsXG4gIEFOTk9UQVRJT05TX0ZPUk1TOiAweDEwLFxuICBBTk5PVEFUSU9OU19TVE9SQUdFOiAweDIwLFxuICBBTk5PVEFUSU9OU19ESVNBQkxFOiAweDQwLFxuICBJU19FRElUSU5HOiAweDgwLFxuICBPUExJU1Q6IDB4MTAwXG59O1xuY29uc3QgQW5ub3RhdGlvbk1vZGUgPSB7XG4gIERJU0FCTEU6IDAsXG4gIEVOQUJMRTogMSxcbiAgRU5BQkxFX0ZPUk1TOiAyLFxuICBFTkFCTEVfU1RPUkFHRTogM1xufTtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JQcmVmaXggPSBcInBkZmpzX2ludGVybmFsX2VkaXRvcl9cIjtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JUeXBlID0ge1xuICBESVNBQkxFOiAtMSxcbiAgTk9ORTogMCxcbiAgRlJFRVRFWFQ6IDMsXG4gIEhJR0hMSUdIVDogOSxcbiAgU1RBTVA6IDEzLFxuICBJTks6IDE1LFxuICBQT1BVUDogMTYsXG4gIFNJR05BVFVSRTogMTAxLFxuICBDT01NRU5UOiAxMDJcbn07XG5jb25zdCBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IHtcbiAgUkVTSVpFOiAxLFxuICBDUkVBVEU6IDIsXG4gIEZSRUVURVhUX1NJWkU6IDExLFxuICBGUkVFVEVYVF9DT0xPUjogMTIsXG4gIEZSRUVURVhUX09QQUNJVFk6IDEzLFxuICBJTktfQ09MT1I6IDIxLFxuICBJTktfVEhJQ0tORVNTOiAyMixcbiAgSU5LX09QQUNJVFk6IDIzLFxuICBISUdITElHSFRfQ09MT1I6IDMxLFxuICBISUdITElHSFRfVEhJQ0tORVNTOiAzMixcbiAgSElHSExJR0hUX0ZSRUU6IDMzLFxuICBISUdITElHSFRfU0hPV19BTEw6IDM0LFxuICBEUkFXX1NURVA6IDQxXG59O1xuY29uc3QgUGVybWlzc2lvbkZsYWcgPSB7XG4gIFBSSU5UOiAweDA0LFxuICBNT0RJRllfQ09OVEVOVFM6IDB4MDgsXG4gIENPUFk6IDB4MTAsXG4gIE1PRElGWV9BTk5PVEFUSU9OUzogMHgyMCxcbiAgRklMTF9JTlRFUkFDVElWRV9GT1JNUzogMHgxMDAsXG4gIENPUFlfRk9SX0FDQ0VTU0lCSUxJVFk6IDB4MjAwLFxuICBBU1NFTUJMRTogMHg0MDAsXG4gIFBSSU5UX0hJR0hfUVVBTElUWTogMHg4MDBcbn07XG5jb25zdCBUZXh0UmVuZGVyaW5nTW9kZSA9IHtcbiAgRklMTDogMCxcbiAgU1RST0tFOiAxLFxuICBGSUxMX1NUUk9LRTogMixcbiAgSU5WSVNJQkxFOiAzLFxuICBGSUxMX0FERF9UT19QQVRIOiA0LFxuICBTVFJPS0VfQUREX1RPX1BBVEg6IDUsXG4gIEZJTExfU1RST0tFX0FERF9UT19QQVRIOiA2LFxuICBBRERfVE9fUEFUSDogNyxcbiAgRklMTF9TVFJPS0VfTUFTSzogMyxcbiAgQUREX1RPX1BBVEhfRkxBRzogNFxufTtcbmNvbnN0IHV0aWxfSW1hZ2VLaW5kID0ge1xuICBHUkFZU0NBTEVfMUJQUDogMSxcbiAgUkdCXzI0QlBQOiAyLFxuICBSR0JBXzMyQlBQOiAzXG59O1xuY29uc3QgQW5ub3RhdGlvblR5cGUgPSB7XG4gIFRFWFQ6IDEsXG4gIExJTks6IDIsXG4gIEZSRUVURVhUOiAzLFxuICBMSU5FOiA0LFxuICBTUVVBUkU6IDUsXG4gIENJUkNMRTogNixcbiAgUE9MWUdPTjogNyxcbiAgUE9MWUxJTkU6IDgsXG4gIEhJR0hMSUdIVDogOSxcbiAgVU5ERVJMSU5FOiAxMCxcbiAgU1FVSUdHTFk6IDExLFxuICBTVFJJS0VPVVQ6IDEyLFxuICBTVEFNUDogMTMsXG4gIENBUkVUOiAxNCxcbiAgSU5LOiAxNSxcbiAgUE9QVVA6IDE2LFxuICBGSUxFQVRUQUNITUVOVDogMTcsXG4gIFNPVU5EOiAxOCxcbiAgTU9WSUU6IDE5LFxuICBXSURHRVQ6IDIwLFxuICBTQ1JFRU46IDIxLFxuICBQUklOVEVSTUFSSzogMjIsXG4gIFRSQVBORVQ6IDIzLFxuICBXQVRFUk1BUks6IDI0LFxuICBUSFJFRUQ6IDI1LFxuICBSRURBQ1Q6IDI2XG59O1xuY29uc3QgQW5ub3RhdGlvblJlcGx5VHlwZSA9IHtcbiAgR1JPVVA6IFwiR3JvdXBcIixcbiAgUkVQTFk6IFwiUlwiXG59O1xuY29uc3QgQW5ub3RhdGlvbkZsYWcgPSB7XG4gIElOVklTSUJMRTogMHgwMSxcbiAgSElEREVOOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgTk9aT09NOiAweDA4LFxuICBOT1JPVEFURTogMHgxMCxcbiAgTk9WSUVXOiAweDIwLFxuICBSRUFET05MWTogMHg0MCxcbiAgTE9DS0VEOiAweDgwLFxuICBUT0dHTEVOT1ZJRVc6IDB4MTAwLFxuICBMT0NLRURDT05URU5UUzogMHgyMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uRmllbGRGbGFnID0ge1xuICBSRUFET05MWTogMHgwMDAwMDAxLFxuICBSRVFVSVJFRDogMHgwMDAwMDAyLFxuICBOT0VYUE9SVDogMHgwMDAwMDA0LFxuICBNVUxUSUxJTkU6IDB4MDAwMTAwMCxcbiAgUEFTU1dPUkQ6IDB4MDAwMjAwMCxcbiAgTk9UT0dHTEVUT09GRjogMHgwMDA0MDAwLFxuICBSQURJTzogMHgwMDA4MDAwLFxuICBQVVNIQlVUVE9OOiAweDAwMTAwMDAsXG4gIENPTUJPOiAweDAwMjAwMDAsXG4gIEVESVQ6IDB4MDA0MDAwMCxcbiAgU09SVDogMHgwMDgwMDAwLFxuICBGSUxFU0VMRUNUOiAweDAxMDAwMDAsXG4gIE1VTFRJU0VMRUNUOiAweDAyMDAwMDAsXG4gIERPTk9UU1BFTExDSEVDSzogMHgwNDAwMDAwLFxuICBET05PVFNDUk9MTDogMHgwODAwMDAwLFxuICBDT01COiAweDEwMDAwMDAsXG4gIFJJQ0hURVhUOiAweDIwMDAwMDAsXG4gIFJBRElPU0lOVU5JU09OOiAweDIwMDAwMDAsXG4gIENPTU1JVE9OU0VMQ0hBTkdFOiAweDQwMDAwMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlID0ge1xuICBTT0xJRDogMSxcbiAgREFTSEVEOiAyLFxuICBCRVZFTEVEOiAzLFxuICBJTlNFVDogNCxcbiAgVU5ERVJMSU5FOiA1XG59O1xuY29uc3QgQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgRTogXCJNb3VzZSBFbnRlclwiLFxuICBYOiBcIk1vdXNlIEV4aXRcIixcbiAgRDogXCJNb3VzZSBEb3duXCIsXG4gIFU6IFwiTW91c2UgVXBcIixcbiAgRm86IFwiRm9jdXNcIixcbiAgQmw6IFwiQmx1clwiLFxuICBQTzogXCJQYWdlT3BlblwiLFxuICBQQzogXCJQYWdlQ2xvc2VcIixcbiAgUFY6IFwiUGFnZVZpc2libGVcIixcbiAgUEk6IFwiUGFnZUludmlzaWJsZVwiLFxuICBLOiBcIktleXN0cm9rZVwiLFxuICBGOiBcIkZvcm1hdFwiLFxuICBWOiBcIlZhbGlkYXRlXCIsXG4gIEM6IFwiQ2FsY3VsYXRlXCJcbn07XG5jb25zdCBEb2N1bWVudEFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgV0M6IFwiV2lsbENsb3NlXCIsXG4gIFdTOiBcIldpbGxTYXZlXCIsXG4gIERTOiBcIkRpZFNhdmVcIixcbiAgV1A6IFwiV2lsbFByaW50XCIsXG4gIERQOiBcIkRpZFByaW50XCJcbn07XG5jb25zdCBQYWdlQWN0aW9uRXZlbnRUeXBlID0ge1xuICBPOiBcIlBhZ2VPcGVuXCIsXG4gIEM6IFwiUGFnZUNsb3NlXCJcbn07XG5jb25zdCBWZXJib3NpdHlMZXZlbCA9IHtcbiAgRVJST1JTOiAwLFxuICBXQVJOSU5HUzogMSxcbiAgSU5GT1M6IDVcbn07XG5jb25zdCBPUFMgPSB7XG4gIGRlcGVuZGVuY3k6IDEsXG4gIHNldExpbmVXaWR0aDogMixcbiAgc2V0TGluZUNhcDogMyxcbiAgc2V0TGluZUpvaW46IDQsXG4gIHNldE1pdGVyTGltaXQ6IDUsXG4gIHNldERhc2g6IDYsXG4gIHNldFJlbmRlcmluZ0ludGVudDogNyxcbiAgc2V0RmxhdG5lc3M6IDgsXG4gIHNldEdTdGF0ZTogOSxcbiAgc2F2ZTogMTAsXG4gIHJlc3RvcmU6IDExLFxuICB0cmFuc2Zvcm06IDEyLFxuICBtb3ZlVG86IDEzLFxuICBsaW5lVG86IDE0LFxuICBjdXJ2ZVRvOiAxNSxcbiAgY3VydmVUbzI6IDE2LFxuICBjdXJ2ZVRvMzogMTcsXG4gIGNsb3NlUGF0aDogMTgsXG4gIHJlY3RhbmdsZTogMTksXG4gIHN0cm9rZTogMjAsXG4gIGNsb3NlU3Ryb2tlOiAyMSxcbiAgZmlsbDogMjIsXG4gIGVvRmlsbDogMjMsXG4gIGZpbGxTdHJva2U6IDI0LFxuICBlb0ZpbGxTdHJva2U6IDI1LFxuICBjbG9zZUZpbGxTdHJva2U6IDI2LFxuICBjbG9zZUVPRmlsbFN0cm9rZTogMjcsXG4gIGVuZFBhdGg6IDI4LFxuICBjbGlwOiAyOSxcbiAgZW9DbGlwOiAzMCxcbiAgYmVnaW5UZXh0OiAzMSxcbiAgZW5kVGV4dDogMzIsXG4gIHNldENoYXJTcGFjaW5nOiAzMyxcbiAgc2V0V29yZFNwYWNpbmc6IDM0LFxuICBzZXRIU2NhbGU6IDM1LFxuICBzZXRMZWFkaW5nOiAzNixcbiAgc2V0Rm9udDogMzcsXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlOiAzOCxcbiAgc2V0VGV4dFJpc2U6IDM5LFxuICBtb3ZlVGV4dDogNDAsXG4gIHNldExlYWRpbmdNb3ZlVGV4dDogNDEsXG4gIHNldFRleHRNYXRyaXg6IDQyLFxuICBuZXh0TGluZTogNDMsXG4gIHNob3dUZXh0OiA0NCxcbiAgc2hvd1NwYWNlZFRleHQ6IDQ1LFxuICBuZXh0TGluZVNob3dUZXh0OiA0NixcbiAgbmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6IDQ3LFxuICBzZXRDaGFyV2lkdGg6IDQ4LFxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IDQ5LFxuICBzZXRTdHJva2VDb2xvclNwYWNlOiA1MCxcbiAgc2V0RmlsbENvbG9yU3BhY2U6IDUxLFxuICBzZXRTdHJva2VDb2xvcjogNTIsXG4gIHNldFN0cm9rZUNvbG9yTjogNTMsXG4gIHNldEZpbGxDb2xvcjogNTQsXG4gIHNldEZpbGxDb2xvck46IDU1LFxuICBzZXRTdHJva2VHcmF5OiA1NixcbiAgc2V0RmlsbEdyYXk6IDU3LFxuICBzZXRTdHJva2VSR0JDb2xvcjogNTgsXG4gIHNldEZpbGxSR0JDb2xvcjogNTksXG4gIHNldFN0cm9rZUNNWUtDb2xvcjogNjAsXG4gIHNldEZpbGxDTVlLQ29sb3I6IDYxLFxuICBzaGFkaW5nRmlsbDogNjIsXG4gIGJlZ2luSW5saW5lSW1hZ2U6IDYzLFxuICBiZWdpbkltYWdlRGF0YTogNjQsXG4gIGVuZElubGluZUltYWdlOiA2NSxcbiAgcGFpbnRYT2JqZWN0OiA2NixcbiAgbWFya1BvaW50OiA2NyxcbiAgbWFya1BvaW50UHJvcHM6IDY4LFxuICBiZWdpbk1hcmtlZENvbnRlbnQ6IDY5LFxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogNzAsXG4gIGVuZE1hcmtlZENvbnRlbnQ6IDcxLFxuICBiZWdpbkNvbXBhdDogNzIsXG4gIGVuZENvbXBhdDogNzMsXG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogNzQsXG4gIHBhaW50Rm9ybVhPYmplY3RFbmQ6IDc1LFxuICBiZWdpbkdyb3VwOiA3NixcbiAgZW5kR3JvdXA6IDc3LFxuICBiZWdpbkFubm90YXRpb246IDgwLFxuICBlbmRBbm5vdGF0aW9uOiA4MSxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiA4MyxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IDg0LFxuICBwYWludEltYWdlWE9iamVjdDogODUsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OiA4NixcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cDogODcsXG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiA4OCxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0OiA4OSxcbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOiA5MCxcbiAgY29uc3RydWN0UGF0aDogOTEsXG4gIHNldFN0cm9rZVRyYW5zcGFyZW50OiA5MixcbiAgc2V0RmlsbFRyYW5zcGFyZW50OiA5MyxcbiAgcmF3RmlsbFBhdGg6IDk0XG59O1xuY29uc3QgRHJhd09QUyA9IHtcbiAgbW92ZVRvOiAwLFxuICBsaW5lVG86IDEsXG4gIGN1cnZlVG86IDIsXG4gIGNsb3NlUGF0aDogM1xufTtcbmNvbnN0IFBhc3N3b3JkUmVzcG9uc2VzID0ge1xuICBORUVEX1BBU1NXT1JEOiAxLFxuICBJTkNPUlJFQ1RfUEFTU1dPUkQ6IDJcbn07XG5sZXQgdmVyYm9zaXR5ID0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1M7XG5mdW5jdGlvbiBzZXRWZXJib3NpdHlMZXZlbChsZXZlbCkge1xuICBpZiAoTnVtYmVyLmlzSW50ZWdlcihsZXZlbCkpIHtcbiAgICB2ZXJib3NpdHkgPSBsZXZlbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmVyYm9zaXR5TGV2ZWwoKSB7XG4gIHJldHVybiB2ZXJib3NpdHk7XG59XG5mdW5jdGlvbiBpbmZvKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLklORk9TKSB7XG4gICAgY29uc29sZS5sb2coYEluZm86ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTKSB7XG4gICAgY29uc29sZS5sb2coYFdhcm5pbmc6ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB1bnJlYWNoYWJsZShtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZCwgbXNnKSB7XG4gIGlmICghY29uZCkge1xuICAgIHVucmVhY2hhYmxlKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc1ZhbGlkUHJvdG9jb2wodXJsKSB7XG4gIHN3aXRjaCAodXJsPy5wcm90b2NvbCkge1xuICAgIGNhc2UgXCJodHRwOlwiOlxuICAgIGNhc2UgXCJodHRwczpcIjpcbiAgICBjYXNlIFwiZnRwOlwiOlxuICAgIGNhc2UgXCJtYWlsdG86XCI6XG4gICAgY2FzZSBcInRlbDpcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwodXJsLCBiYXNlVXJsID0gbnVsbCwgb3B0aW9ucyA9IG51bGwpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG9wdGlvbnMuYWRkRGVmYXVsdFByb3RvY29sICYmIHVybC5zdGFydHNXaXRoKFwid3d3LlwiKSkge1xuICAgICAgY29uc3QgZG90cyA9IHVybC5tYXRjaCgvXFwuL2cpO1xuICAgICAgaWYgKGRvdHM/Lmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHVybCA9IGBodHRwOi8vJHt1cmx9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHJ5Q29udmVydEVuY29kaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICB1cmwgPSBzdHJpbmdUb1VURjhTdHJpbmcodXJsKTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gIH1cbiAgY29uc3QgYWJzb2x1dGVVcmwgPSBiYXNlVXJsID8gVVJMLnBhcnNlKHVybCwgYmFzZVVybCkgOiBVUkwucGFyc2UodXJsKTtcbiAgcmV0dXJuIF9pc1ZhbGlkUHJvdG9jb2woYWJzb2x1dGVVcmwpID8gYWJzb2x1dGVVcmwgOiBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlVXJsSGFzaCh1cmwsIGhhc2gsIGFsbG93UmVsID0gZmFsc2UpIHtcbiAgY29uc3QgcmVzID0gVVJMLnBhcnNlKHVybCk7XG4gIGlmIChyZXMpIHtcbiAgICByZXMuaGFzaCA9IGhhc2g7XG4gICAgcmV0dXJuIHJlcy5ocmVmO1xuICB9XG4gIGlmIChhbGxvd1JlbCAmJiBjcmVhdGVWYWxpZEFic29sdXRlVXJsKHVybCwgXCJodHRwOi8vZXhhbXBsZS5jb21cIikpIHtcbiAgICByZXR1cm4gdXJsLnNwbGl0KFwiI1wiLCAxKVswXSArIGAke2hhc2ggPyBgIyR7aGFzaH1gIDogXCJcIn1gO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuZnVuY3Rpb24gc2hhZG93KG9iaiwgcHJvcCwgdmFsdWUsIG5vblNlcmlhbGl6YWJsZSA9IGZhbHNlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICB2YWx1ZSxcbiAgICBlbnVtZXJhYmxlOiAhbm9uU2VyaWFsaXphYmxlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IEJhc2VFeGNlcHRpb24gPSBmdW5jdGlvbiBCYXNlRXhjZXB0aW9uQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG4gIEJhc2VFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIEJhc2VFeGNlcHRpb24uY29uc3RydWN0b3IgPSBCYXNlRXhjZXB0aW9uO1xuICByZXR1cm4gQmFzZUV4Y2VwdGlvbjtcbn0oKTtcbmNsYXNzIFBhc3N3b3JkRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgY29kZSkge1xuICAgIHN1cGVyKG1zZywgXCJQYXNzd29yZEV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59XG5jbGFzcyBVbmtub3duRXJyb3JFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobXNnLCBcIlVua25vd25FcnJvckV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG59XG5jbGFzcyBJbnZhbGlkUERGRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCIpO1xuICB9XG59XG5jbGFzcyBSZXNwb25zZUV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIHN0YXR1cywgbWlzc2luZykge1xuICAgIHN1cGVyKG1zZywgXCJSZXNwb25zZUV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLm1pc3NpbmcgPSBtaXNzaW5nO1xuICB9XG59XG5jbGFzcyBGb3JtYXRFcnJvciBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiRm9ybWF0RXJyb3JcIik7XG4gIH1cbn1cbmNsYXNzIEFib3J0RXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJBYm9ydEV4Y2VwdGlvblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICBpZiAodHlwZW9mIGJ5dGVzICE9PSBcIm9iamVjdFwiIHx8IGJ5dGVzPy5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHVucmVhY2hhYmxlKFwiSW52YWxpZCBhcmd1bWVudCBmb3IgYnl0ZXNUb1N0cmluZ1wiKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gIGNvbnN0IE1BWF9BUkdVTUVOVF9DT1VOVCA9IDgxOTI7XG4gIGlmIChsZW5ndGggPCBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG4gIH1cbiAgY29uc3Qgc3RyQnVmID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIGNvbnN0IGNodW5rRW5kID0gTWF0aC5taW4oaSArIE1BWF9BUkdVTUVOVF9DT1VOVCwgbGVuZ3RoKTtcbiAgICBjb25zdCBjaHVuayA9IGJ5dGVzLnN1YmFycmF5KGksIGNodW5rRW5kKTtcbiAgICBzdHJCdWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNodW5rKSk7XG4gIH1cbiAgcmV0dXJuIHN0ckJ1Zi5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHtcbiAgICB1bnJlYWNoYWJsZShcIkludmFsaWQgYXJndW1lbnQgZm9yIHN0cmluZ1RvQnl0ZXNcIik7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXNbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gc3RyaW5nMzIodmFsdWUpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUgPj4gMjQgJiAweGZmLCB2YWx1ZSA+PiAxNiAmIDB4ZmYsIHZhbHVlID4+IDggJiAweGZmLCB2YWx1ZSAmIDB4ZmYpO1xufVxuZnVuY3Rpb24gb2JqZWN0U2l6ZShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oKSB7XG4gIGNvbnN0IGJ1ZmZlcjggPSBuZXcgVWludDhBcnJheSg0KTtcbiAgYnVmZmVyOFswXSA9IDE7XG4gIGNvbnN0IHZpZXczMiA9IG5ldyBVaW50MzJBcnJheShidWZmZXI4LmJ1ZmZlciwgMCwgMSk7XG4gIHJldHVybiB2aWV3MzJbMF0gPT09IDE7XG59XG5mdW5jdGlvbiBpc0V2YWxTdXBwb3J0ZWQoKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKFwiXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNsYXNzIHV0aWxfRmVhdHVyZVRlc3Qge1xuICBzdGF0aWMgZ2V0IGlzTGl0dGxlRW5kaWFuKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0xpdHRsZUVuZGlhblwiLCBpc0xpdHRsZUVuZGlhbigpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRXZhbFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNFdmFsU3VwcG9ydGVkXCIsIGlzRXZhbFN1cHBvcnRlZCgpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZFwiLCB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0ltYWdlRGVjb2RlclN1cHBvcnRlZFwiLCB0eXBlb2YgSW1hZ2VEZWNvZGVyICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHBsYXRmb3JtKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgdXNlckFnZW50XG4gICAgfSA9IG5hdmlnYXRvcjtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwicGxhdGZvcm1cIiwge1xuICAgICAgaXNBbmRyb2lkOiB1c2VyQWdlbnQuaW5jbHVkZXMoXCJBbmRyb2lkXCIpLFxuICAgICAgaXNMaW51eDogcGxhdGZvcm0uaW5jbHVkZXMoXCJMaW51eFwiKSxcbiAgICAgIGlzTWFjOiBwbGF0Zm9ybS5pbmNsdWRlcyhcIk1hY1wiKSxcbiAgICAgIGlzV2luZG93czogcGxhdGZvcm0uaW5jbHVkZXMoXCJXaW5cIiksXG4gICAgICBpc0ZpcmVmb3g6IHVzZXJBZ2VudC5pbmNsdWRlcyhcIkZpcmVmb3hcIilcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzQ1NTUm91bmRTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzQ1NTUm91bmRTdXBwb3J0ZWRcIiwgZ2xvYmFsVGhpcy5DU1M/LnN1cHBvcnRzPy4oXCJ3aWR0aDogcm91bmQoMS41cHgsIDFweClcIikpO1xuICB9XG59XG5jb25zdCBoZXhOdW1iZXJzID0gQXJyYXkuZnJvbShBcnJheSgyNTYpLmtleXMoKSwgbiA9PiBuLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpO1xuY2xhc3MgVXRpbCB7XG4gIHN0YXRpYyBtYWtlSGV4Q29sb3IociwgZywgYikge1xuICAgIHJldHVybiBgIyR7aGV4TnVtYmVyc1tyXX0ke2hleE51bWJlcnNbZ119JHtoZXhOdW1iZXJzW2JdfWA7XG4gIH1cbiAgc3RhdGljIGRvbU1hdHJpeFRvVHJhbnNmb3JtKGRtKSB7XG4gICAgcmV0dXJuIFtkbS5hLCBkbS5iLCBkbS5jLCBkbS5kLCBkbS5lLCBkbS5mXTtcbiAgfVxuICBzdGF0aWMgc2NhbGVNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpIHtcbiAgICBsZXQgdGVtcDtcbiAgICBpZiAodHJhbnNmb3JtWzBdKSB7XG4gICAgICBpZiAodHJhbnNmb3JtWzBdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMF0gKj0gdHJhbnNmb3JtWzBdO1xuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVswXTtcbiAgICAgIGlmICh0cmFuc2Zvcm1bM10gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMV07XG4gICAgICAgIG1pbk1heFsxXSA9IG1pbk1heFszXTtcbiAgICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFsxXSAqPSB0cmFuc2Zvcm1bM107XG4gICAgICBtaW5NYXhbM10gKj0gdHJhbnNmb3JtWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgbWluTWF4WzBdID0gbWluTWF4WzFdO1xuICAgICAgbWluTWF4WzFdID0gdGVtcDtcbiAgICAgIHRlbXAgPSBtaW5NYXhbMl07XG4gICAgICBtaW5NYXhbMl0gPSBtaW5NYXhbM107XG4gICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgaWYgKHRyYW5zZm9ybVsxXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gbWluTWF4WzNdO1xuICAgICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzFdICo9IHRyYW5zZm9ybVsxXTtcbiAgICAgIG1pbk1heFszXSAqPSB0cmFuc2Zvcm1bMV07XG4gICAgICBpZiAodHJhbnNmb3JtWzJdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMF0gKj0gdHJhbnNmb3JtWzJdO1xuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVsyXTtcbiAgICB9XG4gICAgbWluTWF4WzBdICs9IHRyYW5zZm9ybVs0XTtcbiAgICBtaW5NYXhbMV0gKz0gdHJhbnNmb3JtWzVdO1xuICAgIG1pbk1heFsyXSArPSB0cmFuc2Zvcm1bNF07XG4gICAgbWluTWF4WzNdICs9IHRyYW5zZm9ybVs1XTtcbiAgfVxuICBzdGF0aWMgdHJhbnNmb3JtKG0xLCBtMikge1xuICAgIHJldHVybiBbbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV0sIG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdLCBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXSwgbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM10sIG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF0sIG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV1dO1xuICB9XG4gIHN0YXRpYyBtdWx0aXBseUJ5RE9NTWF0cml4KG0sIG1kKSB7XG4gICAgcmV0dXJuIFttWzBdICogbWQuYSArIG1bMl0gKiBtZC5iLCBtWzFdICogbWQuYSArIG1bM10gKiBtZC5iLCBtWzBdICogbWQuYyArIG1bMl0gKiBtZC5kLCBtWzFdICogbWQuYyArIG1bM10gKiBtZC5kLCBtWzBdICogbWQuZSArIG1bMl0gKiBtZC5mICsgbVs0XSwgbVsxXSAqIG1kLmUgKyBtWzNdICogbWQuZiArIG1bNV1dO1xuICB9XG4gIHN0YXRpYyBhcHBseVRyYW5zZm9ybShwLCBtLCBwb3MgPSAwKSB7XG4gICAgY29uc3QgcDAgPSBwW3Bvc107XG4gICAgY29uc3QgcDEgPSBwW3BvcyArIDFdO1xuICAgIHBbcG9zXSA9IHAwICogbVswXSArIHAxICogbVsyXSArIG1bNF07XG4gICAgcFtwb3MgKyAxXSA9IHAwICogbVsxXSArIHAxICogbVszXSArIG1bNV07XG4gIH1cbiAgc3RhdGljIGFwcGx5VHJhbnNmb3JtVG9CZXppZXIocCwgdHJhbnNmb3JtLCBwb3MgPSAwKSB7XG4gICAgY29uc3QgbTAgPSB0cmFuc2Zvcm1bMF07XG4gICAgY29uc3QgbTEgPSB0cmFuc2Zvcm1bMV07XG4gICAgY29uc3QgbTIgPSB0cmFuc2Zvcm1bMl07XG4gICAgY29uc3QgbTMgPSB0cmFuc2Zvcm1bM107XG4gICAgY29uc3QgbTQgPSB0cmFuc2Zvcm1bNF07XG4gICAgY29uc3QgbTUgPSB0cmFuc2Zvcm1bNV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHBJID0gcFtwb3MgKyBpXTtcbiAgICAgIGNvbnN0IHBJMSA9IHBbcG9zICsgaSArIDFdO1xuICAgICAgcFtwb3MgKyBpXSA9IHBJICogbTAgKyBwSTEgKiBtMiArIG00O1xuICAgICAgcFtwb3MgKyBpICsgMV0gPSBwSSAqIG0xICsgcEkxICogbTMgKyBtNTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFwcGx5SW52ZXJzZVRyYW5zZm9ybShwLCBtKSB7XG4gICAgY29uc3QgcDAgPSBwWzBdO1xuICAgIGNvbnN0IHAxID0gcFsxXTtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICBwWzBdID0gKHAwICogbVszXSAtIHAxICogbVsyXSArIG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZDtcbiAgICBwWzFdID0gKC1wMCAqIG1bMV0gKyBwMSAqIG1bMF0gKyBtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGQ7XG4gIH1cbiAgc3RhdGljIGF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KHJlY3QsIHRyYW5zZm9ybSwgb3V0cHV0KSB7XG4gICAgY29uc3QgbTAgPSB0cmFuc2Zvcm1bMF07XG4gICAgY29uc3QgbTEgPSB0cmFuc2Zvcm1bMV07XG4gICAgY29uc3QgbTIgPSB0cmFuc2Zvcm1bMl07XG4gICAgY29uc3QgbTMgPSB0cmFuc2Zvcm1bM107XG4gICAgY29uc3QgbTQgPSB0cmFuc2Zvcm1bNF07XG4gICAgY29uc3QgbTUgPSB0cmFuc2Zvcm1bNV07XG4gICAgY29uc3QgcjAgPSByZWN0WzBdO1xuICAgIGNvbnN0IHIxID0gcmVjdFsxXTtcbiAgICBjb25zdCByMiA9IHJlY3RbMl07XG4gICAgY29uc3QgcjMgPSByZWN0WzNdO1xuICAgIGxldCBhMCA9IG0wICogcjAgKyBtNDtcbiAgICBsZXQgYTIgPSBhMDtcbiAgICBsZXQgYTEgPSBtMCAqIHIyICsgbTQ7XG4gICAgbGV0IGEzID0gYTE7XG4gICAgbGV0IGIwID0gbTMgKiByMSArIG01O1xuICAgIGxldCBiMiA9IGIwO1xuICAgIGxldCBiMSA9IG0zICogcjMgKyBtNTtcbiAgICBsZXQgYjMgPSBiMTtcbiAgICBpZiAobTEgIT09IDAgfHwgbTIgIT09IDApIHtcbiAgICAgIGNvbnN0IG0xcjAgPSBtMSAqIHIwO1xuICAgICAgY29uc3QgbTFyMiA9IG0xICogcjI7XG4gICAgICBjb25zdCBtMnIxID0gbTIgKiByMTtcbiAgICAgIGNvbnN0IG0ycjMgPSBtMiAqIHIzO1xuICAgICAgYTAgKz0gbTJyMTtcbiAgICAgIGEzICs9IG0ycjE7XG4gICAgICBhMSArPSBtMnIzO1xuICAgICAgYTIgKz0gbTJyMztcbiAgICAgIGIwICs9IG0xcjA7XG4gICAgICBiMyArPSBtMXIwO1xuICAgICAgYjEgKz0gbTFyMjtcbiAgICAgIGIyICs9IG0xcjI7XG4gICAgfVxuICAgIG91dHB1dFswXSA9IE1hdGgubWluKG91dHB1dFswXSwgYTAsIGExLCBhMiwgYTMpO1xuICAgIG91dHB1dFsxXSA9IE1hdGgubWluKG91dHB1dFsxXSwgYjAsIGIxLCBiMiwgYjMpO1xuICAgIG91dHB1dFsyXSA9IE1hdGgubWF4KG91dHB1dFsyXSwgYTAsIGExLCBhMiwgYTMpO1xuICAgIG91dHB1dFszXSA9IE1hdGgubWF4KG91dHB1dFszXSwgYjAsIGIxLCBiMiwgYjMpO1xuICB9XG4gIHN0YXRpYyBpbnZlcnNlVHJhbnNmb3JtKG0pIHtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICByZXR1cm4gW21bM10gLyBkLCAtbVsxXSAvIGQsIC1tWzJdIC8gZCwgbVswXSAvIGQsIChtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQsIChtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGRdO1xuICB9XG4gIHN0YXRpYyBzaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShtYXRyaXgsIG91dHB1dCkge1xuICAgIGNvbnN0IG0wID0gbWF0cml4WzBdO1xuICAgIGNvbnN0IG0xID0gbWF0cml4WzFdO1xuICAgIGNvbnN0IG0yID0gbWF0cml4WzJdO1xuICAgIGNvbnN0IG0zID0gbWF0cml4WzNdO1xuICAgIGNvbnN0IGEgPSBtMCAqKiAyICsgbTEgKiogMjtcbiAgICBjb25zdCBiID0gbTAgKiBtMiArIG0xICogbTM7XG4gICAgY29uc3QgYyA9IG0yICoqIDIgKyBtMyAqKiAyO1xuICAgIGNvbnN0IGZpcnN0ID0gKGEgKyBjKSAvIDI7XG4gICAgY29uc3Qgc2Vjb25kID0gTWF0aC5zcXJ0KGZpcnN0ICoqIDIgLSAoYSAqIGMgLSBiICoqIDIpKTtcbiAgICBvdXRwdXRbMF0gPSBNYXRoLnNxcnQoZmlyc3QgKyBzZWNvbmQgfHwgMSk7XG4gICAgb3V0cHV0WzFdID0gTWF0aC5zcXJ0KGZpcnN0IC0gc2Vjb25kIHx8IDEpO1xuICB9XG4gIHN0YXRpYyBub3JtYWxpemVSZWN0KHJlY3QpIHtcbiAgICBjb25zdCByID0gcmVjdC5zbGljZSgwKTtcbiAgICBpZiAocmVjdFswXSA+IHJlY3RbMl0pIHtcbiAgICAgIHJbMF0gPSByZWN0WzJdO1xuICAgICAgclsyXSA9IHJlY3RbMF07XG4gICAgfVxuICAgIGlmIChyZWN0WzFdID4gcmVjdFszXSkge1xuICAgICAgclsxXSA9IHJlY3RbM107XG4gICAgICByWzNdID0gcmVjdFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgc3RhdGljIGludGVyc2VjdChyZWN0MSwgcmVjdDIpIHtcbiAgICBjb25zdCB4TG93ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdDFbMF0sIHJlY3QxWzJdKSwgTWF0aC5taW4ocmVjdDJbMF0sIHJlY3QyWzJdKSk7XG4gICAgY29uc3QgeEhpZ2ggPSBNYXRoLm1pbihNYXRoLm1heChyZWN0MVswXSwgcmVjdDFbMl0pLCBNYXRoLm1heChyZWN0MlswXSwgcmVjdDJbMl0pKTtcbiAgICBpZiAoeExvdyA+IHhIaWdoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeUxvdyA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QxWzFdLCByZWN0MVszXSksIE1hdGgubWluKHJlY3QyWzFdLCByZWN0MlszXSkpO1xuICAgIGNvbnN0IHlIaWdoID0gTWF0aC5taW4oTWF0aC5tYXgocmVjdDFbMV0sIHJlY3QxWzNdKSwgTWF0aC5tYXgocmVjdDJbMV0sIHJlY3QyWzNdKSk7XG4gICAgaWYgKHlMb3cgPiB5SGlnaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBbeExvdywgeUxvdywgeEhpZ2gsIHlIaWdoXTtcbiAgfVxuICBzdGF0aWMgcG9pbnRCb3VuZGluZ0JveCh4LCB5LCBtaW5NYXgpIHtcbiAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgpO1xuICAgIG1pbk1heFsxXSA9IE1hdGgubWluKG1pbk1heFsxXSwgeSk7XG4gICAgbWluTWF4WzJdID0gTWF0aC5tYXgobWluTWF4WzJdLCB4KTtcbiAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkpO1xuICB9XG4gIHN0YXRpYyByZWN0Qm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIG1pbk1heCkge1xuICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgeDAsIHgxKTtcbiAgICBtaW5NYXhbMV0gPSBNYXRoLm1pbihtaW5NYXhbMV0sIHkwLCB5MSk7XG4gICAgbWluTWF4WzJdID0gTWF0aC5tYXgobWluTWF4WzJdLCB4MCwgeDEpO1xuICAgIG1pbk1heFszXSA9IE1hdGgubWF4KG1pbk1heFszXSwgeTAsIHkxKTtcbiAgfVxuICBzdGF0aWMgI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIHQsIG1pbk1heCkge1xuICAgIGlmICh0IDw9IDAgfHwgdCA+PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG10ID0gMSAtIHQ7XG4gICAgY29uc3QgdHQgPSB0ICogdDtcbiAgICBjb25zdCB0dHQgPSB0dCAqIHQ7XG4gICAgY29uc3QgeCA9IG10ICogKG10ICogKG10ICogeDAgKyAzICogdCAqIHgxKSArIDMgKiB0dCAqIHgyKSArIHR0dCAqIHgzO1xuICAgIGNvbnN0IHkgPSBtdCAqIChtdCAqIChtdCAqIHkwICsgMyAqIHQgKiB5MSkgKyAzICogdHQgKiB5MikgKyB0dHQgKiB5MztcbiAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgpO1xuICAgIG1pbk1heFsxXSA9IE1hdGgubWluKG1pbk1heFsxXSwgeSk7XG4gICAgbWluTWF4WzJdID0gTWF0aC5tYXgobWluTWF4WzJdLCB4KTtcbiAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkpO1xuICB9XG4gIHN0YXRpYyAjZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCBhLCBiLCBjLCBtaW5NYXgpIHtcbiAgICBpZiAoTWF0aC5hYnMoYSkgPCAxZS0xMikge1xuICAgICAgaWYgKE1hdGguYWJzKGIpID49IDFlLTEyKSB7XG4gICAgICAgIHRoaXMuI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIC1jIC8gYiwgbWluTWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBiICoqIDIgLSA0ICogYyAqIGE7XG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzcXJ0RGVsdGEgPSBNYXRoLnNxcnQoZGVsdGEpO1xuICAgIGNvbnN0IGEyID0gMiAqIGE7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgKC1iICsgc3FydERlbHRhKSAvIGEyLCBtaW5NYXgpO1xuICAgIHRoaXMuI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsICgtYiAtIHNxcnREZWx0YSkgLyBhMiwgbWluTWF4KTtcbiAgfVxuICBzdGF0aWMgYmV6aWVyQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW5NYXgpIHtcbiAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgwLCB4Myk7XG4gICAgbWluTWF4WzFdID0gTWF0aC5taW4obWluTWF4WzFdLCB5MCwgeTMpO1xuICAgIG1pbk1heFsyXSA9IE1hdGgubWF4KG1pbk1heFsyXSwgeDAsIHgzKTtcbiAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkwLCB5Myk7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAzICogKC14MCArIDMgKiAoeDEgLSB4MikgKyB4MyksIDYgKiAoeDAgLSAyICogeDEgKyB4MiksIDMgKiAoeDEgLSB4MCksIG1pbk1heCk7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAzICogKC15MCArIDMgKiAoeTEgLSB5MikgKyB5MyksIDYgKiAoeTAgLSAyICogeTEgKyB5MiksIDMgKiAoeTEgLSB5MCksIG1pbk1heCk7XG4gIH1cbn1cbmNvbnN0IFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MmQ4LCAweDJjNywgMHgyYzYsIDB4MmQ5LCAweDJkZCwgMHgyZGIsIDB4MmRhLCAweDJkYywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgyMDIyLCAweDIwMjAsIDB4MjAyMSwgMHgyMDI2LCAweDIwMTQsIDB4MjAxMywgMHgxOTIsIDB4MjA0NCwgMHgyMDM5LCAweDIwM2EsIDB4MjIxMiwgMHgyMDMwLCAweDIwMWUsIDB4MjAxYywgMHgyMDFkLCAweDIwMTgsIDB4MjAxOSwgMHgyMDFhLCAweDIxMjIsIDB4ZmIwMSwgMHhmYjAyLCAweDE0MSwgMHgxNTIsIDB4MTYwLCAweDE3OCwgMHgxN2QsIDB4MTMxLCAweDE0MiwgMHgxNTMsIDB4MTYxLCAweDE3ZSwgMCwgMHgyMGFjXSkpO1xuZnVuY3Rpb24gc3RyaW5nVG9QREZTdHJpbmcoc3RyLCBrZWVwRXNjYXBlU2VxdWVuY2UgPSBmYWxzZSkge1xuICBpZiAoc3RyWzBdID49IFwiXFx4RUZcIikge1xuICAgIGxldCBlbmNvZGluZztcbiAgICBpZiAoc3RyWzBdID09PSBcIlxceEZFXCIgJiYgc3RyWzFdID09PSBcIlxceEZGXCIpIHtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGYtMTZiZVwiO1xuICAgICAgaWYgKHN0ci5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RkZcIiAmJiBzdHJbMV0gPT09IFwiXFx4RkVcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi0xNmxlXCI7XG4gICAgICBpZiAoc3RyLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0clswXSA9PT0gXCJcXHhFRlwiICYmIHN0clsxXSA9PT0gXCJcXHhCQlwiICYmIHN0clsyXSA9PT0gXCJcXHhCRlwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLThcIjtcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCB7XG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHN0cmluZ1RvQnl0ZXMoc3RyKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIGlmIChrZWVwRXNjYXBlU2VxdWVuY2UgfHwgIWRlY29kZWQuaW5jbHVkZXMoXCJcXHgxYlwiKSkge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvZGVkLnJlcGxhY2VBbGwoL1xceDFiW15cXHgxYl0qKD86XFx4MWJ8JCkvZywgXCJcIik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB3YXJuKGBzdHJpbmdUb1BERlN0cmluZzogXCIke2V4fVwiLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzdHJCdWYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3RyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBjb25zdCBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmICgha2VlcEVzY2FwZVNlcXVlbmNlICYmIGNoYXJDb2RlID09PSAweDFiKSB7XG4gICAgICB3aGlsZSAoKytpIDwgaWkgJiYgc3RyLmNoYXJDb2RlQXQoaSkgIT09IDB4MWIpIHt9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgY29kZSA9IFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlW2NoYXJDb2RlXTtcbiAgICBzdHJCdWYucHVzaChjb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSA6IHN0ci5jaGFyQXQoaSkpO1xuICB9XG4gIHJldHVybiBzdHJCdWYuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyKSk7XG59XG5mdW5jdGlvbiB1dGY4U3RyaW5nVG9TdHJpbmcoc3RyKSB7XG4gIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5mdW5jdGlvbiBpc0FycmF5RXF1YWwoYXJyMSwgYXJyMikge1xuICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGFycjEubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0TW9kaWZpY2F0aW9uRGF0ZShkYXRlID0gbmV3IERhdGUoKSkge1xuICBpZiAoIShkYXRlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gIH1cbiAgY29uc3QgYnVmZmVyID0gW2RhdGUuZ2V0VVRDRnVsbFllYXIoKS50b1N0cmluZygpLCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDTWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKV07XG4gIHJldHVybiBidWZmZXIuam9pbihcIlwiKTtcbn1cbmxldCBOb3JtYWxpemVSZWdleCA9IG51bGw7XG5sZXQgTm9ybWFsaXphdGlvbk1hcCA9IG51bGw7XG5mdW5jdGlvbiBub3JtYWxpemVVbmljb2RlKHN0cikge1xuICBpZiAoIU5vcm1hbGl6ZVJlZ2V4KSB7XG4gICAgTm9ybWFsaXplUmVnZXggPSAvKFtcXHUwMGEwXFx1MDBiNVxcdTAzN2VcXHUwZWIzXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIxMjZcXHVmYjAwLVxcdWZiMDRcXHVmYjA2XFx1ZmIyMC1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmJhMVxcdWZiYTQtXFx1ZmJhOVxcdWZiYWUtXFx1ZmJiMVxcdWZiZDMtXFx1ZmJkY1xcdWZiZGUtXFx1ZmJlN1xcdWZiZWEtXFx1ZmJmOFxcdWZiZmMtXFx1ZmJmZFxcdWZjMDAtXFx1ZmM1ZFxcdWZjNjQtXFx1ZmNmMVxcdWZjZjUtXFx1ZmQzZFxcdWZkODhcXHVmZGY0XFx1ZmRmYS1cXHVmZGZiXFx1ZmU3MVxcdWZlNzdcXHVmZTc5XFx1ZmU3YlxcdWZlN2RdKyl8KFxcdWZiMDUrKS9ndTtcbiAgICBOb3JtYWxpemF0aW9uTWFwID0gbmV3IE1hcChbW1wi76yFXCIsIFwixb90XCJdXSk7XG4gIH1cbiAgcmV0dXJuIHN0ci5yZXBsYWNlQWxsKE5vcm1hbGl6ZVJlZ2V4LCAoXywgcDEsIHAyKSA9PiBwMSA/IHAxLm5vcm1hbGl6ZShcIk5GS0NcIikgOiBOb3JtYWxpemF0aW9uTWFwLmdldChwMikpO1xufVxuZnVuY3Rpb24gZ2V0VXVpZCgpIHtcbiAgaWYgKHR5cGVvZiBjcnlwdG8ucmFuZG9tVVVJRCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gIH1cbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ1Zik7XG4gIHJldHVybiBieXRlc1RvU3RyaW5nKGJ1Zik7XG59XG5jb25zdCBBbm5vdGF0aW9uUHJlZml4ID0gXCJwZGZqc19pbnRlcm5hbF9pZF9cIjtcbmZ1bmN0aW9uIF9pc1ZhbGlkRXhwbGljaXREZXN0KHZhbGlkUmVmLCB2YWxpZE5hbWUsIGRlc3QpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGRlc3QpIHx8IGRlc3QubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBbcGFnZSwgem9vbSwgLi4uYXJnc10gPSBkZXN0O1xuICBpZiAoIXZhbGlkUmVmKHBhZ2UpICYmICFOdW1iZXIuaXNJbnRlZ2VyKHBhZ2UpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghdmFsaWROYW1lKHpvb20pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFyZ3NMZW4gPSBhcmdzLmxlbmd0aDtcbiAgbGV0IGFsbG93TnVsbCA9IHRydWU7XG4gIHN3aXRjaCAoem9vbS5uYW1lKSB7XG4gICAgY2FzZSBcIlhZWlwiOlxuICAgICAgaWYgKGFyZ3NMZW4gPCAyIHx8IGFyZ3NMZW4gPiAzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJGaXRcIjpcbiAgICBjYXNlIFwiRml0QlwiOlxuICAgICAgcmV0dXJuIGFyZ3NMZW4gPT09IDA7XG4gICAgY2FzZSBcIkZpdEhcIjpcbiAgICBjYXNlIFwiRml0QkhcIjpcbiAgICBjYXNlIFwiRml0VlwiOlxuICAgIGNhc2UgXCJGaXRCVlwiOlxuICAgICAgaWYgKGFyZ3NMZW4gPiAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJGaXRSXCI6XG4gICAgICBpZiAoYXJnc0xlbiAhPT0gNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBhbGxvd051bGwgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSBcIm51bWJlclwiIHx8IGFsbG93TnVsbCAmJiBhcmcgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBNYXRoQ2xhbXAodiwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHYsIG1pbiksIG1heCk7XG59XG5mdW5jdGlvbiB0b0hleFV0aWwoYXJyKSB7XG4gIGlmIChVaW50OEFycmF5LnByb3RvdHlwZS50b0hleCkge1xuICAgIHJldHVybiBhcnIudG9IZXgoKTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShhcnIsIG51bSA9PiBoZXhOdW1iZXJzW251bV0pLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiB0b0Jhc2U2NFV0aWwoYXJyKSB7XG4gIGlmIChVaW50OEFycmF5LnByb3RvdHlwZS50b0Jhc2U2NCkge1xuICAgIHJldHVybiBhcnIudG9CYXNlNjQoKTtcbiAgfVxuICByZXR1cm4gYnRvYShieXRlc1RvU3RyaW5nKGFycikpO1xufVxuZnVuY3Rpb24gZnJvbUJhc2U2NFV0aWwoc3RyKSB7XG4gIGlmIChVaW50OEFycmF5LmZyb21CYXNlNjQpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tQmFzZTY0KHN0cik7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ1RvQnl0ZXMoYXRvYihzdHIpKTtcbn1cbmlmICh0eXBlb2YgUHJvbWlzZS50cnkgIT09IFwiZnVuY3Rpb25cIikge1xuICBQcm9taXNlLnRyeSA9IGZ1bmN0aW9uIChmbiwgLi4uYXJncykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgIH0pO1xuICB9O1xufVxuaWYgKHR5cGVvZiBNYXRoLnN1bVByZWNpc2UgIT09IFwiZnVuY3Rpb25cIikge1xuICBNYXRoLnN1bVByZWNpc2UgPSBmdW5jdGlvbiAobnVtYmVycykge1xuICAgIHJldHVybiBudW1iZXJzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICB9O1xufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9kaXNwbGF5X3V0aWxzLmpzXG5cbmNvbnN0IFNWR19OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmNsYXNzIFBpeGVsc1BlckluY2gge1xuICBzdGF0aWMgQ1NTID0gOTYuMDtcbiAgc3RhdGljIFBERiA9IDcyLjA7XG4gIHN0YXRpYyBQREZfVE9fQ1NTX1VOSVRTID0gdGhpcy5DU1MgLyB0aGlzLlBERjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSh1cmwsIHR5cGUgPSBcInRleHRcIikge1xuICBpZiAoaXNWYWxpZEZldGNoVXJsKHVybCwgZG9jdW1lbnQuYmFzZVVSSSkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgIGNhc2UgXCJibG9iXCI6XG4gICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdHlwZTtcbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDAgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICB9O1xuICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbiAgfSk7XG59XG5jbGFzcyBQYWdlVmlld3BvcnQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdmlld0JveCxcbiAgICB1c2VyVW5pdCxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvbixcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLnZpZXdCb3ggPSB2aWV3Qm94O1xuICAgIHRoaXMudXNlclVuaXQgPSB1c2VyVW5pdDtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFg7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WTtcbiAgICBzY2FsZSAqPSB1c2VyVW5pdDtcbiAgICBjb25zdCBjZW50ZXJYID0gKHZpZXdCb3hbMl0gKyB2aWV3Qm94WzBdKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9ICh2aWV3Qm94WzNdICsgdmlld0JveFsxXSkgLyAyO1xuICAgIGxldCByb3RhdGVBLCByb3RhdGVCLCByb3RhdGVDLCByb3RhdGVEO1xuICAgIHJvdGF0aW9uICU9IDM2MDtcbiAgICBpZiAocm90YXRpb24gPCAwKSB7XG4gICAgICByb3RhdGlvbiArPSAzNjA7XG4gICAgfVxuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByb3RhdGVBID0gLTE7XG4gICAgICAgIHJvdGF0ZUIgPSAwO1xuICAgICAgICByb3RhdGVDID0gMDtcbiAgICAgICAgcm90YXRlRCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcm90YXRlQSA9IDA7XG4gICAgICAgIHJvdGF0ZUIgPSAxO1xuICAgICAgICByb3RhdGVDID0gMTtcbiAgICAgICAgcm90YXRlRCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJvdGF0ZUEgPSAwO1xuICAgICAgICByb3RhdGVCID0gLTE7XG4gICAgICAgIHJvdGF0ZUMgPSAtMTtcbiAgICAgICAgcm90YXRlRCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAwOlxuICAgICAgICByb3RhdGVBID0gMTtcbiAgICAgICAgcm90YXRlQiA9IDA7XG4gICAgICAgIHJvdGF0ZUMgPSAwO1xuICAgICAgICByb3RhdGVEID0gLTE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFnZVZpZXdwb3J0OiBJbnZhbGlkIHJvdGF0aW9uLCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgOTAgZGVncmVlcy5cIik7XG4gICAgfVxuICAgIGlmIChkb250RmxpcCkge1xuICAgICAgcm90YXRlQyA9IC1yb3RhdGVDO1xuICAgICAgcm90YXRlRCA9IC1yb3RhdGVEO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0Q2FudmFzWCwgb2Zmc2V0Q2FudmFzWTtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgICBpZiAocm90YXRlQSA9PT0gMCkge1xuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJYIC0gdmlld0JveFswXSkgKiBzY2FsZSArIG9mZnNldFk7XG4gICAgICB3aWR0aCA9ICh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcbiAgICAgIGhlaWdodCA9ICh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFk7XG4gICAgICB3aWR0aCA9ICh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcbiAgICAgIGhlaWdodCA9ICh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBbcm90YXRlQSAqIHNjYWxlLCByb3RhdGVCICogc2NhbGUsIHJvdGF0ZUMgKiBzY2FsZSwgcm90YXRlRCAqIHNjYWxlLCBvZmZzZXRDYW52YXNYIC0gcm90YXRlQSAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUMgKiBzY2FsZSAqIGNlbnRlclksIG9mZnNldENhbnZhc1kgLSByb3RhdGVCICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlRCAqIHNjYWxlICogY2VudGVyWV07XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIGdldCByYXdEaW1zKCkge1xuICAgIGNvbnN0IGRpbXMgPSB0aGlzLnZpZXdCb3g7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInJhd0RpbXNcIiwge1xuICAgICAgcGFnZVdpZHRoOiBkaW1zWzJdIC0gZGltc1swXSxcbiAgICAgIHBhZ2VIZWlnaHQ6IGRpbXNbM10gLSBkaW1zWzFdLFxuICAgICAgcGFnZVg6IGRpbXNbMF0sXG4gICAgICBwYWdlWTogZGltc1sxXVxuICAgIH0pO1xuICB9XG4gIGNsb25lKHtcbiAgICBzY2FsZSA9IHRoaXMuc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uLFxuICAgIG9mZnNldFggPSB0aGlzLm9mZnNldFgsXG4gICAgb2Zmc2V0WSA9IHRoaXMub2Zmc2V0WSxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveC5zbGljZSgpLFxuICAgICAgdXNlclVuaXQ6IHRoaXMudXNlclVuaXQsXG4gICAgICBzY2FsZSxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBkb250RmxpcFxuICAgIH0pO1xuICB9XG4gIGNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQoeCwgeSkge1xuICAgIGNvbnN0IHAgPSBbeCwgeV07XG4gICAgVXRpbC5hcHBseVRyYW5zZm9ybShwLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUocmVjdCkge1xuICAgIGNvbnN0IHRvcExlZnQgPSBbcmVjdFswXSwgcmVjdFsxXV07XG4gICAgVXRpbC5hcHBseVRyYW5zZm9ybSh0b3BMZWZ0LCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSBbcmVjdFsyXSwgcmVjdFszXV07XG4gICAgVXRpbC5hcHBseVRyYW5zZm9ybShib3R0b21SaWdodCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHJldHVybiBbdG9wTGVmdFswXSwgdG9wTGVmdFsxXSwgYm90dG9tUmlnaHRbMF0sIGJvdHRvbVJpZ2h0WzFdXTtcbiAgfVxuICBjb252ZXJ0VG9QZGZQb2ludCh4LCB5KSB7XG4gICAgY29uc3QgcCA9IFt4LCB5XTtcbiAgICBVdGlsLmFwcGx5SW52ZXJzZVRyYW5zZm9ybShwLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbn1cbmNsYXNzIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgc3VwZXIobXNnLCBcIlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmV4dHJhRGVsYXkgPSBleHRyYURlbGF5O1xuICB9XG59XG5mdW5jdGlvbiBpc0RhdGFTY2hlbWUodXJsKSB7XG4gIGNvbnN0IGlpID0gdXJsLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGlpICYmIHVybFtpXS50cmltKCkgPT09IFwiXCIpIHtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoaSwgaSArIDUpLnRvTG93ZXJDYXNlKCkgPT09IFwiZGF0YTpcIjtcbn1cbmZ1bmN0aW9uIGlzUGRmRmlsZShmaWxlbmFtZSkge1xuICByZXR1cm4gdHlwZW9mIGZpbGVuYW1lID09PSBcInN0cmluZ1wiICYmIC9cXC5wZGYkL2kudGVzdChmaWxlbmFtZSk7XG59XG5mdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21VcmwodXJsKSB7XG4gIFt1cmxdID0gdXJsLnNwbGl0KC9bIz9dLywgMSk7XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKHVybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbn1cbmZ1bmN0aW9uIGdldFBkZkZpbGVuYW1lRnJvbVVybCh1cmwsIGRlZmF1bHRGaWxlbmFtZSA9IFwiZG9jdW1lbnQucGRmXCIpIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG4gIGlmIChpc0RhdGFTY2hlbWUodXJsKSkge1xuICAgIHdhcm4oJ2dldFBkZkZpbGVuYW1lRnJvbVVybDogaWdub3JlIFwiZGF0YTpcIi1VUkwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuJyk7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuICBjb25zdCBnZXRVUkwgPSB1cmxTdHJpbmcgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBVUkwoZGVjb2RlVVJJQ29tcG9uZW50KHVybFN0cmluZykpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVUkwodXJsU3RyaW5nLCBcImh0dHBzOi8vZm9vLmJhclwiKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKGRlY29kZVVSSUNvbXBvbmVudCh1cmxTdHJpbmcpLCBcImh0dHBzOi8vZm9vLmJhclwiKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbmV3VVJMID0gZ2V0VVJMKHVybCk7XG4gIGlmICghbmV3VVJMKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuICBjb25zdCBkZWNvZGUgPSBuYW1lID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IGRlY29kZWQgPSBkZWNvZGVVUklDb21wb25lbnQobmFtZSk7XG4gICAgICBpZiAoZGVjb2RlZC5pbmNsdWRlcyhcIi9cIikpIHtcbiAgICAgICAgZGVjb2RlZCA9IGRlY29kZWQuc3BsaXQoXCIvXCIpLmF0KC0xKTtcbiAgICAgICAgaWYgKGRlY29kZWQudGVzdCgvXlxcLnBkZiQvaSkpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICB9O1xuICBjb25zdCBwZGZSZWdleCA9IC9cXC5wZGYkL2k7XG4gIGNvbnN0IGZpbGVuYW1lID0gbmV3VVJMLnBhdGhuYW1lLnNwbGl0KFwiL1wiKS5hdCgtMSk7XG4gIGlmIChwZGZSZWdleC50ZXN0KGZpbGVuYW1lKSkge1xuICAgIHJldHVybiBkZWNvZGUoZmlsZW5hbWUpO1xuICB9XG4gIGlmIChuZXdVUkwuc2VhcmNoUGFyYW1zLnNpemUgPiAwKSB7XG4gICAgY29uc3QgdmFsdWVzID0gQXJyYXkuZnJvbShuZXdVUkwuc2VhcmNoUGFyYW1zLnZhbHVlcygpKS5yZXZlcnNlKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmIChwZGZSZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZGVjb2RlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IEFycmF5LmZyb20obmV3VVJMLnNlYXJjaFBhcmFtcy5rZXlzKCkpLnJldmVyc2UoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAocGRmUmVnZXgudGVzdChrZXkpKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5ld1VSTC5oYXNoKSB7XG4gICAgY29uc3QgcmVGaWxlbmFtZSA9IC9bXi8/Iz1dK1xcLnBkZlxcYig/IS4qXFwucGRmXFxiKS9pO1xuICAgIGNvbnN0IGhhc2hGaWxlbmFtZSA9IHJlRmlsZW5hbWUuZXhlYyhuZXdVUkwuaGFzaCk7XG4gICAgaWYgKGhhc2hGaWxlbmFtZSkge1xuICAgICAgcmV0dXJuIGRlY29kZShoYXNoRmlsZW5hbWVbMF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xufVxuY2xhc3MgU3RhdFRpbWVyIHtcbiAgc3RhcnRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRpbWVzID0gW107XG4gIHRpbWUobmFtZSkge1xuICAgIGlmIChuYW1lIGluIHRoaXMuc3RhcnRlZCkge1xuICAgICAgd2FybihgVGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHRoaXMuc3RhcnRlZFtuYW1lXSA9IERhdGUubm93KCk7XG4gIH1cbiAgdGltZUVuZChuYW1lKSB7XG4gICAgaWYgKCEobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpKSB7XG4gICAgICB3YXJuKGBUaW1lciBoYXMgbm90IGJlZW4gc3RhcnRlZCBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLnRpbWVzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ZWRbbmFtZV0sXG4gICAgICBlbmQ6IERhdGUubm93KClcbiAgICB9KTtcbiAgICBkZWxldGUgdGhpcy5zdGFydGVkW25hbWVdO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IG91dEJ1ZiA9IFtdO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9IG9mIHRoaXMudGltZXMpIHtcbiAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuYW1lLmxlbmd0aCwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kXG4gICAgfSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBvdXRCdWYucHVzaChgJHtuYW1lLnBhZEVuZChsb25nZXN0KX0gJHtlbmQgLSBzdGFydH1tc1xcbmApO1xuICAgIH1cbiAgICByZXR1cm4gb3V0QnVmLmpvaW4oXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRGZXRjaFVybCh1cmwsIGJhc2VVcmwpIHtcbiAgY29uc3QgcmVzID0gYmFzZVVybCA/IFVSTC5wYXJzZSh1cmwsIGJhc2VVcmwpIDogVVJMLnBhcnNlKHVybCk7XG4gIHJldHVybiByZXM/LnByb3RvY29sID09PSBcImh0dHA6XCIgfHwgcmVzPy5wcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbn1cbmZ1bmN0aW9uIG5vQ29udGV4dE1lbnUoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBzdG9wRXZlbnQoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5mdW5jdGlvbiBkZXByZWNhdGVkKGRldGFpbHMpIHtcbiAgY29uc29sZS5sb2coXCJEZXByZWNhdGVkIEFQSSB1c2FnZTogXCIgKyBkZXRhaWxzKTtcbn1cbmNsYXNzIFBERkRhdGVTdHJpbmcge1xuICBzdGF0aWMgI3JlZ2V4O1xuICBzdGF0aWMgdG9EYXRlT2JqZWN0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3JlZ2V4IHx8PSBuZXcgUmVnRXhwKFwiXkQ6XCIgKyBcIihcXFxcZHs0fSlcIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFtafCt8LV0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCInP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCInP1wiKTtcbiAgICBjb25zdCBtYXRjaGVzID0gdGhpcy4jcmVnZXguZXhlYyhpbnB1dCk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeWVhciA9IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKTtcbiAgICBsZXQgbW9udGggPSBwYXJzZUludChtYXRjaGVzWzJdLCAxMCk7XG4gICAgbW9udGggPSBtb250aCA+PSAxICYmIG1vbnRoIDw9IDEyID8gbW9udGggLSAxIDogMDtcbiAgICBsZXQgZGF5ID0gcGFyc2VJbnQobWF0Y2hlc1szXSwgMTApO1xuICAgIGRheSA9IGRheSA+PSAxICYmIGRheSA8PSAzMSA/IGRheSA6IDE7XG4gICAgbGV0IGhvdXIgPSBwYXJzZUludChtYXRjaGVzWzRdLCAxMCk7XG4gICAgaG91ciA9IGhvdXIgPj0gMCAmJiBob3VyIDw9IDIzID8gaG91ciA6IDA7XG4gICAgbGV0IG1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcbiAgICBtaW51dGUgPSBtaW51dGUgPj0gMCAmJiBtaW51dGUgPD0gNTkgPyBtaW51dGUgOiAwO1xuICAgIGxldCBzZWNvbmQgPSBwYXJzZUludChtYXRjaGVzWzZdLCAxMCk7XG4gICAgc2Vjb25kID0gc2Vjb25kID49IDAgJiYgc2Vjb25kIDw9IDU5ID8gc2Vjb25kIDogMDtcbiAgICBjb25zdCB1bml2ZXJzYWxUaW1lUmVsYXRpb24gPSBtYXRjaGVzWzddIHx8IFwiWlwiO1xuICAgIGxldCBvZmZzZXRIb3VyID0gcGFyc2VJbnQobWF0Y2hlc1s4XSwgMTApO1xuICAgIG9mZnNldEhvdXIgPSBvZmZzZXRIb3VyID49IDAgJiYgb2Zmc2V0SG91ciA8PSAyMyA/IG9mZnNldEhvdXIgOiAwO1xuICAgIGxldCBvZmZzZXRNaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzldLCAxMCkgfHwgMDtcbiAgICBvZmZzZXRNaW51dGUgPSBvZmZzZXRNaW51dGUgPj0gMCAmJiBvZmZzZXRNaW51dGUgPD0gNTkgPyBvZmZzZXRNaW51dGUgOiAwO1xuICAgIGlmICh1bml2ZXJzYWxUaW1lUmVsYXRpb24gPT09IFwiLVwiKSB7XG4gICAgICBob3VyICs9IG9mZnNldEhvdXI7XG4gICAgICBtaW51dGUgKz0gb2Zmc2V0TWludXRlO1xuICAgIH0gZWxzZSBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIitcIikge1xuICAgICAgaG91ciAtPSBvZmZzZXRIb3VyO1xuICAgICAgbWludXRlIC09IG9mZnNldE1pbnV0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFhmYVBhZ2VWaWV3cG9ydCh4ZmFQYWdlLCB7XG4gIHNjYWxlID0gMSxcbiAgcm90YXRpb24gPSAwXG59KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHhmYVBhZ2UuYXR0cmlidXRlcy5zdHlsZTtcbiAgY29uc3Qgdmlld0JveCA9IFswLCAwLCBwYXJzZUludCh3aWR0aCksIHBhcnNlSW50KGhlaWdodCldO1xuICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgdmlld0JveCxcbiAgICB1c2VyVW5pdDogMSxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvblxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJHQihjb2xvcikge1xuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBjb25zdCBjb2xvclJHQiA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNik7XG4gICAgcmV0dXJuIFsoY29sb3JSR0IgJiAweGZmMDAwMCkgPj4gMTYsIChjb2xvclJHQiAmIDB4MDBmZjAwKSA+PiA4LCBjb2xvclJHQiAmIDB4MDAwMGZmXTtcbiAgfVxuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcInJnYihcIikpIHtcbiAgICByZXR1cm4gY29sb3Iuc2xpY2UoNCwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoeCA9PiBwYXJzZUludCh4KSk7XG4gIH1cbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2JhKFwiKSkge1xuICAgIHJldHVybiBjb2xvci5zbGljZSg1LCAtMSkuc3BsaXQoXCIsXCIpLm1hcCh4ID0+IHBhcnNlSW50KHgpKS5zbGljZSgwLCAzKTtcbiAgfVxuICB3YXJuKGBOb3QgYSB2YWxpZCBjb2xvciBmb3JtYXQ6IFwiJHtjb2xvcn1cImApO1xuICByZXR1cm4gWzAsIDAsIDBdO1xufVxuZnVuY3Rpb24gZ2V0Q29sb3JWYWx1ZXMoY29sb3JzKSB7XG4gIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgc3Bhbi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgc3Bhbi5zdHlsZS5jb2xvclNjaGVtZSA9IFwib25seSBsaWdodFwiO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZChzcGFuKTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIGNvbG9ycy5rZXlzKCkpIHtcbiAgICBzcGFuLnN0eWxlLmNvbG9yID0gbmFtZTtcbiAgICBjb25zdCBjb21wdXRlZENvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3BhbikuY29sb3I7XG4gICAgY29sb3JzLnNldChuYW1lLCBnZXRSR0IoY29tcHV0ZWRDb2xvcikpO1xuICB9XG4gIHNwYW4ucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCk7XG4gIHJldHVybiBbYSwgYiwgYywgZCwgZSwgZl07XG59XG5mdW5jdGlvbiBzZXRMYXllckRpbWVuc2lvbnMoZGl2LCB2aWV3cG9ydCwgbXVzdEZsaXAgPSBmYWxzZSwgbXVzdFJvdGF0ZSA9IHRydWUpIHtcbiAgaWYgKHZpZXdwb3J0IGluc3RhbmNlb2YgUGFnZVZpZXdwb3J0KSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRpdjtcbiAgICBjb25zdCB1c2VSb3VuZCA9IHV0aWxfRmVhdHVyZVRlc3QuaXNDU1NSb3VuZFN1cHBvcnRlZDtcbiAgICBjb25zdCB3ID0gYHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgKiAke3BhZ2VXaWR0aH1weGAsXG4gICAgICBoID0gYHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgKiAke3BhZ2VIZWlnaHR9cHhgO1xuICAgIGNvbnN0IHdpZHRoU3RyID0gdXNlUm91bmQgPyBgcm91bmQoZG93biwgJHt3fSwgdmFyKC0tc2NhbGUtcm91bmQteCkpYCA6IGBjYWxjKCR7d30pYCxcbiAgICAgIGhlaWdodFN0ciA9IHVzZVJvdW5kID8gYHJvdW5kKGRvd24sICR7aH0sIHZhcigtLXNjYWxlLXJvdW5kLXkpKWAgOiBgY2FsYygke2h9KWA7XG4gICAgaWYgKCFtdXN0RmxpcCB8fCB2aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aFN0cjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodFN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUud2lkdGggPSBoZWlnaHRTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSB3aWR0aFN0cjtcbiAgICB9XG4gIH1cbiAgaWYgKG11c3RSb3RhdGUpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1tYWluLXJvdGF0aW9uXCIsIHZpZXdwb3J0LnJvdGF0aW9uKTtcbiAgfVxufVxuY2xhc3MgT3V0cHV0U2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBwaXhlbFJhdGlvXG4gICAgfSA9IE91dHB1dFNjYWxlO1xuICAgIHRoaXMuc3ggPSBwaXhlbFJhdGlvO1xuICAgIHRoaXMuc3kgPSBwaXhlbFJhdGlvO1xuICB9XG4gIGdldCBzY2FsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ggIT09IDEgfHwgdGhpcy5zeSAhPT0gMTtcbiAgfVxuICBnZXQgc3ltbWV0cmljKCkge1xuICAgIHJldHVybiB0aGlzLnN4ID09PSB0aGlzLnN5O1xuICB9XG4gIGxpbWl0Q2FudmFzKHdpZHRoLCBoZWlnaHQsIG1heFBpeGVscywgbWF4RGltLCBjYXBBcmVhRmFjdG9yID0gLTEpIHtcbiAgICBsZXQgbWF4QXJlYVNjYWxlID0gSW5maW5pdHksXG4gICAgICBtYXhXaWR0aFNjYWxlID0gSW5maW5pdHksXG4gICAgICBtYXhIZWlnaHRTY2FsZSA9IEluZmluaXR5O1xuICAgIG1heFBpeGVscyA9IE91dHB1dFNjYWxlLmNhcFBpeGVscyhtYXhQaXhlbHMsIGNhcEFyZWFGYWN0b3IpO1xuICAgIGlmIChtYXhQaXhlbHMgPiAwKSB7XG4gICAgICBtYXhBcmVhU2NhbGUgPSBNYXRoLnNxcnQobWF4UGl4ZWxzIC8gKHdpZHRoICogaGVpZ2h0KSk7XG4gICAgfVxuICAgIGlmIChtYXhEaW0gIT09IC0xKSB7XG4gICAgICBtYXhXaWR0aFNjYWxlID0gbWF4RGltIC8gd2lkdGg7XG4gICAgICBtYXhIZWlnaHRTY2FsZSA9IG1heERpbSAvIGhlaWdodDtcbiAgICB9XG4gICAgY29uc3QgbWF4U2NhbGUgPSBNYXRoLm1pbihtYXhBcmVhU2NhbGUsIG1heFdpZHRoU2NhbGUsIG1heEhlaWdodFNjYWxlKTtcbiAgICBpZiAodGhpcy5zeCA+IG1heFNjYWxlIHx8IHRoaXMuc3kgPiBtYXhTY2FsZSkge1xuICAgICAgdGhpcy5zeCA9IG1heFNjYWxlO1xuICAgICAgdGhpcy5zeSA9IG1heFNjYWxlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICB9XG4gIHN0YXRpYyBjYXBQaXhlbHMobWF4UGl4ZWxzLCBjYXBBcmVhRmFjdG9yKSB7XG4gICAgaWYgKGNhcEFyZWFGYWN0b3IgPj0gMCkge1xuICAgICAgY29uc3Qgd2luUGl4ZWxzID0gTWF0aC5jZWlsKHdpbmRvdy5zY3JlZW4uYXZhaWxXaWR0aCAqIHdpbmRvdy5zY3JlZW4uYXZhaWxIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8gKiogMiAqICgxICsgY2FwQXJlYUZhY3RvciAvIDEwMCkpO1xuICAgICAgcmV0dXJuIG1heFBpeGVscyA+IDAgPyBNYXRoLm1pbihtYXhQaXhlbHMsIHdpblBpeGVscykgOiB3aW5QaXhlbHM7XG4gICAgfVxuICAgIHJldHVybiBtYXhQaXhlbHM7XG4gIH1cbn1cbmNvbnN0IFN1cHBvcnRlZEltYWdlTWltZVR5cGVzID0gW1wiaW1hZ2UvYXBuZ1wiLCBcImltYWdlL2F2aWZcIiwgXCJpbWFnZS9ibXBcIiwgXCJpbWFnZS9naWZcIiwgXCJpbWFnZS9qcGVnXCIsIFwiaW1hZ2UvcG5nXCIsIFwiaW1hZ2Uvc3ZnK3htbFwiLCBcImltYWdlL3dlYnBcIiwgXCJpbWFnZS94LWljb25cIl07XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci90b29sYmFyLmpzXG5cbmNsYXNzIEVkaXRvclRvb2xiYXIge1xuICAjdG9vbGJhciA9IG51bGw7XG4gICNjb2xvclBpY2tlciA9IG51bGw7XG4gICNlZGl0b3I7XG4gICNidXR0b25zID0gbnVsbDtcbiAgI2FsdFRleHQgPSBudWxsO1xuICAjY29tbWVudCA9IG51bGw7XG4gICNzaWduYXR1cmVEZXNjcmlwdGlvbkJ1dHRvbiA9IG51bGw7XG4gIHN0YXRpYyAjbDEwblJlbW92ZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICBFZGl0b3JUb29sYmFyLiNsMTBuUmVtb3ZlIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIGZyZWV0ZXh0OiBcInBkZmpzLWVkaXRvci1yZW1vdmUtZnJlZXRleHQtYnV0dG9uXCIsXG4gICAgICBoaWdobGlnaHQ6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1oaWdobGlnaHQtYnV0dG9uXCIsXG4gICAgICBpbms6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1pbmstYnV0dG9uXCIsXG4gICAgICBzdGFtcDogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLXN0YW1wLWJ1dHRvblwiLFxuICAgICAgc2lnbmF0dXJlOiBcInBkZmpzLWVkaXRvci1yZW1vdmUtc2lnbmF0dXJlLWJ1dHRvblwiXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGVkaXRUb29sYmFyID0gdGhpcy4jdG9vbGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZWRpdFRvb2xiYXIuY2xhc3NMaXN0LmFkZChcImVkaXRUb29sYmFyXCIsIFwiaGlkZGVuXCIpO1xuICAgIGVkaXRUb29sYmFyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0b29sYmFyXCIpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgaWYgKHNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsICYmICFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgZWRpdFRvb2xiYXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGVkaXRUb29sYmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBFZGl0b3JUb29sYmFyLiNwb2ludGVyRG93biwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBidXR0b25zID0gdGhpcy4jYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgYnV0dG9ucy5jbGFzc05hbWUgPSBcImJ1dHRvbnNcIjtcbiAgICBlZGl0VG9vbGJhci5hcHBlbmQoYnV0dG9ucyk7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLiNlZGl0b3IudG9vbGJhclBvc2l0aW9uO1xuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGVkaXRUb29sYmFyO1xuICAgICAgY29uc3QgeCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IDEgLSBwb3NpdGlvblswXSA6IHBvc2l0aW9uWzBdO1xuICAgICAgc3R5bGUuaW5zZXRJbmxpbmVFbmQgPSBgJHsxMDAgKiB4fSVgO1xuICAgICAgc3R5bGUudG9wID0gYGNhbGMoJHsxMDAgKiBwb3NpdGlvblsxXX0lICsgdmFyKC0tZWRpdG9yLXRvb2xiYXItdmVydC1vZmZzZXQpKWA7XG4gICAgfVxuICAgIHJldHVybiBlZGl0VG9vbGJhcjtcbiAgfVxuICBnZXQgZGl2KCkge1xuICAgIHJldHVybiB0aGlzLiN0b29sYmFyO1xuICB9XG4gIHN0YXRpYyAjcG9pbnRlckRvd24oZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgI2ZvY3VzSW4oZSkge1xuICAgIHRoaXMuI2VkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgc3RvcEV2ZW50KGUpO1xuICB9XG4gICNmb2N1c091dChlKSB7XG4gICAgdGhpcy4jZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgIHN0b3BFdmVudChlKTtcbiAgfVxuICAjYWRkTGlzdGVuZXJzVG9FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGlmICghKHNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsKSB8fCBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2ZvY3VzSW4uYmluZCh0aGlzKSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuI2ZvY3VzT3V0LmJpbmQodGhpcyksIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuI3Rvb2xiYXIuY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB0aGlzLiNjb2xvclBpY2tlcj8uaGlkZURyb3Bkb3duKCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICB0aGlzLiN0b29sYmFyLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgdGhpcy4jYWx0VGV4dD8uc2hvd24oKTtcbiAgICB0aGlzLiNjb21tZW50Py5zaG93bigpO1xuICB9XG4gIGFkZERlbGV0ZUJ1dHRvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBlZGl0b3JUeXBlLFxuICAgICAgX3VpTWFuYWdlclxuICAgIH0gPSB0aGlzLiNlZGl0b3I7XG4gICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZChcImJhc2ljXCIsIFwiZGVsZXRlQnV0dG9uXCIpO1xuICAgIGJ1dHRvbi50YWJJbmRleCA9IDA7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBFZGl0b3JUb29sYmFyLiNsMTBuUmVtb3ZlW2VkaXRvclR5cGVdKTtcbiAgICBpZiAodGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbikpIHtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAgICAgIF91aU1hbmFnZXIuZGVsZXRlKCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbDogX3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uKTtcbiAgfVxuICBnZXQgI2RpdmlkZXIoKSB7XG4gICAgY29uc3QgZGl2aWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2aWRlci5jbGFzc05hbWUgPSBcImRpdmlkZXJcIjtcbiAgICByZXR1cm4gZGl2aWRlcjtcbiAgfVxuICBhc3luYyBhZGRBbHRUZXh0KGFsdFRleHQpIHtcbiAgICBjb25zdCBidXR0b24gPSBhd2FpdCBhbHRUZXh0LnJlbmRlcigpO1xuICAgIHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pO1xuICAgIHRoaXMuI2J1dHRvbnMuYXBwZW5kKGJ1dHRvbiwgdGhpcy4jZGl2aWRlcik7XG4gICAgdGhpcy4jYWx0VGV4dCA9IGFsdFRleHQ7XG4gIH1cbiAgYWRkQ29tbWVudChjb21tZW50KSB7XG4gICAgaWYgKHRoaXMuI2NvbW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnV0dG9uID0gY29tbWVudC5yZW5kZXIoKTtcbiAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24sIHRoaXMuI2RpdmlkZXIpO1xuICAgIHRoaXMuI2NvbW1lbnQgPSBjb21tZW50O1xuICAgIGNvbW1lbnQudG9vbGJhciA9IHRoaXM7XG4gIH1cbiAgYWRkQ29sb3JQaWNrZXIoY29sb3JQaWNrZXIpIHtcbiAgICBpZiAodGhpcy4jY29sb3JQaWNrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29sb3JQaWNrZXIgPSBjb2xvclBpY2tlcjtcbiAgICBjb25zdCBidXR0b24gPSBjb2xvclBpY2tlci5yZW5kZXJCdXR0b24oKTtcbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24sIHRoaXMuI2RpdmlkZXIpO1xuICB9XG4gIGFzeW5jIGFkZEVkaXRTaWduYXR1cmVCdXR0b24oc2lnbmF0dXJlTWFuYWdlcikge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuI3NpZ25hdHVyZURlc2NyaXB0aW9uQnV0dG9uID0gYXdhaXQgc2lnbmF0dXJlTWFuYWdlci5yZW5kZXJFZGl0QnV0dG9uKHRoaXMuI2VkaXRvcik7XG4gICAgdGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbik7XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uLCB0aGlzLiNkaXZpZGVyKTtcbiAgfVxuICBhc3luYyBhZGRCdXR0b24obmFtZSwgdG9vbCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcImNvbG9yUGlja2VyXCI6XG4gICAgICAgIHRoaXMuYWRkQ29sb3JQaWNrZXIodG9vbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImFsdFRleHRcIjpcbiAgICAgICAgYXdhaXQgdGhpcy5hZGRBbHRUZXh0KHRvb2wpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlZGl0U2lnbmF0dXJlXCI6XG4gICAgICAgIGF3YWl0IHRoaXMuYWRkRWRpdFNpZ25hdHVyZUJ1dHRvbih0b29sKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgIHRoaXMuYWRkRGVsZXRlQnV0dG9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgdGhpcy5hZGRDb21tZW50KHRvb2wpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdXBkYXRlRWRpdFNpZ25hdHVyZUJ1dHRvbihkZXNjcmlwdGlvbikge1xuICAgIGlmICh0aGlzLiNzaWduYXR1cmVEZXNjcmlwdGlvbkJ1dHRvbikge1xuICAgICAgdGhpcy4jc2lnbmF0dXJlRGVzY3JpcHRpb25CdXR0b24udGl0bGUgPSBkZXNjcmlwdGlvbjtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuI3Rvb2xiYXIucmVtb3ZlKCk7XG4gICAgdGhpcy4jY29sb3JQaWNrZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiNjb2xvclBpY2tlciA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIEZsb2F0aW5nVG9vbGJhciB7XG4gICNidXR0b25zID0gbnVsbDtcbiAgI3Rvb2xiYXIgPSBudWxsO1xuICAjdWlNYW5hZ2VyO1xuICBjb25zdHJ1Y3Rvcih1aU1hbmFnZXIpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIgPSB1aU1hbmFnZXI7XG4gIH1cbiAgI3JlbmRlcigpIHtcbiAgICBjb25zdCBlZGl0VG9vbGJhciA9IHRoaXMuI3Rvb2xiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGVkaXRUb29sYmFyLmNsYXNzTmFtZSA9IFwiZWRpdFRvb2xiYXJcIjtcbiAgICBlZGl0VG9vbGJhci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidG9vbGJhclwiKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBpZiAoc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwgJiYgIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBlZGl0VG9vbGJhci5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBidXR0b25zID0gdGhpcy4jYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgYnV0dG9ucy5jbGFzc05hbWUgPSBcImJ1dHRvbnNcIjtcbiAgICBlZGl0VG9vbGJhci5hcHBlbmQoYnV0dG9ucyk7XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5oYXNDb21tZW50TWFuYWdlcigpKSB7XG4gICAgICB0aGlzLiNtYWtlQnV0dG9uKFwiY29tbWVudEJ1dHRvblwiLCBgcGRmanMtY29tbWVudC1mbG9hdGluZy1idXR0b25gLCBcInBkZmpzLWNvbW1lbnQtZmxvYXRpbmctYnV0dG9uLWxhYmVsXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1lbnRTZWxlY3Rpb24oXCJmbG9hdGluZ19idXR0b25cIik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy4jbWFrZUJ1dHRvbihcImhpZ2hsaWdodEJ1dHRvblwiLCBgcGRmanMtaGlnaGxpZ2h0LWZsb2F0aW5nLWJ1dHRvbjFgLCBcInBkZmpzLWhpZ2hsaWdodC1mbG9hdGluZy1idXR0b24tbGFiZWxcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmhpZ2hsaWdodFNlbGVjdGlvbihcImZsb2F0aW5nX2J1dHRvblwiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWRpdFRvb2xiYXI7XG4gIH1cbiAgI2dldExhc3RQb2ludChib3hlcywgaXNMVFIpIHtcbiAgICBsZXQgbGFzdFkgPSAwO1xuICAgIGxldCBsYXN0WCA9IDA7XG4gICAgZm9yIChjb25zdCBib3ggb2YgYm94ZXMpIHtcbiAgICAgIGNvbnN0IHkgPSBib3gueSArIGJveC5oZWlnaHQ7XG4gICAgICBpZiAoeSA8IGxhc3RZKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9IGJveC54ICsgKGlzTFRSID8gYm94LndpZHRoIDogMCk7XG4gICAgICBpZiAoeSA+IGxhc3RZKSB7XG4gICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xUUikge1xuICAgICAgICBpZiAoeCA+IGxhc3RYKSB7XG4gICAgICAgICAgbGFzdFggPSB4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHggPCBsYXN0WCkge1xuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbaXNMVFIgPyAxIC0gbGFzdFggOiBsYXN0WCwgbGFzdFldO1xuICB9XG4gIHNob3cocGFyZW50LCBib3hlcywgaXNMVFIpIHtcbiAgICBjb25zdCBbeCwgeV0gPSB0aGlzLiNnZXRMYXN0UG9pbnQoYm94ZXMsIGlzTFRSKTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLiN0b29sYmFyIHx8PSB0aGlzLiNyZW5kZXIoKTtcbiAgICBwYXJlbnQuYXBwZW5kKHRoaXMuI3Rvb2xiYXIpO1xuICAgIHN0eWxlLmluc2V0SW5saW5lRW5kID0gYCR7MTAwICogeH0lYDtcbiAgICBzdHlsZS50b3AgPSBgY2FsYygkezEwMCAqIHl9JSArIHZhcigtLWVkaXRvci10b29sYmFyLXZlcnQtb2Zmc2V0KSlgO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgdGhpcy4jdG9vbGJhci5yZW1vdmUoKTtcbiAgfVxuICAjbWFrZUJ1dHRvbihidXR0b25DbGFzcywgbDEwbklkLCBsYWJlbEwxMG5JZCwgY2xpY2tIYW5kbGVyKSB7XG4gICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZChcImJhc2ljXCIsIGJ1dHRvbkNsYXNzKTtcbiAgICBidXR0b24udGFiSW5kZXggPSAwO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgbDEwbklkKTtcbiAgICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgYnV0dG9uLmFwcGVuZChzcGFuKTtcbiAgICBzcGFuLmNsYXNzTmFtZSA9IFwidmlzdWFsbHlIaWRkZW5cIjtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBsYWJlbEwxMG5JZCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgaWYgKHNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsICYmICFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGNsaWNrSGFuZGxlciwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24pO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci90b29scy5qc1xuXG5cblxuZnVuY3Rpb24gYmluZEV2ZW50cyhvYmosIGVsZW1lbnQsIG5hbWVzKSB7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBvYmpbbmFtZV0uYmluZChvYmopKTtcbiAgfVxufVxuY2xhc3MgSWRNYW5hZ2VyIHtcbiAgI2lkID0gMDtcbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiBgJHtBbm5vdGF0aW9uRWRpdG9yUHJlZml4fSR7dGhpcy4jaWQrK31gO1xuICB9XG59XG5jbGFzcyBJbWFnZU1hbmFnZXIge1xuICAjYmFzZUlkID0gZ2V0VXVpZCgpO1xuICAjaWQgPSAwO1xuICAjY2FjaGUgPSBudWxsO1xuICBzdGF0aWMgZ2V0IF9pc1NWR0ZpdHRpbmdDYW52YXMoKSB7XG4gICAgY29uc3Qgc3ZnID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PVVURi04LDxzdmcgdmlld0JveD1cIjAgMCAxIDFcIiB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxyZWN0IHdpZHRoPVwiMVwiIGhlaWdodD1cIjFcIiBzdHlsZT1cImZpbGw6cmVkO1wiLz48L3N2Zz5gO1xuICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMyk7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGltYWdlLnNyYyA9IHN2ZztcbiAgICBjb25zdCBwcm9taXNlID0gaW1hZ2UuZGVjb2RlKCkudGhlbigoKSA9PiB7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCAxLCAxLCAwLCAwLCAxLCAzKTtcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhLmJ1ZmZlcilbMF0gPT09IDA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9pc1NWR0ZpdHRpbmdDYW52YXNcIiwgcHJvbWlzZSk7XG4gIH1cbiAgYXN5bmMgI2dldChrZXksIHJhd0RhdGEpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGxldCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YT8uYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZGF0YSB8fD0ge1xuICAgICAgICBiaXRtYXA6IG51bGwsXG4gICAgICAgIGlkOiBgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9XyR7dGhpcy4jaWQrK31gLFxuICAgICAgICByZWZDb3VudGVyOiAwLFxuICAgICAgICBpc1N2ZzogZmFsc2VcbiAgICAgIH07XG4gICAgICBsZXQgaW1hZ2U7XG4gICAgICBpZiAodHlwZW9mIHJhd0RhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGF0YS51cmwgPSByYXdEYXRhO1xuICAgICAgICBpbWFnZSA9IGF3YWl0IGZldGNoRGF0YShyYXdEYXRhLCBcImJsb2JcIik7XG4gICAgICB9IGVsc2UgaWYgKHJhd0RhdGEgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIGltYWdlID0gZGF0YS5maWxlID0gcmF3RGF0YTtcbiAgICAgIH0gZWxzZSBpZiAocmF3RGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgaW1hZ2UgPSByYXdEYXRhO1xuICAgICAgfVxuICAgICAgaWYgKGltYWdlLnR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgICAgIGNvbnN0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UgPSBJbWFnZU1hbmFnZXIuX2lzU1ZHRml0dGluZ0NhbnZhcztcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGNvbnN0IGltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBjb25zdCBpbWFnZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgaW1hZ2VFbGVtZW50Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGRhdGEuYml0bWFwID0gaW1hZ2VFbGVtZW50O1xuICAgICAgICAgICAgZGF0YS5pc1N2ZyA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGRhdGEuc3ZnVXJsID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuc3JjID0gKGF3YWl0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UpID8gYCR7dXJsfSNzdmdWaWV3KHByZXNlcnZlQXNwZWN0UmF0aW8obm9uZSkpYCA6IHVybDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGltYWdlRWxlbWVudC5vbmVycm9yID0gZmlsZVJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGltYWdlKTtcbiAgICAgICAgYXdhaXQgaW1hZ2VQcm9taXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5iaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZSk7XG4gICAgICB9XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgPSAxO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oZSk7XG4gICAgICBkYXRhID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgZGF0YSk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChkYXRhLmlkLCBkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUZpbGUoZmlsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RNb2RpZmllZCxcbiAgICAgIG5hbWUsXG4gICAgICBzaXplLFxuICAgICAgdHlwZVxuICAgIH0gPSBmaWxlO1xuICAgIHJldHVybiB0aGlzLiNnZXQoYCR7bGFzdE1vZGlmaWVkfV8ke25hbWV9XyR7c2l6ZX1fJHt0eXBlfWAsIGZpbGUpO1xuICB9XG4gIGFzeW5jIGdldEZyb21VcmwodXJsKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dldCh1cmwsIHVybCk7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUJsb2IoaWQsIGJsb2JQcm9taXNlKSB7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IGJsb2JQcm9taXNlO1xuICAgIHJldHVybiB0aGlzLiNnZXQoaWQsIGJsb2IpO1xuICB9XG4gIGFzeW5jIGdldEZyb21JZChpZCkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEuYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAoZGF0YS5maWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGcm9tRmlsZShkYXRhLmZpbGUpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5ibG9iUHJvbWlzZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBibG9iUHJvbWlzZVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBkZWxldGUgZGF0YS5ibG9iUHJvbWlzZTtcbiAgICAgIHJldHVybiB0aGlzLmdldEZyb21CbG9iKGRhdGEuaWQsIGJsb2JQcm9taXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RnJvbVVybChkYXRhLnVybCk7XG4gIH1cbiAgZ2V0RnJvbUNhbnZhcyhpZCwgY2FudmFzKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBsZXQgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKGRhdGE/LmJpdG1hcCkge1xuICAgICAgZGF0YS5yZWZDb3VudGVyICs9IDE7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY3R4LmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xuICAgIGRhdGEgPSB7XG4gICAgICBiaXRtYXA6IG9mZnNjcmVlbi50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKSxcbiAgICAgIGlkOiBgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9XyR7dGhpcy4jaWQrK31gLFxuICAgICAgcmVmQ291bnRlcjogMSxcbiAgICAgIGlzU3ZnOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy4jY2FjaGUuc2V0KGlkLCBkYXRhKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoZGF0YS5pZCwgZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZ2V0U3ZnVXJsKGlkKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhPy5pc1N2Zykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkYXRhLnN2Z1VybDtcbiAgfVxuICBkZWxldGVJZChpZCkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEucmVmQ291bnRlciAtPSAxO1xuICAgIGlmIChkYXRhLnJlZkNvdW50ZXIgIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYml0bWFwXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKCFkYXRhLnVybCAmJiAhZGF0YS5maWxlKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcImJpdG1hcHJlbmRlcmVyXCIpO1xuICAgICAgY3R4LnRyYW5zZmVyRnJvbUltYWdlQml0bWFwKGJpdG1hcCk7XG4gICAgICBkYXRhLmJsb2JQcm9taXNlID0gY2FudmFzLmNvbnZlcnRUb0Jsb2IoKTtcbiAgICB9XG4gICAgYml0bWFwLmNsb3NlPy4oKTtcbiAgICBkYXRhLmJpdG1hcCA9IG51bGw7XG4gIH1cbiAgaXNWYWxpZElkKGlkKSB7XG4gICAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoYGltYWdlXyR7dGhpcy4jYmFzZUlkfV9gKTtcbiAgfVxufVxuY2xhc3MgQ29tbWFuZE1hbmFnZXIge1xuICAjY29tbWFuZHMgPSBbXTtcbiAgI2xvY2tlZCA9IGZhbHNlO1xuICAjbWF4U2l6ZTtcbiAgI3Bvc2l0aW9uID0gLTE7XG4gIGNvbnN0cnVjdG9yKG1heFNpemUgPSAxMjgpIHtcbiAgICB0aGlzLiNtYXhTaXplID0gbWF4U2l6ZTtcbiAgfVxuICBhZGQoe1xuICAgIGNtZCxcbiAgICB1bmRvLFxuICAgIHBvc3QsXG4gICAgbXVzdEV4ZWMsXG4gICAgdHlwZSA9IE5hTixcbiAgICBvdmVyd3JpdGVJZlNhbWVUeXBlID0gZmFsc2UsXG4gICAga2VlcFVuZG8gPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKG11c3RFeGVjKSB7XG4gICAgICBjbWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2xvY2tlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzYXZlID0ge1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIHBvc3QsXG4gICAgICB0eXBlXG4gICAgfTtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICBpZiAodGhpcy4jY29tbWFuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy4jcG9zaXRpb24gPSAwO1xuICAgICAgdGhpcy4jY29tbWFuZHMucHVzaChzYXZlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG92ZXJ3cml0ZUlmU2FtZVR5cGUgJiYgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIGlmIChrZWVwVW5kbykge1xuICAgICAgICBzYXZlLnVuZG8gPSB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udW5kbztcbiAgICAgIH1cbiAgICAgIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXSA9IHNhdmU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSB0aGlzLiNwb3NpdGlvbiArIDE7XG4gICAgaWYgKG5leHQgPT09IHRoaXMuI21heFNpemUpIHtcbiAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZSgwLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcG9zaXRpb24gPSBuZXh0O1xuICAgICAgaWYgKG5leHQgPCB0aGlzLiNjb21tYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICB9XG4gIHVuZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHVuZG8sXG4gICAgICBwb3N0XG4gICAgfSA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXTtcbiAgICB1bmRvKCk7XG4gICAgcG9zdD8uKCk7XG4gICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy4jcG9zaXRpb24gLT0gMTtcbiAgfVxuICByZWRvKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uICs9IDE7XG4gICAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbWQsXG4gICAgICAgIHBvc3RcbiAgICAgIH0gPSB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl07XG4gICAgICBjbWQoKTtcbiAgICAgIHBvc3Q/LigpO1xuICAgICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGhhc1NvbWV0aGluZ1RvVW5kbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gIT09IC0xO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvUmVkbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gPCB0aGlzLiNjb21tYW5kcy5sZW5ndGggLSAxO1xuICB9XG4gIGNsZWFuVHlwZSh0eXBlKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gdGhpcy4jcG9zaXRpb247IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodGhpcy4jY29tbWFuZHNbaV0udHlwZSAhPT0gdHlwZSkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5zcGxpY2UoaSArIDEsIHRoaXMuI3Bvc2l0aW9uIC0gaSk7XG4gICAgICAgIHRoaXMuI3Bvc2l0aW9uID0gaTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjb21tYW5kcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuI3Bvc2l0aW9uID0gLTE7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNjb21tYW5kcyA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIEtleWJvYXJkTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrcykge1xuICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgdGhpcy5jYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbGxLZXlzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgZm9yIChjb25zdCBba2V5cywgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fV0gb2YgY2FsbGJhY2tzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGNvbnN0IGlzTWFjS2V5ID0ga2V5LnN0YXJ0c1dpdGgoXCJtYWMrXCIpO1xuICAgICAgICBpZiAoaXNNYWMgJiYgaXNNYWNLZXkpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zZXQoa2V5LnNsaWNlKDQpLCB7XG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFsbEtleXMuYWRkKGtleS5zcGxpdChcIitcIikuYXQoLTEpKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNNYWMgJiYgIWlzTWFjS2V5KSB7XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Muc2V0KGtleSwge1xuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hbGxLZXlzLmFkZChrZXkuc3BsaXQoXCIrXCIpLmF0KC0xKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI3NlcmlhbGl6ZShldmVudCkge1xuICAgIGlmIChldmVudC5hbHRLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJhbHRcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5jdHJsS2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiY3RybFwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJtZXRhXCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJzaGlmdFwiKTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXIucHVzaChldmVudC5rZXkpO1xuICAgIGNvbnN0IHN0ciA9IHRoaXMuYnVmZmVyLmpvaW4oXCIrXCIpO1xuICAgIHRoaXMuYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBleGVjKHNlbGYsIGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmFsbEtleXMuaGFzKGV2ZW50LmtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5mbyA9IHRoaXMuY2FsbGJhY2tzLmdldCh0aGlzLiNzZXJpYWxpemUoZXZlbnQpKTtcbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGJ1YmJsZXMgPSBmYWxzZSxcbiAgICAgICAgYXJncyA9IFtdLFxuICAgICAgICBjaGVja2VyID0gbnVsbFxuICAgICAgfVxuICAgIH0gPSBpbmZvO1xuICAgIGlmIChjaGVja2VyICYmICFjaGVja2VyKHNlbGYsIGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjay5iaW5kKHNlbGYsIC4uLmFyZ3MsIGV2ZW50KSgpO1xuICAgIGlmICghYnViYmxlcykge1xuICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIENvbG9yTWFuYWdlciB7XG4gIHN0YXRpYyBfY29sb3JzTWFwcGluZyA9IG5ldyBNYXAoW1tcIkNhbnZhc1RleHRcIiwgWzAsIDAsIDBdXSwgW1wiQ2FudmFzXCIsIFsyNTUsIDI1NSwgMjU1XV1dKTtcbiAgZ2V0IF9jb2xvcnMoKSB7XG4gICAgY29uc3QgY29sb3JzID0gbmV3IE1hcChbW1wiQ2FudmFzVGV4dFwiLCBudWxsXSwgW1wiQ2FudmFzXCIsIG51bGxdXSk7XG4gICAgZ2V0Q29sb3JWYWx1ZXMoY29sb3JzKTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2NvbG9yc1wiLCBjb2xvcnMpO1xuICB9XG4gIGNvbnZlcnQoY29sb3IpIHtcbiAgICBjb25zdCByZ2IgPSBnZXRSR0IoY29sb3IpO1xuICAgIGlmICghd2luZG93Lm1hdGNoTWVkaWEoXCIoZm9yY2VkLWNvbG9yczogYWN0aXZlKVwiKS5tYXRjaGVzKSB7XG4gICAgICByZXR1cm4gcmdiO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBSR0JdIG9mIHRoaXMuX2NvbG9ycykge1xuICAgICAgaWYgKFJHQi5ldmVyeSgoeCwgaSkgPT4geCA9PT0gcmdiW2ldKSkge1xuICAgICAgICByZXR1cm4gQ29sb3JNYW5hZ2VyLl9jb2xvcnNNYXBwaW5nLmdldChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJnYjtcbiAgfVxuICBnZXRIZXhDb2RlKG5hbWUpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9jb2xvcnMuZ2V0KG5hbWUpO1xuICAgIGlmICghcmdiKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWwubWFrZUhleENvbG9yKC4uLnJnYik7XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIge1xuICAjYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAjYWN0aXZlRWRpdG9yID0gbnVsbDtcbiAgI2FsbEVkaXRhYmxlQW5ub3RhdGlvbnMgPSBudWxsO1xuICAjYWxsRWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgI2FsbExheWVycyA9IG5ldyBNYXAoKTtcbiAgI2FsdFRleHRNYW5hZ2VyID0gbnVsbDtcbiAgI2Fubm90YXRpb25TdG9yYWdlID0gbnVsbDtcbiAgI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zID0gbnVsbDtcbiAgI2NvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKCk7XG4gICNjb21tZW50TWFuYWdlciA9IG51bGw7XG4gICNjb3B5UGFzdGVBQyA9IG51bGw7XG4gICNjdXJyZW50RHJhd2luZ1Nlc3Npb24gPSBudWxsO1xuICAjY3VycmVudFBhZ2VJbmRleCA9IDA7XG4gICNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzID0gbmV3IFNldCgpO1xuICAjZHJhZ2dpbmdFZGl0b3JzID0gbnVsbDtcbiAgI2VkaXRvclR5cGVzID0gbnVsbDtcbiAgI2VkaXRvcnNUb1Jlc2NhbGUgPSBuZXcgU2V0KCk7XG4gIF9lZGl0b3JVbmRvQmFyID0gbnVsbDtcbiAgI2VuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uID0gZmFsc2U7XG4gICNlbmFibGVVcGRhdGVkQWRkSW1hZ2UgPSBmYWxzZTtcbiAgI2VuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgPSBmYWxzZTtcbiAgI2ZpbHRlckZhY3RvcnkgPSBudWxsO1xuICAjZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gbnVsbDtcbiAgI2ZvY3VzTWFuYWdlckFDID0gbnVsbDtcbiAgI2hpZ2hsaWdodENvbG9ycyA9IG51bGw7XG4gICNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IGZhbHNlO1xuICAjZmxvYXRpbmdUb29sYmFyID0gbnVsbDtcbiAgI2lkTWFuYWdlciA9IG5ldyBJZE1hbmFnZXIoKTtcbiAgI2lzRW5hYmxlZCA9IGZhbHNlO1xuICAjaXNQb2ludGVyRG93biA9IGZhbHNlO1xuICAjaXNXYWl0aW5nID0gZmFsc2U7XG4gICNrZXlib2FyZE1hbmFnZXJBQyA9IG51bGw7XG4gICNsYXN0QWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICNtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIgPSBudWxsO1xuICAjbWlzc2luZ0NhbnZhc2VzID0gbnVsbDtcbiAgI21sTWFuYWdlciA9IG51bGw7XG4gICNtb2RlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgI3NlbGVjdGVkRWRpdG9ycyA9IG5ldyBTZXQoKTtcbiAgI3NlbGVjdGVkVGV4dE5vZGUgPSBudWxsO1xuICAjc2lnbmF0dXJlTWFuYWdlciA9IG51bGw7XG4gICNwYWdlQ29sb3JzID0gbnVsbDtcbiAgI3Nob3dBbGxTdGF0ZXMgPSBudWxsO1xuICAjcGRmRG9jdW1lbnQgPSBudWxsO1xuICAjcHJldmlvdXNTdGF0ZXMgPSB7XG4gICAgaXNFZGl0aW5nOiBmYWxzZSxcbiAgICBpc0VtcHR5OiB0cnVlLFxuICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogZmFsc2UsXG4gICAgaGFzU29tZXRoaW5nVG9SZWRvOiBmYWxzZSxcbiAgICBoYXNTZWxlY3RlZEVkaXRvcjogZmFsc2UsXG4gICAgaGFzU2VsZWN0ZWRUZXh0OiBmYWxzZVxuICB9O1xuICAjdHJhbnNsYXRpb24gPSBbMCwgMF07XG4gICN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjdmlld2VyID0gbnVsbDtcbiAgI3ZpZXdlckFsZXJ0ID0gbnVsbDtcbiAgI3VwZGF0ZU1vZGVDYXBhYmlsaXR5ID0gbnVsbDtcbiAgc3RhdGljIFRSQU5TTEFURV9TTUFMTCA9IDE7XG4gIHN0YXRpYyBUUkFOU0xBVEVfQklHID0gMTA7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCBwcm90byA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIucHJvdG90eXBlO1xuICAgIGNvbnN0IGFycm93Q2hlY2tlciA9IHNlbGYgPT4gc2VsZi4jY29udGFpbmVyLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudGFnTmFtZSAhPT0gXCJCVVRUT05cIiAmJiBzZWxmLmhhc1NvbWV0aGluZ1RvQ29udHJvbCgpO1xuICAgIGNvbnN0IHRleHRJbnB1dENoZWNrZXIgPSAoX3NlbGYsIHtcbiAgICAgIHRhcmdldDogZWxcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH0gPSBlbDtcbiAgICAgICAgcmV0dXJuIHR5cGUgIT09IFwidGV4dFwiICYmIHR5cGUgIT09IFwibnVtYmVyXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IHNtYWxsID0gdGhpcy5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gdGhpcy5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJjdHJsK2FcIiwgXCJtYWMrbWV0YSthXCJdLCBwcm90by5zZWxlY3RBbGwsIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrelwiLCBcIm1hYyttZXRhK3pcIl0sIHByb3RvLnVuZG8sIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwreVwiLCBcImN0cmwrc2hpZnQrelwiLCBcIm1hYyttZXRhK3NoaWZ0K3pcIiwgXCJjdHJsK3NoaWZ0K1pcIiwgXCJtYWMrbWV0YStzaGlmdCtaXCJdLCBwcm90by5yZWRvLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJCYWNrc3BhY2VcIiwgXCJhbHQrQmFja3NwYWNlXCIsIFwiY3RybCtCYWNrc3BhY2VcIiwgXCJzaGlmdCtCYWNrc3BhY2VcIiwgXCJtYWMrQmFja3NwYWNlXCIsIFwibWFjK2FsdCtCYWNrc3BhY2VcIiwgXCJtYWMrY3RybCtCYWNrc3BhY2VcIiwgXCJEZWxldGVcIiwgXCJjdHJsK0RlbGV0ZVwiLCBcInNoaWZ0K0RlbGV0ZVwiLCBcIm1hYytEZWxldGVcIl0sIHByb3RvLmRlbGV0ZSwge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiRW50ZXJcIiwgXCJtYWMrRW50ZXJcIl0sIHByb3RvLmFkZE5ld0VkaXRvckZyb21LZXlib2FyZCwge1xuICAgICAgY2hlY2tlcjogKHNlbGYsIHtcbiAgICAgICAgdGFyZ2V0OiBlbFxuICAgICAgfSkgPT4gIShlbCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KSAmJiBzZWxmLiNjb250YWluZXIuY29udGFpbnMoZWwpICYmICFzZWxmLmlzRW50ZXJIYW5kbGVkXG4gICAgfV0sIFtbXCIgXCIsIFwibWFjKyBcIl0sIHByb3RvLmFkZE5ld0VkaXRvckZyb21LZXlib2FyZCwge1xuICAgICAgY2hlY2tlcjogKHNlbGYsIHtcbiAgICAgICAgdGFyZ2V0OiBlbFxuICAgICAgfSkgPT4gIShlbCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KSAmJiBzZWxmLiNjb250YWluZXIuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICB9XSwgW1tcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIHByb3RvLnVuc2VsZWN0QWxsXSwgW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIHNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3IoY29udGFpbmVyLCB2aWV3ZXIsIHZpZXdlckFsZXJ0LCBhbHRUZXh0TWFuYWdlciwgY29tbWVudE1hbmFnZXIsIHNpZ25hdHVyZU1hbmFnZXIsIGV2ZW50QnVzLCBwZGZEb2N1bWVudCwgcGFnZUNvbG9ycywgaGlnaGxpZ2h0Q29sb3JzLCBlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbiwgZW5hYmxlVXBkYXRlZEFkZEltYWdlLCBlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlLCBtbE1hbmFnZXIsIGVkaXRvclVuZG9CYXIsIHN1cHBvcnRzUGluY2hUb1pvb20pIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl9zaWduYWwgPSB0aGlzLiNhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgIHRoaXMuI2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiN2aWV3ZXIgPSB2aWV3ZXI7XG4gICAgdGhpcy4jdmlld2VyQWxlcnQgPSB2aWV3ZXJBbGVydDtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlciA9IGFsdFRleHRNYW5hZ2VyO1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyID0gY29tbWVudE1hbmFnZXI7XG4gICAgdGhpcy4jc2lnbmF0dXJlTWFuYWdlciA9IHNpZ25hdHVyZU1hbmFnZXI7XG4gICAgdGhpcy4jcGRmRG9jdW1lbnQgPSBwZGZEb2N1bWVudDtcbiAgICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICAgIGV2ZW50QnVzLl9vbihcImVkaXRpbmdhY3Rpb25cIiwgdGhpcy5vbkVkaXRpbmdBY3Rpb24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwicGFnZWNoYW5naW5nXCIsIHRoaXMub25QYWdlQ2hhbmdpbmcuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwic2NhbGVjaGFuZ2luZ1wiLCB0aGlzLm9uU2NhbGVDaGFuZ2luZy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJyb3RhdGlvbmNoYW5naW5nXCIsIHRoaXMub25Sb3RhdGlvbkNoYW5naW5nLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInNldHByZWZlcmVuY2VcIiwgdGhpcy5vblNldFByZWZlcmVuY2UuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcnBhcmFtc1wiLCBldnQgPT4gdGhpcy51cGRhdGVQYXJhbXMoZXZ0LnR5cGUsIGV2dC52YWx1ZSksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jaXNQb2ludGVyRG93biA9IHRydWU7XG4gICAgfSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsICgpID0+IHtcbiAgICAgIHRoaXMuI2lzUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICB9LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy4jYWRkU2VsZWN0aW9uTGlzdGVuZXIoKTtcbiAgICB0aGlzLiNhZGREcmFnQW5kRHJvcExpc3RlbmVycygpO1xuICAgIHRoaXMuI2FkZEtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlID0gcGRmRG9jdW1lbnQuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgdGhpcy4jZmlsdGVyRmFjdG9yeSA9IHBkZkRvY3VtZW50LmZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy4jcGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy4jaGlnaGxpZ2h0Q29sb3JzID0gaGlnaGxpZ2h0Q29sb3JzIHx8IG51bGw7XG4gICAgdGhpcy4jZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24gPSBlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbjtcbiAgICB0aGlzLiNlbmFibGVVcGRhdGVkQWRkSW1hZ2UgPSBlbmFibGVVcGRhdGVkQWRkSW1hZ2U7XG4gICAgdGhpcy4jZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSA9IGVuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2U7XG4gICAgdGhpcy4jbWxNYW5hZ2VyID0gbWxNYW5hZ2VyIHx8IG51bGw7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycyA9IHtcbiAgICAgIHJlYWxTY2FsZTogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTLFxuICAgICAgcm90YXRpb246IDBcbiAgICB9O1xuICAgIHRoaXMuaXNTaGlmdEtleURvd24gPSBmYWxzZTtcbiAgICB0aGlzLl9lZGl0b3JVbmRvQmFyID0gZWRpdG9yVW5kb0JhciB8fCBudWxsO1xuICAgIHRoaXMuX3N1cHBvcnRzUGluY2hUb1pvb20gPSBzdXBwb3J0c1BpbmNoVG9ab29tICE9PSBmYWxzZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5Py5yZXNvbHZlKCk7XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkgPSBudWxsO1xuICAgIHRoaXMuI2Fib3J0Q29udHJvbGxlcj8uYWJvcnQoKTtcbiAgICB0aGlzLiNhYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgIHRoaXMuX3NpZ25hbCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGxheWVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy4jYWxsTGF5ZXJzLmNsZWFyKCk7XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuY2xlYXIoKTtcbiAgICB0aGlzLiNtaXNzaW5nQ2FudmFzZXM/LmNsZWFyKCk7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yID0gbnVsbDtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiNjb21tZW50TWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI3NpZ25hdHVyZU1hbmFnZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiNmbG9hdGluZ1Rvb2xiYXI/LmhpZGUoKTtcbiAgICB0aGlzLiNmbG9hdGluZ1Rvb2xiYXIgPSBudWxsO1xuICAgIHRoaXMuI21haW5IaWdobGlnaHRDb2xvclBpY2tlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI21haW5IaWdobGlnaHRDb2xvclBpY2tlciA9IG51bGw7XG4gICAgdGhpcy4jYWxsRWRpdGFibGVBbm5vdGF0aW9ucyA9IG51bGw7XG4gICAgaWYgKHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCk7XG4gICAgICB0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCk7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiNwZGZEb2N1bWVudCA9IG51bGw7XG4gIH1cbiAgY29tYmluZWRTaWduYWwoYWMpIHtcbiAgICByZXR1cm4gQWJvcnRTaWduYWwuYW55KFt0aGlzLl9zaWduYWwsIGFjLnNpZ25hbF0pO1xuICB9XG4gIGdldCBtbE1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21sTWFuYWdlcjtcbiAgfVxuICBnZXQgdXNlTmV3QWx0VGV4dEZsb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VuYWJsZVVwZGF0ZWRBZGRJbWFnZTtcbiAgfVxuICBnZXQgdXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZTtcbiAgfVxuICBnZXQgaGNtRmlsdGVyKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJoY21GaWx0ZXJcIiwgdGhpcy4jcGFnZUNvbG9ycyA/IHRoaXMuI2ZpbHRlckZhY3RvcnkuYWRkSENNRmlsdGVyKHRoaXMuI3BhZ2VDb2xvcnMuZm9yZWdyb3VuZCwgdGhpcy4jcGFnZUNvbG9ycy5iYWNrZ3JvdW5kKSA6IFwibm9uZVwiKTtcbiAgfVxuICBnZXQgZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJkaXJlY3Rpb25cIiwgZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiNjb250YWluZXIpLmRpcmVjdGlvbik7XG4gIH1cbiAgZ2V0IF9oaWdobGlnaHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9oaWdobGlnaHRDb2xvcnNcIiwgdGhpcy4jaGlnaGxpZ2h0Q29sb3JzID8gbmV3IE1hcCh0aGlzLiNoaWdobGlnaHRDb2xvcnMuc3BsaXQoXCIsXCIpLm1hcChwYWlyID0+IHtcbiAgICAgIHBhaXIgPSBwYWlyLnNwbGl0KFwiPVwiKS5tYXAoeCA9PiB4LnRyaW0oKSk7XG4gICAgICBwYWlyWzFdID0gcGFpclsxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHBhaXI7XG4gICAgfSkpIDogbnVsbCk7XG4gIH1cbiAgZ2V0IGhpZ2hsaWdodENvbG9ycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBfaGlnaGxpZ2h0Q29sb3JzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFfaGlnaGxpZ2h0Q29sb3JzKSB7XG4gICAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaGlnaGxpZ2h0Q29sb3JzXCIsIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgaGFzSENNID0gISF0aGlzLiNwYWdlQ29sb3JzO1xuICAgIGZvciAoY29uc3QgW25hbWUsIGNvbG9yXSBvZiBfaGlnaGxpZ2h0Q29sb3JzKSB7XG4gICAgICBjb25zdCBpc05hbWVGb3JIQ00gPSBuYW1lLmVuZHNXaXRoKFwiX0hDTVwiKTtcbiAgICAgIGlmIChoYXNIQ00gJiYgaXNOYW1lRm9ySENNKSB7XG4gICAgICAgIG1hcC5zZXQobmFtZS5yZXBsYWNlKFwiX0hDTVwiLCBcIlwiKSwgY29sb3IpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzSENNICYmICFpc05hbWVGb3JIQ00pIHtcbiAgICAgICAgbWFwLnNldChuYW1lLCBjb2xvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJoaWdobGlnaHRDb2xvcnNcIiwgbWFwKTtcbiAgfVxuICBnZXQgaGlnaGxpZ2h0Q29sb3JOYW1lcygpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaGlnaGxpZ2h0Q29sb3JOYW1lc1wiLCB0aGlzLmhpZ2hsaWdodENvbG9ycyA/IG5ldyBNYXAoQXJyYXkuZnJvbSh0aGlzLmhpZ2hsaWdodENvbG9ycywgZSA9PiBlLnJldmVyc2UoKSkpIDogbnVsbCk7XG4gIH1cbiAgZ2V0Tm9uSENNQ29sb3IoY29sb3IpIHtcbiAgICBpZiAoIXRoaXMuX2hpZ2hsaWdodENvbG9ycykge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBjb25zdCBjb2xvck5hbWUgPSB0aGlzLmhpZ2hsaWdodENvbG9yTmFtZXMuZ2V0KGNvbG9yKTtcbiAgICByZXR1cm4gdGhpcy5faGlnaGxpZ2h0Q29sb3JzLmdldChjb2xvck5hbWUpIHx8IGNvbG9yO1xuICB9XG4gIGdldE5vbkhDTUNvbG9yTmFtZShjb2xvcikge1xuICAgIHJldHVybiB0aGlzLmhpZ2hsaWdodENvbG9yTmFtZXMuZ2V0KGNvbG9yKSB8fCBjb2xvcjtcbiAgfVxuICBzZXRDdXJyZW50RHJhd2luZ1Nlc3Npb24obGF5ZXIpIHtcbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24gPSBsYXllcjtcbiAgfVxuICBzZXRNYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIoY29sb3JQaWNrZXIpIHtcbiAgICB0aGlzLiNtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIgPSBjb2xvclBpY2tlcjtcbiAgfVxuICBlZGl0QWx0VGV4dChlZGl0b3IsIGZpcnN0VGltZSA9IGZhbHNlKSB7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXI/LmVkaXRBbHRUZXh0KHRoaXMsIGVkaXRvciwgZmlyc3RUaW1lKTtcbiAgfVxuICBoYXNDb21tZW50TWFuYWdlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLiNjb21tZW50TWFuYWdlcjtcbiAgfVxuICBlZGl0Q29tbWVudChlZGl0b3IsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy4jY29tbWVudE1hbmFnZXI/Lm9wZW4odGhpcywgZWRpdG9yLCBwb3NpdGlvbik7XG4gIH1cbiAgZ2V0U2lnbmF0dXJlKGVkaXRvcikge1xuICAgIHRoaXMuI3NpZ25hdHVyZU1hbmFnZXI/LmdldFNpZ25hdHVyZSh7XG4gICAgICB1aU1hbmFnZXI6IHRoaXMsXG4gICAgICBlZGl0b3JcbiAgICB9KTtcbiAgfVxuICBnZXQgc2lnbmF0dXJlTWFuYWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2lnbmF0dXJlTWFuYWdlcjtcbiAgfVxuICBzd2l0Y2hUb01vZGUobW9kZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9ldmVudEJ1cy5vbihcImFubm90YXRpb25lZGl0b3Jtb2RlY2hhbmdlZFwiLCBjYWxsYmFjaywge1xuICAgICAgb25jZTogdHJ1ZSxcbiAgICAgIHNpZ25hbDogdGhpcy5fc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzaG93YW5ub3RhdGlvbmVkaXRvcnVpXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIG1vZGVcbiAgICB9KTtcbiAgfVxuICBzZXRQcmVmZXJlbmNlKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzZXRwcmVmZXJlbmNlXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIG5hbWUsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9XG4gIG9uU2V0UHJlZmVyZW5jZSh7XG4gICAgbmFtZSxcbiAgICB2YWx1ZVxuICB9KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwiZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZVwiOlxuICAgICAgICB0aGlzLiNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBvblBhZ2VDaGFuZ2luZyh7XG4gICAgcGFnZU51bWJlclxuICB9KSB7XG4gICAgdGhpcy4jY3VycmVudFBhZ2VJbmRleCA9IHBhZ2VOdW1iZXIgLSAxO1xuICB9XG4gIGZvY3VzTWFpbkNvbnRhaW5lcigpIHtcbiAgICB0aGlzLiNjb250YWluZXIuZm9jdXMoKTtcbiAgfVxuICBmaW5kUGFyZW50KHgsIHkpIHtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4OiBsYXllclgsXG4gICAgICAgIHk6IGxheWVyWSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IGxheWVyLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICh4ID49IGxheWVyWCAmJiB4IDw9IGxheWVyWCArIHdpZHRoICYmIHkgPj0gbGF5ZXJZICYmIHkgPD0gbGF5ZXJZICsgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGlzYWJsZVVzZXJTZWxlY3QodmFsdWUgPSBmYWxzZSkge1xuICAgIHRoaXMuI3ZpZXdlci5jbGFzc0xpc3QudG9nZ2xlKFwibm9Vc2VyU2VsZWN0XCIsIHZhbHVlKTtcbiAgfVxuICBhZGRTaG91bGRSZXNjYWxlKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuYWRkKGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlU2hvdWxkUmVzY2FsZShlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmRlbGV0ZShlZGl0b3IpO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZyh7XG4gICAgc2NhbGVcbiAgfSkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZSA9IHNjYWxlICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUpIHtcbiAgICAgIGVkaXRvci5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgICB9XG4gICAgdGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uPy5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgfVxuICBvblJvdGF0aW9uQ2hhbmdpbmcoe1xuICAgIHBhZ2VzUm90YXRpb25cbiAgfSkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uID0gcGFnZXNSb3RhdGlvbjtcbiAgfVxuICAjZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbih7XG4gICAgYW5jaG9yTm9kZVxuICB9KSB7XG4gICAgcmV0dXJuIGFuY2hvck5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gYW5jaG9yTm9kZS5wYXJlbnRFbGVtZW50IDogYW5jaG9yTm9kZTtcbiAgfVxuICAjZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudExheWVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGN1cnJlbnRMYXllci5oYXNUZXh0TGF5ZXIodGV4dExheWVyKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRMYXllcjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChsYXllci5oYXNUZXh0TGF5ZXIodGV4dExheWVyKSkge1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhpZ2hsaWdodFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uID0gXCJcIiwgY29tbWVudCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldFxuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgdGV4dCA9IHNlbGVjdGlvbi50b1N0cmluZygpO1xuICAgIGNvbnN0IGFuY2hvckVsZW1lbnQgPSB0aGlzLiNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgdGV4dExheWVyID0gYW5jaG9yRWxlbWVudC5jbG9zZXN0KFwiLnRleHRMYXllclwiKTtcbiAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0U2VsZWN0aW9uQm94ZXModGV4dExheWVyKTtcbiAgICBpZiAoIWJveGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGVjdGlvbi5lbXB0eSgpO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKTtcbiAgICBjb25zdCBpc05vbmVNb2RlID0gdGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGVkaXRvciA9IGxheWVyPy5jcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LCBmYWxzZSwge1xuICAgICAgICBtZXRob2RPZkNyZWF0aW9uLFxuICAgICAgICBib3hlcyxcbiAgICAgICAgYW5jaG9yTm9kZSxcbiAgICAgICAgYW5jaG9yT2Zmc2V0LFxuICAgICAgICBmb2N1c05vZGUsXG4gICAgICAgIGZvY3VzT2Zmc2V0LFxuICAgICAgICB0ZXh0XG4gICAgICB9KTtcbiAgICAgIGlmIChpc05vbmVNb2RlKSB7XG4gICAgICAgIHRoaXMuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBlZGl0b3I/LmVkaXRDb21tZW50KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNOb25lTW9kZSkge1xuICAgICAgdGhpcy5zd2l0Y2hUb01vZGUoQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULCBjYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH1cbiAgY29tbWVudFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uID0gXCJcIikge1xuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uKG1ldGhvZE9mQ3JlYXRpb24sIHRydWUpO1xuICB9XG4gICNkaXNwbGF5RmxvYXRpbmdUb29sYmFyKCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JFbGVtZW50ID0gdGhpcy4jZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRMYXllciA9IGFuY2hvckVsZW1lbnQuY2xvc2VzdChcIi50ZXh0TGF5ZXJcIik7XG4gICAgY29uc3QgYm94ZXMgPSB0aGlzLmdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcik7XG4gICAgaWYgKCFib3hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNmbG9hdGluZ1Rvb2xiYXIgfHw9IG5ldyBGbG9hdGluZ1Rvb2xiYXIodGhpcyk7XG4gICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyLnNob3codGV4dExheWVyLCBib3hlcywgdGhpcy5kaXJlY3Rpb24gPT09IFwibHRyXCIpO1xuICB9XG4gIGFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNFbXB0eSgpICYmIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlICYmICF0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBhMTF5QWxlcnQobWVzc2FnZUlkLCBhcmdzID0gbnVsbCkge1xuICAgIGNvbnN0IHZpZXdlckFsZXJ0ID0gdGhpcy4jdmlld2VyQWxlcnQ7XG4gICAgaWYgKCF2aWV3ZXJBbGVydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2aWV3ZXJBbGVydC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgbWVzc2FnZUlkKTtcbiAgICBpZiAoYXJncykge1xuICAgICAgdmlld2VyQWxlcnQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3ZXJBbGVydC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiKTtcbiAgICB9XG4gIH1cbiAgI3NlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICAgIGlmICh0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhcj8uaGlkZSgpO1xuICAgICAgICB0aGlzLiNzZWxlY3RlZFRleHROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICAgIGhhc1NlbGVjdGVkVGV4dDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvck5vZGVcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGlmIChhbmNob3JOb2RlID09PSB0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvckVsZW1lbnQgPSB0aGlzLiNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgdGV4dExheWVyID0gYW5jaG9yRWxlbWVudC5jbG9zZXN0KFwiLnRleHRMYXllclwiKTtcbiAgICBpZiAoIXRleHRMYXllcikge1xuICAgICAgaWYgKHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUpIHtcbiAgICAgICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyPy5oaWRlKCk7XG4gICAgICAgIHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgICAgaGFzU2VsZWN0ZWRUZXh0OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyPy5oaWRlKCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSA9IGFuY2hvck5vZGU7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRUZXh0OiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCAmJiB0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQpIHtcbiAgICAgIHRoaXMuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gdGhpcy5pc1NoaWZ0S2V5RG93bjtcbiAgICBpZiAoIXRoaXMuaXNTaGlmdEtleURvd24pIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUxheWVyID0gdGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUID8gdGhpcy4jZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKSA6IG51bGw7XG4gICAgICBhY3RpdmVMYXllcj8udG9nZ2xlRHJhd2luZygpO1xuICAgICAgaWYgKHRoaXMuI2lzUG9pbnRlckRvd24pIHtcbiAgICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwoYWMpO1xuICAgICAgICBjb25zdCBwb2ludGVydXAgPSBlID0+IHtcbiAgICAgICAgICBpZiAoZS50eXBlID09PSBcInBvaW50ZXJ1cFwiICYmIGUuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgICAgYWN0aXZlTGF5ZXI/LnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJwb2ludGVydXBcIikge1xuICAgICAgICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVydXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVydXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVMYXllcj8udG9nZ2xlRHJhd2luZyh0cnVlKTtcbiAgICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNvblNlbGVjdEVuZChtZXRob2RPZkNyZWF0aW9uID0gXCJcIikge1xuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQpIHtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uKG1ldGhvZE9mQ3JlYXRpb24pO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24pIHtcbiAgICAgIHRoaXMuI2Rpc3BsYXlGbG9hdGluZ1Rvb2xiYXIoKTtcbiAgICB9XG4gIH1cbiAgI2FkZFNlbGVjdGlvbkxpc3RlbmVyKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy4jc2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbDogdGhpcy5fc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI2FkZEZvY3VzTWFuYWdlcigpIHtcbiAgICBpZiAodGhpcy4jZm9jdXNNYW5hZ2VyQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZm9jdXNNYW5hZ2VyQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5jb21iaW5lZFNpZ25hbCh0aGlzLiNmb2N1c01hbmFnZXJBQyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLmZvY3VzLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLmJsdXIuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI3JlbW92ZUZvY3VzTWFuYWdlcigpIHtcbiAgICB0aGlzLiNmb2N1c01hbmFnZXJBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNmb2N1c01hbmFnZXJBQyA9IG51bGw7XG4gIH1cbiAgYmx1cigpIHtcbiAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwKSB7XG4gICAgICB0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IGZhbHNlO1xuICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlRWxlbWVudFxuICAgIH0gPSBkb2N1bWVudDtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50ID0gW2VkaXRvciwgYWN0aXZlRWxlbWVudF07XG4gICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb2N1cygpIHtcbiAgICBpZiAoIXRoaXMuI2xhc3RBY3RpdmVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtsYXN0RWRpdG9yLCBsYXN0QWN0aXZlRWxlbWVudF0gPSB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudDtcbiAgICB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgbGFzdEFjdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKCkgPT4ge1xuICAgICAgbGFzdEVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICB9LCB7XG4gICAgICBvbmNlOiB0cnVlLFxuICAgICAgc2lnbmFsOiB0aGlzLl9zaWduYWxcbiAgICB9KTtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG4gICNhZGRLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgaWYgKHRoaXMuI2tleWJvYXJkTWFuYWdlckFDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2tleWJvYXJkTWFuYWdlckFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwodGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmtleWRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLmtleXVwLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgdGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUM/LmFib3J0KCk7XG4gICAgdGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMgPSBudWxsO1xuICB9XG4gICNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuI2NvcHlQYXN0ZUFDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvcHlQYXN0ZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwodGhpcy4jY29weVBhc3RlQUMpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsIHRoaXMuY29weS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY3V0XCIsIHRoaXMuY3V0LmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCB0aGlzLnBhc3RlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jY29weVBhc3RlQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jY29weVBhc3RlQUMgPSBudWxsO1xuICB9XG4gICNhZGREcmFnQW5kRHJvcExpc3RlbmVycygpIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl9zaWduYWw7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIHRoaXMuZHJhZ092ZXIuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgdGhpcy5kcm9wLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGFkZEVkaXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jYWRkS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jYWRkQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVtb3ZlRWRpdExpc3RlbmVycygpIHtcbiAgICB0aGlzLiNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgfVxuICBkcmFnT3ZlcihldmVudCkge1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gb2YgZXZlbnQuZGF0YVRyYW5zZmVyLml0ZW1zKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgaWYgKGVkaXRvclR5cGUuaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKHR5cGUpKSB7XG4gICAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcImNvcHlcIjtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcm9wKGV2ZW50KSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGV2ZW50LmRhdGFUcmFuc2Zlci5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgZWRpdG9yVHlwZS5wYXN0ZShpdGVtLCB0aGlzLmN1cnJlbnRMYXllcik7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29weShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yPy5jb21taXRPclJlbW92ZSgpO1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IGVkaXRvci5zZXJpYWxpemUodHJ1ZSk7XG4gICAgICBpZiAoc2VyaWFsaXplZCkge1xuICAgICAgICBlZGl0b3JzLnB1c2goc2VyaWFsaXplZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlZGl0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJhcHBsaWNhdGlvbi9wZGZqc1wiLCBKU09OLnN0cmluZ2lmeShlZGl0b3JzKSk7XG4gIH1cbiAgY3V0KGV2ZW50KSB7XG4gICAgdGhpcy5jb3B5KGV2ZW50KTtcbiAgICB0aGlzLmRlbGV0ZSgpO1xuICB9XG4gIGFzeW5jIHBhc3RlKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB7XG4gICAgICBjbGlwYm9hcmREYXRhXG4gICAgfSA9IGV2ZW50O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjbGlwYm9hcmREYXRhLml0ZW1zKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgaWYgKGVkaXRvclR5cGUuaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKGl0ZW0udHlwZSkpIHtcbiAgICAgICAgICBlZGl0b3JUeXBlLnBhc3RlKGl0ZW0sIHRoaXMuY3VycmVudExheWVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRhdGEgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi9wZGZqc1wiKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB3YXJuKGBwYXN0ZTogXCIke2V4Lm1lc3NhZ2V9XCIuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmN1cnJlbnRMYXllcjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV3RWRpdG9ycyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZGF0YSkge1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWRFZGl0b3IgPSBhd2FpdCBsYXllci5kZXNlcmlhbGl6ZShlZGl0b3IpO1xuICAgICAgICBpZiAoIWRlc2VyaWFsaXplZEVkaXRvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXdFZGl0b3JzLnB1c2goZGVzZXJpYWxpemVkRWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgbmV3RWRpdG9ycykge1xuICAgICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKG5ld0VkaXRvcnMpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIG5ld0VkaXRvcnMpIHtcbiAgICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgY21kLFxuICAgICAgICB1bmRvLFxuICAgICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHdhcm4oYHBhc3RlOiBcIiR7ZXgubWVzc2FnZX1cIi5gKTtcbiAgICB9XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5pc1NoaWZ0S2V5RG93biAmJiBldmVudC5rZXkgPT09IFwiU2hpZnRcIikge1xuICAgICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FICYmICF0aGlzLmlzRWRpdG9ySGFuZGxpbmdLZXlib2FyZCkge1xuICAgICAgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfVxuICBrZXl1cChldmVudCkge1xuICAgIGlmICh0aGlzLmlzU2hpZnRLZXlEb3duICYmIGV2ZW50LmtleSA9PT0gXCJTaGlmdFwiKSB7XG4gICAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXApIHtcbiAgICAgICAgdGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uRWRpdGluZ0FjdGlvbih7XG4gICAgbmFtZVxuICB9KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwidW5kb1wiOlxuICAgICAgY2FzZSBcInJlZG9cIjpcbiAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgIGNhc2UgXCJzZWxlY3RBbGxcIjpcbiAgICAgICAgdGhpc1tuYW1lXSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJoaWdobGlnaHRTZWxlY3Rpb25cIjpcbiAgICAgICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24oXCJjb250ZXh0X21lbnVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNvbW1lbnRTZWxlY3Rpb25cIjpcbiAgICAgICAgdGhpcy5jb21tZW50U2VsZWN0aW9uKFwiY29udGV4dF9tZW51XCIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKGRldGFpbHMpIHtcbiAgICBjb25zdCBoYXNDaGFuZ2VkID0gT2JqZWN0LmVudHJpZXMoZGV0YWlscykuc29tZSgoW2tleSwgdmFsdWVdKSA9PiB0aGlzLiNwcmV2aW91c1N0YXRlc1trZXldICE9PSB2YWx1ZSk7XG4gICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwiYW5ub3RhdGlvbmVkaXRvcnN0YXRlc2NoYW5nZWRcIiwge1xuICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgIGRldGFpbHM6IE9iamVjdC5hc3NpZ24odGhpcy4jcHJldmlvdXNTdGF0ZXMsIGRldGFpbHMpXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQgJiYgZGV0YWlscy5oYXNTZWxlY3RlZEVkaXRvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9GUkVFLCB0cnVlXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjZGlzcGF0Y2hVcGRhdGVVSShkZXRhaWxzKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJhbm5vdGF0aW9uZWRpdG9ycGFyYW1zY2hhbmdlZFwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBkZXRhaWxzXG4gICAgfSk7XG4gIH1cbiAgc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZykge1xuICAgIGlmIChpc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuI2FkZEZvY3VzTWFuYWdlcigpO1xuICAgICAgdGhpcy4jYWRkQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgIGlzRWRpdGluZzogdGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSxcbiAgICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpLFxuICAgICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvVW5kbygpLFxuICAgICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvUmVkbygpLFxuICAgICAgICBoYXNTZWxlY3RlZEVkaXRvcjogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNyZW1vdmVGb2N1c01hbmFnZXIoKTtcbiAgICAgIHRoaXMuI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckVkaXRvclR5cGVzKHR5cGVzKSB7XG4gICAgaWYgKHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2VkaXRvclR5cGVzID0gdHlwZXM7XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvclR5cGUuZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLiNpZE1hbmFnZXIuaWQ7XG4gIH1cbiAgZ2V0IGN1cnJlbnRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsTGF5ZXJzLmdldCh0aGlzLiNjdXJyZW50UGFnZUluZGV4KTtcbiAgfVxuICBnZXRMYXllcihwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICB9XG4gIGdldCBjdXJyZW50UGFnZUluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50UGFnZUluZGV4O1xuICB9XG4gIGFkZExheWVyKGxheWVyKSB7XG4gICAgdGhpcy4jYWxsTGF5ZXJzLnNldChsYXllci5wYWdlSW5kZXgsIGxheWVyKTtcbiAgICBpZiAodGhpcy4jaXNFbmFibGVkKSB7XG4gICAgICBsYXllci5lbmFibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXIuZGlzYWJsZSgpO1xuICAgIH1cbiAgfVxuICByZW1vdmVMYXllcihsYXllcikge1xuICAgIHRoaXMuI2FsbExheWVycy5kZWxldGUobGF5ZXIucGFnZUluZGV4KTtcbiAgfVxuICBhc3luYyB1cGRhdGVNb2RlKG1vZGUsIGVkaXRJZCA9IG51bGwsIGlzRnJvbUtleWJvYXJkID0gZmFsc2UsIG11c3RFbnRlckluRWRpdE1vZGUgPSBmYWxzZSwgZWRpdENvbW1lbnQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLiNtb2RlID09PSBtb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSkge1xuICAgICAgYXdhaXQgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIGlmICghdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuI2N1cnJlbnREcmF3aW5nU2Vzc2lvbj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuUE9QVVApIHtcbiAgICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5oaWRlU2lkZWJhcigpO1xuICAgIH1cbiAgICB0aGlzLiNtb2RlID0gbW9kZTtcbiAgICBpZiAobW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgdGhpcy5zZXRFZGl0aW5nU3RhdGUoZmFsc2UpO1xuICAgICAgdGhpcy4jZGlzYWJsZUFsbCgpO1xuICAgICAgdGhpcy5fZWRpdG9yVW5kb0Jhcj8uaGlkZSgpO1xuICAgICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU0lHTkFUVVJFKSB7XG4gICAgICBhd2FpdCB0aGlzLiNzaWduYXR1cmVNYW5hZ2VyPy5sb2FkU2lnbmF0dXJlcygpO1xuICAgIH1cbiAgICBpZiAobW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuUE9QVVApIHtcbiAgICAgIHRoaXMuI2FsbEVkaXRhYmxlQW5ub3RhdGlvbnMgfHw9IGF3YWl0IHRoaXMuI3BkZkRvY3VtZW50LmdldEFubm90YXRpb25zQnlUeXBlKG5ldyBTZXQodGhpcy4jZWRpdG9yVHlwZXMubWFwKGVkaXRvckNsYXNzID0+IGVkaXRvckNsYXNzLl9lZGl0b3JUeXBlKSkpO1xuICAgICAgdGhpcy4jY29tbWVudE1hbmFnZXI/LnNob3dTaWRlYmFyKHRoaXMuI2FsbEVkaXRhYmxlQW5ub3RhdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICBhd2FpdCB0aGlzLiNlbmFibGVBbGwoKTtcbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGxheWVyLnVwZGF0ZU1vZGUobW9kZSk7XG4gICAgfVxuICAgIGlmICghZWRpdElkKSB7XG4gICAgICBpZiAoaXNGcm9tS2V5Ym9hcmQpIHtcbiAgICAgICAgdGhpcy5hZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID09PSBlZGl0SWQgfHwgZWRpdG9yLmlkID09PSBlZGl0SWQpIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZChlZGl0b3IpO1xuICAgICAgICBpZiAoZWRpdENvbW1lbnQpIHtcbiAgICAgICAgICBlZGl0b3IuZWRpdENvbW1lbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChtdXN0RW50ZXJJbkVkaXRNb2RlKSB7XG4gICAgICAgICAgZWRpdG9yLmVudGVySW5FZGl0TW9kZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIGFkZE5ld0VkaXRvckZyb21LZXlib2FyZCgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50TGF5ZXIuY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSkge1xuICAgICAgdGhpcy5jdXJyZW50TGF5ZXIuYWRkTmV3RWRpdG9yKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRvb2xiYXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLm1vZGUgPT09IHRoaXMuI21vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuQ1JFQVRFOlxuICAgICAgICB0aGlzLmN1cnJlbnRMYXllci5hZGROZXdFZGl0b3IodmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9TSE9XX0FMTDpcbiAgICAgICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJyZXBvcnR0ZWxlbWV0cnlcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVkaXRpbmdcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJoaWdobGlnaHRcIixcbiAgICAgICAgICAgICAgYWN0aW9uOiBcInRvZ2dsZV92aXNpYmlsaXR5XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAodGhpcy4jc2hvd0FsbFN0YXRlcyB8fD0gbmV3IE1hcCgpKS5zZXQodHlwZSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICAgIGVkaXRvci51cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgZWRpdG9yVHlwZS51cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2hvd0FsbEVkaXRvcnModHlwZSwgdmlzaWJsZSwgdXBkYXRlQnV0dG9uID0gZmFsc2UpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLmVkaXRvclR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgZWRpdG9yLnNob3codmlzaWJsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jc2hvd0FsbFN0YXRlcz8uZ2V0KEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9TSE9XX0FMTCkgPz8gdHJ1ZTtcbiAgICBpZiAoc3RhdGUgIT09IHZpc2libGUpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEwsIHZpc2libGVdXSk7XG4gICAgfVxuICB9XG4gIGVuYWJsZVdhaXRpbmcobXVzdFdhaXQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLiNpc1dhaXRpbmcgPT09IG11c3RXYWl0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2lzV2FpdGluZyA9IG11c3RXYWl0O1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBpZiAobXVzdFdhaXQpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZUNsaWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXllci5lbmFibGVDbGljaygpO1xuICAgICAgfVxuICAgICAgbGF5ZXIuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJ3YWl0aW5nXCIsIG11c3RXYWl0KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgI2VuYWJsZUFsbCgpIHtcbiAgICBpZiAoIXRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy4jaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKGxheWVyLmVuYWJsZSgpKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgZWRpdG9yLmVuYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjZGlzYWJsZUFsbCgpIHtcbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgaWYgKHRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy4jaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBsYXllci5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGVkaXRvci5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEVkaXRvcnMocGFnZUluZGV4KSB7XG4gICAgY29uc3QgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IucGFnZUluZGV4ID09PSBwYWdlSW5kZXgpIHtcbiAgICAgICAgZWRpdG9ycy5wdXNoKGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3JzO1xuICB9XG4gIGdldEVkaXRvcihpZCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxFZGl0b3JzLmdldChpZCk7XG4gIH1cbiAgYWRkRWRpdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2FsbEVkaXRvcnMuc2V0KGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgfVxuICByZW1vdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIGlmICh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5mb2N1c01haW5Db250YWluZXIoKTtcbiAgICAgICAgdGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gbnVsbDtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICB0aGlzLiNhbGxFZGl0b3JzLmRlbGV0ZShlZGl0b3IuaWQpO1xuICAgIGlmIChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy4jbWlzc2luZ0NhbnZhc2VzPy5kZWxldGUoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIH1cbiAgICB0aGlzLnVuc2VsZWN0KGVkaXRvcik7XG4gICAgaWYgKCFlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCB8fCAhdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5oYXMoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpKSB7XG4gICAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZT8ucmVtb3ZlKGVkaXRvci5pZCk7XG4gICAgfVxuICB9XG4gIGFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmFkZChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgdGhpcy5hZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgZWRpdG9yLmRlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIGlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5oYXMoYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gIH1cbiAgcmVtb3ZlRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuZGVsZXRlKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICB0aGlzLnJlbW92ZUNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oZWRpdG9yKTtcbiAgICBlZGl0b3IuZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gICNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcikge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jYWxsTGF5ZXJzLmdldChlZGl0b3IucGFnZUluZGV4KTtcbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIHNldEFjdGl2ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jYWN0aXZlRWRpdG9yID09PSBlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIGdldCAjbGFzdFNlbGVjdGVkRWRpdG9yKCkge1xuICAgIGxldCBlZCA9IG51bGw7XG4gICAgZm9yIChlZCBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHt9XG4gICAgcmV0dXJuIGVkO1xuICB9XG4gIHVwZGF0ZVVJKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNsYXN0U2VsZWN0ZWRFZGl0b3IgPT09IGVkaXRvcikge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVUlGb3JEZWZhdWx0UHJvcGVydGllcyhlZGl0b3JUeXBlKSB7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3JUeXBlLmRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICB9XG4gIHRvZ2dsZVNlbGVjdGVkKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNzZWxlY3RlZEVkaXRvcnMuaGFzKGVkaXRvcikpIHtcbiAgICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdGhpcy5oYXNTZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzZXRTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLnVwZGF0ZVRvb2xiYXIoe1xuICAgICAgbW9kZTogZWRpdG9yLm1vZGUsXG4gICAgICBlZGl0SWQ6IGVkaXRvci5pZFxuICAgIH0pO1xuICAgIHRoaXMuI2N1cnJlbnREcmF3aW5nU2Vzc2lvbj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgICBmb3IgKGNvbnN0IGVkIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgaWYgKGVkICE9PSBlZGl0b3IpIHtcbiAgICAgICAgZWQudW5zZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgaXNTZWxlY3RlZChlZGl0b3IpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmhhcyhlZGl0b3IpO1xuICB9XG4gIGdldCBmaXJzdFNlbGVjdGVkRWRpdG9yKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICB9XG4gIHVuc2VsZWN0KGVkaXRvcikge1xuICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdGhpcy5oYXNTZWxlY3Rpb25cbiAgICB9KTtcbiAgfVxuICBnZXQgaGFzU2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuc2l6ZSAhPT0gMDtcbiAgfVxuICBnZXQgaXNFbnRlckhhbmRsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplID09PSAxICYmIHRoaXMuZmlyc3RTZWxlY3RlZEVkaXRvci5pc0VudGVySGFuZGxlZDtcbiAgfVxuICB1bmRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnVuZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvVW5kbygpLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0cnVlLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gICAgdGhpcy5fZWRpdG9yVW5kb0Jhcj8uaGlkZSgpO1xuICB9XG4gIHJlZG8oKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIucmVkbygpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdHJ1ZSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9SZWRvKCksXG4gICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KClcbiAgICB9KTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5hZGQocGFyYW1zKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRydWUsXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IGZhbHNlLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgY2xlYW5VbmRvU3RhY2sodHlwZSkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmNsZWFuVHlwZSh0eXBlKTtcbiAgfVxuICAjaXNFbXB0eSgpIHtcbiAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuc2l6ZSA9PT0gMSkge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmlzRW1wdHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlbGV0ZSgpIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgY29uc3QgZHJhd2luZ0VkaXRvciA9IHRoaXMuY3VycmVudExheWVyPy5lbmREcmF3aW5nU2Vzc2lvbih0cnVlKTtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uICYmICFkcmF3aW5nRWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvcnMgPSBkcmF3aW5nRWRpdG9yID8gW2RyYXdpbmdFZGl0b3JdIDogWy4uLnRoaXMuI3NlbGVjdGVkRWRpdG9yc107XG4gICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWRpdG9yVW5kb0Jhcj8uc2hvdyh1bmRvLCBlZGl0b3JzLmxlbmd0aCA9PT0gMSA/IGVkaXRvcnNbMF0uZWRpdG9yVHlwZSA6IGVkaXRvcnMubGVuZ3RoKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgdGhpcy4jYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBjb21taXRPclJlbW92ZSgpIHtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3I/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9Db250cm9sKCkge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3IgfHwgdGhpcy5oYXNTZWxlY3Rpb247XG4gIH1cbiAgI3NlbGVjdEVkaXRvcnMoZWRpdG9ycykge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdGhpcy5oYXNTZWxlY3Rpb25cbiAgICB9KTtcbiAgfVxuICBzZWxlY3RBbGwoKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IuY29tbWl0KCk7XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdEVkaXRvcnModGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSk7XG4gIH1cbiAgdW5zZWxlY3RBbGwoKSB7XG4gICAgaWYgKHRoaXMuI2FjdGl2ZUVkaXRvcikge1xuICAgICAgdGhpcy4jYWN0aXZlRWRpdG9yLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICBpZiAodGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24/LmNvbW1pdE9yUmVtb3ZlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogZmFsc2VcbiAgICB9KTtcbiAgfVxuICB0cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMoeCwgeSwgbm9Db21taXQgPSBmYWxzZSkge1xuICAgIGlmICghbm9Db21taXQpIHtcbiAgICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN0cmFuc2xhdGlvblswXSArPSB4O1xuICAgIHRoaXMuI3RyYW5zbGF0aW9uWzFdICs9IHk7XG4gICAgY29uc3QgW3RvdGFsWCwgdG90YWxZXSA9IHRoaXMuI3RyYW5zbGF0aW9uO1xuICAgIGNvbnN0IGVkaXRvcnMgPSBbLi4udGhpcy4jc2VsZWN0ZWRFZGl0b3JzXTtcbiAgICBjb25zdCBUSU1FX1RPX1dBSVQgPSAxMDAwO1xuICAgIGlmICh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKTtcbiAgICB9XG4gICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uWzBdID0gdGhpcy4jdHJhbnNsYXRpb25bMV0gPSAwO1xuICAgICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UodG90YWxYLCB0b3RhbFkpO1xuICAgICAgICAgICAgICBlZGl0b3IudHJhbnNsYXRpb25Eb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSgtdG90YWxYLCAtdG90YWxZKTtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0aW9uRG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9LCBUSU1FX1RPX1dBSVQpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UoeCwgeSk7XG4gICAgICBlZGl0b3IudHJhbnNsYXRpb25Eb25lKCk7XG4gICAgfVxuICB9XG4gIHNldFVwRHJhZ1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KHRydWUpO1xuICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycy5zZXQoZWRpdG9yLCB7XG4gICAgICAgIHNhdmVkWDogZWRpdG9yLngsXG4gICAgICAgIHNhdmVkWTogZWRpdG9yLnksXG4gICAgICAgIHNhdmVkUGFnZUluZGV4OiBlZGl0b3IucGFnZUluZGV4LFxuICAgICAgICBuZXdYOiAwLFxuICAgICAgICBuZXdZOiAwLFxuICAgICAgICBuZXdQYWdlSW5kZXg6IC0xXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZW5kRHJhZ1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLiNkcmFnZ2luZ0VkaXRvcnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdChmYWxzZSk7XG4gICAgY29uc3QgbWFwID0gdGhpcy4jZHJhZ2dpbmdFZGl0b3JzO1xuICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycyA9IG51bGw7XG4gICAgbGV0IG11c3RCZUFkZGVkSW5VbmRvU3RhY2sgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IFt7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0sIHZhbHVlXSBvZiBtYXApIHtcbiAgICAgIHZhbHVlLm5ld1ggPSB4O1xuICAgICAgdmFsdWUubmV3WSA9IHk7XG4gICAgICB2YWx1ZS5uZXdQYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICBtdXN0QmVBZGRlZEluVW5kb1N0YWNrIHx8PSB4ICE9PSB2YWx1ZS5zYXZlZFggfHwgeSAhPT0gdmFsdWUuc2F2ZWRZIHx8IHBhZ2VJbmRleCAhPT0gdmFsdWUuc2F2ZWRQYWdlSW5kZXg7XG4gICAgfVxuICAgIGlmICghbXVzdEJlQWRkZWRJblVuZG9TdGFjaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtb3ZlID0gKGVkaXRvciwgeCwgeSwgcGFnZUluZGV4KSA9PiB7XG4gICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLiNhbGxMYXllcnMuZ2V0KHBhZ2VJbmRleCk7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBlZGl0b3IuX3NldFBhcmVudEFuZFBvc2l0aW9uKHBhcmVudCwgeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdG9yLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICAgICAgICBlZGl0b3IueCA9IHg7XG4gICAgICAgICAgZWRpdG9yLnkgPSB5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtlZGl0b3IsIHtcbiAgICAgICAgICBuZXdYLFxuICAgICAgICAgIG5ld1ksXG4gICAgICAgICAgbmV3UGFnZUluZGV4XG4gICAgICAgIH1dIG9mIG1hcCkge1xuICAgICAgICAgIG1vdmUoZWRpdG9yLCBuZXdYLCBuZXdZLCBuZXdQYWdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtlZGl0b3IsIHtcbiAgICAgICAgICBzYXZlZFgsXG4gICAgICAgICAgc2F2ZWRZLFxuICAgICAgICAgIHNhdmVkUGFnZUluZGV4XG4gICAgICAgIH1dIG9mIG1hcCkge1xuICAgICAgICAgIG1vdmUoZWRpdG9yLCBzYXZlZFgsIHNhdmVkWSwgc2F2ZWRQYWdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkcmFnU2VsZWN0ZWRFZGl0b3JzKHR4LCB0eSkge1xuICAgIGlmICghdGhpcy4jZHJhZ2dpbmdFZGl0b3JzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2RyYWdnaW5nRWRpdG9ycy5rZXlzKCkpIHtcbiAgICAgIGVkaXRvci5kcmFnKHR4LCB0eSk7XG4gICAgfVxuICB9XG4gIHJlYnVpbGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0TGF5ZXIoZWRpdG9yLnBhZ2VJbmRleCk7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICAgICAgcGFyZW50LmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICAgICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci5wYXJlbnQuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGdldCBpc0VkaXRvckhhbmRsaW5nS2V5Ym9hcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlKCk/LnNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkgfHwgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgPT09IDEgJiYgdGhpcy5maXJzdFNlbGVjdGVkRWRpdG9yLnNob3VsZEdldEtleWJvYXJkRXZlbnRzKCk7XG4gIH1cbiAgaXNBY3RpdmUoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvciA9PT0gZWRpdG9yO1xuICB9XG4gIGdldEFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yO1xuICB9XG4gIGdldE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21vZGU7XG4gIH1cbiAgZ2V0IGltYWdlTWFuYWdlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaW1hZ2VNYW5hZ2VyXCIsIG5ldyBJbWFnZU1hbmFnZXIoKSk7XG4gIH1cbiAgZ2V0U2VsZWN0aW9uQm94ZXModGV4dExheWVyKSB7XG4gICAgaWYgKCF0ZXh0TGF5ZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlmICghdGV4dExheWVyLmNvbnRhaW5zKHNlbGVjdGlvbi5nZXRSYW5nZUF0KGkpLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeDogbGF5ZXJYLFxuICAgICAgeTogbGF5ZXJZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGV4dExheWVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCByb3RhdG9yO1xuICAgIHN3aXRjaCAodGV4dExheWVyLmdldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiKSkge1xuICAgICAgY2FzZSBcIjkwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAoeSAtIGxheWVyWSkgLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgeTogMSAtICh4ICsgdyAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB3aWR0aDogaCAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IHcgLyBwYXJlbnRXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiMTgwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAxIC0gKHggKyB3IC0gbGF5ZXJYKSAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIHk6IDEgLSAoeSArIGggLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3IC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoIC8gcGFyZW50SGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIyNzBcIjpcbiAgICAgICAgcm90YXRvciA9ICh4LCB5LCB3LCBoKSA9PiAoe1xuICAgICAgICAgIHg6IDEgLSAoeSArIGggLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHk6ICh4IC0gbGF5ZXJYKSAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIHdpZHRoOiBoIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIGhlaWdodDogdyAvIHBhcmVudFdpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAoeCAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB5OiAoeSAtIGxheWVyWSkgLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IHcgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGggLyBwYXJlbnRIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNlbGVjdGlvbi5yYW5nZUNvdW50OyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKTtcbiAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSBvZiByYW5nZS5nZXRDbGllbnRSZWN0cygpKSB7XG4gICAgICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBib3hlcy5wdXNoKHJvdGF0b3IoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm94ZXMubGVuZ3RoID09PSAwID8gbnVsbCA6IGJveGVzO1xuICB9XG4gIGFkZENoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oe1xuICAgIGFubm90YXRpb25FbGVtZW50SWQsXG4gICAgaWRcbiAgfSkge1xuICAgICh0aGlzLiNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucyB8fD0gbmV3IE1hcCgpKS5zZXQoYW5ub3RhdGlvbkVsZW1lbnRJZCwgaWQpO1xuICB9XG4gIHJlbW92ZUNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oe1xuICAgIGFubm90YXRpb25FbGVtZW50SWRcbiAgfSkge1xuICAgIHRoaXMuI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zPy5kZWxldGUoYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGNvbnN0IGVkaXRvcklkID0gdGhpcy4jY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnM/LmdldChhbm5vdGF0aW9uLmRhdGEuaWQpO1xuICAgIGlmICghZWRpdG9ySWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUoZWRpdG9ySWQpO1xuICAgIGlmICghZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FICYmICFlZGl0b3IuaGFzQmVlbk1vZGlmaWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVkaXRvci5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKTtcbiAgfVxuICBzZXRNaXNzaW5nQ2FudmFzKGFubm90YXRpb25JZCwgYW5ub3RhdGlvbkVsZW1lbnRJZCwgY2FudmFzKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jbWlzc2luZ0NhbnZhc2VzPy5nZXQoYW5ub3RhdGlvbklkKTtcbiAgICBpZiAoIWVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZGl0b3Iuc2V0Q2FudmFzKGFubm90YXRpb25FbGVtZW50SWQsIGNhbnZhcyk7XG4gICAgdGhpcy4jbWlzc2luZ0NhbnZhc2VzLmRlbGV0ZShhbm5vdGF0aW9uSWQpO1xuICB9XG4gIGFkZE1pc3NpbmdDYW52YXMoYW5ub3RhdGlvbklkLCBlZGl0b3IpIHtcbiAgICAodGhpcy4jbWlzc2luZ0NhbnZhc2VzIHx8PSBuZXcgTWFwKCkpLnNldChhbm5vdGF0aW9uSWQsIGVkaXRvcik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2FsdF90ZXh0LmpzXG5cbmNsYXNzIEFsdFRleHQge1xuICAjYWx0VGV4dCA9IG51bGw7XG4gICNhbHRUZXh0RGVjb3JhdGl2ZSA9IGZhbHNlO1xuICAjYWx0VGV4dEJ1dHRvbiA9IG51bGw7XG4gICNhbHRUZXh0QnV0dG9uTGFiZWwgPSBudWxsO1xuICAjYWx0VGV4dFRvb2x0aXAgPSBudWxsO1xuICAjYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmQgPSBmYWxzZTtcbiAgI2JhZGdlID0gbnVsbDtcbiAgI2VkaXRvciA9IG51bGw7XG4gICNndWVzc2VkVGV4dCA9IG51bGw7XG4gICN0ZXh0V2l0aERpc2NsYWltZXIgPSBudWxsO1xuICAjdXNlTmV3QWx0VGV4dEZsb3cgPSBmYWxzZTtcbiAgc3RhdGljICNsMTBuTmV3QnV0dG9uID0gbnVsbDtcbiAgc3RhdGljIF9sMTBuID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuI3VzZU5ld0FsdFRleHRGbG93ID0gZWRpdG9yLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3c7XG4gICAgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbiB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBhZGRlZDogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LWFkZGVkLWJ1dHRvblwiLFxuICAgICAgXCJhZGRlZC1sYWJlbFwiOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtYWRkZWQtYnV0dG9uLWxhYmVsXCIsXG4gICAgICBtaXNzaW5nOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtbWlzc2luZy1idXR0b25cIixcbiAgICAgIFwibWlzc2luZy1sYWJlbFwiOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtbWlzc2luZy1idXR0b24tbGFiZWxcIixcbiAgICAgIHJldmlldzogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LXRvLXJldmlldy1idXR0b25cIixcbiAgICAgIFwicmV2aWV3LWxhYmVsXCI6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC10by1yZXZpZXctYnV0dG9uLWxhYmVsXCJcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuKSB7XG4gICAgQWx0VGV4dC5fbDEwbiA/Pz0gbDEwbjtcbiAgfVxuICBhc3luYyByZW5kZXIoKSB7XG4gICAgY29uc3QgYWx0VGV4dCA9IHRoaXMuI2FsdFRleHRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGFsdFRleHQuY2xhc3NOYW1lID0gXCJhbHRUZXh0XCI7XG4gICAgYWx0VGV4dC50YWJJbmRleCA9IFwiMFwiO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy4jYWx0VGV4dEJ1dHRvbkxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgYWx0VGV4dC5hcHBlbmQobGFiZWwpO1xuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgYWx0VGV4dC5jbGFzc0xpc3QuYWRkKFwibmV3XCIpO1xuICAgICAgYWx0VGV4dC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbi5taXNzaW5nKTtcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uW1wibWlzc2luZy1sYWJlbFwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsdFRleHQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWJ1dHRvblwiKTtcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1idXR0b24tbGFiZWxcIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZXZlbnQgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IG9uQ2xpY2sgPSBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZWRpdEFsdFRleHQodGhpcy4jZWRpdG9yKTtcbiAgICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgICB0aGlzLiNlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmFsdF90ZXh0LmltYWdlX3N0YXR1c19sYWJlbF9jbGlja2VkXCIsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgbGFiZWw6IHRoaXMuI2xhYmVsXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xpY2ssIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGFsdFRleHQgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCA9IHRydWU7XG4gICAgICAgIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuI3NldFN0YXRlKCk7XG4gICAgcmV0dXJuIGFsdFRleHQ7XG4gIH1cbiAgZ2V0ICNsYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dCAmJiBcImFkZGVkXCIgfHwgdGhpcy4jYWx0VGV4dCA9PT0gbnVsbCAmJiB0aGlzLmd1ZXNzZWRUZXh0ICYmIFwicmV2aWV3XCIgfHwgXCJtaXNzaW5nXCI7XG4gIH1cbiAgZmluaXNoKCkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dEJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uLmZvY3VzKHtcbiAgICAgIGZvY3VzVmlzaWJsZTogdGhpcy4jYWx0VGV4dFdhc0Zyb21LZXlCb2FyZFxuICAgIH0pO1xuICAgIHRoaXMuI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmQgPSBmYWxzZTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FsdFRleHQgPT09IG51bGw7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy4jYWx0VGV4dCAmJiAhdGhpcy4jYWx0VGV4dERlY29yYXRpdmU7XG4gIH1cbiAgaGFzRGF0YSgpIHtcbiAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIHJldHVybiB0aGlzLiNhbHRUZXh0ICE9PSBudWxsIHx8ICEhdGhpcy4jZ3Vlc3NlZFRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKTtcbiAgfVxuICBnZXQgZ3Vlc3NlZFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2d1ZXNzZWRUZXh0O1xuICB9XG4gIGFzeW5jIHNldEd1ZXNzZWRUZXh0KGd1ZXNzZWRUZXh0KSB7XG4gICAgaWYgKHRoaXMuI2FsdFRleHQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZ3Vlc3NlZFRleHQgPSBndWVzc2VkVGV4dDtcbiAgICB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXIgPSBhd2FpdCBBbHRUZXh0Ll9sMTBuLmdldChcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtZ2VuZXJhdGVkLWFsdC10ZXh0LXdpdGgtZGlzY2xhaW1lclwiLCB7XG4gICAgICBnZW5lcmF0ZWRBbHRUZXh0OiBndWVzc2VkVGV4dFxuICAgIH0pO1xuICAgIHRoaXMuI3NldFN0YXRlKCk7XG4gIH1cbiAgdG9nZ2xlQWx0VGV4dEJhZGdlKHZpc2liaWxpdHkgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cgfHwgdGhpcy4jYWx0VGV4dCkge1xuICAgICAgdGhpcy4jYmFkZ2U/LnJlbW92ZSgpO1xuICAgICAgdGhpcy4jYmFkZ2UgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2JhZGdlKSB7XG4gICAgICBjb25zdCBiYWRnZSA9IHRoaXMuI2JhZGdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGJhZGdlLmNsYXNzTmFtZSA9IFwibm9BbHRUZXh0QmFkZ2VcIjtcbiAgICAgIHRoaXMuI2VkaXRvci5kaXYuYXBwZW5kKGJhZGdlKTtcbiAgICB9XG4gICAgdGhpcy4jYmFkZ2UuY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiLCAhdmlzaWJpbGl0eSk7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZykge1xuICAgIGxldCBhbHRUZXh0ID0gdGhpcy4jYWx0VGV4dDtcbiAgICBpZiAoIWlzRm9yQ29weWluZyAmJiB0aGlzLiNndWVzc2VkVGV4dCA9PT0gYWx0VGV4dCkge1xuICAgICAgYWx0VGV4dCA9IHRoaXMuI3RleHRXaXRoRGlzY2xhaW1lcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGFsdFRleHQsXG4gICAgICBkZWNvcmF0aXZlOiB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSxcbiAgICAgIGd1ZXNzZWRUZXh0OiB0aGlzLiNndWVzc2VkVGV4dCxcbiAgICAgIHRleHRXaXRoRGlzY2xhaW1lcjogdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyXG4gICAgfTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWx0VGV4dDogdGhpcy4jYWx0VGV4dCxcbiAgICAgIGRlY29yYXRpdmU6IHRoaXMuI2FsdFRleHREZWNvcmF0aXZlXG4gICAgfTtcbiAgfVxuICBzZXQgZGF0YSh7XG4gICAgYWx0VGV4dCxcbiAgICBkZWNvcmF0aXZlLFxuICAgIGd1ZXNzZWRUZXh0LFxuICAgIHRleHRXaXRoRGlzY2xhaW1lcixcbiAgICBjYW5jZWwgPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKGd1ZXNzZWRUZXh0KSB7XG4gICAgICB0aGlzLiNndWVzc2VkVGV4dCA9IGd1ZXNzZWRUZXh0O1xuICAgICAgdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyID0gdGV4dFdpdGhEaXNjbGFpbWVyO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYWx0VGV4dCA9PT0gYWx0VGV4dCAmJiB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSA9PT0gZGVjb3JhdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNhbmNlbCkge1xuICAgICAgdGhpcy4jYWx0VGV4dCA9IGFsdFRleHQ7XG4gICAgICB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSA9IGRlY29yYXRpdmU7XG4gICAgfVxuICAgIHRoaXMuI3NldFN0YXRlKCk7XG4gIH1cbiAgdG9nZ2xlKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dEJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWVuYWJsZWQgJiYgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KTtcbiAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHRCdXR0b24uZGlzYWJsZWQgPSAhZW5hYmxlZDtcbiAgfVxuICBzaG93bigpIHtcbiAgICB0aGlzLiNlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwicGRmanMuaW1hZ2UuYWx0X3RleHQuaW1hZ2Vfc3RhdHVzX2xhYmVsX2Rpc3BsYXllZFwiLFxuICAgICAgZGF0YToge1xuICAgICAgICBsYWJlbDogdGhpcy4jbGFiZWxcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b24gPSBudWxsO1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b25MYWJlbCA9IG51bGw7XG4gICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAgPSBudWxsO1xuICAgIHRoaXMuI2JhZGdlPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNiYWRnZSA9IG51bGw7XG4gIH1cbiAgYXN5bmMgI3NldFN0YXRlKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuI2FsdFRleHRCdXR0b247XG4gICAgaWYgKCFidXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZShcImRvbmVcIiwgISF0aGlzLiNhbHRUZXh0KTtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvblt0aGlzLiNsYWJlbF0pO1xuICAgICAgdGhpcy4jYWx0VGV4dEJ1dHRvbkxhYmVsPy5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbltgJHt0aGlzLiNsYWJlbH0tbGFiZWxgXSk7XG4gICAgICBpZiAoIXRoaXMuI2FsdFRleHQpIHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy4jYWx0VGV4dCAmJiAhdGhpcy4jYWx0VGV4dERlY29yYXRpdmUpIHtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJkb25lXCIpO1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8ucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZG9uZVwiKTtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtZWRpdC1idXR0b25cIik7XG4gICAgfVxuICAgIGxldCB0b29sdGlwID0gdGhpcy4jYWx0VGV4dFRvb2x0aXA7XG4gICAgaWYgKCF0b29sdGlwKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcCA9IHRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHRvb2x0aXAuY2xhc3NOYW1lID0gXCJ0b29sdGlwXCI7XG4gICAgICB0b29sdGlwLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0b29sdGlwXCIpO1xuICAgICAgdG9vbHRpcC5pZCA9IGBhbHQtdGV4dC10b29sdGlwLSR7dGhpcy4jZWRpdG9yLmlkfWA7XG4gICAgICBjb25zdCBERUxBWV9UT19TSE9XX1RPT0xUSVAgPSAxMDA7XG4gICAgICBjb25zdCBzaWduYWwgPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpO1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgICAgfSwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAuY2xhc3NMaXN0LmFkZChcInNob3dcIik7XG4gICAgICAgICAgdGhpcy4jZWRpdG9yLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICAgICAgYWN0aW9uOiBcImFsdF90ZXh0X3Rvb2x0aXBcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBERUxBWV9UT19TSE9XX1RPT0xUSVApO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpO1xuICAgICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYWx0VGV4dERlY29yYXRpdmUpIHtcbiAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWRlY29yYXRpdmUtdG9vbHRpcFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9vbHRpcC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIik7XG4gICAgICB0b29sdGlwLnRleHRDb250ZW50ID0gdGhpcy4jYWx0VGV4dDtcbiAgICB9XG4gICAgaWYgKCF0b29sdGlwLnBhcmVudE5vZGUpIHtcbiAgICAgIGJ1dHRvbi5hcHBlbmQodG9vbHRpcCk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLiNlZGl0b3IuZ2V0RWxlbWVudEZvckFsdFRleHQoKTtcbiAgICBlbGVtZW50Py5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIHRvb2x0aXAuaWQpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9jb21tZW50LmpzXG5cbmNsYXNzIENvbW1lbnQge1xuICAjY29tbWVudEJ1dHRvbiA9IG51bGw7XG4gICNjb21tZW50V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gICNlZGl0b3IgPSBudWxsO1xuICAjaW5pdGlhbFRleHQgPSBudWxsO1xuICAjdGV4dCA9IG51bGw7XG4gICNkYXRlID0gbnVsbDtcbiAgI2RlbGV0ZWQgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMudG9vbGJhciA9IG51bGw7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuaGFzQ29tbWVudE1hbmFnZXIoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLiNjb21tZW50QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBjb21tZW50LmNsYXNzTmFtZSA9IFwiY29tbWVudFwiO1xuICAgIGNvbW1lbnQudGFiSW5kZXggPSBcIjBcIjtcbiAgICBjb21tZW50LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1lZGl0LWNvbW1lbnQtYnV0dG9uXCIpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgaWYgKCEoc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpIHx8IHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gY29tbWVudDtcbiAgICB9XG4gICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZXZlbnQgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IG9uQ2xpY2sgPSBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5lZGl0KCk7XG4gICAgfTtcbiAgICBjb21tZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBvbkNsaWNrLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBjb21tZW50ICYmIGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgIHRoaXMuI2NvbW1lbnRXYXNGcm9tS2V5Qm9hcmQgPSB0cnVlO1xuICAgICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gY29tbWVudDtcbiAgfVxuICBlZGl0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJvdHRvbSxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH0gPSB0aGlzLiNlZGl0b3IuZ2V0Q2xpZW50RGltZW5zaW9ucygpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgdG9wOiBib3R0b21cbiAgICB9O1xuICAgIGlmICh0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIpIHtcbiAgICAgIHBvc2l0aW9uLnJpZ2h0ID0gcmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc2l0aW9uLmxlZnQgPSBsZWZ0O1xuICAgIH1cbiAgICB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5lZGl0Q29tbWVudCh0aGlzLiNlZGl0b3IsIHBvc2l0aW9uKTtcbiAgfVxuICBmaW5pc2goKSB7XG4gICAgaWYgKCF0aGlzLiNjb21tZW50QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbW1lbnRCdXR0b24uZm9jdXMoe1xuICAgICAgZm9jdXNWaXNpYmxlOiB0aGlzLiNjb21tZW50V2FzRnJvbUtleUJvYXJkXG4gICAgfSk7XG4gICAgdGhpcy4jY29tbWVudFdhc0Zyb21LZXlCb2FyZCA9IGZhbHNlO1xuICB9XG4gIGlzRGVsZXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jZGVsZXRlZCB8fCB0aGlzLiN0ZXh0ID09PSBcIlwiO1xuICB9XG4gIGhhc0JlZW5FZGl0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEZWxldGVkKCkgfHwgdGhpcy4jdGV4dCAhPT0gdGhpcy4jaW5pdGlhbFRleHQ7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHRoaXMuI3RleHQsXG4gICAgICBkYXRlOiB0aGlzLiNkYXRlLFxuICAgICAgZGVsZXRlZDogdGhpcy4jZGVsZXRlZFxuICAgIH07XG4gIH1cbiAgc2V0IGRhdGEodGV4dCkge1xuICAgIGlmICh0ZXh0ID09PSBudWxsKSB7XG4gICAgICB0aGlzLiN0ZXh0ID0gXCJcIjtcbiAgICAgIHRoaXMuI2RlbGV0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN0ZXh0ID0gdGV4dDtcbiAgICB0aGlzLiNkYXRlID0gbmV3IERhdGUoKTtcbiAgICB0aGlzLiNkZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgc2V0SW5pdGlhbFRleHQodGV4dCkge1xuICAgIHRoaXMuI2luaXRpYWxUZXh0ID0gdGV4dDtcbiAgICB0aGlzLmRhdGEgPSB0ZXh0O1xuICB9XG4gIHRvZ2dsZShlbmFibGVkID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuI2NvbW1lbnRCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudEJ1dHRvbi5kaXNhYmxlZCA9ICFlbmFibGVkO1xuICB9XG4gIHNob3duKCkge31cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNjb21tZW50QnV0dG9uPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNjb21tZW50QnV0dG9uID0gbnVsbDtcbiAgICB0aGlzLiN0ZXh0ID0gXCJcIjtcbiAgICB0aGlzLiNkYXRlID0gbnVsbDtcbiAgICB0aGlzLiNlZGl0b3IgPSBudWxsO1xuICAgIHRoaXMuI2NvbW1lbnRXYXNGcm9tS2V5Qm9hcmQgPSBmYWxzZTtcbiAgICB0aGlzLiNkZWxldGVkID0gZmFsc2U7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvdG91Y2hfbWFuYWdlci5qc1xuXG5jbGFzcyBUb3VjaE1hbmFnZXIge1xuICAjY29udGFpbmVyO1xuICAjaXNQaW5jaGluZyA9IGZhbHNlO1xuICAjaXNQaW5jaGluZ1N0b3BwZWQgPSBudWxsO1xuICAjaXNQaW5jaGluZ0Rpc2FibGVkO1xuICAjb25QaW5jaFN0YXJ0O1xuICAjb25QaW5jaGluZztcbiAgI29uUGluY2hFbmQ7XG4gICNwb2ludGVyRG93bkFDID0gbnVsbDtcbiAgI3NpZ25hbDtcbiAgI3RvdWNoSW5mbyA9IG51bGw7XG4gICN0b3VjaE1hbmFnZXJBQztcbiAgI3RvdWNoTW92ZUFDID0gbnVsbDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRhaW5lcixcbiAgICBpc1BpbmNoaW5nRGlzYWJsZWQgPSBudWxsLFxuICAgIGlzUGluY2hpbmdTdG9wcGVkID0gbnVsbCxcbiAgICBvblBpbmNoU3RhcnQgPSBudWxsLFxuICAgIG9uUGluY2hpbmcgPSBudWxsLFxuICAgIG9uUGluY2hFbmQgPSBudWxsLFxuICAgIHNpZ25hbFxuICB9KSB7XG4gICAgdGhpcy4jY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI2lzUGluY2hpbmdTdG9wcGVkID0gaXNQaW5jaGluZ1N0b3BwZWQ7XG4gICAgdGhpcy4jaXNQaW5jaGluZ0Rpc2FibGVkID0gaXNQaW5jaGluZ0Rpc2FibGVkO1xuICAgIHRoaXMuI29uUGluY2hTdGFydCA9IG9uUGluY2hTdGFydDtcbiAgICB0aGlzLiNvblBpbmNoaW5nID0gb25QaW5jaGluZztcbiAgICB0aGlzLiNvblBpbmNoRW5kID0gb25QaW5jaEVuZDtcbiAgICB0aGlzLiN0b3VjaE1hbmFnZXJBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLiNzaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW3NpZ25hbCwgdGhpcy4jdG91Y2hNYW5hZ2VyQUMuc2lnbmFsXSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuI29uVG91Y2hTdGFydC5iaW5kKHRoaXMpLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbDogdGhpcy4jc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgZ2V0IE1JTl9UT1VDSF9ESVNUQU5DRV9UT19QSU5DSCgpIHtcbiAgICByZXR1cm4gMzUgLyBPdXRwdXRTY2FsZS5waXhlbFJhdGlvO1xuICB9XG4gICNvblRvdWNoU3RhcnQoZXZ0KSB7XG4gICAgaWYgKHRoaXMuI2lzUGluY2hpbmdEaXNhYmxlZD8uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2dC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKHRoaXMuI3BvaW50ZXJEb3duQUMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9pbnRlckRvd25BQyA9IHRoaXMuI3BvaW50ZXJEb3duQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBzaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW3RoaXMuI3NpZ25hbCwgcG9pbnRlckRvd25BQy5zaWduYWxdKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBjb25zdCBjYW5jZWxQb2ludGVyRG93biA9IGUgPT4ge1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgdGhpcy4jcG9pbnRlckRvd25BQz8uYWJvcnQoKTtcbiAgICAgICAgICB0aGlzLiNwb2ludGVyRG93bkFDID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZSA9PiB7XG4gICAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZSk7XG4gICAgICAgICAgY2FuY2VsUG9pbnRlckRvd24oZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIG9wdHMpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgY2FuY2VsUG9pbnRlckRvd24sIG9wdHMpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIGNhbmNlbFBvaW50ZXJEb3duLCBvcHRzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiN0b3VjaE1vdmVBQykge1xuICAgICAgdGhpcy4jdG91Y2hNb3ZlQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBzaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW3RoaXMuI3NpZ25hbCwgdGhpcy4jdG91Y2hNb3ZlQUMuc2lnbmFsXSk7XG4gICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLiNjb250YWluZXI7XG4gICAgICBjb25zdCBvcHQgPSB7XG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy4jb25Ub3VjaE1vdmUuYmluZCh0aGlzKSwgb3B0KTtcbiAgICAgIGNvbnN0IG9uVG91Y2hFbmQgPSB0aGlzLiNvblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIG9uVG91Y2hFbmQsIG9wdCk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIG9uVG91Y2hFbmQsIG9wdCk7XG4gICAgICBvcHQuY2FwdHVyZSA9IHRydWU7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHN0b3BFdmVudCwgb3B0KTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgc3RvcEV2ZW50LCBvcHQpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIHN0b3BFdmVudCwgb3B0KTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHN0b3BFdmVudCwgb3B0KTtcbiAgICAgIHRoaXMuI29uUGluY2hTdGFydD8uKCk7XG4gICAgfVxuICAgIHN0b3BFdmVudChldnQpO1xuICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgdGhpcy4jaXNQaW5jaGluZ1N0b3BwZWQ/LigpKSB7XG4gICAgICB0aGlzLiN0b3VjaEluZm8gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgW3RvdWNoMCwgdG91Y2gxXSA9IGV2dC50b3VjaGVzO1xuICAgIGlmICh0b3VjaDAuaWRlbnRpZmllciA+IHRvdWNoMS5pZGVudGlmaWVyKSB7XG4gICAgICBbdG91Y2gwLCB0b3VjaDFdID0gW3RvdWNoMSwgdG91Y2gwXTtcbiAgICB9XG4gICAgdGhpcy4jdG91Y2hJbmZvID0ge1xuICAgICAgdG91Y2gwWDogdG91Y2gwLnNjcmVlblgsXG4gICAgICB0b3VjaDBZOiB0b3VjaDAuc2NyZWVuWSxcbiAgICAgIHRvdWNoMVg6IHRvdWNoMS5zY3JlZW5YLFxuICAgICAgdG91Y2gxWTogdG91Y2gxLnNjcmVlbllcbiAgICB9O1xuICB9XG4gICNvblRvdWNoTW92ZShldnQpIHtcbiAgICBpZiAoIXRoaXMuI3RvdWNoSW5mbyB8fCBldnQudG91Y2hlcy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2dCk7XG4gICAgbGV0IFt0b3VjaDAsIHRvdWNoMV0gPSBldnQudG91Y2hlcztcbiAgICBpZiAodG91Y2gwLmlkZW50aWZpZXIgPiB0b3VjaDEuaWRlbnRpZmllcikge1xuICAgICAgW3RvdWNoMCwgdG91Y2gxXSA9IFt0b3VjaDEsIHRvdWNoMF07XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNjcmVlblg6IHNjcmVlbjBYLFxuICAgICAgc2NyZWVuWTogc2NyZWVuMFlcbiAgICB9ID0gdG91Y2gwO1xuICAgIGNvbnN0IHtcbiAgICAgIHNjcmVlblg6IHNjcmVlbjFYLFxuICAgICAgc2NyZWVuWTogc2NyZWVuMVlcbiAgICB9ID0gdG91Y2gxO1xuICAgIGNvbnN0IHRvdWNoSW5mbyA9IHRoaXMuI3RvdWNoSW5mbztcbiAgICBjb25zdCB7XG4gICAgICB0b3VjaDBYOiBwVG91Y2gwWCxcbiAgICAgIHRvdWNoMFk6IHBUb3VjaDBZLFxuICAgICAgdG91Y2gxWDogcFRvdWNoMVgsXG4gICAgICB0b3VjaDFZOiBwVG91Y2gxWVxuICAgIH0gPSB0b3VjaEluZm87XG4gICAgY29uc3QgcHJldkdhcFggPSBwVG91Y2gxWCAtIHBUb3VjaDBYO1xuICAgIGNvbnN0IHByZXZHYXBZID0gcFRvdWNoMVkgLSBwVG91Y2gwWTtcbiAgICBjb25zdCBjdXJyR2FwWCA9IHNjcmVlbjFYIC0gc2NyZWVuMFg7XG4gICAgY29uc3QgY3VyckdhcFkgPSBzY3JlZW4xWSAtIHNjcmVlbjBZO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5oeXBvdChjdXJyR2FwWCwgY3VyckdhcFkpIHx8IDE7XG4gICAgY29uc3QgcERpc3RhbmNlID0gTWF0aC5oeXBvdChwcmV2R2FwWCwgcHJldkdhcFkpIHx8IDE7XG4gICAgaWYgKCF0aGlzLiNpc1BpbmNoaW5nICYmIE1hdGguYWJzKHBEaXN0YW5jZSAtIGRpc3RhbmNlKSA8PSBUb3VjaE1hbmFnZXIuTUlOX1RPVUNIX0RJU1RBTkNFX1RPX1BJTkNIKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRvdWNoSW5mby50b3VjaDBYID0gc2NyZWVuMFg7XG4gICAgdG91Y2hJbmZvLnRvdWNoMFkgPSBzY3JlZW4wWTtcbiAgICB0b3VjaEluZm8udG91Y2gxWCA9IHNjcmVlbjFYO1xuICAgIHRvdWNoSW5mby50b3VjaDFZID0gc2NyZWVuMVk7XG4gICAgaWYgKCF0aGlzLiNpc1BpbmNoaW5nKSB7XG4gICAgICB0aGlzLiNpc1BpbmNoaW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luID0gWyhzY3JlZW4wWCArIHNjcmVlbjFYKSAvIDIsIChzY3JlZW4wWSArIHNjcmVlbjFZKSAvIDJdO1xuICAgIHRoaXMuI29uUGluY2hpbmc/LihvcmlnaW4sIHBEaXN0YW5jZSwgZGlzdGFuY2UpO1xuICB9XG4gICNvblRvdWNoRW5kKGV2dCkge1xuICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdG91Y2hNb3ZlQUMpIHtcbiAgICAgIHRoaXMuI3RvdWNoTW92ZUFDLmFib3J0KCk7XG4gICAgICB0aGlzLiN0b3VjaE1vdmVBQyA9IG51bGw7XG4gICAgICB0aGlzLiNvblBpbmNoRW5kPy4oKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiN0b3VjaEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2dCk7XG4gICAgdGhpcy4jdG91Y2hJbmZvID0gbnVsbDtcbiAgICB0aGlzLiNpc1BpbmNoaW5nID0gZmFsc2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiN0b3VjaE1hbmFnZXJBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiN0b3VjaE1hbmFnZXJBQyA9IG51bGw7XG4gICAgdGhpcy4jcG9pbnRlckRvd25BQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNwb2ludGVyRG93bkFDID0gbnVsbDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZWRpdG9yLmpzXG5cblxuXG5cblxuXG5cbmNsYXNzIEFubm90YXRpb25FZGl0b3Ige1xuICAjYWNjZXNzaWJpbGl0eURhdGEgPSBudWxsO1xuICAjYWxsUmVzaXplckRpdnMgPSBudWxsO1xuICAjYWx0VGV4dCA9IG51bGw7XG4gICNjb21tZW50ID0gbnVsbDtcbiAgI2Rpc2FibGVkID0gZmFsc2U7XG4gICNkcmFnUG9pbnRlcklkID0gbnVsbDtcbiAgI2RyYWdQb2ludGVyVHlwZSA9IFwiXCI7XG4gICNrZWVwQXNwZWN0UmF0aW8gPSBmYWxzZTtcbiAgI3Jlc2l6ZXJzRGl2ID0gbnVsbDtcbiAgI2xhc3RQb2ludGVyQ29vcmRzID0gbnVsbDtcbiAgI3NhdmVkRGltZW5zaW9ucyA9IG51bGw7XG4gICNmb2N1c0FDID0gbnVsbDtcbiAgI2ZvY3VzZWRSZXNpemVyTmFtZSA9IFwiXCI7XG4gICNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAjaW5pdGlhbFJlY3QgPSBudWxsO1xuICAjaXNFZGl0aW5nID0gZmFsc2U7XG4gICNpc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA9IGZhbHNlO1xuICAjbW92ZUluRE9NVGltZW91dCA9IG51bGw7XG4gICNwcmV2RHJhZ1ggPSAwO1xuICAjcHJldkRyYWdZID0gMDtcbiAgI3RlbGVtZXRyeVRpbWVvdXRzID0gbnVsbDtcbiAgI3RvdWNoTWFuYWdlciA9IG51bGw7XG4gIGlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgX2lzQ29weSA9IGZhbHNlO1xuICBfZWRpdFRvb2xiYXIgPSBudWxsO1xuICBfaW5pdGlhbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBfaW5pdGlhbERhdGEgPSBudWxsO1xuICBfaXNWaXNpYmxlID0gdHJ1ZTtcbiAgX3VpTWFuYWdlciA9IG51bGw7XG4gIF9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICBzdGF0aWMgX2wxMG4gPSBudWxsO1xuICBzdGF0aWMgX2wxMG5SZXNpemVyID0gbnVsbDtcbiAgI2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICN6SW5kZXggPSBBbm5vdGF0aW9uRWRpdG9yLl96SW5kZXgrKztcbiAgc3RhdGljIF9ib3JkZXJMaW5lV2lkdGggPSAtMTtcbiAgc3RhdGljIF9jb2xvck1hbmFnZXIgPSBuZXcgQ29sb3JNYW5hZ2VyKCk7XG4gIHN0YXRpYyBfekluZGV4ID0gMTtcbiAgc3RhdGljIF90ZWxlbWV0cnlUaW1lb3V0ID0gMTAwMDtcbiAgc3RhdGljIGdldCBfcmVzaXplcktleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCByZXNpemUgPSBBbm5vdGF0aW9uRWRpdG9yLnByb3RvdHlwZS5fcmVzaXplV2l0aEtleWJvYXJkO1xuICAgIGNvbnN0IHNtYWxsID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfcmVzaXplcktleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbLXNtYWxsLCAwXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0xlZnRcIiwgXCJtYWMrc2hpZnQrQXJyb3dMZWZ0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFstYmlnLCAwXVxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFtzbWFsbCwgMF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dSaWdodFwiLCBcIm1hYytzaGlmdCtBcnJvd1JpZ2h0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFtiaWcsIDBdXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIC1zbWFsbF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dVcFwiLCBcIm1hYytzaGlmdCtBcnJvd1VwXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCAtYmlnXVxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgc21hbGxdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93RG93blwiLCBcIm1hYytzaGlmdCtBcnJvd0Rvd25cIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIGJpZ11cbiAgICB9XSwgW1tcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIEFubm90YXRpb25FZGl0b3IucHJvdG90eXBlLl9zdG9wUmVzaXppbmdXaXRoS2V5Ym9hcmRdXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50O1xuICAgIHRoaXMuaWQgPSBwYXJhbWV0ZXJzLmlkO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IG51bGw7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYXJhbWV0ZXJzLnBhcmVudC5wYWdlSW5kZXg7XG4gICAgdGhpcy5uYW1lID0gcGFyYW1ldGVycy5uYW1lO1xuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLl91aU1hbmFnZXIgPSBwYXJhbWV0ZXJzLnVpTWFuYWdlcjtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBudWxsO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucy5pc0NlbnRlcmVkID0gcGFyYW1ldGVycy5pc0NlbnRlcmVkO1xuICAgIHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IG51bGw7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uRWxlbWVudElkIHx8IG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb24sXG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgcGFnZVgsXG4gICAgICAgIHBhZ2VZXG4gICAgICB9XG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLnBhZ2VSb3RhdGlvbiA9ICgzNjAgKyByb3RhdGlvbiAtIHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yb3RhdGlvbikgJSAzNjA7XG4gICAgdGhpcy5wYWdlRGltZW5zaW9ucyA9IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdO1xuICAgIHRoaXMucGFnZVRyYW5zbGF0aW9uID0gW3BhZ2VYLCBwYWdlWV07XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMueCA9IHBhcmFtZXRlcnMueCAvIHdpZHRoO1xuICAgIHRoaXMueSA9IHBhcmFtZXRlcnMueSAvIGhlaWdodDtcbiAgICB0aGlzLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICAgIHRoaXMuZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gIGdldCBlZGl0b3JUeXBlKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IuX3R5cGU7XG4gIH1cbiAgZ2V0IG1vZGUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvci5fZWRpdG9yVHlwZTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRHJhd2VyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgZ2V0IF9kZWZhdWx0TGluZUNvbG9yKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfZGVmYXVsdExpbmVDb2xvclwiLCB0aGlzLl9jb2xvck1hbmFnZXIuZ2V0SGV4Q29kZShcIkNhbnZhc1RleHRcIikpO1xuICB9XG4gIHN0YXRpYyBkZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICBjb25zdCBmYWtlRWRpdG9yID0gbmV3IEZha2VFZGl0b3Ioe1xuICAgICAgaWQ6IGVkaXRvci5wYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICBwYXJlbnQ6IGVkaXRvci5wYXJlbnQsXG4gICAgICB1aU1hbmFnZXI6IGVkaXRvci5fdWlNYW5hZ2VyXG4gICAgfSk7XG4gICAgZmFrZUVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgZmFrZUVkaXRvci5kZWxldGVkID0gdHJ1ZTtcbiAgICBmYWtlRWRpdG9yLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShmYWtlRWRpdG9yKTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCBfdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fbDEwbiA/Pz0gbDEwbjtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUmVzaXplciB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICB0b3BMZWZ0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLXRvcC1sZWZ0XCIsXG4gICAgICB0b3BNaWRkbGU6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItdG9wLW1pZGRsZVwiLFxuICAgICAgdG9wUmlnaHQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItdG9wLXJpZ2h0XCIsXG4gICAgICBtaWRkbGVSaWdodDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1taWRkbGUtcmlnaHRcIixcbiAgICAgIGJvdHRvbVJpZ2h0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLWJvdHRvbS1yaWdodFwiLFxuICAgICAgYm90dG9tTWlkZGxlOiBcInBkZmpzLWVkaXRvci1yZXNpemVyLWJvdHRvbS1taWRkbGVcIixcbiAgICAgIGJvdHRvbUxlZnQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItYm90dG9tLWxlZnRcIixcbiAgICAgIG1pZGRsZUxlZnQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItbWlkZGxlLWxlZnRcIlxuICAgIH0pO1xuICAgIGlmIChBbm5vdGF0aW9uRWRpdG9yLl9ib3JkZXJMaW5lV2lkdGggIT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIEFubm90YXRpb25FZGl0b3IuX2JvcmRlckxpbmVXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tb3V0bGluZS13aWR0aFwiKSkgfHwgMDtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyhfdHlwZSwgX3ZhbHVlKSB7fVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHN0YXRpYyBpc0hhbmRsaW5nTWltZUZvclBhc3RpbmcobWltZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgcGFzdGUoaXRlbSwgcGFyZW50KSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0IF9pc0RyYWdnYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNEcmFnZ2FibGU7XG4gIH1cbiAgc2V0IF9pc0RyYWdnYWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuI2lzRHJhZ2dhYmxlID0gdmFsdWU7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC50b2dnbGUoXCJkcmFnZ2FibGVcIiwgdmFsdWUpO1xuICB9XG4gIGdldCBpc0VudGVySGFuZGxlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjZW50ZXIoKSB7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnRSb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgdGhpcy54IC09IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAvIChwYWdlV2lkdGggKiAyKTtcbiAgICAgICAgdGhpcy55ICs9IHRoaXMud2lkdGggKiBwYWdlV2lkdGggLyAocGFnZUhlaWdodCAqIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB0aGlzLnggKz0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSArPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHRoaXMueCArPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgLyAocGFnZVdpZHRoICogMik7XG4gICAgICAgIHRoaXMueSAtPSB0aGlzLndpZHRoICogcGFnZVdpZHRoIC8gKHBhZ2VIZWlnaHQgKiAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnggLT0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSAtPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZENvbW1hbmRzKHBhcmFtcyk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLmN1cnJlbnRMYXllcjtcbiAgfVxuICBzZXRJbkJhY2tncm91bmQoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gMDtcbiAgfVxuICBzZXRJbkZvcmVncm91bmQoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gdGhpcy4jekluZGV4O1xuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhZ2VJbmRleCA9IHBhcmVudC5wYWdlSW5kZXg7XG4gICAgICB0aGlzLnBhZ2VEaW1lbnNpb25zID0gcGFyZW50LnBhZ2VEaW1lbnNpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaGFzQmVlbkNsaWNrZWQpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb2N1c291dChldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICBpZiAodGFyZ2V0Py5jbG9zZXN0KGAjJHt0aGlzLmlkfWApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCF0aGlzLnBhcmVudD8uaXNNdWx0aXBsZVNlbGVjdGlvbikge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBjb21taXRPclJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKCk7XG4gIH1cbiAgYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSh0aGlzKTtcbiAgfVxuICBzZXRBdCh4LCB5LCB0eCwgdHkpIHtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgW3R4LCB0eV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHR4LCB0eSk7XG4gICAgdGhpcy54ID0gKHggKyB0eCkgLyB3aWR0aDtcbiAgICB0aGlzLnkgPSAoeSArIHR5KSAvIGhlaWdodDtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgX21vdmVBZnRlclBhc3RlKGJhc2VYLCBiYXNlWSkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldEF0KGJhc2VYICogcGFyZW50V2lkdGgsIGJhc2VZICogcGFyZW50SGVpZ2h0LCB0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICB0aGlzLl9vblRyYW5zbGF0ZWQoKTtcbiAgfVxuICAjdHJhbnNsYXRlKFt3aWR0aCwgaGVpZ2h0XSwgeCwgeSkge1xuICAgIFt4LCB5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCwgeSk7XG4gICAgdGhpcy54ICs9IHggLyB3aWR0aDtcbiAgICB0aGlzLnkgKz0geSAvIGhlaWdodDtcbiAgICB0aGlzLl9vblRyYW5zbGF0aW5nKHRoaXMueCwgdGhpcy55KTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICB0aGlzLiN0cmFuc2xhdGUodGhpcy5wYXJlbnREaW1lbnNpb25zLCB4LCB5KTtcbiAgfVxuICB0cmFuc2xhdGVJblBhZ2UoeCwgeSkge1xuICAgIHRoaXMuI2luaXRpYWxSZWN0IHx8PSBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XTtcbiAgICB0aGlzLiN0cmFuc2xhdGUodGhpcy5wYWdlRGltZW5zaW9ucywgeCwgeSk7XG4gICAgdGhpcy5kaXYuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH1cbiAgdHJhbnNsYXRpb25Eb25lKCkge1xuICAgIHRoaXMuX29uVHJhbnNsYXRlZCh0aGlzLngsIHRoaXMueSk7XG4gIH1cbiAgZHJhZyh0eCwgdHkpIHtcbiAgICB0aGlzLiNpbml0aWFsUmVjdCB8fD0gW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF07XG4gICAgY29uc3Qge1xuICAgICAgZGl2LFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy54ICs9IHR4IC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy55ICs9IHR5IC8gcGFyZW50SGVpZ2h0O1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiAodGhpcy54IDwgMCB8fCB0aGlzLnggPiAxIHx8IHRoaXMueSA8IDAgfHwgdGhpcy55ID4gMSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHRoaXMucGFyZW50LmZpbmROZXdQYXJlbnQodGhpcywgeCwgeSkpIHtcbiAgICAgICAgdGhpcy54IC09IE1hdGguZmxvb3IodGhpcy54KTtcbiAgICAgICAgdGhpcy55IC09IE1hdGguZmxvb3IodGhpcy55KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgW2J4LCBieV0gPSB0aGlzLmdldEJhc2VUcmFuc2xhdGlvbigpO1xuICAgIHggKz0gYng7XG4gICAgeSArPSBieTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBkaXY7XG4gICAgc3R5bGUubGVmdCA9IGAkeygxMDAgKiB4KS50b0ZpeGVkKDIpfSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkeygxMDAgKiB5KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMuX29uVHJhbnNsYXRpbmcoeCwgeSk7XG4gICAgZGl2LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxuICAgIH0pO1xuICB9XG4gIF9vblRyYW5zbGF0aW5nKHgsIHkpIHt9XG4gIF9vblRyYW5zbGF0ZWQoeCwgeSkge31cbiAgZ2V0IF9oYXNCZWVuTW92ZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4jaW5pdGlhbFJlY3QgJiYgKHRoaXMuI2luaXRpYWxSZWN0WzBdICE9PSB0aGlzLnggfHwgdGhpcy4jaW5pdGlhbFJlY3RbMV0gIT09IHRoaXMueSk7XG4gIH1cbiAgZ2V0IF9oYXNCZWVuUmVzaXplZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLiNpbml0aWFsUmVjdCAmJiAodGhpcy4jaW5pdGlhbFJlY3RbMl0gIT09IHRoaXMud2lkdGggfHwgdGhpcy4jaW5pdGlhbFJlY3RbM10gIT09IHRoaXMuaGVpZ2h0KTtcbiAgfVxuICBnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIF9ib3JkZXJMaW5lV2lkdGhcbiAgICB9ID0gQW5ub3RhdGlvbkVkaXRvcjtcbiAgICBjb25zdCB4ID0gX2JvcmRlckxpbmVXaWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHkgPSBfYm9yZGVyTGluZVdpZHRoIC8gcGFyZW50SGVpZ2h0O1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsteCwgeV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3gsIC15XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbLXgsIC15XTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9tdXN0Rml4UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZml4QW5kU2V0UG9zaXRpb24ocm90YXRpb24gPSB0aGlzLnJvdGF0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2OiB7XG4gICAgICAgIHN0eWxlXG4gICAgICB9LFxuICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICB3aWR0aCAqPSBwYWdlV2lkdGg7XG4gICAgaGVpZ2h0ICo9IHBhZ2VIZWlnaHQ7XG4gICAgeCAqPSBwYWdlV2lkdGg7XG4gICAgeSAqPSBwYWdlSGVpZ2h0O1xuICAgIGlmICh0aGlzLl9tdXN0Rml4UG9zaXRpb24pIHtcbiAgICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHggPSBNYXRoQ2xhbXAoeCwgMCwgcGFnZVdpZHRoIC0gd2lkdGgpO1xuICAgICAgICAgIHkgPSBNYXRoQ2xhbXAoeSwgMCwgcGFnZUhlaWdodCAtIGhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgeCA9IE1hdGhDbGFtcCh4LCAwLCBwYWdlV2lkdGggLSBoZWlnaHQpO1xuICAgICAgICAgIHkgPSBNYXRoQ2xhbXAoeSwgd2lkdGgsIHBhZ2VIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgICB4ID0gTWF0aENsYW1wKHgsIHdpZHRoLCBwYWdlV2lkdGgpO1xuICAgICAgICAgIHkgPSBNYXRoQ2xhbXAoeSwgaGVpZ2h0LCBwYWdlSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgeCA9IE1hdGhDbGFtcCh4LCBoZWlnaHQsIHBhZ2VXaWR0aCk7XG4gICAgICAgICAgeSA9IE1hdGhDbGFtcCh5LCAwLCBwYWdlSGVpZ2h0IC0gd2lkdGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnggPSB4IC89IHBhZ2VXaWR0aDtcbiAgICB0aGlzLnkgPSB5IC89IHBhZ2VIZWlnaHQ7XG4gICAgY29uc3QgW2J4LCBieV0gPSB0aGlzLmdldEJhc2VUcmFuc2xhdGlvbigpO1xuICAgIHggKz0gYng7XG4gICAgeSArPSBieTtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIHgpLnRvRml4ZWQoMil9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7KDEwMCAqIHkpLnRvRml4ZWQoMil9JWA7XG4gICAgdGhpcy5tb3ZlSW5ET00oKTtcbiAgfVxuICBzdGF0aWMgI3JvdGF0ZVBvaW50KHgsIHksIGFuZ2xlKSB7XG4gICAgc3dpdGNoIChhbmdsZSkge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt5LCAteF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsteCwgLXldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbLXksIHhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gIH1cbiAgc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCwgeSkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yLiNyb3RhdGVQb2ludCh4LCB5LCB0aGlzLnBhcmVudFJvdGF0aW9uKTtcbiAgfVxuICBwYWdlVHJhbnNsYXRpb25Ub1NjcmVlbih4LCB5KSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3IuI3JvdGF0ZVBvaW50KHgsIHksIDM2MCAtIHRoaXMucGFyZW50Um90YXRpb24pO1xuICB9XG4gICNnZXRSb3RhdGlvbk1hdHJpeChyb3RhdGlvbikge1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICAgICAgcmV0dXJuIFswLCAtcGFnZVdpZHRoIC8gcGFnZUhlaWdodCwgcGFnZUhlaWdodCAvIHBhZ2VXaWR0aCwgMF07XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWy0xLCAwLCAwLCAtMV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgICByZXR1cm4gWzAsIHBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQsIC1wYWdlSGVpZ2h0IC8gcGFnZVdpZHRoLCAwXTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFsxLCAwLCAwLCAxXTtcbiAgICB9XG4gIH1cbiAgZ2V0IHBhcmVudFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlO1xuICB9XG4gIGdldCBwYXJlbnRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yb3RhdGlvbiArIHRoaXMucGFnZVJvdGF0aW9uKSAlIDM2MDtcbiAgfVxuICBnZXQgcGFyZW50RGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnRTY2FsZSxcbiAgICAgIHBhZ2VEaW1lbnNpb25zOiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBbcGFnZVdpZHRoICogcGFyZW50U2NhbGUsIHBhZ2VIZWlnaHQgKiBwYXJlbnRTY2FsZV07XG4gIH1cbiAgc2V0RGltcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIHN0eWxlLndpZHRoID0gYCR7KDEwMCAqIHdpZHRoIC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgaWYgKCF0aGlzLiNrZWVwQXNwZWN0UmF0aW8pIHtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGAkeygxMDAgKiBoZWlnaHQgLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICB9XG4gIGZpeERpbXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgY29uc3Qge1xuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGhcbiAgICB9ID0gc3R5bGU7XG4gICAgY29uc3Qgd2lkdGhQZXJjZW50ID0gd2lkdGguZW5kc1dpdGgoXCIlXCIpO1xuICAgIGNvbnN0IGhlaWdodFBlcmNlbnQgPSAhdGhpcy4ja2VlcEFzcGVjdFJhdGlvICYmIGhlaWdodC5lbmRzV2l0aChcIiVcIik7XG4gICAgaWYgKHdpZHRoUGVyY2VudCAmJiBoZWlnaHRQZXJjZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBpZiAoIXdpZHRoUGVyY2VudCkge1xuICAgICAgc3R5bGUud2lkdGggPSBgJHsoMTAwICogcGFyc2VGbG9hdCh3aWR0aCkgLyBwYXJlbnRXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNrZWVwQXNwZWN0UmF0aW8gJiYgIWhlaWdodFBlcmNlbnQpIHtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGAkeygxMDAgKiBwYXJzZUZsb2F0KGhlaWdodCkgLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICB9XG4gIGdldEluaXRpYWxUcmFuc2xhdGlvbigpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gICNjcmVhdGVSZXNpemVycygpIHtcbiAgICBpZiAodGhpcy4jcmVzaXplcnNEaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcmVzaXplcnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmNsYXNzTGlzdC5hZGQoXCJyZXNpemVyc1wiKTtcbiAgICBjb25zdCBjbGFzc2VzID0gdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA/IFtcInRvcExlZnRcIiwgXCJ0b3BSaWdodFwiLCBcImJvdHRvbVJpZ2h0XCIsIFwiYm90dG9tTGVmdFwiXSA6IFtcInRvcExlZnRcIiwgXCJ0b3BNaWRkbGVcIiwgXCJ0b3BSaWdodFwiLCBcIm1pZGRsZVJpZ2h0XCIsIFwiYm90dG9tUmlnaHRcIiwgXCJib3R0b21NaWRkbGVcIiwgXCJib3R0b21MZWZ0XCIsIFwibWlkZGxlTGVmdFwiXTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgY2xhc3Nlcykge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmFwcGVuZChkaXYpO1xuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoXCJyZXNpemVyXCIsIG5hbWUpO1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtcmVzaXplci1uYW1lXCIsIG5hbWUpO1xuICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNyZXNpemVyUG9pbnRlcmRvd24uYmluZCh0aGlzLCBuYW1lKSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBkaXYudGFiSW5kZXggPSAtMTtcbiAgICB9XG4gICAgdGhpcy5kaXYucHJlcGVuZCh0aGlzLiNyZXNpemVyc0Rpdik7XG4gIH1cbiAgI3Jlc2l6ZXJQb2ludGVyZG93bihuYW1lLCBldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlKGZhbHNlKTtcbiAgICBjb25zdCBzYXZlZERyYWdnYWJsZSA9IHRoaXMuX2lzRHJhZ2dhYmxlO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgdGhpcy4jbGFzdFBvaW50ZXJDb29yZHMgPSBbZXZlbnQuc2NyZWVuWCwgZXZlbnQuc2NyZWVuWV07XG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuI3Jlc2l6ZXJQb2ludGVybW92ZS5iaW5kKHRoaXMsIG5hbWUpLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHN0b3BFdmVudCwge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuI3NhdmVkRGltZW5zaW9ucyA9IHtcbiAgICAgIHNhdmVkWDogdGhpcy54LFxuICAgICAgc2F2ZWRZOiB0aGlzLnksXG4gICAgICBzYXZlZFdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgc2F2ZWRIZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBzYXZlZFBhcmVudEN1cnNvciA9IHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3I7XG4gICAgY29uc3Qgc2F2ZWRDdXJzb3IgPSB0aGlzLmRpdi5zdHlsZS5jdXJzb3I7XG4gICAgdGhpcy5kaXYuc3R5bGUuY3Vyc29yID0gdGhpcy5wYXJlbnQuZGl2LnN0eWxlLmN1cnNvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGV2ZW50LnRhcmdldCkuY3Vyc29yO1xuICAgIGNvbnN0IHBvaW50ZXJVcENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgYWMuYWJvcnQoKTtcbiAgICAgIHRoaXMucGFyZW50LnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGUodHJ1ZSk7XG4gICAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHNhdmVkRHJhZ2dhYmxlO1xuICAgICAgdGhpcy5wYXJlbnQuZGl2LnN0eWxlLmN1cnNvciA9IHNhdmVkUGFyZW50Q3Vyc29yO1xuICAgICAgdGhpcy5kaXYuc3R5bGUuY3Vyc29yID0gc2F2ZWRDdXJzb3I7XG4gICAgICB0aGlzLiNhZGRSZXNpemVUb1VuZG9TdGFjaygpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI3Jlc2l6ZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXREaW1zKHBhcmVudFdpZHRoICogd2lkdGgsIHBhcmVudEhlaWdodCAqIGhlaWdodCk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIHRoaXMuX29uUmVzaXplZCgpO1xuICB9XG4gIF9vblJlc2l6ZWQoKSB7fVxuICAjYWRkUmVzaXplVG9VbmRvU3RhY2soKSB7XG4gICAgaWYgKCF0aGlzLiNzYXZlZERpbWVuc2lvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc2F2ZWRYLFxuICAgICAgc2F2ZWRZLFxuICAgICAgc2F2ZWRXaWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0XG4gICAgfSA9IHRoaXMuI3NhdmVkRGltZW5zaW9ucztcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSBudWxsO1xuICAgIGNvbnN0IG5ld1ggPSB0aGlzLng7XG4gICAgY29uc3QgbmV3WSA9IHRoaXMueTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgaWYgKG5ld1ggPT09IHNhdmVkWCAmJiBuZXdZID09PSBzYXZlZFkgJiYgbmV3V2lkdGggPT09IHNhdmVkV2lkdGggJiYgbmV3SGVpZ2h0ID09PSBzYXZlZEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogdGhpcy4jcmVzaXplLmJpbmQodGhpcywgbmV3WCwgbmV3WSwgbmV3V2lkdGgsIG5ld0hlaWdodCksXG4gICAgICB1bmRvOiB0aGlzLiNyZXNpemUuYmluZCh0aGlzLCBzYXZlZFgsIHNhdmVkWSwgc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpLFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgX3JvdW5kKHgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh4ICogMTAwMDApIC8gMTAwMDA7XG4gIH1cbiAgI3Jlc2l6ZXJQb2ludGVybW92ZShuYW1lLCBldmVudCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluV2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgbWluSGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudEhlaWdodDtcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IHRyYW5zZiA9ICh4LCB5KSA9PiBbcm90YXRpb25NYXRyaXhbMF0gKiB4ICsgcm90YXRpb25NYXRyaXhbMl0gKiB5LCByb3RhdGlvbk1hdHJpeFsxXSAqIHggKyByb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGNvbnN0IGludlJvdGF0aW9uTWF0cml4ID0gdGhpcy4jZ2V0Um90YXRpb25NYXRyaXgoMzYwIC0gdGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgaW52VHJhbnNmID0gKHgsIHkpID0+IFtpbnZSb3RhdGlvbk1hdHJpeFswXSAqIHggKyBpbnZSb3RhdGlvbk1hdHJpeFsyXSAqIHksIGludlJvdGF0aW9uTWF0cml4WzFdICogeCArIGludlJvdGF0aW9uTWF0cml4WzNdICogeV07XG4gICAgbGV0IGdldFBvaW50O1xuICAgIGxldCBnZXRPcHBvc2l0ZTtcbiAgICBsZXQgaXNEaWFnb25hbCA9IGZhbHNlO1xuICAgIGxldCBpc0hvcml6b250YWwgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJ0b3BMZWZ0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbMCwgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9wTWlkZGxlXCI6XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3IC8gMiwgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3IC8gMiwgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcFJpZ2h0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWlkZGxlUmlnaHRcIjpcbiAgICAgICAgaXNIb3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIGggLyAyXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIGggLyAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tUmlnaHRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21NaWRkbGVcIjpcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3cgLyAyLCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3cgLyAyLCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tTGVmdFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIGhdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZUxlZnRcIjpcbiAgICAgICAgaXNIb3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIGggLyAyXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIGggLyAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ID0gZ2V0UG9pbnQoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIGNvbnN0IG9wcG9zaXRlUG9pbnQgPSBnZXRPcHBvc2l0ZShzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgbGV0IHRyYW5zZk9wcG9zaXRlUG9pbnQgPSB0cmFuc2YoLi4ub3Bwb3NpdGVQb2ludCk7XG4gICAgY29uc3Qgb3Bwb3NpdGVYID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRYICsgdHJhbnNmT3Bwb3NpdGVQb2ludFswXSk7XG4gICAgY29uc3Qgb3Bwb3NpdGVZID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRZICsgdHJhbnNmT3Bwb3NpdGVQb2ludFsxXSk7XG4gICAgbGV0IHJhdGlvWCA9IDE7XG4gICAgbGV0IHJhdGlvWSA9IDE7XG4gICAgbGV0IGRlbHRhWCwgZGVsdGFZO1xuICAgIGlmICghZXZlbnQuZnJvbUtleWJvYXJkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNjcmVlblgsXG4gICAgICAgIHNjcmVlbllcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIGNvbnN0IFtsYXN0U2NyZWVuWCwgbGFzdFNjcmVlblldID0gdGhpcy4jbGFzdFBvaW50ZXJDb29yZHM7XG4gICAgICBbZGVsdGFYLCBkZWx0YVldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbihzY3JlZW5YIC0gbGFzdFNjcmVlblgsIHNjcmVlblkgLSBsYXN0U2NyZWVuWSk7XG4gICAgICB0aGlzLiNsYXN0UG9pbnRlckNvb3Jkc1swXSA9IHNjcmVlblg7XG4gICAgICB0aGlzLiNsYXN0UG9pbnRlckNvb3Jkc1sxXSA9IHNjcmVlblk7XG4gICAgfSBlbHNlIHtcbiAgICAgICh7XG4gICAgICAgIGRlbHRhWCxcbiAgICAgICAgZGVsdGFZXG4gICAgICB9ID0gZXZlbnQpO1xuICAgIH1cbiAgICBbZGVsdGFYLCBkZWx0YVldID0gaW52VHJhbnNmKGRlbHRhWCAvIHBhcmVudFdpZHRoLCBkZWx0YVkgLyBwYXJlbnRIZWlnaHQpO1xuICAgIGlmIChpc0RpYWdvbmFsKSB7XG4gICAgICBjb25zdCBvbGREaWFnID0gTWF0aC5oeXBvdChzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgICByYXRpb1ggPSByYXRpb1kgPSBNYXRoLm1heChNYXRoLm1pbihNYXRoLmh5cG90KG9wcG9zaXRlUG9pbnRbMF0gLSBwb2ludFswXSAtIGRlbHRhWCwgb3Bwb3NpdGVQb2ludFsxXSAtIHBvaW50WzFdIC0gZGVsdGFZKSAvIG9sZERpYWcsIDEgLyBzYXZlZFdpZHRoLCAxIC8gc2F2ZWRIZWlnaHQpLCBtaW5XaWR0aCAvIHNhdmVkV2lkdGgsIG1pbkhlaWdodCAvIHNhdmVkSGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgcmF0aW9YID0gTWF0aENsYW1wKE1hdGguYWJzKG9wcG9zaXRlUG9pbnRbMF0gLSBwb2ludFswXSAtIGRlbHRhWCksIG1pbldpZHRoLCAxKSAvIHNhdmVkV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhdGlvWSA9IE1hdGhDbGFtcChNYXRoLmFicyhvcHBvc2l0ZVBvaW50WzFdIC0gcG9pbnRbMV0gLSBkZWx0YVkpLCBtaW5IZWlnaHQsIDEpIC8gc2F2ZWRIZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IG5ld1dpZHRoID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRXaWR0aCAqIHJhdGlvWCk7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRIZWlnaHQgKiByYXRpb1kpO1xuICAgIHRyYW5zZk9wcG9zaXRlUG9pbnQgPSB0cmFuc2YoLi4uZ2V0T3Bwb3NpdGUobmV3V2lkdGgsIG5ld0hlaWdodCkpO1xuICAgIGNvbnN0IG5ld1ggPSBvcHBvc2l0ZVggLSB0cmFuc2ZPcHBvc2l0ZVBvaW50WzBdO1xuICAgIGNvbnN0IG5ld1kgPSBvcHBvc2l0ZVkgLSB0cmFuc2ZPcHBvc2l0ZVBvaW50WzFdO1xuICAgIHRoaXMuI2luaXRpYWxSZWN0IHx8PSBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XTtcbiAgICB0aGlzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgdGhpcy54ID0gbmV3WDtcbiAgICB0aGlzLnkgPSBuZXdZO1xuICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIG5ld1dpZHRoLCBwYXJlbnRIZWlnaHQgKiBuZXdIZWlnaHQpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblJlc2l6aW5nKCk7XG4gIH1cbiAgX29uUmVzaXppbmcoKSB7fVxuICBhbHRUZXh0RmluaXNoKCkge1xuICAgIHRoaXMuI2FsdFRleHQ/LmZpbmlzaCgpO1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBhc3luYyBhZGRFZGl0VG9vbGJhcigpIHtcbiAgICBpZiAodGhpcy5fZWRpdFRvb2xiYXIgfHwgdGhpcy4jaXNJbkVkaXRNb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWRpdFRvb2xiYXI7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyID0gbmV3IEVkaXRvclRvb2xiYXIodGhpcyk7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuX2VkaXRUb29sYmFyLnJlbmRlcigpKTtcbiAgICBjb25zdCB7XG4gICAgICB0b29sYmFyQnV0dG9uc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICh0b29sYmFyQnV0dG9ucykge1xuICAgICAgZm9yIChjb25zdCBbbmFtZSwgdG9vbF0gb2YgdG9vbGJhckJ1dHRvbnMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fZWRpdFRvb2xiYXIuYWRkQnV0dG9uKG5hbWUsIHRvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9lZGl0VG9vbGJhci5hZGRCdXR0b24oXCJjb21tZW50XCIsIHRoaXMuYWRkQ29tbWVudEJ1dHRvbigpKTtcbiAgICB0aGlzLl9lZGl0VG9vbGJhci5hZGRCdXR0b24oXCJkZWxldGVcIik7XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRUb29sYmFyO1xuICB9XG4gIHJlbW92ZUVkaXRUb29sYmFyKCkge1xuICAgIGlmICghdGhpcy5fZWRpdFRvb2xiYXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZWRpdFRvb2xiYXIucmVtb3ZlKCk7XG4gICAgdGhpcy5fZWRpdFRvb2xiYXIgPSBudWxsO1xuICAgIHRoaXMuI2FsdFRleHQ/LmRlc3Ryb3koKTtcbiAgfVxuICBhZGRDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXJEaXYgPSB0aGlzLl9lZGl0VG9vbGJhcj8uZGl2O1xuICAgIGlmIChlZGl0VG9vbGJhckRpdikge1xuICAgICAgZWRpdFRvb2xiYXJEaXYuYmVmb3JlKGNvbnRhaW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChjb250YWluZXIpO1xuICAgIH1cbiAgfVxuICBnZXRDbGllbnREaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICBjcmVhdGVBbHRUZXh0KCkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dCkge1xuICAgICAgQWx0VGV4dC5pbml0aWFsaXplKEFubm90YXRpb25FZGl0b3IuX2wxMG4pO1xuICAgICAgdGhpcy4jYWx0VGV4dCA9IG5ldyBBbHRUZXh0KHRoaXMpO1xuICAgICAgaWYgKHRoaXMuI2FjY2Vzc2liaWxpdHlEYXRhKSB7XG4gICAgICAgIHRoaXMuI2FsdFRleHQuZGF0YSA9IHRoaXMuI2FjY2Vzc2liaWxpdHlEYXRhO1xuICAgICAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5RGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0O1xuICB9XG4gIGdldCBhbHRUZXh0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uZGF0YTtcbiAgfVxuICBzZXQgYWx0VGV4dERhdGEoZGF0YSkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0LmRhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBndWVzc2VkQWx0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uZ3Vlc3NlZFRleHQ7XG4gIH1cbiAgYXN5bmMgc2V0R3Vlc3NlZEFsdFRleHQodGV4dCkge1xuICAgIGF3YWl0IHRoaXMuI2FsdFRleHQ/LnNldEd1ZXNzZWRUZXh0KHRleHQpO1xuICB9XG4gIHNlcmlhbGl6ZUFsdFRleHQoaXNGb3JDb3B5aW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/LnNlcmlhbGl6ZShpc0ZvckNvcHlpbmcpO1xuICB9XG4gIGhhc0FsdFRleHQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4jYWx0VGV4dCAmJiAhdGhpcy4jYWx0VGV4dC5pc0VtcHR5KCk7XG4gIH1cbiAgaGFzQWx0VGV4dERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/Lmhhc0RhdGEoKSA/PyBmYWxzZTtcbiAgfVxuICBhZGRDb21tZW50QnV0dG9uKCkge1xuICAgIGlmICh0aGlzLiNjb21tZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy4jY29tbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnQgPSBuZXcgQ29tbWVudCh0aGlzKTtcbiAgfVxuICBnZXQgY29tbWVudENvbG9yKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBjb21tZW50KCkge1xuICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLiNjb21tZW50O1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiBjb21tZW50LmRhdGEudGV4dCxcbiAgICAgIGRhdGU6IGNvbW1lbnQuZGF0YS5kYXRlLFxuICAgICAgZGVsZXRlZDogY29tbWVudC5pc0RlbGV0ZWQoKSxcbiAgICAgIGNvbG9yOiB0aGlzLmNvbW1lbnRDb2xvclxuICAgIH07XG4gIH1cbiAgc2V0IGNvbW1lbnQodGV4dCkge1xuICAgIGlmICghdGhpcy4jY29tbWVudCkge1xuICAgICAgdGhpcy4jY29tbWVudCA9IG5ldyBDb21tZW50KHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50LmRhdGEgPSB0ZXh0O1xuICB9XG4gIHNldENvbW1lbnREYXRhKHRleHQpIHtcbiAgICBpZiAoIXRoaXMuI2NvbW1lbnQpIHtcbiAgICAgIHRoaXMuI2NvbW1lbnQgPSBuZXcgQ29tbWVudCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudC5zZXRJbml0aWFsVGV4dCh0ZXh0KTtcbiAgfVxuICBnZXQgaGFzRWRpdGVkQ29tbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29tbWVudD8uaGFzQmVlbkVkaXRlZCgpO1xuICB9XG4gIGFzeW5jIGVkaXRDb21tZW50KCkge1xuICAgIGlmICghdGhpcy4jY29tbWVudCkge1xuICAgICAgdGhpcy4jY29tbWVudCA9IG5ldyBDb21tZW50KHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50LmVkaXQoKTtcbiAgfVxuICBhZGRDb21tZW50KHNlcmlhbGl6ZWQpIHtcbiAgICBpZiAodGhpcy5oYXNFZGl0ZWRDb21tZW50KSB7XG4gICAgICBjb25zdCBERUZBVUxUX1BPUFVQX1dJRFRIID0gMTgwO1xuICAgICAgY29uc3QgREVGQVVMVF9QT1BVUF9IRUlHSFQgPSAxMDA7XG4gICAgICBjb25zdCBbLCwsIHRyWV0gPSBzZXJpYWxpemVkLnJlY3Q7XG4gICAgICBjb25zdCBbcGFnZVdpZHRoXSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICBjb25zdCBbcGFnZVhdID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgICBjb25zdCBibFggPSBwYWdlWCArIHBhZ2VXaWR0aCArIDE7XG4gICAgICBjb25zdCBibFkgPSB0clkgLSBERUZBVUxUX1BPUFVQX0hFSUdIVDtcbiAgICAgIGNvbnN0IHRyWCA9IGJsWCArIERFRkFVTFRfUE9QVVBfV0lEVEg7XG4gICAgICBzZXJpYWxpemVkLnBvcHVwID0ge1xuICAgICAgICBjb250ZW50czogdGhpcy5jb21tZW50LnRleHQsXG4gICAgICAgIGRlbGV0ZWQ6IHRoaXMuY29tbWVudC5kZWxldGVkLFxuICAgICAgICByZWN0OiBbYmxYLCBibFksIHRyWCwgdHJZXVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGRpdiA9IHRoaXMuZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1lZGl0b3Itcm90YXRpb25cIiwgKDM2MCAtIHRoaXMucm90YXRpb24pICUgMzYwKTtcbiAgICBkaXYuY2xhc3NOYW1lID0gdGhpcy5uYW1lO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB0aGlzLmlkKTtcbiAgICBkaXYudGFiSW5kZXggPSB0aGlzLiNkaXNhYmxlZCA/IC0xIDogMDtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImFwcGxpY2F0aW9uXCIpO1xuICAgIGlmICh0aGlzLmRlZmF1bHRMMTBuSWQpIHtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgdGhpcy5kZWZhdWx0TDEwbklkKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUpIHtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIH1cbiAgICB0aGlzLnNldEluRm9yZWdyb3VuZCgpO1xuICAgIHRoaXMuI2FkZEZvY3VzTGlzdGVuZXJzKCk7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGlmICh0aGlzLnBhcmVudFJvdGF0aW9uICUgMTgwICE9PSAwKSB7XG4gICAgICBkaXYuc3R5bGUubWF4V2lkdGggPSBgJHsoMTAwICogcGFyZW50SGVpZ2h0IC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgICBkaXYuc3R5bGUubWF4SGVpZ2h0ID0gYCR7KDEwMCAqIHBhcmVudFdpZHRoIC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCk7XG4gICAgdGhpcy50cmFuc2xhdGUodHgsIHR5KTtcbiAgICBiaW5kRXZlbnRzKHRoaXMsIGRpdiwgW1wia2V5ZG93blwiLCBcInBvaW50ZXJkb3duXCIsIFwiZGJsY2xpY2tcIl0pO1xuICAgIGlmICh0aGlzLmlzUmVzaXphYmxlICYmIHRoaXMuX3VpTWFuYWdlci5fc3VwcG9ydHNQaW5jaFRvWm9vbSkge1xuICAgICAgdGhpcy4jdG91Y2hNYW5hZ2VyIHx8PSBuZXcgVG91Y2hNYW5hZ2VyKHtcbiAgICAgICAgY29udGFpbmVyOiBkaXYsXG4gICAgICAgIGlzUGluY2hpbmdEaXNhYmxlZDogKCkgPT4gIXRoaXMuaXNTZWxlY3RlZCxcbiAgICAgICAgb25QaW5jaFN0YXJ0OiB0aGlzLiN0b3VjaFBpbmNoU3RhcnRDYWxsYmFjay5iaW5kKHRoaXMpLFxuICAgICAgICBvblBpbmNoaW5nOiB0aGlzLiN0b3VjaFBpbmNoQ2FsbGJhY2suYmluZCh0aGlzKSxcbiAgICAgICAgb25QaW5jaEVuZDogdGhpcy4jdG91Y2hQaW5jaEVuZENhbGxiYWNrLmJpbmQodGhpcyksXG4gICAgICAgIHNpZ25hbDogdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl91aU1hbmFnZXIuX2VkaXRvclVuZG9CYXI/LmhpZGUoKTtcbiAgICByZXR1cm4gZGl2O1xuICB9XG4gICN0b3VjaFBpbmNoU3RhcnRDYWxsYmFjaygpIHtcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSB7XG4gICAgICBzYXZlZFg6IHRoaXMueCxcbiAgICAgIHNhdmVkWTogdGhpcy55LFxuICAgICAgc2F2ZWRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlKGZhbHNlKTtcbiAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgfVxuICAjdG91Y2hQaW5jaENhbGxiYWNrKF9vcmlnaW4sIHByZXZEaXN0YW5jZSwgZGlzdGFuY2UpIHtcbiAgICBjb25zdCBzbG93RG93bkZhY3RvciA9IDAuNztcbiAgICBsZXQgZmFjdG9yID0gc2xvd0Rvd25GYWN0b3IgKiAoZGlzdGFuY2UgLyBwcmV2RGlzdGFuY2UpICsgMSAtIHNsb3dEb3duRmFjdG9yO1xuICAgIGlmIChmYWN0b3IgPT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSB0aGlzLiNnZXRSb3RhdGlvbk1hdHJpeCh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCB0cmFuc2YgPSAoeCwgeSkgPT4gW3JvdGF0aW9uTWF0cml4WzBdICogeCArIHJvdGF0aW9uTWF0cml4WzJdICogeSwgcm90YXRpb25NYXRyaXhbMV0gKiB4ICsgcm90YXRpb25NYXRyaXhbM10gKiB5XTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qgc2F2ZWRYID0gdGhpcy54O1xuICAgIGNvbnN0IHNhdmVkWSA9IHRoaXMueTtcbiAgICBjb25zdCBzYXZlZFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBzYXZlZEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG1pbldpZHRoID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IG1pbkhlaWdodCA9IEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUgLyBwYXJlbnRIZWlnaHQ7XG4gICAgZmFjdG9yID0gTWF0aC5tYXgoTWF0aC5taW4oZmFjdG9yLCAxIC8gc2F2ZWRXaWR0aCwgMSAvIHNhdmVkSGVpZ2h0KSwgbWluV2lkdGggLyBzYXZlZFdpZHRoLCBtaW5IZWlnaHQgLyBzYXZlZEhlaWdodCk7XG4gICAgY29uc3QgbmV3V2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZFdpZHRoICogZmFjdG9yKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZEhlaWdodCAqIGZhY3Rvcik7XG4gICAgaWYgKG5ld1dpZHRoID09PSBzYXZlZFdpZHRoICYmIG5ld0hlaWdodCA9PT0gc2F2ZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaW5pdGlhbFJlY3QgfHw9IFtzYXZlZFgsIHNhdmVkWSwgc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHRdO1xuICAgIGNvbnN0IHRyYW5zZkNlbnRlclBvaW50ID0gdHJhbnNmKHNhdmVkV2lkdGggLyAyLCBzYXZlZEhlaWdodCAvIDIpO1xuICAgIGNvbnN0IGNlbnRlclggPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZFggKyB0cmFuc2ZDZW50ZXJQb2ludFswXSk7XG4gICAgY29uc3QgY2VudGVyWSA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkWSArIHRyYW5zZkNlbnRlclBvaW50WzFdKTtcbiAgICBjb25zdCBuZXdUcmFuc2ZDZW50ZXJQb2ludCA9IHRyYW5zZihuZXdXaWR0aCAvIDIsIG5ld0hlaWdodCAvIDIpO1xuICAgIHRoaXMueCA9IGNlbnRlclggLSBuZXdUcmFuc2ZDZW50ZXJQb2ludFswXTtcbiAgICB0aGlzLnkgPSBjZW50ZXJZIC0gbmV3VHJhbnNmQ2VudGVyUG9pbnRbMV07XG4gICAgdGhpcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIG5ld1dpZHRoLCBwYXJlbnRIZWlnaHQgKiBuZXdIZWlnaHQpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblJlc2l6aW5nKCk7XG4gIH1cbiAgI3RvdWNoUGluY2hFbmRDYWxsYmFjaygpIHtcbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGUodHJ1ZSk7XG4gICAgdGhpcy5wYXJlbnQudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICB0aGlzLiNhZGRSZXNpemVUb1VuZG9TdGFjaygpO1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5faXNEcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuI3NldFVwRHJhZ1Nlc3Npb24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RPblBvaW50ZXJFdmVudChldmVudCk7XG4gIH1cbiAgI3NlbGVjdE9uUG9pbnRlckV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuY3RybEtleSAmJiAhaXNNYWMgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQubWV0YUtleSAmJiBpc01hYykge1xuICAgICAgdGhpcy5wYXJlbnQudG9nZ2xlU2VsZWN0ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH1cbiAgfVxuICAjc2V0VXBEcmFnU2Vzc2lvbihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzU2VsZWN0ZWRcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLl91aU1hbmFnZXIuc2V0VXBEcmFnU2Vzc2lvbigpO1xuICAgIGxldCBoYXNEcmFnZ2luZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWxcbiAgICB9O1xuICAgIGNvbnN0IGNhbmNlbERyYWcgPSBlID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICB0aGlzLiNkcmFnUG9pbnRlcklkID0gbnVsbDtcbiAgICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICAgICBpZiAoIXRoaXMuX3VpTWFuYWdlci5lbmREcmFnU2Vzc2lvbigpKSB7XG4gICAgICAgIHRoaXMuI3NlbGVjdE9uUG9pbnRlckV2ZW50KGUpO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0RyYWdnaW5nU3RhcnRlZCkge1xuICAgICAgICB0aGlzLl9vblN0b3BEcmFnZ2luZygpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuI3ByZXZEcmFnWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICB0aGlzLiNwcmV2RHJhZ1kgPSBldmVudC5jbGllbnRZO1xuICAgICAgdGhpcy4jZHJhZ1BvaW50ZXJJZCA9IGV2ZW50LnBvaW50ZXJJZDtcbiAgICAgIHRoaXMuI2RyYWdQb2ludGVyVHlwZSA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBlID0+IHtcbiAgICAgICAgaWYgKCFoYXNEcmFnZ2luZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICBoYXNEcmFnZ2luZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX29uU3RhcnREcmFnZ2luZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjbGllbnRYOiB4LFxuICAgICAgICAgIGNsaWVudFk6IHksXG4gICAgICAgICAgcG9pbnRlcklkXG4gICAgICAgIH0gPSBlO1xuICAgICAgICBpZiAocG9pbnRlcklkICE9PSB0aGlzLiNkcmFnUG9pbnRlcklkKSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCAtIHRoaXMuI3ByZXZEcmFnWCwgeSAtIHRoaXMuI3ByZXZEcmFnWSk7XG4gICAgICAgIHRoaXMuI3ByZXZEcmFnWCA9IHg7XG4gICAgICAgIHRoaXMuI3ByZXZEcmFnWSA9IHk7XG4gICAgICAgIHRoaXMuX3VpTWFuYWdlci5kcmFnU2VsZWN0ZWRFZGl0b3JzKHR4LCB0eSk7XG4gICAgICB9LCBvcHRzKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHN0b3BFdmVudCwgb3B0cyk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGUgPT4ge1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gdGhpcy4jZHJhZ1BvaW50ZXJUeXBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuI3RvdWNoTWFuYWdlciB8fCBlLmlzUHJpbWFyeSkge1xuICAgICAgICAgICAgY2FuY2VsRHJhZyhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgfSwgb3B0cyk7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ZXJVcENhbGxiYWNrID0gZSA9PiB7XG4gICAgICBpZiAoIXRoaXMuI2RyYWdQb2ludGVySWQgfHwgdGhpcy4jZHJhZ1BvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcbiAgICAgICAgY2FuY2VsRHJhZyhlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RvcEV2ZW50KGUpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgX29uU3RhcnREcmFnZ2luZygpIHt9XG4gIF9vblN0b3BEcmFnZ2luZygpIHt9XG4gIG1vdmVJbkRPTSgpIHtcbiAgICBpZiAodGhpcy4jbW92ZUluRE9NVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpO1xuICAgIH1cbiAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMucGFyZW50Py5tb3ZlRWRpdG9ySW5ET00odGhpcyk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX3NldFBhcmVudEFuZFBvc2l0aW9uKHBhcmVudCwgeCwgeSkge1xuICAgIHBhcmVudC5jaGFuZ2VQYXJlbnQodGhpcyk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblRyYW5zbGF0ZWQoKTtcbiAgfVxuICBnZXRSZWN0KHR4LCB0eSwgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IHNoaWZ0WCA9IHR4IC8gc2NhbGU7XG4gICAgY29uc3Qgc2hpZnRZID0gdHkgLyBzY2FsZTtcbiAgICBjb25zdCB4ID0gdGhpcy54ICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IHkgPSB0aGlzLnkgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW3ggKyBzaGlmdFggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFkgLSBoZWlnaHQgKyBwYWdlWSwgeCArIHNoaWZ0WCArIHdpZHRoICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRZICsgcGFnZVldO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt4ICsgc2hpZnRZICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRYICsgcGFnZVksIHggKyBzaGlmdFkgKyBoZWlnaHQgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFggKyB3aWR0aCArIHBhZ2VZXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3ggLSBzaGlmdFggLSB3aWR0aCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WSArIHBhZ2VZLCB4IC0gc2hpZnRYICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRZICsgaGVpZ2h0ICsgcGFnZVldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeCAtIHNoaWZ0WSAtIGhlaWdodCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WCAtIHdpZHRoICsgcGFnZVksIHggLSBzaGlmdFkgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFggKyBwYWdlWV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBnZXRSZWN0SW5DdXJyZW50Q29vcmRzKHJlY3QsIHBhZ2VIZWlnaHQpIHtcbiAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTJdID0gcmVjdDtcbiAgICBjb25zdCB3aWR0aCA9IHgyIC0geDE7XG4gICAgY29uc3QgaGVpZ2h0ID0geTIgLSB5MTtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFt4MSwgcGFnZUhlaWdodCAtIHkyLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeDEsIHBhZ2VIZWlnaHQgLSB5MSwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4MiwgcGFnZUhlaWdodCAtIHkxLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3gyLCBwYWdlSGVpZ2h0IC0geTIsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0UERGUmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZWN0KDAsIDApO1xuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge31cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKGZhbHNlKTtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIHRoaXMuI2lzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlzSW5FZGl0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNJbkVkaXRNb2RlO1xuICB9XG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQ7XG4gIH1cbiAgbmVlZHNUb0JlUmVidWlsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYgJiYgIXRoaXMuaXNBdHRhY2hlZFRvRE9NO1xuICB9XG4gIGdldCBpc09uU2NyZWVuKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICBib3R0b20sXG4gICAgICByaWdodFxuICAgIH0gPSB0aGlzLmdldENsaWVudERpbWVuc2lvbnMoKTtcbiAgICBjb25zdCB7XG4gICAgICBpbm5lckhlaWdodCxcbiAgICAgIGlubmVyV2lkdGhcbiAgICB9ID0gd2luZG93O1xuICAgIHJldHVybiBsZWZ0IDwgaW5uZXJXaWR0aCAmJiByaWdodCA+IDAgJiYgdG9wIDwgaW5uZXJIZWlnaHQgJiYgYm90dG9tID4gMDtcbiAgfVxuICAjYWRkRm9jdXNMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuI2ZvY3VzQUMgfHwgIXRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2ZvY3VzQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2ZvY3VzQUMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuZm9jdXNpbi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy5mb2N1c291dC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIHRoaXMuI2FkZEZvY3VzTGlzdGVuZXJzKCk7XG4gIH1cbiAgcm90YXRlKF9hbmdsZSkge31cbiAgcmVzaXplKCkge31cbiAgc2VyaWFsaXplRGVsZXRlZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgIGRlbGV0ZWQ6IHRydWUsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcG9wdXBSZWY6IHRoaXMuX2luaXRpYWxEYXRhPy5wb3B1cFJlZiB8fCBcIlwiXG4gICAgfTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBbiBlZGl0b3IgbXVzdCBiZSBzZXJpYWxpemFibGVcIik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgY29uc3QgZWRpdG9yID0gbmV3IHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yKHtcbiAgICAgIHBhcmVudCxcbiAgICAgIGlkOiBwYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICB1aU1hbmFnZXIsXG4gICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBkYXRhLmFubm90YXRpb25FbGVtZW50SWRcbiAgICB9KTtcbiAgICBlZGl0b3Iucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xuICAgIGVkaXRvci4jYWNjZXNzaWJpbGl0eURhdGEgPSBkYXRhLmFjY2Vzc2liaWxpdHlEYXRhO1xuICAgIGVkaXRvci5faXNDb3B5ID0gZGF0YS5pc0NvcHkgfHwgZmFsc2U7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gZWRpdG9yLmdldFJlY3RJbkN1cnJlbnRDb29yZHMoZGF0YS5yZWN0LCBwYWdlSGVpZ2h0KTtcbiAgICBlZGl0b3IueCA9IHggLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLnkgPSB5IC8gcGFnZUhlaWdodDtcbiAgICBlZGl0b3Iud2lkdGggPSB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICBlZGl0b3IuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIGdldCBoYXNCZWVuTW9kaWZpZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICh0aGlzLmRlbGV0ZWQgfHwgdGhpcy5zZXJpYWxpemUoKSAhPT0gbnVsbCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuI2ZvY3VzQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jZm9jdXNBQyA9IG51bGw7XG4gICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVFZGl0b3IodGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jbW92ZUluRE9NVGltZW91dCk7XG4gICAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgdGhpcy5yZW1vdmVFZGl0VG9vbGJhcigpO1xuICAgIGlmICh0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cykge1xuICAgICAgZm9yIChjb25zdCB0aW1lb3V0IG9mIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLnZhbHVlcygpKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuI3RvdWNoTWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI3RvdWNoTWFuYWdlciA9IG51bGw7XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYWtlUmVzaXphYmxlKCkge1xuICAgIGlmICh0aGlzLmlzUmVzaXphYmxlKSB7XG4gICAgICB0aGlzLiNjcmVhdGVSZXNpemVycygpO1xuICAgICAgdGhpcy4jcmVzaXplcnNEaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRvb2xiYXJQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBrZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzUmVzaXphYmxlIHx8IGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kaXYgfHwgZXZlbnQua2V5ICE9PSBcIkVudGVyXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdWlNYW5hZ2VyLnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIHRoaXMuI3NhdmVkRGltZW5zaW9ucyA9IHtcbiAgICAgIHNhdmVkWDogdGhpcy54LFxuICAgICAgc2F2ZWRZOiB0aGlzLnksXG4gICAgICBzYXZlZFdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgc2F2ZWRIZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuI3Jlc2l6ZXJzRGl2LmNoaWxkcmVuO1xuICAgIGlmICghdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgIHRoaXMuI2FsbFJlc2l6ZXJEaXZzID0gQXJyYXkuZnJvbShjaGlsZHJlbik7XG4gICAgICBjb25zdCBib3VuZFJlc2l6ZXJLZXlkb3duID0gdGhpcy4jcmVzaXplcktleWRvd24uYmluZCh0aGlzKTtcbiAgICAgIGNvbnN0IGJvdW5kUmVzaXplckJsdXIgPSB0aGlzLiNyZXNpemVyQmx1ci5iaW5kKHRoaXMpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgICBmb3IgKGNvbnN0IGRpdiBvZiB0aGlzLiNhbGxSZXNpemVyRGl2cykge1xuICAgICAgICBjb25zdCBuYW1lID0gZGl2LmdldEF0dHJpYnV0ZShcImRhdGEtcmVzaXplci1uYW1lXCIpO1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInNwaW5idXR0b25cIik7XG4gICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBib3VuZFJlc2l6ZXJLZXlkb3duLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYm91bmRSZXNpemVyQmx1ciwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLiNyZXNpemVyRm9jdXMuYmluZCh0aGlzLCBuYW1lKSwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUmVzaXplcltuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0ID0gdGhpcy4jYWxsUmVzaXplckRpdnNbMF07XG4gICAgbGV0IGZpcnN0UG9zaXRpb24gPSAwO1xuICAgIGZvciAoY29uc3QgZGl2IG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoZGl2ID09PSBmaXJzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGZpcnN0UG9zaXRpb24rKztcbiAgICB9XG4gICAgY29uc3QgbmV4dEZpcnN0UG9zaXRpb24gPSAoMzYwIC0gdGhpcy5yb3RhdGlvbiArIHRoaXMucGFyZW50Um90YXRpb24pICUgMzYwIC8gOTAgKiAodGhpcy4jYWxsUmVzaXplckRpdnMubGVuZ3RoIC8gNCk7XG4gICAgaWYgKG5leHRGaXJzdFBvc2l0aW9uICE9PSBmaXJzdFBvc2l0aW9uKSB7XG4gICAgICBpZiAobmV4dEZpcnN0UG9zaXRpb24gPCBmaXJzdFBvc2l0aW9uKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RQb3NpdGlvbiAtIG5leHRGaXJzdFBvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICB0aGlzLiNyZXNpemVyc0Rpdi5hcHBlbmQodGhpcy4jcmVzaXplcnNEaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobmV4dEZpcnN0UG9zaXRpb24gPiBmaXJzdFBvc2l0aW9uKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEZpcnN0UG9zaXRpb24gLSBmaXJzdFBvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICB0aGlzLiNyZXNpemVyc0Rpdi5maXJzdENoaWxkLmJlZm9yZSh0aGlzLiNyZXNpemVyc0Rpdi5sYXN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IGRpdiA9IHRoaXMuI2FsbFJlc2l6ZXJEaXZzW2krK107XG4gICAgICAgIGNvbnN0IG5hbWUgPSBkaXYuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZXNpemVyLW5hbWVcIik7XG4gICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUmVzaXplcltuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3NldFJlc2l6ZXJUYWJJbmRleCgwKTtcbiAgICB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgPSB0cnVlO1xuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmZpcnN0Q2hpbGQuZm9jdXMoe1xuICAgICAgZm9jdXNWaXNpYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfVxuICAjcmVzaXplcktleWRvd24oZXZlbnQpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gICNyZXNpemVyQmx1cihldmVudCkge1xuICAgIGlmICh0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgJiYgZXZlbnQucmVsYXRlZFRhcmdldD8ucGFyZW50Tm9kZSAhPT0gdGhpcy4jcmVzaXplcnNEaXYpIHtcbiAgICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgIH1cbiAgfVxuICAjcmVzaXplckZvY3VzKG5hbWUpIHtcbiAgICB0aGlzLiNmb2N1c2VkUmVzaXplck5hbWUgPSB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgPyBuYW1lIDogXCJcIjtcbiAgfVxuICAjc2V0UmVzaXplclRhYkluZGV4KHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLiNhbGxSZXNpemVyRGl2cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRpdiBvZiB0aGlzLiNhbGxSZXNpemVyRGl2cykge1xuICAgICAgZGl2LnRhYkluZGV4ID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIF9yZXNpemVXaXRoS2V5Ym9hcmQoeCwgeSkge1xuICAgIGlmICghdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3Jlc2l6ZXJQb2ludGVybW92ZSh0aGlzLiNmb2N1c2VkUmVzaXplck5hbWUsIHtcbiAgICAgIGRlbHRhWDogeCxcbiAgICAgIGRlbHRhWTogeSxcbiAgICAgIGZyb21LZXlib2FyZDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICNzdG9wUmVzaXppbmcoKSB7XG4gICAgdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID0gZmFsc2U7XG4gICAgdGhpcy4jc2V0UmVzaXplclRhYkluZGV4KC0xKTtcbiAgICB0aGlzLiNhZGRSZXNpemVUb1VuZG9TdGFjaygpO1xuICB9XG4gIF9zdG9wUmVzaXppbmdXaXRoS2V5Ym9hcmQoKSB7XG4gICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgaWYgKHRoaXMuaXNTZWxlY3RlZCAmJiB0aGlzLl9lZGl0VG9vbGJhcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMubWFrZVJlc2l6YWJsZSgpO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgaWYgKCF0aGlzLl9lZGl0VG9vbGJhcikge1xuICAgICAgdGhpcy5hZGRFZGl0VG9vbGJhcigpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5kaXY/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkRWRpdG9yXCIpKSB7XG4gICAgICAgICAgdGhpcy5fZWRpdFRvb2xiYXI/LnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyPy5zaG93KCk7XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlQWx0VGV4dEJhZGdlKGZhbHNlKTtcbiAgfVxuICB1bnNlbGVjdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdj8uY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIGlmICh0aGlzLmRpdj8uY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5jdXJyZW50TGF5ZXIuZGl2LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyPy5oaWRlKCk7XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlQWx0VGV4dEJhZGdlKHRydWUpO1xuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge31cbiAgZGlzYWJsZUVkaXRpbmcoKSB7fVxuICBlbmFibGVFZGl0aW5nKCkge31cbiAgZ2V0IGNhbkNoYW5nZUNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGVudGVySW5FZGl0TW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuY2FuQ2hhbmdlQ29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfVxuICBkYmxjbGljayhldmVudCkge1xuICAgIHRoaXMuZW50ZXJJbkVkaXRNb2RlKCk7XG4gICAgdGhpcy5wYXJlbnQudXBkYXRlVG9vbGJhcih7XG4gICAgICBtb2RlOiB0aGlzLmNvbnN0cnVjdG9yLl9lZGl0b3JUeXBlLFxuICAgICAgZWRpdElkOiB0aGlzLmlkXG4gICAgfSk7XG4gIH1cbiAgZ2V0RWxlbWVudEZvckFsdFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIGdldCBjb250ZW50RGl2KCkge1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBnZXQgaXNFZGl0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0VkaXRpbmc7XG4gIH1cbiAgc2V0IGlzRWRpdGluZyh2YWx1ZSkge1xuICAgIHRoaXMuI2lzRWRpdGluZyA9IHZhbHVlO1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICAgIHRoaXMucGFyZW50LnNldEFjdGl2ZUVkaXRvcih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgfVxuICBzZXRBc3BlY3RSYXRpbyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy4ja2VlcEFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIHN0eWxlLmFzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW87XG4gICAgc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG4gIH1cbiAgc3RhdGljIGdldCBNSU5fU0laRSgpIHtcbiAgICByZXR1cm4gMTY7XG4gIH1cbiAgc3RhdGljIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCB0ZWxlbWV0cnlJbml0aWFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBcImFkZGVkXCJcbiAgICB9O1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX3JlcG9ydFRlbGVtZXRyeShkYXRhLCBtdXN0V2FpdCA9IGZhbHNlKSB7XG4gICAgaWYgKG11c3RXYWl0KSB7XG4gICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cyB8fD0gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY3Rpb25cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgbGV0IHRpbWVvdXQgPSB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5nZXQoYWN0aW9uKTtcbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KGRhdGEpO1xuICAgICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5kZWxldGUoYWN0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sIEFubm90YXRpb25FZGl0b3IuX3RlbGVtZXRyeVRpbWVvdXQpO1xuICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuc2V0KGFjdGlvbiwgdGltZW91dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEudHlwZSB8fD0gdGhpcy5lZGl0b3JUeXBlO1xuICAgIHRoaXMuX3VpTWFuYWdlci5fZXZlbnRCdXMuZGlzcGF0Y2goXCJyZXBvcnR0ZWxlbWV0cnlcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZGV0YWlsczoge1xuICAgICAgICB0eXBlOiBcImVkaXRpbmdcIixcbiAgICAgICAgZGF0YVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNob3codmlzaWJsZSA9IHRoaXMuX2lzVmlzaWJsZSkge1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIiwgIXZpc2libGUpO1xuICAgIHRoaXMuX2lzVmlzaWJsZSA9IHZpc2libGU7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5kaXYudGFiSW5kZXggPSAwO1xuICAgIH1cbiAgICB0aGlzLiNkaXNhYmxlZCA9IGZhbHNlO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICB0aGlzLmRpdi50YWJJbmRleCA9IC0xO1xuICAgIH1cbiAgICB0aGlzLiNkaXNhYmxlZCA9IHRydWU7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGFubm90YXRpb24uaGlkZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBjb250ZW50ID0gYW5ub3RhdGlvbi5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5hbm5vdGF0aW9uQ29udGVudFwiKTtcbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3RhdGlvbkNvbnRlbnRcIiwgdGhpcy5lZGl0b3JUeXBlKTtcbiAgICAgIGFubm90YXRpb24uY29udGFpbmVyLnByZXBlbmQoY29udGVudCk7XG4gICAgfSBlbHNlIGlmIChjb250ZW50Lm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjb250ZW50O1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJhbm5vdGF0aW9uQ29udGVudFwiLCB0aGlzLmVkaXRvclR5cGUpO1xuICAgICAgY2FudmFzLmJlZm9yZShjb250ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgcmVzZXRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgZmlyc3RDaGlsZFxuICAgIH0gPSBhbm5vdGF0aW9uLmNvbnRhaW5lcjtcbiAgICBpZiAoZmlyc3RDaGlsZD8ubm9kZU5hbWUgPT09IFwiRElWXCIgJiYgZmlyc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoXCJhbm5vdGF0aW9uQ29udGVudFwiKSkge1xuICAgICAgZmlyc3RDaGlsZC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEZha2VFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKTtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBwYXJhbXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICB0aGlzLmRlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL3NoYXJlZC9tdXJtdXJoYXNoMy5qc1xuY29uc3QgU0VFRCA9IDB4YzNkMmUxZjA7XG5jb25zdCBNQVNLX0hJR0ggPSAweGZmZmYwMDAwO1xuY29uc3QgTUFTS19MT1cgPSAweGZmZmY7XG5jbGFzcyBNdXJtdXJIYXNoM182NCB7XG4gIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICB0aGlzLmgxID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgICB0aGlzLmgyID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgfVxuICB1cGRhdGUoaW5wdXQpIHtcbiAgICBsZXQgZGF0YSwgbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGggKiAyKTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8PSAweGZmKSB7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZSA+Pj4gODtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGUgJiAweGZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoaW5wdXQpKSB7XG4gICAgICBkYXRhID0gaW5wdXQuc2xpY2UoKTtcbiAgICAgIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIGZvcm1hdCwgbXVzdCBiZSBhIHN0cmluZyBvciBUeXBlZEFycmF5LlwiKTtcbiAgICB9XG4gICAgY29uc3QgYmxvY2tDb3VudHMgPSBsZW5ndGggPj4gMjtcbiAgICBjb25zdCB0YWlsTGVuZ3RoID0gbGVuZ3RoIC0gYmxvY2tDb3VudHMgKiA0O1xuICAgIGNvbnN0IGRhdGFVaW50MzIgPSBuZXcgVWludDMyQXJyYXkoZGF0YS5idWZmZXIsIDAsIGJsb2NrQ291bnRzKTtcbiAgICBsZXQgazEgPSAwLFxuICAgICAgazIgPSAwO1xuICAgIGxldCBoMSA9IHRoaXMuaDEsXG4gICAgICBoMiA9IHRoaXMuaDI7XG4gICAgY29uc3QgQzEgPSAweGNjOWUyZDUxLFxuICAgICAgQzIgPSAweDFiODczNTkzO1xuICAgIGNvbnN0IEMxX0xPVyA9IEMxICYgTUFTS19MT1csXG4gICAgICBDMl9MT1cgPSBDMiAmIE1BU0tfTE9XO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tDb3VudHM7IGkrKykge1xuICAgICAgaWYgKGkgJiAxKSB7XG4gICAgICAgIGsxID0gZGF0YVVpbnQzMltpXTtcbiAgICAgICAgazEgPSBrMSAqIEMxICYgTUFTS19ISUdIIHwgazEgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazEgPSBrMSA8PCAxNSB8IGsxID4+PiAxNztcbiAgICAgICAgazEgPSBrMSAqIEMyICYgTUFTS19ISUdIIHwgazEgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIGgxID0gaDEgPDwgMTMgfCBoMSA+Pj4gMTk7XG4gICAgICAgIGgxID0gaDEgKiA1ICsgMHhlNjU0NmI2NDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsyID0gZGF0YVVpbnQzMltpXTtcbiAgICAgICAgazIgPSBrMiAqIEMxICYgTUFTS19ISUdIIHwgazIgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazIgPSBrMiA8PCAxNSB8IGsyID4+PiAxNztcbiAgICAgICAgazIgPSBrMiAqIEMyICYgTUFTS19ISUdIIHwgazIgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaDIgXj0gazI7XG4gICAgICAgIGgyID0gaDIgPDwgMTMgfCBoMiA+Pj4gMTk7XG4gICAgICAgIGgyID0gaDIgKiA1ICsgMHhlNjU0NmI2NDtcbiAgICAgIH1cbiAgICB9XG4gICAgazEgPSAwO1xuICAgIHN3aXRjaCAodGFpbExlbmd0aCkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNCArIDJdIDw8IDE2O1xuICAgICAgY2FzZSAyOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNCArIDFdIDw8IDg7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0XTtcbiAgICAgICAgazEgPSBrMSAqIEMxICYgTUFTS19ISUdIIHwgazEgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazEgPSBrMSA8PCAxNSB8IGsxID4+PiAxNztcbiAgICAgICAgazEgPSBrMSAqIEMyICYgTUFTS19ISUdIIHwgazEgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaWYgKGJsb2NrQ291bnRzICYgMSkge1xuICAgICAgICAgIGgxIF49IGsxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGgyIF49IGsxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuaDEgPSBoMTtcbiAgICB0aGlzLmgyID0gaDI7XG4gIH1cbiAgaGV4ZGlnZXN0KCkge1xuICAgIGxldCBoMSA9IHRoaXMuaDEsXG4gICAgICBoMiA9IHRoaXMuaDI7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgaDEgPSBoMSAqIDB4ZWQ1NThjY2QgJiBNQVNLX0hJR0ggfCBoMSAqIDB4OGNjZCAmIE1BU0tfTE9XO1xuICAgIGgyID0gaDIgKiAweGZmNTFhZmQ3ICYgTUFTS19ISUdIIHwgKChoMiA8PCAxNiB8IGgxID4+PiAxNikgKiAweGFmZDdlZDU1ICYgTUFTS19ISUdIKSA+Pj4gMTY7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgaDEgPSBoMSAqIDB4MWE4NWVjNTMgJiBNQVNLX0hJR0ggfCBoMSAqIDB4ZWM1MyAmIE1BU0tfTE9XO1xuICAgIGgyID0gaDIgKiAweGM0Y2ViOWZlICYgTUFTS19ISUdIIHwgKChoMiA8PCAxNiB8IGgxID4+PiAxNikgKiAweGI5ZmUxYTg1ICYgTUFTS19ISUdIKSA+Pj4gMTY7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgcmV0dXJuIChoMSA+Pj4gMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKSArIChoMiA+Pj4gMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9hbm5vdGF0aW9uX3N0b3JhZ2UuanNcblxuXG5cbmNvbnN0IFNlcmlhbGl6YWJsZUVtcHR5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIG1hcDogbnVsbCxcbiAgaGFzaDogXCJcIixcbiAgdHJhbnNmZXI6IHVuZGVmaW5lZFxufSk7XG5jbGFzcyBBbm5vdGF0aW9uU3RvcmFnZSB7XG4gICNtb2RpZmllZCA9IGZhbHNlO1xuICAjbW9kaWZpZWRJZHMgPSBudWxsO1xuICAjc3RvcmFnZSA9IG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vblNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCA9IG51bGw7XG4gICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPSBudWxsO1xuICB9XG4gIGdldFZhbHVlKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0VmFsdWUsIHZhbHVlKTtcbiAgfVxuICBnZXRSYXdWYWx1ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgfVxuICByZW1vdmUoa2V5KSB7XG4gICAgdGhpcy4jc3RvcmFnZS5kZWxldGUoa2V5KTtcbiAgICBpZiAodGhpcy4jc3RvcmFnZS5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuI3N0b3JhZ2UudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IobnVsbCk7XG4gICAgfVxuICB9XG4gIHNldFZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICAgIGxldCBtb2RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChjb25zdCBbZW50cnksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIGlmIChvYmpbZW50cnldICE9PSB2YWwpIHtcbiAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgb2JqW2VudHJ5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICB0aGlzLiNzdG9yYWdlLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBbm5vdGF0aW9uRWRpdG9yICYmIHR5cGVvZiB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvcih2YWx1ZS5jb25zdHJ1Y3Rvci5fdHlwZSk7XG4gICAgfVxuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5oYXMoa2V5KTtcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5zaXplO1xuICB9XG4gICNzZXRNb2RpZmllZCgpIHtcbiAgICBpZiAoIXRoaXMuI21vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNtb2RpZmllZCA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub25TZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25TZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXNldE1vZGlmaWVkKCkge1xuICAgIGlmICh0aGlzLiNtb2RpZmllZCkge1xuICAgICAgdGhpcy4jbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblJlc2V0TW9kaWZpZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgcHJpbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcmludEFubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIGdldCBzZXJpYWxpemFibGUoKSB7XG4gICAgaWYgKHRoaXMuI3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUVtcHR5O1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCksXG4gICAgICBoYXNoID0gbmV3IE11cm11ckhhc2gzXzY0KCksXG4gICAgICB0cmFuc2ZlciA9IFtdO1xuICAgIGNvbnN0IGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBoYXNCaXRtYXAgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy4jc3RvcmFnZSkge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHZhbCBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IgPyB2YWwuc2VyaWFsaXplKGZhbHNlLCBjb250ZXh0KSA6IHZhbDtcbiAgICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBzZXJpYWxpemVkKTtcbiAgICAgICAgaGFzaC51cGRhdGUoYCR7a2V5fToke0pTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZWQpfWApO1xuICAgICAgICBoYXNCaXRtYXAgfHw9ICEhc2VyaWFsaXplZC5iaXRtYXA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNCaXRtYXApIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgbWFwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5iaXRtYXApIHtcbiAgICAgICAgICB0cmFuc2Zlci5wdXNoKHZhbHVlLmJpdG1hcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcC5zaXplID4gMCA/IHtcbiAgICAgIG1hcCxcbiAgICAgIGhhc2g6IGhhc2guaGV4ZGlnZXN0KCksXG4gICAgICB0cmFuc2ZlclxuICAgIH0gOiBTZXJpYWxpemFibGVFbXB0eTtcbiAgfVxuICBnZXQgZWRpdG9yU3RhdHMoKSB7XG4gICAgbGV0IHN0YXRzID0gbnVsbDtcbiAgICBjb25zdCB0eXBlVG9FZGl0b3IgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNzdG9yYWdlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRpdG9yU3RhdHMgPSB2YWx1ZS50ZWxlbWV0cnlGaW5hbERhdGE7XG4gICAgICBpZiAoIWVkaXRvclN0YXRzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlXG4gICAgICB9ID0gZWRpdG9yU3RhdHM7XG4gICAgICBpZiAoIXR5cGVUb0VkaXRvci5oYXModHlwZSkpIHtcbiAgICAgICAgdHlwZVRvRWRpdG9yLnNldCh0eXBlLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHN0YXRzIHx8PSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgY29uc3QgbWFwID0gc3RhdHNbdHlwZV0gfHw9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhlZGl0b3JTdGF0cykpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY291bnRlcnMgPSBtYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghY291bnRlcnMpIHtcbiAgICAgICAgICBjb3VudGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBtYXAuc2V0KGtleSwgY291bnRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvdW50ID0gY291bnRlcnMuZ2V0KHZhbCkgPz8gMDtcbiAgICAgICAgY291bnRlcnMuc2V0KHZhbCwgY291bnQgKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbdHlwZSwgZWRpdG9yXSBvZiB0eXBlVG9FZGl0b3IpIHtcbiAgICAgIHN0YXRzW3R5cGVdID0gZWRpdG9yLmNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEoc3RhdHNbdHlwZV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdHM7XG4gIH1cbiAgcmVzZXRNb2RpZmllZElkcygpIHtcbiAgICB0aGlzLiNtb2RpZmllZElkcyA9IG51bGw7XG4gIH1cbiAgZ2V0IG1vZGlmaWVkSWRzKCkge1xuICAgIGlmICh0aGlzLiNtb2RpZmllZElkcykge1xuICAgICAgcmV0dXJuIHRoaXMuI21vZGlmaWVkSWRzO1xuICAgIH1cbiAgICBjb25zdCBpZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuI3N0b3JhZ2UudmFsdWVzKCkpIHtcbiAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvcikgfHwgIXZhbHVlLmFubm90YXRpb25FbGVtZW50SWQgfHwgIXZhbHVlLnNlcmlhbGl6ZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWRzLnB1c2godmFsdWUuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNtb2RpZmllZElkcyA9IHtcbiAgICAgIGlkczogbmV3IFNldChpZHMpLFxuICAgICAgaGFzaDogaWRzLmpvaW4oXCIsXCIpXG4gICAgfTtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5lbnRyaWVzKCk7XG4gIH1cbn1cbmNsYXNzIFByaW50QW5ub3RhdGlvblN0b3JhZ2UgZXh0ZW5kcyBBbm5vdGF0aW9uU3RvcmFnZSB7XG4gICNzZXJpYWxpemFibGU7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgaGFzaCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA9IHBhcmVudC5zZXJpYWxpemFibGU7XG4gICAgY29uc3QgY2xvbmUgPSBzdHJ1Y3R1cmVkQ2xvbmUobWFwLCB0cmFuc2ZlciA/IHtcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA6IG51bGwpO1xuICAgIHRoaXMuI3NlcmlhbGl6YWJsZSA9IHtcbiAgICAgIG1hcDogY2xvbmUsXG4gICAgICBoYXNoLFxuICAgICAgdHJhbnNmZXJcbiAgICB9O1xuICB9XG4gIGdldCBwcmludCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIlNob3VsZCBub3QgY2FsbCBQcmludEFubm90YXRpb25TdG9yYWdlLnByaW50XCIpO1xuICB9XG4gIGdldCBzZXJpYWxpemFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlcmlhbGl6YWJsZTtcbiAgfVxuICBnZXQgbW9kaWZpZWRJZHMoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIm1vZGlmaWVkSWRzXCIsIHtcbiAgICAgIGlkczogbmV3IFNldCgpLFxuICAgICAgaGFzaDogXCJcIlxuICAgIH0pO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2ZvbnRfbG9hZGVyLmpzXG5cbmNsYXNzIEZvbnRMb2FkZXIge1xuICAjc3lzdGVtRm9udHMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudCxcbiAgICBzdHlsZUVsZW1lbnQgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLl9kb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMubG9hZGluZ1JlcXVlc3RzID0gW107XG4gICAgdGhpcy5sb2FkVGVzdEZvbnRJZCA9IDA7XG4gIH1cbiAgYWRkTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpIHtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5hZGQobmF0aXZlRm9udEZhY2UpO1xuICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmFkZChuYXRpdmVGb250RmFjZSk7XG4gIH1cbiAgcmVtb3ZlTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpIHtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gIH1cbiAgaW5zZXJ0UnVsZShydWxlKSB7XG4gICAgaWYgKCF0aGlzLnN0eWxlRWxlbWVudCkge1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZCh0aGlzLnN0eWxlRWxlbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlU2hlZXQgPSB0aGlzLnN0eWxlRWxlbWVudC5zaGVldDtcbiAgICBzdHlsZVNoZWV0Lmluc2VydFJ1bGUocnVsZSwgc3R5bGVTaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgbmF0aXZlRm9udEZhY2Ugb2YgdGhpcy5uYXRpdmVGb250RmFjZXMpIHtcbiAgICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gICAgfVxuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmNsZWFyKCk7XG4gICAgdGhpcy4jc3lzdGVtRm9udHMuY2xlYXIoKTtcbiAgICBpZiAodGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBhc3luYyBsb2FkU3lzdGVtRm9udCh7XG4gICAgc3lzdGVtRm9udEluZm86IGluZm8sXG4gICAgZGlzYWJsZUZvbnRGYWNlLFxuICAgIF9pbnNwZWN0Rm9udFxuICB9KSB7XG4gICAgaWYgKCFpbmZvIHx8IHRoaXMuI3N5c3RlbUZvbnRzLmhhcyhpbmZvLmxvYWRlZE5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFzc2VydCghZGlzYWJsZUZvbnRGYWNlLCBcImxvYWRTeXN0ZW1Gb250IHNob3VsZG4ndCBiZSBjYWxsZWQgd2hlbiBgZGlzYWJsZUZvbnRGYWNlYCBpcyBzZXQuXCIpO1xuICAgIGlmICh0aGlzLmlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbG9hZGVkTmFtZSxcbiAgICAgICAgc3JjLFxuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGluZm87XG4gICAgICBjb25zdCBmb250RmFjZSA9IG5ldyBGb250RmFjZShsb2FkZWROYW1lLCBzcmMsIHN0eWxlKTtcbiAgICAgIHRoaXMuYWRkTmF0aXZlRm9udEZhY2UoZm9udEZhY2UpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZm9udEZhY2UubG9hZCgpO1xuICAgICAgICB0aGlzLiNzeXN0ZW1Gb250cy5hZGQobG9hZGVkTmFtZSk7XG4gICAgICAgIF9pbnNwZWN0Rm9udD8uKGluZm8pO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHdhcm4oYENhbm5vdCBsb2FkIHN5c3RlbSBmb250OiAke2luZm8uYmFzZUZvbnROYW1lfSwgaW5zdGFsbGluZyBpdCBjb3VsZCBoZWxwIHRvIGltcHJvdmUgUERGIHJlbmRlcmluZy5gKTtcbiAgICAgICAgdGhpcy5yZW1vdmVOYXRpdmVGb250RmFjZShmb250RmFjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkOiBsb2FkU3lzdGVtRm9udCB3aXRob3V0IHRoZSBGb250IExvYWRpbmcgQVBJLlwiKTtcbiAgfVxuICBhc3luYyBiaW5kKGZvbnQpIHtcbiAgICBpZiAoZm9udC5hdHRhY2hlZCB8fCBmb250Lm1pc3NpbmdGaWxlICYmICFmb250LnN5c3RlbUZvbnRJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvbnQuYXR0YWNoZWQgPSB0cnVlO1xuICAgIGlmIChmb250LnN5c3RlbUZvbnRJbmZvKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvYWRTeXN0ZW1Gb250KGZvbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCBuYXRpdmVGb250RmFjZSA9IGZvbnQuY3JlYXRlTmF0aXZlRm9udEZhY2UoKTtcbiAgICAgIGlmIChuYXRpdmVGb250RmFjZSkge1xuICAgICAgICB0aGlzLmFkZE5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBuYXRpdmVGb250RmFjZS5sb2FkZWQ7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgd2FybihgRmFpbGVkIHRvIGxvYWQgZm9udCAnJHtuYXRpdmVGb250RmFjZS5mYW1pbHl9JzogJyR7ZXh9Jy5gKTtcbiAgICAgICAgICBmb250LmRpc2FibGVGb250RmFjZSA9IHRydWU7XG4gICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGZvbnQuY3JlYXRlRm9udEZhY2VSdWxlKCk7XG4gICAgaWYgKHJ1bGUpIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgIGlmICh0aGlzLmlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcXVldWVMb2FkaW5nQ2FsbGJhY2socmVzb2x2ZSk7XG4gICAgICAgIHRoaXMuX3ByZXBhcmVGb250TG9hZEV2ZW50KGZvbnQsIHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKCkge1xuICAgIGNvbnN0IGhhc0ZvbnRzID0gISF0aGlzLl9kb2N1bWVudD8uZm9udHM7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWRcIiwgaGFzRm9udHMpO1xuICB9XG4gIGdldCBpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWRcIiwgaXNOb2RlSlMgfHwgdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc0ZpcmVmb3gpO1xuICB9XG4gIF9xdWV1ZUxvYWRpbmdDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIGNvbXBsZXRlUmVxdWVzdCgpIHtcbiAgICAgIGFzc2VydCghcmVxdWVzdC5kb25lLCBcImNvbXBsZXRlUmVxdWVzdCgpIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2UuXCIpO1xuICAgICAgcmVxdWVzdC5kb25lID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChsb2FkaW5nUmVxdWVzdHMubGVuZ3RoID4gMCAmJiBsb2FkaW5nUmVxdWVzdHNbMF0uZG9uZSkge1xuICAgICAgICBjb25zdCBvdGhlclJlcXVlc3QgPSBsb2FkaW5nUmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgc2V0VGltZW91dChvdGhlclJlcXVlc3QuY2FsbGJhY2ssIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsb2FkaW5nUmVxdWVzdHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBjb21wbGV0ZTogY29tcGxldGVSZXF1ZXN0LFxuICAgICAgY2FsbGJhY2tcbiAgICB9O1xuICAgIGxvYWRpbmdSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG4gIGdldCBfbG9hZFRlc3RGb250KCkge1xuICAgIGNvbnN0IHRlc3RGb250ID0gYXRvYihcIlQxUlVUd0FMQUlBQUF3QXdRMFpHSURIdFpnNEFBQU9ZQUFBQWdVWkdWRTFsa3pad0FBQUVIQUFBQUJ4SFJFVkdBQlFBXCIgKyBcIkZRQUFCRGdBQUFBZVQxTXZNbFlOWXdrQUFBRWdBQUFBWUdOdFlYQUJEUUxVQUFBQ05BQUFBVUpvWldGay94VkZEUUFBXCIgKyBcIkFMd0FBQUEyYUdobFlRZGtBK29BQUFEMEFBQUFKR2h0ZEhnRDZBQUFBQUFFV0FBQUFBWnRZWGh3QUFKUUFBQUFBUmdBXCIgKyBcIkFBQUdibUZ0WlZqbWRINEFBQUdBQUFBQXNYQnZjM1QvaGdBekFBQURlQUFBQUNBQUFRQUFBQUVBQUxaUkZzUmZEenoxXCIgKyBcIkFBc0Q2QUFBQUFET0JPVExBQUFBQU00S0hEd0FBQUFBQStnRElRQUFBQWdBQWdBQUFBQUFBQUFCQUFBRElRQUFBRm9EXCIgKyBcIjZBQUFBQUFENkFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQVVBQUFBZ0FBQUFRRDZBSDBBQVVBQUFLS0Fyd0FBQUNNXCIgKyBcIkFvb0N2QUFBQWVBQU1RRUNBQUFDQUFZSkFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBRkJtUldRQXdBQXVBQzREXCIgKyBcIklQODRBRm9ESVFBQUFBQUFBUUFBQUFBQUFBQUFBQ0FBSUFBQkFBQUFEZ0N1QUFFQUFBQUFBQUFBQVFBQUFBRUFBQUFBXCIgKyBcIkFBRUFBUUFBQUFFQUFBQUFBQUlBQVFBQUFBRUFBQUFBQUFNQUFRQUFBQUVBQUFBQUFBUUFBUUFBQUFFQUFBQUFBQVVBXCIgKyBcIkFRQUFBQUVBQUFBQUFBWUFBUUFBQUFNQUFRUUpBQUFBQWdBQkFBTUFBUVFKQUFFQUFnQUJBQU1BQVFRSkFBSUFBZ0FCXCIgKyBcIkFBTUFBUVFKQUFNQUFnQUJBQU1BQVFRSkFBUUFBZ0FCQUFNQUFRUUpBQVVBQWdBQkFBTUFBUVFKQUFZQUFnQUJXQUJZXCIgKyBcIkFBQUFBQUFBQXdBQUFBTUFBQUFjQUFFQUFBQUFBRHdBQXdBQkFBQUFIQUFFQUNBQUFBQUVBQVFBQVFBQUFDNy8vd0FBXCIgKyBcIkFDNy8vLy9UQUFFQUFBQUFBQUFCQmdBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1BQUFBQUFBRC9nd0F5QUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUJBQVFFQUFFQkFRSllBQUVCQVNINER3RDRHd0hFQXZnY0EvZ1hCSXdNQVl1TCtuejV0UVhrRDVqM0NCTG5FUUFDXCIgKyBcIkFRRUJJVmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWUFBQUJBUUFBRHdBQ0FRRUVFL3QzXCIgKyBcIkRvdjZmQUg2ZkFUK2ZQcDgrbndIRG9zTUN2bTFDdm0xREF6NmZCUUFBQUFBQUFBQkFBQUFBTW1KYnpFQUFBQUF6Z1RqXCIgKyBcIkZRQUFBQURPQk9RcEFBRUFBQUFBQUFBQURBQVVBQVFBQUFBQkFBQUFBZ0FCQUFBQUFBQUFBQUFENkFBQUFBQUFBQT09XCIpO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfbG9hZFRlc3RGb250XCIsIHRlc3RGb250KTtcbiAgfVxuICBfcHJlcGFyZUZvbnRMb2FkRXZlbnQoZm9udCwgcmVxdWVzdCkge1xuICAgIGZ1bmN0aW9uIGludDMyKGRhdGEsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIGRhdGEuY2hhckNvZGVBdChvZmZzZXQpIDw8IDI0IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDIpIDw8IDggfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMykgJiAweGZmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGxpY2VTdHJpbmcocywgb2Zmc2V0LCByZW1vdmUsIGluc2VydCkge1xuICAgICAgY29uc3QgY2h1bmsxID0gcy5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcbiAgICAgIGNvbnN0IGNodW5rMiA9IHMuc3Vic3RyaW5nKG9mZnNldCArIHJlbW92ZSk7XG4gICAgICByZXR1cm4gY2h1bmsxICsgaW5zZXJ0ICsgY2h1bmsyO1xuICAgIH1cbiAgICBsZXQgaSwgaWk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSAxO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgbGV0IGNhbGxlZCA9IDA7XG4gICAgZnVuY3Rpb24gaXNGb250UmVhZHkobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICgrK2NhbGxlZCA+IDMwKSB7XG4gICAgICAgIHdhcm4oXCJMb2FkIHRlc3QgZm9udCBuZXZlciBsb2FkZWQuXCIpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguZm9udCA9IFwiMzBweCBcIiArIG5hbWU7XG4gICAgICBjdHguZmlsbFRleHQoXCIuXCIsIDAsIDIwKTtcbiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XG4gICAgICBpZiAoaW1hZ2VEYXRhLmRhdGFbM10gPiAwKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoaXNGb250UmVhZHkuYmluZChudWxsLCBuYW1lLCBjYWxsYmFjaykpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkVGVzdEZvbnRJZCA9IGBsdCR7RGF0ZS5ub3coKX0ke3RoaXMubG9hZFRlc3RGb250SWQrK31gO1xuICAgIGxldCBkYXRhID0gdGhpcy5fbG9hZFRlc3RGb250O1xuICAgIGNvbnN0IENPTU1FTlRfT0ZGU0VUID0gOTc2O1xuICAgIGRhdGEgPSBzcGxpY2VTdHJpbmcoZGF0YSwgQ09NTUVOVF9PRkZTRVQsIGxvYWRUZXN0Rm9udElkLmxlbmd0aCwgbG9hZFRlc3RGb250SWQpO1xuICAgIGNvbnN0IENGRl9DSEVDS1NVTV9PRkZTRVQgPSAxNjtcbiAgICBjb25zdCBYWFhYX1ZBTFVFID0gMHg1ODU4NTg1ODtcbiAgICBsZXQgY2hlY2tzdW0gPSBpbnQzMihkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUKTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IGxvYWRUZXN0Rm9udElkLmxlbmd0aCAtIDM7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICBjaGVja3N1bSA9IGNoZWNrc3VtIC0gWFhYWF9WQUxVRSArIGludDMyKGxvYWRUZXN0Rm9udElkLCBpKSB8IDA7XG4gICAgfVxuICAgIGlmIChpIDwgbG9hZFRlc3RGb250SWQubGVuZ3RoKSB7XG4gICAgICBjaGVja3N1bSA9IGNoZWNrc3VtIC0gWFhYWF9WQUxVRSArIGludDMyKGxvYWRUZXN0Rm9udElkICsgXCJYWFhcIiwgaSkgfCAwO1xuICAgIH1cbiAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENGRl9DSEVDS1NVTV9PRkZTRVQsIDQsIHN0cmluZzMyKGNoZWNrc3VtKSk7XG4gICAgY29uc3QgdXJsID0gYHVybChkYXRhOmZvbnQvb3BlbnR5cGU7YmFzZTY0LCR7YnRvYShkYXRhKX0pO2A7XG4gICAgY29uc3QgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7bG9hZFRlc3RGb250SWR9XCI7c3JjOiR7dXJsfX1gO1xuICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICBjb25zdCBkaXYgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICBkaXYuc3R5bGUud2lkdGggPSBkaXYuc3R5bGUuaGVpZ2h0ID0gXCIxMHB4XCI7XG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGRpdi5zdHlsZS50b3AgPSBkaXYuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIFtmb250LmxvYWRlZE5hbWUsIGxvYWRUZXN0Rm9udElkXSkge1xuICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IFwiSGlcIjtcbiAgICAgIHNwYW4uc3R5bGUuZm9udEZhbWlseSA9IG5hbWU7XG4gICAgICBkaXYuYXBwZW5kKHNwYW4pO1xuICAgIH1cbiAgICB0aGlzLl9kb2N1bWVudC5ib2R5LmFwcGVuZChkaXYpO1xuICAgIGlzRm9udFJlYWR5KGxvYWRUZXN0Rm9udElkLCAoKSA9PiB7XG4gICAgICBkaXYucmVtb3ZlKCk7XG4gICAgICByZXF1ZXN0LmNvbXBsZXRlKCk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEZvbnRGYWNlT2JqZWN0IHtcbiAgY29uc3RydWN0b3IodHJhbnNsYXRlZERhdGEsIGluc3BlY3RGb250ID0gbnVsbCkge1xuICAgIHRoaXMuY29tcGlsZWRHbHlwaHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAoY29uc3QgaSBpbiB0cmFuc2xhdGVkRGF0YSkge1xuICAgICAgdGhpc1tpXSA9IHRyYW5zbGF0ZWREYXRhW2ldO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udCA9IGluc3BlY3RGb250O1xuICB9XG4gIGNyZWF0ZU5hdGl2ZUZvbnRGYWNlKCkge1xuICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGlzYWJsZUZvbnRGYWNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IG5hdGl2ZUZvbnRGYWNlO1xuICAgIGlmICghdGhpcy5jc3NGb250SW5mbykge1xuICAgICAgbmF0aXZlRm9udEZhY2UgPSBuZXcgRm9udEZhY2UodGhpcy5sb2FkZWROYW1lLCB0aGlzLmRhdGEsIHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY3NzID0ge1xuICAgICAgICB3ZWlnaHQ6IHRoaXMuY3NzRm9udEluZm8uZm9udFdlaWdodFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlKSB7XG4gICAgICAgIGNzcy5zdHlsZSA9IGBvYmxpcXVlICR7dGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZX1kZWdgO1xuICAgICAgfVxuICAgICAgbmF0aXZlRm9udEZhY2UgPSBuZXcgRm9udEZhY2UodGhpcy5jc3NGb250SW5mby5mb250RmFtaWx5LCB0aGlzLmRhdGEsIGNzcyk7XG4gICAgfVxuICAgIHRoaXMuX2luc3BlY3RGb250Py4odGhpcyk7XG4gICAgcmV0dXJuIG5hdGl2ZUZvbnRGYWNlO1xuICB9XG4gIGNyZWF0ZUZvbnRGYWNlUnVsZSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRpc2FibGVGb250RmFjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGB1cmwoZGF0YToke3RoaXMubWltZXR5cGV9O2Jhc2U2NCwke3RvQmFzZTY0VXRpbCh0aGlzLmRhdGEpfSk7YDtcbiAgICBsZXQgcnVsZTtcbiAgICBpZiAoIXRoaXMuY3NzRm9udEluZm8pIHtcbiAgICAgIHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke3RoaXMubG9hZGVkTmFtZX1cIjtzcmM6JHt1cmx9fWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjc3MgPSBgZm9udC13ZWlnaHQ6ICR7dGhpcy5jc3NGb250SW5mby5mb250V2VpZ2h0fTtgO1xuICAgICAgaWYgKHRoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGUpIHtcbiAgICAgICAgY3NzICs9IGBmb250LXN0eWxlOiBvYmxpcXVlICR7dGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZX1kZWc7YDtcbiAgICAgIH1cbiAgICAgIHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke3RoaXMuY3NzRm9udEluZm8uZm9udEZhbWlseX1cIjske2Nzc31zcmM6JHt1cmx9fWA7XG4gICAgfVxuICAgIHRoaXMuX2luc3BlY3RGb250Py4odGhpcywgdXJsKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICBnZXRQYXRoR2VuZXJhdG9yKG9ianMsIGNoYXJhY3Rlcikge1xuICAgIGlmICh0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXTtcbiAgICB9XG4gICAgY29uc3Qgb2JqSWQgPSB0aGlzLmxvYWRlZE5hbWUgKyBcIl9wYXRoX1wiICsgY2hhcmFjdGVyO1xuICAgIGxldCBjbWRzO1xuICAgIHRyeSB7XG4gICAgICBjbWRzID0gb2Jqcy5nZXQob2JqSWQpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB3YXJuKGBnZXRQYXRoR2VuZXJhdG9yIC0gaWdub3JpbmcgY2hhcmFjdGVyOiBcIiR7ZXh9XCIuYCk7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKGNtZHMgfHwgXCJcIik7XG4gICAgaWYgKCF0aGlzLmZvbnRFeHRyYVByb3BlcnRpZXMpIHtcbiAgICAgIG9ianMuZGVsZXRlKG9iaklkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSA9IHBhdGg7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvYXBpX3V0aWxzLmpzXG5cbmZ1bmN0aW9uIGdldFVybFByb3AodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICByZXR1cm4gdmFsLmhyZWY7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IFVSTC5wYXJzZSh2YWwsIHdpbmRvdy5sb2NhdGlvbik7XG4gICAgaWYgKHVybCkge1xuICAgICAgcmV0dXJuIHVybC5ocmVmO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiB1cmwgZGF0YTogXCIgKyBcImVpdGhlciBzdHJpbmcgb3IgVVJMLW9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgdXJsIHByb3BlcnR5LlwiKTtcbn1cbmZ1bmN0aW9uIGdldERhdGFQcm9wKHZhbCkge1xuICBpZiAoaXNOb2RlSlMgJiYgdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBiaW5hcnkgZGF0YSBhcyBgVWludDhBcnJheWAsIHJhdGhlciB0aGFuIGBCdWZmZXJgLlwiKTtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB2YWwuYnl0ZUxlbmd0aCA9PT0gdmFsLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzdHJpbmdUb0J5dGVzKHZhbCk7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpIHx8IHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgIWlzTmFOKHZhbD8ubGVuZ3RoKSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUERGIGJpbmFyeSBkYXRhOiBlaXRoZXIgVHlwZWRBcnJheSwgXCIgKyBcInN0cmluZywgb3IgYXJyYXktbGlrZSBvYmplY3QgaXMgZXhwZWN0ZWQgaW4gdGhlIGRhdGEgcHJvcGVydHkuXCIpO1xufVxuZnVuY3Rpb24gZ2V0RmFjdG9yeVVybFByb3AodmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHZhbC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmYWN0b3J5IHVybDogXCIke3ZhbH1cIiBtdXN0IGluY2x1ZGUgdHJhaWxpbmcgc2xhc2guYCk7XG59XG5jb25zdCBpc1JlZlByb3h5ID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKHY/Lm51bSkgJiYgdi5udW0gPj0gMCAmJiBOdW1iZXIuaXNJbnRlZ2VyKHY/LmdlbikgJiYgdi5nZW4gPj0gMDtcbmNvbnN0IGlzTmFtZVByb3h5ID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygdj8ubmFtZSA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IGlzVmFsaWRFeHBsaWNpdERlc3QgPSBfaXNWYWxpZEV4cGxpY2l0RGVzdC5iaW5kKG51bGwsIGlzUmVmUHJveHksIGlzTmFtZVByb3h5KTtcbmNsYXNzIExvb3BiYWNrUG9ydCB7XG4gICNsaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICNkZWZlcnJlZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBwb3N0TWVzc2FnZShvYmosIHRyYW5zZmVyKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICBkYXRhOiBzdHJ1Y3R1cmVkQ2xvbmUob2JqLCB0cmFuc2ZlciA/IHtcbiAgICAgICAgdHJhbnNmZXJcbiAgICAgIH0gOiBudWxsKVxuICAgIH07XG4gICAgdGhpcy4jZGVmZXJyZWQudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtsaXN0ZW5lcl0gb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgbGV0IHJtQWJvcnQgPSBudWxsO1xuICAgIGlmIChvcHRpb25zPy5zaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHdhcm4oXCJMb29wYmFja1BvcnQgLSBjYW5ub3QgdXNlIGFuIGBhYm9ydGVkYCBzaWduYWwuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvbkFib3J0ID0gKCkgPT4gdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIHJtQWJvcnQgPSAoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB9XG4gICAgdGhpcy4jbGlzdGVuZXJzLnNldChsaXN0ZW5lciwgcm1BYm9ydCk7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHJtQWJvcnQgPSB0aGlzLiNsaXN0ZW5lcnMuZ2V0KGxpc3RlbmVyKTtcbiAgICBybUFib3J0Py4oKTtcbiAgICB0aGlzLiNsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfVxuICB0ZXJtaW5hdGUoKSB7XG4gICAgZm9yIChjb25zdCBbLCBybUFib3J0XSBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgIHJtQWJvcnQ/LigpO1xuICAgIH1cbiAgICB0aGlzLiNsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvc2hhcmVkL21lc3NhZ2VfaGFuZGxlci5qc1xuXG5jb25zdCBDYWxsYmFja0tpbmQgPSB7XG4gIERBVEE6IDEsXG4gIEVSUk9SOiAyXG59O1xuY29uc3QgU3RyZWFtS2luZCA9IHtcbiAgQ0FOQ0VMOiAxLFxuICBDQU5DRUxfQ09NUExFVEU6IDIsXG4gIENMT1NFOiAzLFxuICBFTlFVRVVFOiA0LFxuICBFUlJPUjogNSxcbiAgUFVMTDogNixcbiAgUFVMTF9DT01QTEVURTogNyxcbiAgU1RBUlRfQ09NUExFVEU6IDhcbn07XG5mdW5jdGlvbiBvbkZuKCkge31cbmZ1bmN0aW9uIHdyYXBSZWFzb24oZXgpIHtcbiAgaWYgKGV4IGluc3RhbmNlb2YgQWJvcnRFeGNlcHRpb24gfHwgZXggaW5zdGFuY2VvZiBJbnZhbGlkUERGRXhjZXB0aW9uIHx8IGV4IGluc3RhbmNlb2YgUGFzc3dvcmRFeGNlcHRpb24gfHwgZXggaW5zdGFuY2VvZiBSZXNwb25zZUV4Y2VwdGlvbiB8fCBleCBpbnN0YW5jZW9mIFVua25vd25FcnJvckV4Y2VwdGlvbikge1xuICAgIHJldHVybiBleDtcbiAgfVxuICBpZiAoIShleCBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiBleCA9PT0gXCJvYmplY3RcIiAmJiBleCAhPT0gbnVsbCkpIHtcbiAgICB1bnJlYWNoYWJsZSgnd3JhcFJlYXNvbjogRXhwZWN0ZWQgXCJyZWFzb25cIiB0byBiZSBhIChwb3NzaWJseSBjbG9uZWQpIEVycm9yLicpO1xuICB9XG4gIHN3aXRjaCAoZXgubmFtZSkge1xuICAgIGNhc2UgXCJBYm9ydEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBBYm9ydEV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICBjYXNlIFwiSW52YWxpZFBERkV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkUERGRXhjZXB0aW9uKGV4Lm1lc3NhZ2UpO1xuICAgIGNhc2UgXCJQYXNzd29yZEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBQYXNzd29yZEV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5jb2RlKTtcbiAgICBjYXNlIFwiUmVzcG9uc2VFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2VFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguc3RhdHVzLCBleC5taXNzaW5nKTtcbiAgICBjYXNlIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IFVua25vd25FcnJvckV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5kZXRhaWxzKTtcbiAgfVxuICByZXR1cm4gbmV3IFVua25vd25FcnJvckV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC50b1N0cmluZygpKTtcbn1cbmNsYXNzIE1lc3NhZ2VIYW5kbGVyIHtcbiAgI21lc3NhZ2VBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgY29uc3RydWN0b3Ioc291cmNlTmFtZSwgdGFyZ2V0TmFtZSwgY29tT2JqKSB7XG4gICAgdGhpcy5zb3VyY2VOYW1lID0gc291cmNlTmFtZTtcbiAgICB0aGlzLnRhcmdldE5hbWUgPSB0YXJnZXROYW1lO1xuICAgIHRoaXMuY29tT2JqID0gY29tT2JqO1xuICAgIHRoaXMuY2FsbGJhY2tJZCA9IDE7XG4gICAgdGhpcy5zdHJlYW1JZCA9IDE7XG4gICAgdGhpcy5zdHJlYW1TaW5rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hY3Rpb25IYW5kbGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb21PYmouYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy4jb25NZXNzYWdlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbDogdGhpcy4jbWVzc2FnZUFDLnNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNvbk1lc3NhZ2Uoe1xuICAgIGRhdGFcbiAgfSkge1xuICAgIGlmIChkYXRhLnRhcmdldE5hbWUgIT09IHRoaXMuc291cmNlTmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5zdHJlYW0pIHtcbiAgICAgIHRoaXMuI3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jYWxsYmFjaykge1xuICAgICAgY29uc3QgY2FsbGJhY2tJZCA9IGRhdGEuY2FsbGJhY2tJZDtcbiAgICAgIGNvbnN0IGNhcGFiaWxpdHkgPSB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuICAgICAgaWYgKCFjYXBhYmlsaXR5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlc29sdmUgY2FsbGJhY2sgJHtjYWxsYmFja0lkfWApO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkRBVEEpIHtcbiAgICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEuZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEuY2FsbGJhY2sgPT09IENhbGxiYWNrS2luZC5FUlJPUikge1xuICAgICAgICBjYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNhbGxiYWNrIGNhc2VcIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhY3Rpb24gZnJvbSB3b3JrZXI6ICR7ZGF0YS5hY3Rpb259YCk7XG4gICAgfVxuICAgIGlmIChkYXRhLmNhbGxiYWNrSWQpIHtcbiAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgICAgUHJvbWlzZS50cnkoYWN0aW9uLCBkYXRhLmRhdGEpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkRBVEEsXG4gICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgIGRhdGE6IHJlc3VsdFxuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5FUlJPUixcbiAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuc3RyZWFtSWQpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdGlvbihkYXRhLmRhdGEpO1xuICB9XG4gIG9uKGFjdGlvbk5hbWUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBhaCA9IHRoaXMuYWN0aW9uSGFuZGxlcjtcbiAgICBpZiAoYWhbYWN0aW9uTmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYWxyZWFkeSBhbiBhY3Rpb25OYW1lIGNhbGxlZCBcIiR7YWN0aW9uTmFtZX1cImApO1xuICAgIH1cbiAgICBhaFthY3Rpb25OYW1lXSA9IGhhbmRsZXI7XG4gIH1cbiAgc2VuZChhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICBkYXRhXG4gICAgfSwgdHJhbnNmZXJzKTtcbiAgfVxuICBzZW5kV2l0aFByb21pc2UoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3QgY2FsbGJhY2tJZCA9IHRoaXMuY2FsbGJhY2tJZCsrO1xuICAgIGNvbnN0IGNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdID0gY2FwYWJpbGl0eTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICBjYWxsYmFja0lkLFxuICAgICAgICBkYXRhXG4gICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjYXBhYmlsaXR5LnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc2VuZFdpdGhTdHJlYW0oYWN0aW9uTmFtZSwgZGF0YSwgcXVldWVpbmdTdHJhdGVneSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSB0aGlzLnN0cmVhbUlkKyssXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBjb25zdCBzdGFydENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0gPSB7XG4gICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICBzdGFydENhbGw6IHN0YXJ0Q2FwYWJpbGl0eSxcbiAgICAgICAgICBwdWxsQ2FsbDogbnVsbCxcbiAgICAgICAgICBjYW5jZWxDYWxsOiBudWxsLFxuICAgICAgICAgIGlzQ2xvc2VkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgICAgICByZXR1cm4gc3RhcnRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgcHVsbDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIGNvbnN0IHB1bGxDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLnB1bGxDYWxsID0gcHVsbENhcGFiaWxpdHk7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHVsbENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6IHJlYXNvbiA9PiB7XG4gICAgICAgIGFzc2VydChyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJjYW5jZWwgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBjb25zdCBjYW5jZWxDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmNhbmNlbENhbGwgPSBjYW5jZWxDYXBhYmlsaXR5O1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUwsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYW5jZWxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9XG4gICAgfSwgcXVldWVpbmdTdHJhdGVneSk7XG4gIH1cbiAgI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZCxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMsXG4gICAgICBhY3Rpb24gPSB0aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuICAgIGNvbnN0IHN0cmVhbVNpbmsgPSB7XG4gICAgICBlbnF1ZXVlKGNodW5rLCBzaXplID0gMSwgdHJhbnNmZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3REZXNpcmVkU2l6ZSA9IHRoaXMuZGVzaXJlZFNpemU7XG4gICAgICAgIHRoaXMuZGVzaXJlZFNpemUgLT0gc2l6ZTtcbiAgICAgICAgaWYgKGxhc3REZXNpcmVkU2l6ZSA+IDAgJiYgdGhpcy5kZXNpcmVkU2l6ZSA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5zaW5rQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0aGlzLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVOUVVFVUUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgY2h1bmtcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgIH0sXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DTE9TRSxcbiAgICAgICAgICBzdHJlYW1JZFxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIHNlbGYuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgfSxcbiAgICAgIGVycm9yKHJlYXNvbikge1xuICAgICAgICBhc3NlcnQocmVhc29uIGluc3RhbmNlb2YgRXJyb3IsIFwiZXJyb3IgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVSUk9SLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNpbmtDYXBhYmlsaXR5OiBQcm9taXNlLndpdGhSZXNvbHZlcnMoKSxcbiAgICAgIG9uUHVsbDogbnVsbCxcbiAgICAgIG9uQ2FuY2VsOiBudWxsLFxuICAgICAgaXNDYW5jZWxsZWQ6IGZhbHNlLFxuICAgICAgZGVzaXJlZFNpemU6IGRhdGEuZGVzaXJlZFNpemUsXG4gICAgICByZWFkeTogbnVsbFxuICAgIH07XG4gICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgc3RyZWFtU2luay5yZWFkeSA9IHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXSA9IHN0cmVhbVNpbms7XG4gICAgUHJvbWlzZS50cnkoYWN0aW9uLCBkYXRhLmRhdGEsIHN0cmVhbVNpbmspLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gICNwcm9jZXNzU3RyZWFtTWVzc2FnZShkYXRhKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSBkYXRhLnN0cmVhbUlkLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICBjb25zdCBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0sXG4gICAgICBzdHJlYW1TaW5rID0gdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgc3dpdGNoIChkYXRhLnN0cmVhbSkge1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5QVUxMOlxuICAgICAgICBpZiAoIXN0cmVhbVNpbmspIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW1TaW5rLmRlc2lyZWRTaXplIDw9IDAgJiYgZGF0YS5kZXNpcmVkU2l6ZSA+IDApIHtcbiAgICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1TaW5rLmRlc2lyZWRTaXplID0gZGF0YS5kZXNpcmVkU2l6ZTtcbiAgICAgICAgUHJvbWlzZS50cnkoc3RyZWFtU2luay5vblB1bGwgfHwgb25GbikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRU5RVUVVRTpcbiAgICAgICAgYXNzZXJ0KHN0cmVhbUNvbnRyb2xsZXIsIFwiZW5xdWV1ZSBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgaWYgKHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhLmNodW5rKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0xPU0U6XG4gICAgICAgIGFzc2VydChzdHJlYW1Db250cm9sbGVyLCBcImNsb3NlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBpZiAoc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkVSUk9SOlxuICAgICAgICBhc3NlcnQoc3RyZWFtQ29udHJvbGxlciwgXCJlcnJvciBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTDpcbiAgICAgICAgaWYgKCFzdHJlYW1TaW5rKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YVJlYXNvbiA9IHdyYXBSZWFzb24oZGF0YS5yZWFzb24pO1xuICAgICAgICBQcm9taXNlLnRyeShzdHJlYW1TaW5rLm9uQ2FuY2VsIHx8IG9uRm4sIGRhdGFSZWFzb24pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlamVjdChkYXRhUmVhc29uKTtcbiAgICAgICAgc3RyZWFtU2luay5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHN0cmVhbSBjYXNlXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyAjZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGw/LnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGw/LnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbD8ucHJvbWlzZV0pO1xuICAgIGRlbGV0ZSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI21lc3NhZ2VBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNtZXNzYWdlQUMgPSBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NhbnZhc19mYWN0b3J5LmpzXG5cbmNsYXNzIEJhc2VDYW52YXNGYWN0b3J5IHtcbiAgI2VuYWJsZUhXQSA9IGZhbHNlO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZW5hYmxlSFdBID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMuI2VuYWJsZUhXQSA9IGVuYWJsZUhXQTtcbiAgfVxuICBjcmVhdGUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIGNvbnRleHQ6IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICF0aGlzLiNlbmFibGVIV0FcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICByZXNldChjYW52YXNBbmRDb250ZXh0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBkZXN0cm95KGNhbnZhc0FuZENvbnRleHQpIHtcbiAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQuY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMgPSBudWxsO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVDYW52YXNgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudCxcbiAgICBlbmFibGVIV0EgPSBmYWxzZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgZW5hYmxlSFdBXG4gICAgfSk7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NtYXBfcmVhZGVyX2ZhY3RvcnkuanNcblxuXG5jbGFzcyBCYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmFzZVVybCA9IG51bGwsXG4gICAgaXNDb21wcmVzc2VkID0gdHJ1ZVxuICB9KSB7XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICB0aGlzLmlzQ29tcHJlc3NlZCA9IGlzQ29tcHJlc3NlZDtcbiAgfVxuICBhc3luYyBmZXRjaCh7XG4gICAgbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGF0IHRoZSBgY01hcFVybGAgYW5kIGBjTWFwUGFja2VkYCBBUEkgcGFyYW1ldGVycyBhcmUgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNNYXAgbmFtZSBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IHRoaXMuYmFzZVVybCArIG5hbWUgKyAodGhpcy5pc0NvbXByZXNzZWQgPyBcIi5iY21hcFwiIDogXCJcIik7XG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoKHVybCkudGhlbihjTWFwRGF0YSA9PiAoe1xuICAgICAgY01hcERhdGEsXG4gICAgICBpc0NvbXByZXNzZWQ6IHRoaXMuaXNDb21wcmVzc2VkXG4gICAgfSkpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkICR7dGhpcy5pc0NvbXByZXNzZWQgPyBcImJpbmFyeSBcIiA6IFwiXCJ9Q01hcCBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTUNNYXBSZWFkZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaERhdGEodXJsLCB0aGlzLmlzQ29tcHJlc3NlZCA/IFwiYXJyYXlidWZmZXJcIiA6IFwidGV4dFwiKTtcbiAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoZGF0YSkgOiBzdHJpbmdUb0J5dGVzKGRhdGEpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2ZpbHRlcl9mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZUZpbHRlckZhY3Rvcnkge1xuICBhZGRGaWx0ZXIobWFwcykge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRIQ01GaWx0ZXIoZmdDb2xvciwgYmdDb2xvcikge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRBbHBoYUZpbHRlcihtYXApIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkTHVtaW5vc2l0eUZpbHRlcihtYXApIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZpbHRlck5hbWUsIGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHt9XG59XG5jbGFzcyBET01GaWx0ZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUZpbHRlckZhY3Rvcnkge1xuICAjYmFzZVVybDtcbiAgI19jYWNoZTtcbiAgI19kZWZzO1xuICAjZG9jSWQ7XG4gICNkb2N1bWVudDtcbiAgI19oY21DYWNoZTtcbiAgI2lkID0gMDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRvY0lkLFxuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50XG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI2RvY0lkID0gZG9jSWQ7XG4gICAgdGhpcy4jZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG4gIGdldCAjY2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI19jYWNoZSB8fD0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCAjaGNtQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI19oY21DYWNoZSB8fD0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCAjZGVmcygpIHtcbiAgICBpZiAoIXRoaXMuI19kZWZzKSB7XG4gICAgICBjb25zdCBkaXYgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGRpdjtcbiAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgc3R5bGUuY29udGFpbiA9IFwic3RyaWN0XCI7XG4gICAgICBzdHlsZS53aWR0aCA9IHN0eWxlLmhlaWdodCA9IDA7XG4gICAgICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIHN0eWxlLnRvcCA9IHN0eWxlLmxlZnQgPSAwO1xuICAgICAgc3R5bGUuekluZGV4ID0gLTE7XG4gICAgICBjb25zdCBzdmcgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcInN2Z1wiKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAwKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgICB0aGlzLiNfZGVmcyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZGVmc1wiKTtcbiAgICAgIGRpdi5hcHBlbmQoc3ZnKTtcbiAgICAgIHN2Zy5hcHBlbmQodGhpcy4jX2RlZnMpO1xuICAgICAgdGhpcy4jZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI19kZWZzO1xuICB9XG4gICNjcmVhdGVUYWJsZXMobWFwcykge1xuICAgIGlmIChtYXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgbWFwUiA9IG1hcHNbMF07XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYnVmZmVyW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhYmxlID0gYnVmZmVyLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIFt0YWJsZSwgdGFibGUsIHRhYmxlXTtcbiAgICB9XG4gICAgY29uc3QgW21hcFIsIG1hcEcsIG1hcEJdID0gbWFwcztcbiAgICBjb25zdCBidWZmZXJSID0gbmV3IEFycmF5KDI1Nik7XG4gICAgY29uc3QgYnVmZmVyRyA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGNvbnN0IGJ1ZmZlckIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBidWZmZXJSW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgIGJ1ZmZlckdbaV0gPSBtYXBHW2ldIC8gMjU1O1xuICAgICAgYnVmZmVyQltpXSA9IG1hcEJbaV0gLyAyNTU7XG4gICAgfVxuICAgIHJldHVybiBbYnVmZmVyUi5qb2luKFwiLFwiKSwgYnVmZmVyRy5qb2luKFwiLFwiKSwgYnVmZmVyQi5qb2luKFwiLFwiKV07XG4gIH1cbiAgI2NyZWF0ZVVybChpZCkge1xuICAgIGlmICh0aGlzLiNiYXNlVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuI2Jhc2VVcmwgPSBcIlwiO1xuICAgICAgY29uc3QgdXJsID0gdGhpcy4jZG9jdW1lbnQuVVJMO1xuICAgICAgaWYgKHVybCAhPT0gdGhpcy4jZG9jdW1lbnQuYmFzZVVSSSkge1xuICAgICAgICBpZiAoaXNEYXRhU2NoZW1lKHVybCkpIHtcbiAgICAgICAgICB3YXJuKCcjY3JlYXRlVXJsOiBpZ25vcmUgXCJkYXRhOlwiLVVSTCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNiYXNlVXJsID0gdXBkYXRlVXJsSGFzaCh1cmwsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgdXJsKCR7dGhpcy4jYmFzZVVybH0jJHtpZH0pYDtcbiAgfVxuICBhZGRGaWx0ZXIobWFwcykge1xuICAgIGlmICghbWFwcykge1xuICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgIH1cbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwcyk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IFt0YWJsZVIsIHRhYmxlRywgdGFibGVCXSA9IHRoaXMuI2NyZWF0ZVRhYmxlcyhtYXBzKTtcbiAgICBjb25zdCBrZXkgPSBtYXBzLmxlbmd0aCA9PT0gMSA/IHRhYmxlUiA6IGAke3RhYmxlUn0ke3RhYmxlR30ke3RhYmxlQn1gO1xuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwcywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X3RyYW5zZmVyX21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXBzLCB1cmwpO1xuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIHVybCk7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGVSLCB0YWJsZUcsIHRhYmxlQiwgZmlsdGVyKTtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmdDb2xvcn0tJHtiZ0NvbG9yfWA7XG4gICAgY29uc3QgZmlsdGVyTmFtZSA9IFwiYmFzZVwiO1xuICAgIGxldCBpbmZvID0gdGhpcy4jaGNtQ2FjaGUuZ2V0KGZpbHRlck5hbWUpO1xuICAgIGlmIChpbmZvPy5rZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBpZiAoaW5mbykge1xuICAgICAgaW5mby5maWx0ZXI/LnJlbW92ZSgpO1xuICAgICAgaW5mby5rZXkgPSBrZXk7XG4gICAgICBpbmZvLnVybCA9IFwibm9uZVwiO1xuICAgICAgaW5mby5maWx0ZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvID0ge1xuICAgICAgICBrZXksXG4gICAgICAgIHVybDogXCJub25lXCIsXG4gICAgICAgIGZpbHRlcjogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuI2hjbUNhY2hlLnNldChmaWx0ZXJOYW1lLCBpbmZvKTtcbiAgICB9XG4gICAgaWYgKCFmZ0NvbG9yIHx8ICFiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGNvbnN0IGZnUkdCID0gdGhpcy4jZ2V0UkdCKGZnQ29sb3IpO1xuICAgIGZnQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5mZ1JHQik7XG4gICAgY29uc3QgYmdSR0IgPSB0aGlzLiNnZXRSR0IoYmdDb2xvcik7XG4gICAgYmdDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmJnUkdCKTtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBpZiAoZmdDb2xvciA9PT0gXCIjMDAwMDAwXCIgJiYgYmdDb2xvciA9PT0gXCIjZmZmZmZmXCIgfHwgZmdDb2xvciA9PT0gYmdDb2xvcikge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAyNTU7IGkrKykge1xuICAgICAgY29uc3QgeCA9IGkgLyAyNTU7XG4gICAgICBtYXBbaV0gPSB4IDw9IDAuMDM5MjggPyB4IC8gMTIuOTIgOiAoKHggKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40O1xuICAgIH1cbiAgICBjb25zdCB0YWJsZSA9IG1hcC5qb2luKFwiLFwiKTtcbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2hjbV9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IGluZm8uZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGUsIHRhYmxlLCB0YWJsZSwgZmlsdGVyKTtcbiAgICB0aGlzLiNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIGNvbnN0IGdldFN0ZXBzID0gKGMsIG4pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZmdSR0JbY10gLyAyNTU7XG4gICAgICBjb25zdCBlbmQgPSBiZ1JHQltjXSAvIDI1NTtcbiAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheShuICsgMSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gc3RhcnQgKyBpIC8gbiAqIChlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyLmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKGdldFN0ZXBzKDAsIDUpLCBnZXRTdGVwcygxLCA1KSwgZ2V0U3RlcHMoMiwgNSksIGZpbHRlcik7XG4gICAgaW5mby51cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHJldHVybiBpbmZvLnVybDtcbiAgfVxuICBhZGRBbHBoYUZpbHRlcihtYXApIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgW3RhYmxlQV0gPSB0aGlzLiNjcmVhdGVUYWJsZXMoW21hcF0pO1xuICAgIGNvbnN0IGtleSA9IGBhbHBoYV8ke3RhYmxlQX1gO1xuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1fYWxwaGFfbWFwXyR7dGhpcy4jaWQrK31gO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24odGFibGVBLCBmaWx0ZXIpO1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgYWRkTHVtaW5vc2l0eUZpbHRlcihtYXApIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwIHx8IFwibHVtaW5vc2l0eVwiKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IHRhYmxlQSwga2V5O1xuICAgIGlmIChtYXApIHtcbiAgICAgIFt0YWJsZUFdID0gdGhpcy4jY3JlYXRlVGFibGVzKFttYXBdKTtcbiAgICAgIGtleSA9IGBsdW1pbm9zaXR5XyR7dGFibGVBfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IFwibHVtaW5vc2l0eVwiO1xuICAgIH1cbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2x1bWlub3NpdHlfbWFwXyR7dGhpcy4jaWQrK31gO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkTHVtaW5vc2l0eUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICBpZiAobWFwKSB7XG4gICAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcEFscGhhQ29udmVyc2lvbih0YWJsZUEsIGZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZpbHRlck5hbWUsIGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICBjb25zdCBrZXkgPSBgJHtmZ0NvbG9yfS0ke2JnQ29sb3J9LSR7bmV3RmdDb2xvcn0tJHtuZXdCZ0NvbG9yfWA7XG4gICAgbGV0IGluZm8gPSB0aGlzLiNoY21DYWNoZS5nZXQoZmlsdGVyTmFtZSk7XG4gICAgaWYgKGluZm8/LmtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGlmIChpbmZvKSB7XG4gICAgICBpbmZvLmZpbHRlcj8ucmVtb3ZlKCk7XG4gICAgICBpbmZvLmtleSA9IGtleTtcbiAgICAgIGluZm8udXJsID0gXCJub25lXCI7XG4gICAgICBpbmZvLmZpbHRlciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gPSB7XG4gICAgICAgIGtleSxcbiAgICAgICAgdXJsOiBcIm5vbmVcIixcbiAgICAgICAgZmlsdGVyOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy4jaGNtQ2FjaGUuc2V0KGZpbHRlck5hbWUsIGluZm8pO1xuICAgIH1cbiAgICBpZiAoIWZnQ29sb3IgfHwgIWJnQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgY29uc3QgW2ZnUkdCLCBiZ1JHQl0gPSBbZmdDb2xvciwgYmdDb2xvcl0ubWFwKHRoaXMuI2dldFJHQi5iaW5kKHRoaXMpKTtcbiAgICBsZXQgZmdHcmF5ID0gTWF0aC5yb3VuZCgwLjIxMjYgKiBmZ1JHQlswXSArIDAuNzE1MiAqIGZnUkdCWzFdICsgMC4wNzIyICogZmdSR0JbMl0pO1xuICAgIGxldCBiZ0dyYXkgPSBNYXRoLnJvdW5kKDAuMjEyNiAqIGJnUkdCWzBdICsgMC43MTUyICogYmdSR0JbMV0gKyAwLjA3MjIgKiBiZ1JHQlsyXSk7XG4gICAgbGV0IFtuZXdGZ1JHQiwgbmV3QmdSR0JdID0gW25ld0ZnQ29sb3IsIG5ld0JnQ29sb3JdLm1hcCh0aGlzLiNnZXRSR0IuYmluZCh0aGlzKSk7XG4gICAgaWYgKGJnR3JheSA8IGZnR3JheSkge1xuICAgICAgW2ZnR3JheSwgYmdHcmF5LCBuZXdGZ1JHQiwgbmV3QmdSR0JdID0gW2JnR3JheSwgZmdHcmF5LCBuZXdCZ1JHQiwgbmV3RmdSR0JdO1xuICAgIH1cbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBjb25zdCBnZXRTdGVwcyA9IChmZywgYmcsIG4pID0+IHtcbiAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgY29uc3Qgc3RlcCA9IChiZ0dyYXkgLSBmZ0dyYXkpIC8gbjtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gZmcgLyAyNTU7XG4gICAgICBjb25zdCBuZXdTdGVwID0gKGJnIC0gZmcpIC8gKDI1NSAqIG4pO1xuICAgICAgbGV0IHByZXYgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBNYXRoLnJvdW5kKGZnR3JheSArIGkgKiBzdGVwKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXdTdGFydCArIGkgKiBuZXdTdGVwO1xuICAgICAgICBmb3IgKGxldCBqID0gcHJldjsgaiA8PSBrOyBqKyspIHtcbiAgICAgICAgICBhcnJbal0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gayArIDE7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gcHJldjsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFycltwcmV2IC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyLmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9oY21fJHtmaWx0ZXJOYW1lfV9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IGluZm8uZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbihnZXRTdGVwcyhuZXdGZ1JHQlswXSwgbmV3QmdSR0JbMF0sIDUpLCBnZXRTdGVwcyhuZXdGZ1JHQlsxXSwgbmV3QmdSR0JbMV0sIDUpLCBnZXRTdGVwcyhuZXdGZ1JHQlsyXSwgbmV3QmdSR0JbMl0sIDUpLCBmaWx0ZXIpO1xuICAgIGluZm8udXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICByZXR1cm4gaW5mby51cmw7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHtcbiAgICBpZiAoa2VlcEhDTSAmJiB0aGlzLiNfaGNtQ2FjaGU/LnNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jX2RlZnM/LnBhcmVudE5vZGUucGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICB0aGlzLiNfZGVmcyA9IG51bGw7XG4gICAgdGhpcy4jX2NhY2hlPy5jbGVhcigpO1xuICAgIHRoaXMuI19jYWNoZSA9IG51bGw7XG4gICAgdGhpcy4jX2hjbUNhY2hlPy5jbGVhcigpO1xuICAgIHRoaXMuI19oY21DYWNoZSA9IG51bGw7XG4gICAgdGhpcy4jaWQgPSAwO1xuICB9XG4gICNhZGRMdW1pbm9zaXR5Q29udmVyc2lvbihmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbG9yTWF0cml4ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbG9yTWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInZhbHVlc1wiLCBcIjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMyAwLjU5IDAuMTEgMCAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29sb3JNYXRyaXggPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29sb3JNYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwibWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidmFsdWVzXCIsIFwiMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMCAwIDAgMSAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2NyZWF0ZUZpbHRlcihpZCkge1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmlsdGVyXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIiwgXCJzUkdCXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgdGhpcy4jZGVmcy5hcHBlbmQoZmlsdGVyKTtcbiAgICByZXR1cm4gZmlsdGVyO1xuICB9XG4gICNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgZnVuYywgdGFibGUpIHtcbiAgICBjb25zdCBmZUZ1bmMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBmdW5jKTtcbiAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImRpc2NyZXRlXCIpO1xuICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoXCJ0YWJsZVZhbHVlc1wiLCB0YWJsZSk7XG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmQoZmVGdW5jKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHJUYWJsZSwgZ1RhYmxlLCBiVGFibGUsIGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29tcG9uZW50VHJhbnNmZXIgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29tcG9uZW50VHJhbnNmZXJcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNSXCIsIHJUYWJsZSk7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jR1wiLCBnVGFibGUpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY0JcIiwgYlRhYmxlKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24oYVRhYmxlLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbXBvbmVudFRyYW5zZmVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jQVwiLCBhVGFibGUpO1xuICB9XG4gICNnZXRSR0IoY29sb3IpIHtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgcmV0dXJuIGdldFJHQihnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2RlZnMpLmdldFByb3BlcnR5VmFsdWUoXCJjb2xvclwiKSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvc3RhbmRhcmRfZm9udGRhdGFfZmFjdG9yeS5qc1xuXG5cbmNsYXNzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgfVxuICBhc3luYyBmZXRjaCh7XG4gICAgZmlsZW5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCB0aGUgYHN0YW5kYXJkRm9udERhdGFVcmxgIEFQSSBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb250IGZpbGVuYW1lIG11c3QgYmUgc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfSR7ZmlsZW5hbWV9YDtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2godXJsKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCBmb250IGRhdGEgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBleHRlbmRzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hEYXRhKHVybCwgXCJhcnJheWJ1ZmZlclwiKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvd2FzbV9mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZVdhc21GYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB9XG4gIGFzeW5jIGZldGNoKHtcbiAgICBmaWxlbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGF0IHRoZSBgd2FzbVVybGAgQVBJIHBhcmFtZXRlciBpcyBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldhc20gZmlsZW5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9JHtmaWxlbmFtZX1gO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkIHdhc20gZGF0YSBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTVdhc21GYWN0b3J5IGV4dGVuZHMgQmFzZVdhc21GYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaERhdGEodXJsLCBcImFycmF5YnVmZmVyXCIpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9ub2RlX3V0aWxzLmpzXG5cblxuXG5cblxuXG5pZiAoaXNOb2RlSlMpIHtcbiAgd2FybihcIlBsZWFzZSB1c2UgdGhlIGBsZWdhY3lgIGJ1aWxkIGluIE5vZGUuanMgZW52aXJvbm1lbnRzLlwiKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCkge1xuICBjb25zdCBmcyA9IHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShcImZzXCIpO1xuICBjb25zdCBkYXRhID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUodXJsKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xufVxuY2xhc3MgTm9kZUZpbHRlckZhY3RvcnkgZXh0ZW5kcyBCYXNlRmlsdGVyRmFjdG9yeSB7fVxuY2xhc3MgTm9kZUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlcXVpcmUgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJtb2R1bGVcIikuY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHJlcXVpcmUoXCJAbmFwaS1ycy9jYW52YXNcIik7XG4gICAgcmV0dXJuIGNhbnZhcy5jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIH1cbn1cbmNsYXNzIE5vZGVDTWFwUmVhZGVyRmFjdG9yeSBleHRlbmRzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICByZXR1cm4gbm9kZV91dGlsc19mZXRjaERhdGEodXJsKTtcbiAgfVxufVxuY2xhc3MgTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IGV4dGVuZHMgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHJldHVybiBub2RlX3V0aWxzX2ZldGNoRGF0YSh1cmwpO1xuICB9XG59XG5jbGFzcyBOb2RlV2FzbUZhY3RvcnkgZXh0ZW5kcyBCYXNlV2FzbUZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgcmV0dXJuIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvY2FudmFzX2RlcGVuZGVuY3lfdHJhY2tlci5qc1xuXG5jb25zdCBGT1JDRURfREVQRU5ERU5DWV9MQUJFTCA9IFwiX19mb3JjZWREZXBlbmRlbmN5XCI7XG5jbGFzcyBDYW52YXNEZXBlbmRlbmN5VHJhY2tlciB7XG4gICNzaW1wbGUgPSB7XG4gICAgX19wcm90b19fOiBudWxsXG4gIH07XG4gICNpbmNyZW1lbnRhbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdHJhbnNmb3JtOiBbXSxcbiAgICBtb3ZlVGV4dDogW10sXG4gICAgc2FtZUxpbmVUZXh0OiBbXSxcbiAgICBbRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUxdOiBbXVxuICB9O1xuICAjbmFtZWREZXBlbmRlbmNpZXMgPSBuZXcgTWFwKCk7XG4gICNzYXZlc1N0YWNrID0gW107XG4gICNtYXJrZWRDb250ZW50U3RhY2sgPSBbXTtcbiAgI2Jhc2VUcmFuc2Zvcm1TdGFjayA9IFtbMSwgMCwgMCwgMSwgMCwgMF1dO1xuICAjY2xpcEJveCA9IFstSW5maW5pdHksIC1JbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5XTtcbiAgI3BlbmRpbmdCQm94ID0gbmV3IEZsb2F0NjRBcnJheShbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV0pO1xuICAjcGVuZGluZ0JCb3hJZHggPSAtMTtcbiAgI3BlbmRpbmdEZXBlbmRlbmNpZXMgPSBuZXcgU2V0KCk7XG4gICNvcGVyYXRpb25zID0gbmV3IE1hcCgpO1xuICAjZm9udEJCb3hUcnVzdHdvcnRoeSA9IG5ldyBNYXAoKTtcbiAgI2NhbnZhc1dpZHRoO1xuICAjY2FudmFzSGVpZ2h0O1xuICBjb25zdHJ1Y3RvcihjYW52YXMpIHtcbiAgICB0aGlzLiNjYW52YXNXaWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB0aGlzLiNjYW52YXNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICB9XG4gIHNhdmUob3BJZHgpIHtcbiAgICB0aGlzLiNzaW1wbGUgPSB7XG4gICAgICBfX3Byb3RvX186IHRoaXMuI3NpbXBsZVxuICAgIH07XG4gICAgdGhpcy4jaW5jcmVtZW50YWwgPSB7XG4gICAgICBfX3Byb3RvX186IHRoaXMuI2luY3JlbWVudGFsLFxuICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgIF9fcHJvdG9fXzogdGhpcy4jaW5jcmVtZW50YWwudHJhbnNmb3JtXG4gICAgICB9LFxuICAgICAgbW92ZVRleHQ6IHtcbiAgICAgICAgX19wcm90b19fOiB0aGlzLiNpbmNyZW1lbnRhbC5tb3ZlVGV4dFxuICAgICAgfSxcbiAgICAgIHNhbWVMaW5lVGV4dDoge1xuICAgICAgICBfX3Byb3RvX186IHRoaXMuI2luY3JlbWVudGFsLnNhbWVMaW5lVGV4dFxuICAgICAgfSxcbiAgICAgIFtGT1JDRURfREVQRU5ERU5DWV9MQUJFTF06IHtcbiAgICAgICAgX19wcm90b19fOiB0aGlzLiNpbmNyZW1lbnRhbFtGT1JDRURfREVQRU5ERU5DWV9MQUJFTF1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuI2NsaXBCb3ggPSB7XG4gICAgICBfX3Byb3RvX186IHRoaXMuI2NsaXBCb3hcbiAgICB9O1xuICAgIHRoaXMuI3NhdmVzU3RhY2sucHVzaChbb3BJZHgsIG51bGxdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXN0b3JlKG9wSWR4KSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy4jc2ltcGxlKTtcbiAgICBpZiAocHJldmlvdXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLiNzaW1wbGUgPSBwcmV2aW91cztcbiAgICB0aGlzLiNpbmNyZW1lbnRhbCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLiNpbmNyZW1lbnRhbCk7XG4gICAgdGhpcy4jY2xpcEJveCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLiNjbGlwQm94KTtcbiAgICBjb25zdCBsYXN0UGFpciA9IHRoaXMuI3NhdmVzU3RhY2sucG9wKCk7XG4gICAgaWYgKGxhc3RQYWlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxhc3RQYWlyWzFdID0gb3BJZHg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE9wZW5NYXJrZXIoaWR4KSB7XG4gICAgdGhpcy4jc2F2ZXNTdGFjay5wdXNoKFtpZHgsIG51bGxdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRPcGVuTWFya2VyKCkge1xuICAgIGlmICh0aGlzLiNzYXZlc1N0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNzYXZlc1N0YWNrLmF0KC0xKVswXTtcbiAgfVxuICByZWNvcmRDbG9zZU1hcmtlcihpZHgpIHtcbiAgICBjb25zdCBsYXN0UGFpciA9IHRoaXMuI3NhdmVzU3RhY2sucG9wKCk7XG4gICAgaWYgKGxhc3RQYWlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxhc3RQYWlyWzFdID0gaWR4O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiZWdpbk1hcmtlZENvbnRlbnQob3BJZHgpIHtcbiAgICB0aGlzLiNtYXJrZWRDb250ZW50U3RhY2sucHVzaChbb3BJZHgsIG51bGxdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBlbmRNYXJrZWRDb250ZW50KG9wSWR4KSB7XG4gICAgY29uc3QgbGFzdFBhaXIgPSB0aGlzLiNtYXJrZWRDb250ZW50U3RhY2sucG9wKCk7XG4gICAgaWYgKGxhc3RQYWlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxhc3RQYWlyWzFdID0gb3BJZHg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHB1c2hCYXNlVHJhbnNmb3JtKGN0eCkge1xuICAgIHRoaXMuI2Jhc2VUcmFuc2Zvcm1TdGFjay5wdXNoKFV0aWwubXVsdGlwbHlCeURPTU1hdHJpeCh0aGlzLiNiYXNlVHJhbnNmb3JtU3RhY2suYXQoLTEpLCBjdHguZ2V0VHJhbnNmb3JtKCkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwb3BCYXNlVHJhbnNmb3JtKCkge1xuICAgIGlmICh0aGlzLiNiYXNlVHJhbnNmb3JtU3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy4jYmFzZVRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRTaW1wbGVEYXRhKG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI3NpbXBsZVtuYW1lXSA9IGlkeDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRJbmNyZW1lbnRhbERhdGEobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jaW5jcmVtZW50YWxbbmFtZV0ucHVzaChpZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2V0SW5jcmVtZW50YWxEYXRhKG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI2luY3JlbWVudGFsW25hbWVdLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkTmFtZWREYXRhKG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI25hbWVkRGVwZW5kZW5jaWVzLnNldChuYW1lLCBpZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3kobmFtZSwgaWR4KSB7XG4gICAgdGhpcy5yZWNvcmRJbmNyZW1lbnRhbERhdGEoRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUwsIGlkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW5oZXJpdFNpbXBsZURhdGFBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcyhuYW1lcykge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgaWYgKG5hbWUgaW4gdGhpcy4jc2ltcGxlKSB7XG4gICAgICAgIHRoaXMucmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShuYW1lLCB0aGlzLiNzaW1wbGVbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbmhlcml0UGVuZGluZ0RlcGVuZGVuY2llc0FzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKCkge1xuICAgIGZvciAoY29uc3QgZGVwIG9mIHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMucmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShGT1JDRURfREVQRU5ERU5DWV9MQUJFTCwgZGVwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzZXRCQm94KGlkeCkge1xuICAgIHRoaXMuI3BlbmRpbmdCQm94SWR4ID0gaWR4O1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzBdID0gSW5maW5pdHk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbMV0gPSBJbmZpbml0eTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFsyXSA9IC1JbmZpbml0eTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFszXSA9IC1JbmZpbml0eTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXQgaGFzUGVuZGluZ0JCb3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BlbmRpbmdCQm94SWR4ICE9PSAtMTtcbiAgfVxuICByZWNvcmRDbGlwQm94KGlkeCwgY3R4LCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gVXRpbC5tdWx0aXBseUJ5RE9NTWF0cml4KHRoaXMuI2Jhc2VUcmFuc2Zvcm1TdGFjay5hdCgtMSksIGN0eC5nZXRUcmFuc2Zvcm0oKSk7XG4gICAgY29uc3QgY2xpcEJveCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSwgdHJhbnNmb3JtLCBjbGlwQm94KTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBVdGlsLmludGVyc2VjdCh0aGlzLiNjbGlwQm94LCBjbGlwQm94KTtcbiAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICB0aGlzLiNjbGlwQm94WzBdID0gaW50ZXJzZWN0aW9uWzBdO1xuICAgICAgdGhpcy4jY2xpcEJveFsxXSA9IGludGVyc2VjdGlvblsxXTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMl0gPSBpbnRlcnNlY3Rpb25bMl07XG4gICAgICB0aGlzLiNjbGlwQm94WzNdID0gaW50ZXJzZWN0aW9uWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNjbGlwQm94WzBdID0gdGhpcy4jY2xpcEJveFsxXSA9IEluZmluaXR5O1xuICAgICAgdGhpcy4jY2xpcEJveFsyXSA9IHRoaXMuI2NsaXBCb3hbM10gPSAtSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZEJCb3goaWR4LCBjdHgsIG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcbiAgICBjb25zdCBjbGlwQm94ID0gdGhpcy4jY2xpcEJveDtcbiAgICBpZiAoY2xpcEJveFswXSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBVdGlsLm11bHRpcGx5QnlET01NYXRyaXgodGhpcy4jYmFzZVRyYW5zZm9ybVN0YWNrLmF0KC0xKSwgY3R4LmdldFRyYW5zZm9ybSgpKTtcbiAgICBpZiAoY2xpcEJveFswXSA9PT0gLUluZmluaXR5KSB7XG4gICAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSwgdHJhbnNmb3JtLCB0aGlzLiNwZW5kaW5nQkJveCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgYmJveCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSwgdHJhbnNmb3JtLCBiYm94KTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFswXSA9IE1hdGgubWluKHRoaXMuI3BlbmRpbmdCQm94WzBdLCBNYXRoLm1heChiYm94WzBdLCBjbGlwQm94WzBdKSk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbMV0gPSBNYXRoLm1pbih0aGlzLiNwZW5kaW5nQkJveFsxXSwgTWF0aC5tYXgoYmJveFsxXSwgY2xpcEJveFsxXSkpO1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzJdID0gTWF0aC5tYXgodGhpcy4jcGVuZGluZ0JCb3hbMl0sIE1hdGgubWluKGJib3hbMl0sIGNsaXBCb3hbMl0pKTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFszXSA9IE1hdGgubWF4KHRoaXMuI3BlbmRpbmdCQm94WzNdLCBNYXRoLm1pbihiYm94WzNdLCBjbGlwQm94WzNdKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkQ2hhcmFjdGVyQkJveChpZHgsIGN0eCwgZm9udCwgc2NhbGUgPSAxLCB4ID0gMCwgeSA9IDAsIGdldE1lYXN1cmUpIHtcbiAgICBjb25zdCBmb250QkJveCA9IGZvbnQuYmJveDtcbiAgICBsZXQgaXNCQm94VHJ1c3R3b3J0aHk7XG4gICAgbGV0IGNvbXB1dGVkQkJveDtcbiAgICBpZiAoZm9udEJCb3gpIHtcbiAgICAgIGlzQkJveFRydXN0d29ydGh5ID0gZm9udEJCb3hbMl0gIT09IGZvbnRCQm94WzBdICYmIGZvbnRCQm94WzNdICE9PSBmb250QkJveFsxXSAmJiB0aGlzLiNmb250QkJveFRydXN0d29ydGh5LmdldChmb250KTtcbiAgICAgIGlmIChpc0JCb3hUcnVzdHdvcnRoeSAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29tcHV0ZWRCQm94ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KGZvbnRCQm94LCBmb250LmZvbnRNYXRyaXgsIGNvbXB1dGVkQkJveCk7XG4gICAgICAgIGlmIChzY2FsZSAhPT0gMSB8fCB4ICE9PSAwIHx8IHkgIT09IDApIHtcbiAgICAgICAgICBVdGlsLnNjYWxlTWluTWF4KFtzY2FsZSwgMCwgMCwgLXNjYWxlLCB4LCB5XSwgY29tcHV0ZWRCQm94KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCQm94VHJ1c3R3b3J0aHkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZWNvcmRCQm94KGlkeCwgY3R4LCBjb21wdXRlZEJCb3hbMF0sIGNvbXB1dGVkQkJveFsyXSwgY29tcHV0ZWRCQm94WzFdLCBjb21wdXRlZEJCb3hbM10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZ2V0TWVhc3VyZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVjb3JkRnVsbFBhZ2VCQm94KGlkeCk7XG4gICAgfVxuICAgIGNvbnN0IG1lYXN1cmUgPSBnZXRNZWFzdXJlKCk7XG4gICAgaWYgKGZvbnRCQm94ICYmIGNvbXB1dGVkQkJveCAmJiBpc0JCb3hUcnVzdHdvcnRoeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpc0JCb3hUcnVzdHdvcnRoeSA9IGNvbXB1dGVkQkJveFswXSA8PSB4IC0gbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveExlZnQgJiYgY29tcHV0ZWRCQm94WzJdID49IHggKyBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQgJiYgY29tcHV0ZWRCQm94WzFdIDw9IHkgLSBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ICYmIGNvbXB1dGVkQkJveFszXSA+PSB5ICsgbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgICB0aGlzLiNmb250QkJveFRydXN0d29ydGh5LnNldChmb250LCBpc0JCb3hUcnVzdHdvcnRoeSk7XG4gICAgICBpZiAoaXNCQm94VHJ1c3R3b3J0aHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb3JkQkJveChpZHgsIGN0eCwgY29tcHV0ZWRCQm94WzBdLCBjb21wdXRlZEJCb3hbMl0sIGNvbXB1dGVkQkJveFsxXSwgY29tcHV0ZWRCQm94WzNdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVjb3JkQkJveChpZHgsIGN0eCwgeCAtIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hMZWZ0LCB4ICsgbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0LCB5IC0gbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCwgeSArIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50KTtcbiAgfVxuICByZWNvcmRGdWxsUGFnZUJCb3goaWR4KSB7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbMF0gPSBNYXRoLm1heCgwLCB0aGlzLiNjbGlwQm94WzBdKTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFsxXSA9IE1hdGgubWF4KDAsIHRoaXMuI2NsaXBCb3hbMV0pO1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzJdID0gTWF0aC5taW4odGhpcy4jY2FudmFzV2lkdGgsIHRoaXMuI2NsaXBCb3hbMl0pO1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzNdID0gTWF0aC5taW4odGhpcy4jY2FudmFzSGVpZ2h0LCB0aGlzLiNjbGlwQm94WzNdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRTaW1wbGVJbmRleChkZXBlbmRlbmN5TmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNzaW1wbGVbZGVwZW5kZW5jeU5hbWVdO1xuICB9XG4gIHJlY29yZERlcGVuZGVuY2llcyhpZHgsIGRlcGVuZGVuY3lOYW1lcykge1xuICAgIGNvbnN0IHBlbmRpbmdEZXBlbmRlbmNpZXMgPSB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzO1xuICAgIGNvbnN0IHNpbXBsZSA9IHRoaXMuI3NpbXBsZTtcbiAgICBjb25zdCBpbmNyZW1lbnRhbCA9IHRoaXMuI2luY3JlbWVudGFsO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBkZXBlbmRlbmN5TmFtZXMpIHtcbiAgICAgIGlmIChuYW1lIGluIHRoaXMuI3NpbXBsZSkge1xuICAgICAgICBwZW5kaW5nRGVwZW5kZW5jaWVzLmFkZChzaW1wbGVbbmFtZV0pO1xuICAgICAgfSBlbHNlIGlmIChuYW1lIGluIGluY3JlbWVudGFsKSB7XG4gICAgICAgIGluY3JlbWVudGFsW25hbWVdLmZvckVhY2gocGVuZGluZ0RlcGVuZGVuY2llcy5hZGQsIHBlbmRpbmdEZXBlbmRlbmNpZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb3B5RGVwZW5kZW5jaWVzRnJvbUluY3JlbWVudGFsT3BlcmF0aW9uKGlkeCwgbmFtZSkge1xuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSB0aGlzLiNvcGVyYXRpb25zO1xuICAgIGNvbnN0IHBlbmRpbmdEZXBlbmRlbmNpZXMgPSB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzO1xuICAgIGZvciAoY29uc3QgZGVwSWR4IG9mIHRoaXMuI2luY3JlbWVudGFsW25hbWVdKSB7XG4gICAgICBvcGVyYXRpb25zLmdldChkZXBJZHgpLmRlcGVuZGVuY2llcy5mb3JFYWNoKHBlbmRpbmdEZXBlbmRlbmNpZXMuYWRkLCBwZW5kaW5nRGVwZW5kZW5jaWVzLmFkZChkZXBJZHgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkTmFtZWREZXBlbmRlbmN5KGlkeCwgbmFtZSkge1xuICAgIGlmICh0aGlzLiNuYW1lZERlcGVuZGVuY2llcy5oYXMobmFtZSkpIHtcbiAgICAgIHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMuYWRkKHRoaXMuI25hbWVkRGVwZW5kZW5jaWVzLmdldChuYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE9wZXJhdGlvbihpZHgsIHByZXNlcnZlQmJveCA9IGZhbHNlKSB7XG4gICAgdGhpcy5yZWNvcmREZXBlbmRlbmNpZXMoaWR4LCBbRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUxdKTtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBuZXcgU2V0KHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMpO1xuICAgIGNvbnN0IHBhaXJzID0gdGhpcy4jc2F2ZXNTdGFjay5jb25jYXQodGhpcy4jbWFya2VkQ29udGVudFN0YWNrKTtcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jcGVuZGluZ0JCb3hJZHggPT09IGlkeCA/IHtcbiAgICAgIG1pblg6IHRoaXMuI3BlbmRpbmdCQm94WzBdLFxuICAgICAgbWluWTogdGhpcy4jcGVuZGluZ0JCb3hbMV0sXG4gICAgICBtYXhYOiB0aGlzLiNwZW5kaW5nQkJveFsyXSxcbiAgICAgIG1heFk6IHRoaXMuI3BlbmRpbmdCQm94WzNdXG4gICAgfSA6IG51bGw7XG4gICAgdGhpcy4jb3BlcmF0aW9ucy5zZXQoaWR4LCB7XG4gICAgICBiYm94LFxuICAgICAgcGFpcnMsXG4gICAgICBkZXBlbmRlbmNpZXNcbiAgICB9KTtcbiAgICBpZiAoIXByZXNlcnZlQmJveCkge1xuICAgICAgdGhpcy4jcGVuZGluZ0JCb3hJZHggPSAtMTtcbiAgICB9XG4gICAgdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcy5jbGVhcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGJib3hUb0NsaXBCb3hEcm9wT3BlcmF0aW9uKGlkeCkge1xuICAgIGlmICh0aGlzLiNwZW5kaW5nQkJveElkeCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuI3BlbmRpbmdCQm94SWR4ID0gLTE7XG4gICAgICB0aGlzLiNjbGlwQm94WzBdID0gTWF0aC5tYXgodGhpcy4jY2xpcEJveFswXSwgdGhpcy4jcGVuZGluZ0JCb3hbMF0pO1xuICAgICAgdGhpcy4jY2xpcEJveFsxXSA9IE1hdGgubWF4KHRoaXMuI2NsaXBCb3hbMV0sIHRoaXMuI3BlbmRpbmdCQm94WzFdKTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMl0gPSBNYXRoLm1pbih0aGlzLiNjbGlwQm94WzJdLCB0aGlzLiNwZW5kaW5nQkJveFsyXSk7XG4gICAgICB0aGlzLiNjbGlwQm94WzNdID0gTWF0aC5taW4odGhpcy4jY2xpcEJveFszXSwgdGhpcy4jcGVuZGluZ0JCb3hbM10pO1xuICAgIH1cbiAgICB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzLmNsZWFyKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX3Rha2VQZW5kaW5nRGVwZW5kZW5jaWVzKCkge1xuICAgIGNvbnN0IHBlbmRpbmdEZXBlbmRlbmNpZXMgPSB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzO1xuICAgIHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMgPSBuZXcgU2V0KCk7XG4gICAgcmV0dXJuIHBlbmRpbmdEZXBlbmRlbmNpZXM7XG4gIH1cbiAgX2V4dHJhY3RPcGVyYXRpb24oaWR4KSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy4jb3BlcmF0aW9ucy5nZXQoaWR4KTtcbiAgICB0aGlzLiNvcGVyYXRpb25zLmRlbGV0ZShpZHgpO1xuICAgIHJldHVybiBvcGVyYXRpb247XG4gIH1cbiAgX3B1c2hQZW5kaW5nRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcykge1xuICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcy5hZGQoZGVwKTtcbiAgICB9XG4gIH1cbiAgdGFrZSgpIHtcbiAgICB0aGlzLiNmb250QkJveFRydXN0d29ydGh5LmNsZWFyKCk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jb3BlcmF0aW9ucywgKFtpZHgsIHtcbiAgICAgIGJib3gsXG4gICAgICBwYWlycyxcbiAgICAgIGRlcGVuZGVuY2llc1xuICAgIH1dKSA9PiB7XG4gICAgICBwYWlycy5mb3JFYWNoKHBhaXIgPT4gcGFpci5mb3JFYWNoKGRlcGVuZGVuY2llcy5hZGQsIGRlcGVuZGVuY2llcykpO1xuICAgICAgZGVwZW5kZW5jaWVzLmRlbGV0ZShpZHgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluWDogKGJib3g/Lm1pblggPz8gMCkgLyB0aGlzLiNjYW52YXNXaWR0aCxcbiAgICAgICAgbWF4WDogKGJib3g/Lm1heFggPz8gdGhpcy4jY2FudmFzV2lkdGgpIC8gdGhpcy4jY2FudmFzV2lkdGgsXG4gICAgICAgIG1pblk6IChiYm94Py5taW5ZID8/IDApIC8gdGhpcy4jY2FudmFzSGVpZ2h0LFxuICAgICAgICBtYXhZOiAoYmJveD8ubWF4WSA/PyB0aGlzLiNjYW52YXNIZWlnaHQpIC8gdGhpcy4jY2FudmFzSGVpZ2h0LFxuICAgICAgICBkZXBlbmRlbmNpZXM6IEFycmF5LmZyb20oZGVwZW5kZW5jaWVzKS5zb3J0KChhLCBiKSA9PiBhIC0gYiksXG4gICAgICAgIGlkeFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgQ2FudmFzTmVzdGVkRGVwZW5kZW5jeVRyYWNrZXIge1xuICAjZGVwZW5kZW5jeVRyYWNrZXI7XG4gICNvcElkeDtcbiAgI25lc3RpbmdMZXZlbCA9IDA7XG4gICNvdXRlckRlcGVuZGVuY2llcztcbiAgI3NhdmVzTGV2ZWwgPSAwO1xuICBjb25zdHJ1Y3RvcihkZXBlbmRlbmN5VHJhY2tlciwgb3BJZHgpIHtcbiAgICBpZiAoZGVwZW5kZW5jeVRyYWNrZXIgaW5zdGFuY2VvZiBDYW52YXNOZXN0ZWREZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgcmV0dXJuIGRlcGVuZGVuY3lUcmFja2VyO1xuICAgIH1cbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlciA9IGRlcGVuZGVuY3lUcmFja2VyO1xuICAgIHRoaXMuI291dGVyRGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jeVRyYWNrZXIuX3Rha2VQZW5kaW5nRGVwZW5kZW5jaWVzKCk7XG4gICAgdGhpcy4jb3BJZHggPSBvcElkeDtcbiAgfVxuICBzYXZlKG9wSWR4KSB7XG4gICAgdGhpcy4jc2F2ZXNMZXZlbCsrO1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnNhdmUodGhpcy4jb3BJZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc3RvcmUob3BJZHgpIHtcbiAgICBpZiAodGhpcy4jc2F2ZXNMZXZlbCA+IDApIHtcbiAgICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlc3RvcmUodGhpcy4jb3BJZHgpO1xuICAgICAgdGhpcy4jc2F2ZXNMZXZlbC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRPcGVuTWFya2VyKGlkeCkge1xuICAgIHRoaXMuI25lc3RpbmdMZXZlbCsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldE9wZW5NYXJrZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI25lc3RpbmdMZXZlbCA+IDAgPyB0aGlzLiNvcElkeCA6IHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLmdldE9wZW5NYXJrZXIoKTtcbiAgfVxuICByZWNvcmRDbG9zZU1hcmtlcihpZHgpIHtcbiAgICB0aGlzLiNuZXN0aW5nTGV2ZWwtLTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiZWdpbk1hcmtlZENvbnRlbnQob3BJZHgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBlbmRNYXJrZWRDb250ZW50KG9wSWR4KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcHVzaEJhc2VUcmFuc2Zvcm0oY3R4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucHVzaEJhc2VUcmFuc2Zvcm0oY3R4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwb3BCYXNlVHJhbnNmb3JtKCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnBvcEJhc2VUcmFuc2Zvcm0oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRTaW1wbGVEYXRhKG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZFNpbXBsZURhdGEobmFtZSwgdGhpcy4jb3BJZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZEluY3JlbWVudGFsRGF0YShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRJbmNyZW1lbnRhbERhdGEobmFtZSwgdGhpcy4jb3BJZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2V0SW5jcmVtZW50YWxEYXRhKG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlc2V0SW5jcmVtZW50YWxEYXRhKG5hbWUsIHRoaXMuI29wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmROYW1lZERhdGEobmFtZSwgaWR4KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KG5hbWUsIHRoaXMuI29wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbmhlcml0U2ltcGxlRGF0YUFzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKG5hbWVzKSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuaW5oZXJpdFNpbXBsZURhdGFBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcyhuYW1lcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW5oZXJpdFBlbmRpbmdEZXBlbmRlbmNpZXNBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcygpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5pbmhlcml0UGVuZGluZ0RlcGVuZGVuY2llc0FzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzZXRCQm94KGlkeCkge1xuICAgIGlmICghdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuaGFzUGVuZGluZ0JCb3gpIHtcbiAgICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlc2V0QkJveCh0aGlzLiNvcElkeCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldCBoYXNQZW5kaW5nQkJveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuaGFzUGVuZGluZ0JCb3g7XG4gIH1cbiAgcmVjb3JkQ2xpcEJveChpZHgsIGN0eCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZENsaXBCb3godGhpcy4jb3BJZHgsIGN0eCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkQkJveChpZHgsIGN0eCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZEJCb3godGhpcy4jb3BJZHgsIGN0eCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkQ2hhcmFjdGVyQkJveChpZHgsIGN0eCwgZm9udCwgc2NhbGUsIHgsIHksIGdldE1lYXN1cmUpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRDaGFyYWN0ZXJCQm94KHRoaXMuI29wSWR4LCBjdHgsIGZvbnQsIHNjYWxlLCB4LCB5LCBnZXRNZWFzdXJlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRGdWxsUGFnZUJCb3goaWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkRnVsbFBhZ2VCQm94KHRoaXMuI29wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRTaW1wbGVJbmRleChkZXBlbmRlbmN5TmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5nZXRTaW1wbGVJbmRleChkZXBlbmRlbmN5TmFtZSk7XG4gIH1cbiAgcmVjb3JkRGVwZW5kZW5jaWVzKGlkeCwgZGVwZW5kZW5jeU5hbWVzKSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkRGVwZW5kZW5jaWVzKHRoaXMuI29wSWR4LCBkZXBlbmRlbmN5TmFtZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvcHlEZXBlbmRlbmNpZXNGcm9tSW5jcmVtZW50YWxPcGVyYXRpb24oaWR4LCBuYW1lKSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuY29weURlcGVuZGVuY2llc0Zyb21JbmNyZW1lbnRhbE9wZXJhdGlvbih0aGlzLiNvcElkeCwgbmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkTmFtZWREZXBlbmRlbmN5KGlkeCwgbmFtZSkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZE5hbWVkRGVwZW5kZW5jeSh0aGlzLiNvcElkeCwgbmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkT3BlcmF0aW9uKGlkeCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZE9wZXJhdGlvbih0aGlzLiNvcElkeCwgdHJ1ZSk7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuX2V4dHJhY3RPcGVyYXRpb24odGhpcy4jb3BJZHgpO1xuICAgIGZvciAoY29uc3QgZGVwSWR4IG9mIG9wZXJhdGlvbi5kZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuI291dGVyRGVwZW5kZW5jaWVzLmFkZChkZXBJZHgpO1xuICAgIH1cbiAgICB0aGlzLiNvdXRlckRlcGVuZGVuY2llcy5kZWxldGUodGhpcy4jb3BJZHgpO1xuICAgIHRoaXMuI291dGVyRGVwZW5kZW5jaWVzLmRlbGV0ZShudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiYm94VG9DbGlwQm94RHJvcE9wZXJhdGlvbihpZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5iYm94VG9DbGlwQm94RHJvcE9wZXJhdGlvbih0aGlzLiNvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkTmVzdGVkRGVwZW5kZW5jaWVzKCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLl9wdXNoUGVuZGluZ0RlcGVuZGVuY2llcyh0aGlzLiNvdXRlckRlcGVuZGVuY2llcyk7XG4gIH1cbiAgdGFrZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlYWNoYWJsZVwiKTtcbiAgfVxufVxuY29uc3QgRGVwZW5kZW5jaWVzID0ge1xuICBzdHJva2U6IFtcInBhdGhcIiwgXCJ0cmFuc2Zvcm1cIiwgXCJmaWx0ZXJcIiwgXCJzdHJva2VDb2xvclwiLCBcInN0cm9rZUFscGhhXCIsIFwibGluZVdpZHRoXCIsIFwibGluZUNhcFwiLCBcImxpbmVKb2luXCIsIFwibWl0ZXJMaW1pdFwiLCBcImRhc2hcIl0sXG4gIGZpbGw6IFtcInBhdGhcIiwgXCJ0cmFuc2Zvcm1cIiwgXCJmaWx0ZXJcIiwgXCJmaWxsQ29sb3JcIiwgXCJmaWxsQWxwaGFcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIiwgXCJTTWFza1wiXSxcbiAgaW1hZ2VYT2JqZWN0OiBbXCJ0cmFuc2Zvcm1cIiwgXCJTTWFza1wiLCBcImZpbHRlclwiLCBcImZpbGxBbHBoYVwiLCBcInN0cm9rZUFscGhhXCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCJdLFxuICByYXdGaWxsUGF0aDogW1wiZmlsdGVyXCIsIFwiZmlsbENvbG9yXCIsIFwiZmlsbEFscGhhXCJdLFxuICBzaG93VGV4dDogW1widHJhbnNmb3JtXCIsIFwibGVhZGluZ1wiLCBcImNoYXJTcGFjaW5nXCIsIFwid29yZFNwYWNpbmdcIiwgXCJoU2NhbGVcIiwgXCJ0ZXh0UmlzZVwiLCBcIm1vdmVUZXh0XCIsIFwidGV4dE1hdHJpeFwiLCBcImZvbnRcIiwgXCJmaWx0ZXJcIiwgXCJmaWxsQ29sb3JcIiwgXCJ0ZXh0UmVuZGVyaW5nTW9kZVwiLCBcIlNNYXNrXCIsIFwiZmlsbEFscGhhXCIsIFwic3Ryb2tlQWxwaGFcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIl0sXG4gIHRyYW5zZm9ybTogW1widHJhbnNmb3JtXCJdLFxuICB0cmFuc2Zvcm1BbmRGaWxsOiBbXCJ0cmFuc2Zvcm1cIiwgXCJmaWxsQ29sb3JcIl1cbn07XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3BhdHRlcm5faGVscGVyLmpzXG5cblxuY29uc3QgUGF0aFR5cGUgPSB7XG4gIEZJTEw6IFwiRmlsbFwiLFxuICBTVFJPS0U6IFwiU3Ryb2tlXCIsXG4gIFNIQURJTkc6IFwiU2hhZGluZ1wiXG59O1xuZnVuY3Rpb24gYXBwbHlCb3VuZGluZ0JveChjdHgsIGJib3gpIHtcbiAgaWYgKCFiYm94KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHdpZHRoID0gYmJveFsyXSAtIGJib3hbMF07XG4gIGNvbnN0IGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICBjb25zdCByZWdpb24gPSBuZXcgUGF0aDJEKCk7XG4gIHJlZ2lvbi5yZWN0KGJib3hbMF0sIGJib3hbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICBjdHguY2xpcChyZWdpb24pO1xufVxuY2xhc3MgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRQYXR0ZXJuKCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBnZXRQYXR0ZXJuYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoSVIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3R5cGUgPSBJUlsxXTtcbiAgICB0aGlzLl9iYm94ID0gSVJbMl07XG4gICAgdGhpcy5fY29sb3JTdG9wcyA9IElSWzNdO1xuICAgIHRoaXMuX3AwID0gSVJbNF07XG4gICAgdGhpcy5fcDEgPSBJUls1XTtcbiAgICB0aGlzLl9yMCA9IElSWzZdO1xuICAgIHRoaXMuX3IxID0gSVJbN107XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICB9XG4gIF9jcmVhdGVHcmFkaWVudChjdHgpIHtcbiAgICBsZXQgZ3JhZDtcbiAgICBpZiAodGhpcy5fdHlwZSA9PT0gXCJheGlhbFwiKSB7XG4gICAgICBncmFkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHRoaXMuX3AwWzBdLCB0aGlzLl9wMFsxXSwgdGhpcy5fcDFbMF0sIHRoaXMuX3AxWzFdKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3R5cGUgPT09IFwicmFkaWFsXCIpIHtcbiAgICAgIGdyYWQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQodGhpcy5fcDBbMF0sIHRoaXMuX3AwWzFdLCB0aGlzLl9yMCwgdGhpcy5fcDFbMF0sIHRoaXMuX3AxWzFdLCB0aGlzLl9yMSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29sb3JTdG9wIG9mIHRoaXMuX2NvbG9yU3RvcHMpIHtcbiAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcFswXSwgY29sb3JTdG9wWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGdyYWQ7XG4gIH1cbiAgZ2V0UGF0dGVybihjdHgsIG93bmVyLCBpbnZlcnNlLCBwYXRoVHlwZSkge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU1RST0tFIHx8IHBhdGhUeXBlID09PSBQYXRoVHlwZS5GSUxMKSB7XG4gICAgICBjb25zdCBvd25lckJCb3ggPSBvd25lci5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUsIGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSkgfHwgWzAsIDAsIDAsIDBdO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwob3duZXJCQm94WzJdIC0gb3duZXJCQm94WzBdKSB8fCAxO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKG93bmVyQkJveFszXSAtIG93bmVyQkJveFsxXSkgfHwgMTtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgdG1wQ3R4LmNhbnZhcy53aWR0aCwgdG1wQ3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdG1wQ3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdG1wQ3R4LnJlY3QoMCwgMCwgdG1wQ3R4LmNhbnZhcy53aWR0aCwgdG1wQ3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdG1wQ3R4LnRyYW5zbGF0ZSgtb3duZXJCQm94WzBdLCAtb3duZXJCQm94WzFdKTtcbiAgICAgIGludmVyc2UgPSBVdGlsLnRyYW5zZm9ybShpbnZlcnNlLCBbMSwgMCwgMCwgMSwgb3duZXJCQm94WzBdLCBvd25lckJCb3hbMV1dKTtcbiAgICAgIHRtcEN0eC50cmFuc2Zvcm0oLi4ub3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgdG1wQ3R4LnRyYW5zZm9ybSguLi50aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgICBhcHBseUJvdW5kaW5nQm94KHRtcEN0eCwgdGhpcy5fYmJveCk7XG4gICAgICB0bXBDdHguZmlsbFN0eWxlID0gdGhpcy5fY3JlYXRlR3JhZGllbnQodG1wQ3R4KTtcbiAgICAgIHRtcEN0eC5maWxsKCk7XG4gICAgICBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odG1wQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gICAgICBjb25zdCBkb21NYXRyaXggPSBuZXcgRE9NTWF0cml4KGludmVyc2UpO1xuICAgICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0oZG9tTWF0cml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgICAgcGF0dGVybiA9IHRoaXMuX2NyZWF0ZUdyYWRpZW50KGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG59XG5mdW5jdGlvbiBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcDEsIHAyLCBwMywgYzEsIGMyLCBjMykge1xuICBjb25zdCBjb29yZHMgPSBjb250ZXh0LmNvb3JkcyxcbiAgICBjb2xvcnMgPSBjb250ZXh0LmNvbG9ycztcbiAgY29uc3QgYnl0ZXMgPSBkYXRhLmRhdGEsXG4gICAgcm93U2l6ZSA9IGRhdGEud2lkdGggKiA0O1xuICBsZXQgdG1wO1xuICBpZiAoY29vcmRzW3AxICsgMV0gPiBjb29yZHNbcDIgKyAxXSkge1xuICAgIHRtcCA9IHAxO1xuICAgIHAxID0gcDI7XG4gICAgcDIgPSB0bXA7XG4gICAgdG1wID0gYzE7XG4gICAgYzEgPSBjMjtcbiAgICBjMiA9IHRtcDtcbiAgfVxuICBpZiAoY29vcmRzW3AyICsgMV0gPiBjb29yZHNbcDMgKyAxXSkge1xuICAgIHRtcCA9IHAyO1xuICAgIHAyID0gcDM7XG4gICAgcDMgPSB0bXA7XG4gICAgdG1wID0gYzI7XG4gICAgYzIgPSBjMztcbiAgICBjMyA9IHRtcDtcbiAgfVxuICBpZiAoY29vcmRzW3AxICsgMV0gPiBjb29yZHNbcDIgKyAxXSkge1xuICAgIHRtcCA9IHAxO1xuICAgIHAxID0gcDI7XG4gICAgcDIgPSB0bXA7XG4gICAgdG1wID0gYzE7XG4gICAgYzEgPSBjMjtcbiAgICBjMiA9IHRtcDtcbiAgfVxuICBjb25zdCB4MSA9IChjb29yZHNbcDFdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MSA9IChjb29yZHNbcDEgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgY29uc3QgeDIgPSAoY29vcmRzW3AyXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTIgPSAoY29vcmRzW3AyICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGNvbnN0IHgzID0gKGNvb3Jkc1twM10gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkzID0gKGNvb3Jkc1twMyArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBpZiAoeTEgPj0geTMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYzFyID0gY29sb3JzW2MxXSxcbiAgICBjMWcgPSBjb2xvcnNbYzEgKyAxXSxcbiAgICBjMWIgPSBjb2xvcnNbYzEgKyAyXTtcbiAgY29uc3QgYzJyID0gY29sb3JzW2MyXSxcbiAgICBjMmcgPSBjb2xvcnNbYzIgKyAxXSxcbiAgICBjMmIgPSBjb2xvcnNbYzIgKyAyXTtcbiAgY29uc3QgYzNyID0gY29sb3JzW2MzXSxcbiAgICBjM2cgPSBjb2xvcnNbYzMgKyAxXSxcbiAgICBjM2IgPSBjb2xvcnNbYzMgKyAyXTtcbiAgY29uc3QgbWluWSA9IE1hdGgucm91bmQoeTEpLFxuICAgIG1heFkgPSBNYXRoLnJvdW5kKHkzKTtcbiAgbGV0IHhhLCBjYXIsIGNhZywgY2FiO1xuICBsZXQgeGIsIGNiciwgY2JnLCBjYmI7XG4gIGZvciAobGV0IHkgPSBtaW5ZOyB5IDw9IG1heFk7IHkrKykge1xuICAgIGlmICh5IDwgeTIpIHtcbiAgICAgIGNvbnN0IGsgPSB5IDwgeTEgPyAwIDogKHkxIC0geSkgLyAoeTEgLSB5Mik7XG4gICAgICB4YSA9IHgxIC0gKHgxIC0geDIpICogaztcbiAgICAgIGNhciA9IGMxciAtIChjMXIgLSBjMnIpICogaztcbiAgICAgIGNhZyA9IGMxZyAtIChjMWcgLSBjMmcpICogaztcbiAgICAgIGNhYiA9IGMxYiAtIChjMWIgLSBjMmIpICogaztcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGs7XG4gICAgICBpZiAoeSA+IHkzKSB7XG4gICAgICAgIGsgPSAxO1xuICAgICAgfSBlbHNlIGlmICh5MiA9PT0geTMpIHtcbiAgICAgICAgayA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrID0gKHkyIC0geSkgLyAoeTIgLSB5Myk7XG4gICAgICB9XG4gICAgICB4YSA9IHgyIC0gKHgyIC0geDMpICogaztcbiAgICAgIGNhciA9IGMyciAtIChjMnIgLSBjM3IpICogaztcbiAgICAgIGNhZyA9IGMyZyAtIChjMmcgLSBjM2cpICogaztcbiAgICAgIGNhYiA9IGMyYiAtIChjMmIgLSBjM2IpICogaztcbiAgICB9XG4gICAgbGV0IGs7XG4gICAgaWYgKHkgPCB5MSkge1xuICAgICAgayA9IDA7XG4gICAgfSBlbHNlIGlmICh5ID4geTMpIHtcbiAgICAgIGsgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBrID0gKHkxIC0geSkgLyAoeTEgLSB5Myk7XG4gICAgfVxuICAgIHhiID0geDEgLSAoeDEgLSB4MykgKiBrO1xuICAgIGNiciA9IGMxciAtIChjMXIgLSBjM3IpICogaztcbiAgICBjYmcgPSBjMWcgLSAoYzFnIC0gYzNnKSAqIGs7XG4gICAgY2JiID0gYzFiIC0gKGMxYiAtIGMzYikgKiBrO1xuICAgIGNvbnN0IHgxXyA9IE1hdGgucm91bmQoTWF0aC5taW4oeGEsIHhiKSk7XG4gICAgY29uc3QgeDJfID0gTWF0aC5yb3VuZChNYXRoLm1heCh4YSwgeGIpKTtcbiAgICBsZXQgaiA9IHJvd1NpemUgKiB5ICsgeDFfICogNDtcbiAgICBmb3IgKGxldCB4ID0geDFfOyB4IDw9IHgyXzsgeCsrKSB7XG4gICAgICBrID0gKHhhIC0geCkgLyAoeGEgLSB4Yik7XG4gICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgayA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGsgPiAxKSB7XG4gICAgICAgIGsgPSAxO1xuICAgICAgfVxuICAgICAgYnl0ZXNbaisrXSA9IGNhciAtIChjYXIgLSBjYnIpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gY2FnIC0gKGNhZyAtIGNiZykgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSBjYWIgLSAoY2FiIC0gY2JiKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IDI1NTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdGaWd1cmUoZGF0YSwgZmlndXJlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHBzID0gZmlndXJlLmNvb3JkcztcbiAgY29uc3QgY3MgPSBmaWd1cmUuY29sb3JzO1xuICBsZXQgaSwgaWk7XG4gIHN3aXRjaCAoZmlndXJlLnR5cGUpIHtcbiAgICBjYXNlIFwibGF0dGljZVwiOlxuICAgICAgY29uc3QgdmVydGljZXNQZXJSb3cgPSBmaWd1cmUudmVydGljZXNQZXJSb3c7XG4gICAgICBjb25zdCByb3dzID0gTWF0aC5mbG9vcihwcy5sZW5ndGggLyB2ZXJ0aWNlc1BlclJvdykgLSAxO1xuICAgICAgY29uc3QgY29scyA9IHZlcnRpY2VzUGVyUm93IC0gMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgbGV0IHEgPSBpICogdmVydGljZXNQZXJSb3c7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sczsgaisrLCBxKyspIHtcbiAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidHJpYW5nbGVzXCI6XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHBzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDMpIHtcbiAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW2ldLCBwc1tpICsgMV0sIHBzW2kgKyAyXSwgY3NbaV0sIGNzW2kgKyAxXSwgY3NbaSArIDJdKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGZpZ3VyZVwiKTtcbiAgfVxufVxuY2xhc3MgTWVzaFNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoSVIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2Nvb3JkcyA9IElSWzJdO1xuICAgIHRoaXMuX2NvbG9ycyA9IElSWzNdO1xuICAgIHRoaXMuX2ZpZ3VyZXMgPSBJUls0XTtcbiAgICB0aGlzLl9ib3VuZHMgPSBJUls1XTtcbiAgICB0aGlzLl9iYm94ID0gSVJbNl07XG4gICAgdGhpcy5fYmFja2dyb3VuZCA9IElSWzddO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlTWVzaENhbnZhcyhjb21iaW5lZFNjYWxlLCBiYWNrZ3JvdW5kQ29sb3IsIGNhY2hlZENhbnZhc2VzKSB7XG4gICAgY29uc3QgRVhQRUNURURfU0NBTEUgPSAxLjE7XG4gICAgY29uc3QgTUFYX1BBVFRFUk5fU0laRSA9IDMwMDA7XG4gICAgY29uc3QgQk9SREVSX1NJWkUgPSAyO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmZsb29yKHRoaXMuX2JvdW5kc1swXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IodGhpcy5fYm91bmRzWzFdKTtcbiAgICBjb25zdCBib3VuZHNXaWR0aCA9IE1hdGguY2VpbCh0aGlzLl9ib3VuZHNbMl0pIC0gb2Zmc2V0WDtcbiAgICBjb25zdCBib3VuZHNIZWlnaHQgPSBNYXRoLmNlaWwodGhpcy5fYm91bmRzWzNdKSAtIG9mZnNldFk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzV2lkdGggKiBjb21iaW5lZFNjYWxlWzBdICogRVhQRUNURURfU0NBTEUpKSwgTUFYX1BBVFRFUk5fU0laRSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5jZWlsKE1hdGguYWJzKGJvdW5kc0hlaWdodCAqIGNvbWJpbmVkU2NhbGVbMV0gKiBFWFBFQ1RFRF9TQ0FMRSkpLCBNQVhfUEFUVEVSTl9TSVpFKTtcbiAgICBjb25zdCBzY2FsZVggPSBib3VuZHNXaWR0aCAvIHdpZHRoO1xuICAgIGNvbnN0IHNjYWxlWSA9IGJvdW5kc0hlaWdodCAvIGhlaWdodDtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgY29vcmRzOiB0aGlzLl9jb29yZHMsXG4gICAgICBjb2xvcnM6IHRoaXMuX2NvbG9ycyxcbiAgICAgIG9mZnNldFg6IC1vZmZzZXRYLFxuICAgICAgb2Zmc2V0WTogLW9mZnNldFksXG4gICAgICBzY2FsZVg6IDEgLyBzY2FsZVgsXG4gICAgICBzY2FsZVk6IDEgLyBzY2FsZVlcbiAgICB9O1xuICAgIGNvbnN0IHBhZGRlZFdpZHRoID0gd2lkdGggKyBCT1JERVJfU0laRSAqIDI7XG4gICAgY29uc3QgcGFkZGVkSGVpZ2h0ID0gaGVpZ2h0ICsgQk9SREVSX1NJWkUgKiAyO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IGNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1lc2hcIiwgcGFkZGVkV2lkdGgsIHBhZGRlZEhlaWdodCk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgZGF0YSA9IHRtcEN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgYnl0ZXMgPSBkYXRhLmRhdGE7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBieXRlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICAgIGJ5dGVzW2ldID0gYmFja2dyb3VuZENvbG9yWzBdO1xuICAgICAgICBieXRlc1tpICsgMV0gPSBiYWNrZ3JvdW5kQ29sb3JbMV07XG4gICAgICAgIGJ5dGVzW2kgKyAyXSA9IGJhY2tncm91bmRDb2xvclsyXTtcbiAgICAgICAgYnl0ZXNbaSArIDNdID0gMjU1O1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZ3VyZSBvZiB0aGlzLl9maWd1cmVzKSB7XG4gICAgICBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHRtcEN0eC5wdXRJbWFnZURhdGEoZGF0YSwgQk9SREVSX1NJWkUsIEJPUkRFUl9TSVpFKTtcbiAgICBjb25zdCBjYW52YXMgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICBvZmZzZXRYOiBvZmZzZXRYIC0gQk9SREVSX1NJWkUgKiBzY2FsZVgsXG4gICAgICBvZmZzZXRZOiBvZmZzZXRZIC0gQk9SREVSX1NJWkUgKiBzY2FsZVksXG4gICAgICBzY2FsZVgsXG4gICAgICBzY2FsZVlcbiAgICB9O1xuICB9XG4gIGlzTW9kaWZ5aW5nQ3VycmVudFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgIGNvbnN0IHNjYWxlID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICBpZiAocGF0aFR5cGUgPT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUoZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpLCBzY2FsZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLm1hdHJpeCwgc2NhbGUpO1xuICAgICAgY29uc3QgW21hdHJpeFNjYWxlWCwgbWF0cml4U2NhbGVZXSA9IHNjYWxlO1xuICAgICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShvd25lci5iYXNlVHJhbnNmb3JtLCBzY2FsZSk7XG4gICAgICBzY2FsZVswXSAqPSBtYXRyaXhTY2FsZVg7XG4gICAgICBzY2FsZVsxXSAqPSBtYXRyaXhTY2FsZVk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUob3duZXIuYmFzZVRyYW5zZm9ybSwgc2NhbGUpO1xuICAgIH1cbiAgICBjb25zdCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gdGhpcy5fY3JlYXRlTWVzaENhbnZhcyhzY2FsZSwgcGF0aFR5cGUgPT09IFBhdGhUeXBlLlNIQURJTkcgPyBudWxsIDogdGhpcy5fYmFja2dyb3VuZCwgb3duZXIuY2FjaGVkQ2FudmFzZXMpO1xuICAgIGlmIChwYXRoVHlwZSAhPT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5vd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBjdHgudHJhbnNmb3JtKC4uLnRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LnRyYW5zbGF0ZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WSk7XG4gICAgY3R4LnNjYWxlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWSk7XG4gICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuY2FudmFzLCBcIm5vLXJlcGVhdFwiKTtcbiAgfVxufVxuY2xhc3MgRHVtbXlTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGdldFBhdHRlcm4oKSB7XG4gICAgcmV0dXJuIFwiaG90cGlua1wiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTaGFkaW5nUGF0dGVybihJUikge1xuICBzd2l0Y2ggKElSWzBdKSB7XG4gICAgY2FzZSBcIlJhZGlhbEF4aWFsXCI6XG4gICAgICByZXR1cm4gbmV3IFJhZGlhbEF4aWFsU2hhZGluZ1BhdHRlcm4oSVIpO1xuICAgIGNhc2UgXCJNZXNoXCI6XG4gICAgICByZXR1cm4gbmV3IE1lc2hTaGFkaW5nUGF0dGVybihJUik7XG4gICAgY2FzZSBcIkR1bW15XCI6XG4gICAgICByZXR1cm4gbmV3IER1bW15U2hhZGluZ1BhdHRlcm4oKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gSVIgdHlwZTogJHtJUlswXX1gKTtcbn1cbmNvbnN0IFBhaW50VHlwZSA9IHtcbiAgQ09MT1JFRDogMSxcbiAgVU5DT0xPUkVEOiAyXG59O1xuY2xhc3MgVGlsaW5nUGF0dGVybiB7XG4gIHN0YXRpYyBNQVhfUEFUVEVSTl9TSVpFID0gMzAwMDtcbiAgY29uc3RydWN0b3IoSVIsIGN0eCwgY2FudmFzR3JhcGhpY3NGYWN0b3J5LCBiYXNlVHJhbnNmb3JtKSB7XG4gICAgdGhpcy5jb2xvciA9IElSWzFdO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gSVJbMl07XG4gICAgdGhpcy5tYXRyaXggPSBJUlszXTtcbiAgICB0aGlzLmJib3ggPSBJUls0XTtcbiAgICB0aGlzLnhzdGVwID0gSVJbNV07XG4gICAgdGhpcy55c3RlcCA9IElSWzZdO1xuICAgIHRoaXMucGFpbnRUeXBlID0gSVJbN107XG4gICAgdGhpcy50aWxpbmdUeXBlID0gSVJbOF07XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5jYW52YXNHcmFwaGljc0ZhY3RvcnkgPSBjYW52YXNHcmFwaGljc0ZhY3Rvcnk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gYmFzZVRyYW5zZm9ybTtcbiAgfVxuICBjcmVhdGVQYXR0ZXJuQ2FudmFzKG93bmVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgYmJveCxcbiAgICAgIG9wZXJhdG9yTGlzdCxcbiAgICAgIHBhaW50VHlwZSxcbiAgICAgIHRpbGluZ1R5cGUsXG4gICAgICBjb2xvcixcbiAgICAgIGNhbnZhc0dyYXBoaWNzRmFjdG9yeVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICB4c3RlcCxcbiAgICAgIHlzdGVwXG4gICAgfSA9IHRoaXM7XG4gICAgeHN0ZXAgPSBNYXRoLmFicyh4c3RlcCk7XG4gICAgeXN0ZXAgPSBNYXRoLmFicyh5c3RlcCk7XG4gICAgaW5mbyhcIlRpbGluZ1R5cGU6IFwiICsgdGlsaW5nVHlwZSk7XG4gICAgY29uc3QgeDAgPSBiYm94WzBdLFxuICAgICAgeTAgPSBiYm94WzFdLFxuICAgICAgeDEgPSBiYm94WzJdLFxuICAgICAgeTEgPSBiYm94WzNdO1xuICAgIGNvbnN0IHdpZHRoID0geDEgLSB4MDtcbiAgICBjb25zdCBoZWlnaHQgPSB5MSAtIHkwO1xuICAgIGNvbnN0IHNjYWxlID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4LCBzY2FsZSk7XG4gICAgY29uc3QgW21hdHJpeFNjYWxlWCwgbWF0cml4U2NhbGVZXSA9IHNjYWxlO1xuICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5iYXNlVHJhbnNmb3JtLCBzY2FsZSk7XG4gICAgY29uc3QgY29tYmluZWRTY2FsZVggPSBtYXRyaXhTY2FsZVggKiBzY2FsZVswXTtcbiAgICBjb25zdCBjb21iaW5lZFNjYWxlWSA9IG1hdHJpeFNjYWxlWSAqIHNjYWxlWzFdO1xuICAgIGxldCBjYW52YXNXaWR0aCA9IHdpZHRoLFxuICAgICAgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0LFxuICAgICAgcmVkcmF3SG9yaXpvbnRhbGx5ID0gZmFsc2UsXG4gICAgICByZWRyYXdWZXJ0aWNhbGx5ID0gZmFsc2U7XG4gICAgY29uc3QgeFNjYWxlZFN0ZXAgPSBNYXRoLmNlaWwoeHN0ZXAgKiBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgeVNjYWxlZFN0ZXAgPSBNYXRoLmNlaWwoeXN0ZXAgKiBjb21iaW5lZFNjYWxlWSk7XG4gICAgY29uc3QgeFNjYWxlZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogY29tYmluZWRTY2FsZVgpO1xuICAgIGNvbnN0IHlTY2FsZWRIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogY29tYmluZWRTY2FsZVkpO1xuICAgIGlmICh4U2NhbGVkU3RlcCA+PSB4U2NhbGVkV2lkdGgpIHtcbiAgICAgIGNhbnZhc1dpZHRoID0geHN0ZXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZHJhd0hvcml6b250YWxseSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh5U2NhbGVkU3RlcCA+PSB5U2NhbGVkSGVpZ2h0KSB7XG4gICAgICBjYW52YXNIZWlnaHQgPSB5c3RlcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkcmF3VmVydGljYWxseSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGRpbXggPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNXaWR0aCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgZGlteSA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc0hlaWdodCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCwgY29tYmluZWRTY2FsZVkpO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgZGlteC5zaXplLCBkaW15LnNpemUpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGdyYXBoaWNzID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5LmNyZWF0ZUNhbnZhc0dyYXBoaWNzKHRtcEN0eCk7XG4gICAgZ3JhcGhpY3MuZ3JvdXBMZXZlbCA9IG93bmVyLmdyb3VwTGV2ZWw7XG4gICAgdGhpcy5zZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQoZ3JhcGhpY3MsIHBhaW50VHlwZSwgY29sb3IpO1xuICAgIHRtcEN0eC50cmFuc2xhdGUoLWRpbXguc2NhbGUgKiB4MCwgLWRpbXkuc2NhbGUgKiB5MCk7XG4gICAgZ3JhcGhpY3MudHJhbnNmb3JtKDAsIGRpbXguc2NhbGUsIDAsIDAsIGRpbXkuc2NhbGUsIDAsIDApO1xuICAgIHRtcEN0eC5zYXZlKCk7XG4gICAgZ3JhcGhpY3MuZGVwZW5kZW5jeVRyYWNrZXI/LnNhdmUoKTtcbiAgICB0aGlzLmNsaXBCYm94KGdyYXBoaWNzLCB4MCwgeTAsIHgxLCB5MSk7XG4gICAgZ3JhcGhpY3MuYmFzZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oZ3JhcGhpY3MuY3R4KTtcbiAgICBncmFwaGljcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgZ3JhcGhpY3MuZW5kRHJhd2luZygpO1xuICAgIGdyYXBoaWNzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXN0b3JlKCkucmVjb3JkTmVzdGVkRGVwZW5kZW5jaWVzPy4oKTtcbiAgICB0bXBDdHgucmVzdG9yZSgpO1xuICAgIGlmIChyZWRyYXdIb3Jpem9udGFsbHkgfHwgcmVkcmF3VmVydGljYWxseSkge1xuICAgICAgY29uc3QgaW1hZ2UgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgICAgaWYgKHJlZHJhd0hvcml6b250YWxseSkge1xuICAgICAgICBjYW52YXNXaWR0aCA9IHhzdGVwO1xuICAgICAgfVxuICAgICAgaWYgKHJlZHJhd1ZlcnRpY2FsbHkpIHtcbiAgICAgICAgY2FudmFzSGVpZ2h0ID0geXN0ZXA7XG4gICAgICB9XG4gICAgICBjb25zdCBkaW14MiA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc1dpZHRoLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIGNvbWJpbmVkU2NhbGVYKTtcbiAgICAgIGNvbnN0IGRpbXkyID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoY2FudmFzSGVpZ2h0LCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0LCBjb21iaW5lZFNjYWxlWSk7XG4gICAgICBjb25zdCB4U2l6ZSA9IGRpbXgyLnNpemU7XG4gICAgICBjb25zdCB5U2l6ZSA9IGRpbXkyLnNpemU7XG4gICAgICBjb25zdCB0bXBDYW52YXMyID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVybi13b3JrYXJvdW5kXCIsIHhTaXplLCB5U2l6ZSk7XG4gICAgICBjb25zdCB0bXBDdHgyID0gdG1wQ2FudmFzMi5jb250ZXh0O1xuICAgICAgY29uc3QgaWkgPSByZWRyYXdIb3Jpem9udGFsbHkgPyBNYXRoLmZsb29yKHdpZHRoIC8geHN0ZXApIDogMDtcbiAgICAgIGNvbnN0IGpqID0gcmVkcmF3VmVydGljYWxseSA/IE1hdGguZmxvb3IoaGVpZ2h0IC8geXN0ZXApIDogMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGlpOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gamo7IGorKykge1xuICAgICAgICAgIHRtcEN0eDIuZHJhd0ltYWdlKGltYWdlLCB4U2l6ZSAqIGksIHlTaXplICogaiwgeFNpemUsIHlTaXplLCAwLCAwLCB4U2l6ZSwgeVNpemUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW52YXM6IHRtcENhbnZhczIuY2FudmFzLFxuICAgICAgICBzY2FsZVg6IGRpbXgyLnNjYWxlLFxuICAgICAgICBzY2FsZVk6IGRpbXkyLnNjYWxlLFxuICAgICAgICBvZmZzZXRYOiB4MCxcbiAgICAgICAgb2Zmc2V0WTogeTBcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjYW52YXM6IHRtcENhbnZhcy5jYW52YXMsXG4gICAgICBzY2FsZVg6IGRpbXguc2NhbGUsXG4gICAgICBzY2FsZVk6IGRpbXkuc2NhbGUsXG4gICAgICBvZmZzZXRYOiB4MCxcbiAgICAgIG9mZnNldFk6IHkwXG4gICAgfTtcbiAgfVxuICBnZXRTaXplQW5kU2NhbGUoc3RlcCwgcmVhbE91dHB1dFNpemUsIHNjYWxlKSB7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KFRpbGluZ1BhdHRlcm4uTUFYX1BBVFRFUk5fU0laRSwgcmVhbE91dHB1dFNpemUpO1xuICAgIGxldCBzaXplID0gTWF0aC5jZWlsKHN0ZXAgKiBzY2FsZSk7XG4gICAgaWYgKHNpemUgPj0gbWF4U2l6ZSkge1xuICAgICAgc2l6ZSA9IG1heFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gc2l6ZSAvIHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2FsZSxcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG4gIGNsaXBCYm94KGdyYXBoaWNzLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGNvbnN0IGJib3hXaWR0aCA9IHgxIC0geDA7XG4gICAgY29uc3QgYmJveEhlaWdodCA9IHkxIC0geTA7XG4gICAgZ3JhcGhpY3MuY3R4LnJlY3QoeDAsIHkwLCBiYm94V2lkdGgsIGJib3hIZWlnaHQpO1xuICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goW3gwLCB5MCwgeDEsIHkxXSwgZ2V0Q3VycmVudFRyYW5zZm9ybShncmFwaGljcy5jdHgpLCBncmFwaGljcy5jdXJyZW50Lm1pbk1heCk7XG4gICAgZ3JhcGhpY3MuY2xpcCgpO1xuICAgIGdyYXBoaWNzLmVuZFBhdGgoKTtcbiAgfVxuICBzZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQoZ3JhcGhpY3MsIHBhaW50VHlwZSwgY29sb3IpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gZ3JhcGhpY3MuY3R4LFxuICAgICAgY3VycmVudCA9IGdyYXBoaWNzLmN1cnJlbnQ7XG4gICAgc3dpdGNoIChwYWludFR5cGUpIHtcbiAgICAgIGNhc2UgUGFpbnRUeXBlLkNPTE9SRUQ6XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBmaWxsU3R5bGUsXG4gICAgICAgICAgc3Ryb2tlU3R5bGVcbiAgICAgICAgfSA9IHRoaXMuY3R4O1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGN1cnJlbnQuZmlsbENvbG9yID0gZmlsbFN0eWxlO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY3VycmVudC5zdHJva2VDb2xvciA9IHN0cm9rZVN0eWxlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGFpbnRUeXBlLlVOQ09MT1JFRDpcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN1cnJlbnQuZmlsbENvbG9yID0gY3VycmVudC5zdHJva2VDb2xvciA9IGNvbG9yO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBGb3JtYXRFcnJvcihgVW5zdXBwb3J0ZWQgcGFpbnQgdHlwZTogJHtwYWludFR5cGV9YCk7XG4gICAgfVxuICB9XG4gIGlzTW9kaWZ5aW5nQ3VycmVudFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0UGF0dGVybihjdHgsIG93bmVyLCBpbnZlcnNlLCBwYXRoVHlwZSkge1xuICAgIGxldCBtYXRyaXggPSBpbnZlcnNlO1xuICAgIGlmIChwYXRoVHlwZSAhPT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgbWF0cml4ID0gVXRpbC50cmFuc2Zvcm0obWF0cml4LCBvd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBtYXRyaXggPSBVdGlsLnRyYW5zZm9ybShtYXRyaXgsIHRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcyA9IHRoaXMuY3JlYXRlUGF0dGVybkNhbnZhcyhvd25lcik7XG4gICAgbGV0IGRvbU1hdHJpeCA9IG5ldyBET01NYXRyaXgobWF0cml4KTtcbiAgICBkb21NYXRyaXggPSBkb21NYXRyaXgudHJhbnNsYXRlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRZKTtcbiAgICBkb21NYXRyaXggPSBkb21NYXRyaXguc2NhbGUoMSAvIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVYLCAxIC8gdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVkpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybih0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLmNhbnZhcywgXCJyZXBlYXRcIik7XG4gICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0oZG9tTWF0cml4KTtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxufVxuXG47Ly8gLi9zcmMvc2hhcmVkL2ltYWdlX3V0aWxzLmpzXG5cbmZ1bmN0aW9uIGNvbnZlcnRUb1JHQkEocGFyYW1zKSB7XG4gIHN3aXRjaCAocGFyYW1zLmtpbmQpIHtcbiAgICBjYXNlIEltYWdlS2luZC5HUkFZU0NBTEVfMUJQUDpcbiAgICAgIHJldHVybiBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQShwYXJhbXMpO1xuICAgIGNhc2UgSW1hZ2VLaW5kLlJHQl8yNEJQUDpcbiAgICAgIHJldHVybiBjb252ZXJ0UkdCVG9SR0JBKHBhcmFtcyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQSh7XG4gIHNyYyxcbiAgc3JjUG9zID0gMCxcbiAgZGVzdCxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgbm9uQmxhY2tDb2xvciA9IDB4ZmZmZmZmZmYsXG4gIGludmVyc2VEZWNvZGUgPSBmYWxzZVxufSkge1xuICBjb25zdCBibGFjayA9IHV0aWxfRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyAweGZmMDAwMDAwIDogMHgwMDAwMDBmZjtcbiAgY29uc3QgW3plcm9NYXBwaW5nLCBvbmVNYXBwaW5nXSA9IGludmVyc2VEZWNvZGUgPyBbbm9uQmxhY2tDb2xvciwgYmxhY2tdIDogW2JsYWNrLCBub25CbGFja0NvbG9yXTtcbiAgY29uc3Qgd2lkdGhJblNvdXJjZSA9IHdpZHRoID4+IDM7XG4gIGNvbnN0IHdpZHRoUmVtYWluZGVyID0gd2lkdGggJiA3O1xuICBjb25zdCBzcmNMZW5ndGggPSBzcmMubGVuZ3RoO1xuICBkZXN0ID0gbmV3IFVpbnQzMkFycmF5KGRlc3QuYnVmZmVyKTtcbiAgbGV0IGRlc3RQb3MgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgZm9yIChjb25zdCBtYXggPSBzcmNQb3MgKyB3aWR0aEluU291cmNlOyBzcmNQb3MgPCBtYXg7IHNyY1BvcysrKSB7XG4gICAgICBjb25zdCBlbGVtID0gc3JjUG9zIDwgc3JjTGVuZ3RoID8gc3JjW3NyY1Bvc10gOiAyNTU7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgfVxuICAgIGlmICh3aWR0aFJlbWFpbmRlciA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGVsZW0gPSBzcmNQb3MgPCBzcmNMZW5ndGggPyBzcmNbc3JjUG9zKytdIDogMjU1O1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGhSZW1haW5kZXI7IGorKykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDEgPDwgNyAtIGogPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3JjUG9zLFxuICAgIGRlc3RQb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSR0JUb1JHQkEoe1xuICBzcmMsXG4gIHNyY1BvcyA9IDAsXG4gIGRlc3QsXG4gIGRlc3RQb3MgPSAwLFxuICB3aWR0aCxcbiAgaGVpZ2h0XG59KSB7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbGVuID0gd2lkdGggKiBoZWlnaHQgKiAzO1xuICBjb25zdCBsZW4zMiA9IGxlbiA+PiAyO1xuICBjb25zdCBzcmMzMiA9IG5ldyBVaW50MzJBcnJheShzcmMuYnVmZmVyLCBzcmNQb3MsIGxlbjMyKTtcbiAgaWYgKEZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuKSB7XG4gICAgZm9yICg7IGkgPCBsZW4zMiAtIDI7IGkgKz0gMywgZGVzdFBvcyArPSA0KSB7XG4gICAgICBjb25zdCBzMSA9IHNyYzMyW2ldO1xuICAgICAgY29uc3QgczIgPSBzcmMzMltpICsgMV07XG4gICAgICBjb25zdCBzMyA9IHNyYzMyW2kgKyAyXTtcbiAgICAgIGRlc3RbZGVzdFBvc10gPSBzMSB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAxXSA9IHMxID4+PiAyNCB8IHMyIDw8IDggfCAweGZmMDAwMDAwO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMl0gPSBzMiA+Pj4gMTYgfCBzMyA8PCAxNiB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAzXSA9IHMzID4+PiA4IHwgMHhmZjAwMDAwMDtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGkgKiA0LCBqaiA9IHNyY1BvcyArIGxlbjsgaiA8IGpqOyBqICs9IDMpIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tqXSB8IHNyY1tqICsgMV0gPDwgOCB8IHNyY1tqICsgMl0gPDwgMTYgfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKDsgaSA8IGxlbjMyIC0gMjsgaSArPSAzLCBkZXN0UG9zICs9IDQpIHtcbiAgICAgIGNvbnN0IHMxID0gc3JjMzJbaV07XG4gICAgICBjb25zdCBzMiA9IHNyYzMyW2kgKyAxXTtcbiAgICAgIGNvbnN0IHMzID0gc3JjMzJbaSArIDJdO1xuICAgICAgZGVzdFtkZXN0UG9zXSA9IHMxIHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDFdID0gczEgPDwgMjQgfCBzMiA+Pj4gOCB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAyXSA9IHMyIDw8IDE2IHwgczMgPj4+IDE2IHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDNdID0gczMgPDwgOCB8IDB4ZmY7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpICogNCwgamogPSBzcmNQb3MgKyBsZW47IGogPCBqajsgaiArPSAzKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbal0gPDwgMjQgfCBzcmNbaiArIDFdIDw8IDE2IHwgc3JjW2ogKyAyXSA8PCA4IHwgMHhmZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcmNQb3M6IHNyY1BvcyArIGxlbixcbiAgICBkZXN0UG9zXG4gIH07XG59XG5mdW5jdGlvbiBncmF5VG9SR0JBKHNyYywgZGVzdCkge1xuICBpZiAoRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgZGVzdFtpXSA9IHNyY1tpXSAqIDB4MTAxMDEgfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgZGVzdFtpXSA9IHNyY1tpXSAqIDB4MTAxMDEwMCB8IDB4MDAwMDAwZmY7XG4gICAgfVxuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NhbnZhcy5qc1xuXG5cblxuXG5cbmNvbnN0IE1JTl9GT05UX1NJWkUgPSAxNjtcbmNvbnN0IE1BWF9GT05UX1NJWkUgPSAxMDA7XG5jb25zdCBFWEVDVVRJT05fVElNRSA9IDE1O1xuY29uc3QgRVhFQ1VUSU9OX1NURVBTID0gMTA7XG5jb25zdCBGVUxMX0NIVU5LX0hFSUdIVCA9IDE2O1xuY29uc3QgU0NBTEVfTUFUUklYID0gbmV3IERPTU1hdHJpeCgpO1xuY29uc3QgWFkgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuY29uc3QgTUlOX01BWF9JTklUID0gbmV3IEZsb2F0MzJBcnJheShbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV0pO1xuZnVuY3Rpb24gbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCBkZXN0Q3R4KSB7XG4gIGlmIChjdHguX3JlbW92ZU1pcnJvcmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRleHQgaXMgYWxyZWFkeSBmb3J3YXJkaW5nIG9wZXJhdGlvbnMuXCIpO1xuICB9XG4gIGN0eC5fX29yaWdpbmFsU2F2ZSA9IGN0eC5zYXZlO1xuICBjdHguX19vcmlnaW5hbFJlc3RvcmUgPSBjdHgucmVzdG9yZTtcbiAgY3R4Ll9fb3JpZ2luYWxSb3RhdGUgPSBjdHgucm90YXRlO1xuICBjdHguX19vcmlnaW5hbFNjYWxlID0gY3R4LnNjYWxlO1xuICBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZSA9IGN0eC50cmFuc2xhdGU7XG4gIGN0eC5fX29yaWdpbmFsVHJhbnNmb3JtID0gY3R4LnRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0gPSBjdHguc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtID0gY3R4LnJlc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbENsaXAgPSBjdHguY2xpcDtcbiAgY3R4Ll9fb3JpZ2luYWxNb3ZlVG8gPSBjdHgubW92ZVRvO1xuICBjdHguX19vcmlnaW5hbExpbmVUbyA9IGN0eC5saW5lVG87XG4gIGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyA9IGN0eC5iZXppZXJDdXJ2ZVRvO1xuICBjdHguX19vcmlnaW5hbFJlY3QgPSBjdHgucmVjdDtcbiAgY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGggPSBjdHguY2xvc2VQYXRoO1xuICBjdHguX19vcmlnaW5hbEJlZ2luUGF0aCA9IGN0eC5iZWdpblBhdGg7XG4gIGN0eC5fcmVtb3ZlTWlycm9yaW5nID0gKCkgPT4ge1xuICAgIGN0eC5zYXZlID0gY3R4Ll9fb3JpZ2luYWxTYXZlO1xuICAgIGN0eC5yZXN0b3JlID0gY3R4Ll9fb3JpZ2luYWxSZXN0b3JlO1xuICAgIGN0eC5yb3RhdGUgPSBjdHguX19vcmlnaW5hbFJvdGF0ZTtcbiAgICBjdHguc2NhbGUgPSBjdHguX19vcmlnaW5hbFNjYWxlO1xuICAgIGN0eC50cmFuc2xhdGUgPSBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZTtcbiAgICBjdHgudHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxUcmFuc2Zvcm07XG4gICAgY3R4LnNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsU2V0VHJhbnNmb3JtO1xuICAgIGN0eC5yZXNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm07XG4gICAgY3R4LmNsaXAgPSBjdHguX19vcmlnaW5hbENsaXA7XG4gICAgY3R4Lm1vdmVUbyA9IGN0eC5fX29yaWdpbmFsTW92ZVRvO1xuICAgIGN0eC5saW5lVG8gPSBjdHguX19vcmlnaW5hbExpbmVUbztcbiAgICBjdHguYmV6aWVyQ3VydmVUbyA9IGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbztcbiAgICBjdHgucmVjdCA9IGN0eC5fX29yaWdpbmFsUmVjdDtcbiAgICBjdHguY2xvc2VQYXRoID0gY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGg7XG4gICAgY3R4LmJlZ2luUGF0aCA9IGN0eC5fX29yaWdpbmFsQmVnaW5QYXRoO1xuICAgIGRlbGV0ZSBjdHguX3JlbW92ZU1pcnJvcmluZztcbiAgfTtcbiAgY3R4LnNhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5zYXZlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsU2F2ZSgpO1xuICB9O1xuICBjdHgucmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZXN0b3JlKCk7XG4gIH07XG4gIGN0eC50cmFuc2xhdGUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGRlc3RDdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbFRyYW5zbGF0ZSh4LCB5KTtcbiAgfTtcbiAgY3R4LnNjYWxlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4LnNjYWxlKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNjYWxlKHgsIHkpO1xuICB9O1xuICBjdHgudHJhbnNmb3JtID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIGN0eC5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGRlc3RDdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgfTtcbiAgY3R4LnJlc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSgpO1xuICB9O1xuICBjdHgucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgZGVzdEN0eC5yb3RhdGUoYW5nbGUpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJvdGF0ZShhbmdsZSk7XG4gIH07XG4gIGN0eC5jbGlwID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBkZXN0Q3R4LmNsaXAocnVsZSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xpcChydWxlKTtcbiAgfTtcbiAgY3R4Lm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsTW92ZVRvKHgsIHkpO1xuICB9O1xuICBjdHgubGluZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4LmxpbmVUbyh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxMaW5lVG8oeCwgeSk7XG4gIH07XG4gIGN0eC5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24gKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcbiAgICBkZXN0Q3R4LmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbiAgfTtcbiAgY3R4LnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGRlc3RDdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuICBjdHguY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xvc2VQYXRoKCk7XG4gIH07XG4gIGN0eC5iZWdpblBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5iZWdpblBhdGgoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxCZWdpblBhdGgoKTtcbiAgfTtcbn1cbmNsYXNzIENhY2hlZENhbnZhc2VzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzRmFjdG9yeSkge1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgZ2V0Q2FudmFzKGlkLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgbGV0IGNhbnZhc0VudHJ5O1xuICAgIGlmICh0aGlzLmNhY2hlW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXNFbnRyeSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgICAgdGhpcy5jYW52YXNGYWN0b3J5LnJlc2V0KGNhbnZhc0VudHJ5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBjYW52YXNFbnRyeTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhc0VudHJ5O1xuICB9XG4gIGRlbGV0ZShpZCkge1xuICAgIGRlbGV0ZSB0aGlzLmNhY2hlW2lkXTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIGNvbnN0IGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICB0aGlzLmNhbnZhc0ZhY3RvcnkuZGVzdHJveShjYW52YXNFbnRyeSk7XG4gICAgICBkZWxldGUgdGhpcy5jYWNoZVtpZF07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRlc3RYLCBkZXN0WSwgZGVzdFcsIGRlc3RIKSB7XG4gIGNvbnN0IFthLCBiLCBjLCBkLCB0eCwgdHldID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICBpZiAoYiA9PT0gMCAmJiBjID09PSAwKSB7XG4gICAgY29uc3QgdGxYID0gZGVzdFggKiBhICsgdHg7XG4gICAgY29uc3QgclRsWCA9IE1hdGgucm91bmQodGxYKTtcbiAgICBjb25zdCB0bFkgPSBkZXN0WSAqIGQgKyB0eTtcbiAgICBjb25zdCByVGxZID0gTWF0aC5yb3VuZCh0bFkpO1xuICAgIGNvbnN0IGJyWCA9IChkZXN0WCArIGRlc3RXKSAqIGEgKyB0eDtcbiAgICBjb25zdCByV2lkdGggPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWCkgLSByVGxYKSB8fCAxO1xuICAgIGNvbnN0IGJyWSA9IChkZXN0WSArIGRlc3RIKSAqIGQgKyB0eTtcbiAgICBjb25zdCBySGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclkpIC0gclRsWSkgfHwgMTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKE1hdGguc2lnbihhKSwgMCwgMCwgTWF0aC5zaWduKGQpLCByVGxYLCByVGxZKTtcbiAgICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgMCwgMCwgcldpZHRoLCBySGVpZ2h0KTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIHR4LCB0eSk7XG4gICAgcmV0dXJuIFtyV2lkdGgsIHJIZWlnaHRdO1xuICB9XG4gIGlmIChhID09PSAwICYmIGQgPT09IDApIHtcbiAgICBjb25zdCB0bFggPSBkZXN0WSAqIGMgKyB0eDtcbiAgICBjb25zdCByVGxYID0gTWF0aC5yb3VuZCh0bFgpO1xuICAgIGNvbnN0IHRsWSA9IGRlc3RYICogYiArIHR5O1xuICAgIGNvbnN0IHJUbFkgPSBNYXRoLnJvdW5kKHRsWSk7XG4gICAgY29uc3QgYnJYID0gKGRlc3RZICsgZGVzdEgpICogYyArIHR4O1xuICAgIGNvbnN0IHJXaWR0aCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJYKSAtIHJUbFgpIHx8IDE7XG4gICAgY29uc3QgYnJZID0gKGRlc3RYICsgZGVzdFcpICogYiArIHR5O1xuICAgIGNvbnN0IHJIZWlnaHQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWSkgLSByVGxZKSB8fCAxO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMCwgTWF0aC5zaWduKGIpLCBNYXRoLnNpZ24oYyksIDAsIHJUbFgsIHJUbFkpO1xuICAgIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCAwLCAwLCBySGVpZ2h0LCByV2lkdGgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgdHgsIHR5KTtcbiAgICByZXR1cm4gW3JIZWlnaHQsIHJXaWR0aF07XG4gIH1cbiAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRlc3RYLCBkZXN0WSwgZGVzdFcsIGRlc3RIKTtcbiAgY29uc3Qgc2NhbGVYID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgY29uc3Qgc2NhbGVZID0gTWF0aC5oeXBvdChjLCBkKTtcbiAgcmV0dXJuIFtzY2FsZVggKiBkZXN0Vywgc2NhbGVZICogZGVzdEhdO1xufVxuY2xhc3MgQ2FudmFzRXh0cmFTdGF0ZSB7XG4gIGFscGhhSXNTaGFwZSA9IGZhbHNlO1xuICBmb250U2l6ZSA9IDA7XG4gIGZvbnRTaXplU2NhbGUgPSAxO1xuICB0ZXh0TWF0cml4ID0gbnVsbDtcbiAgdGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgZm9udE1hdHJpeCA9IEZPTlRfSURFTlRJVFlfTUFUUklYO1xuICBsZWFkaW5nID0gMDtcbiAgeCA9IDA7XG4gIHkgPSAwO1xuICBsaW5lWCA9IDA7XG4gIGxpbmVZID0gMDtcbiAgY2hhclNwYWNpbmcgPSAwO1xuICB3b3JkU3BhY2luZyA9IDA7XG4gIHRleHRIU2NhbGUgPSAxO1xuICB0ZXh0UmVuZGVyaW5nTW9kZSA9IFRleHRSZW5kZXJpbmdNb2RlLkZJTEw7XG4gIHRleHRSaXNlID0gMDtcbiAgZmlsbENvbG9yID0gXCIjMDAwMDAwXCI7XG4gIHN0cm9rZUNvbG9yID0gXCIjMDAwMDAwXCI7XG4gIHBhdHRlcm5GaWxsID0gZmFsc2U7XG4gIHBhdHRlcm5TdHJva2UgPSBmYWxzZTtcbiAgZmlsbEFscGhhID0gMTtcbiAgc3Ryb2tlQWxwaGEgPSAxO1xuICBsaW5lV2lkdGggPSAxO1xuICBhY3RpdmVTTWFzayA9IG51bGw7XG4gIHRyYW5zZmVyTWFwcyA9IFwibm9uZVwiO1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBwcmVJbml0KSB7XG4gICAgcHJlSW5pdD8uKHRoaXMpO1xuICAgIHRoaXMuY2xpcEJveCA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIHdpZHRoLCBoZWlnaHRdKTtcbiAgICB0aGlzLm1pbk1heCA9IE1JTl9NQVhfSU5JVC5zbGljZSgpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICBjbG9uZS5jbGlwQm94ID0gdGhpcy5jbGlwQm94LnNsaWNlKCk7XG4gICAgY2xvbmUubWluTWF4ID0gdGhpcy5taW5NYXguc2xpY2UoKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgZ2V0UGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlID0gUGF0aFR5cGUuRklMTCwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIGNvbnN0IGJveCA9IHRoaXMubWluTWF4LnNsaWNlKCk7XG4gICAgaWYgKHBhdGhUeXBlID09PSBQYXRoVHlwZS5TVFJPS0UpIHtcbiAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgIHVucmVhY2hhYmxlKFwiU3Ryb2tlIGJvdW5kaW5nIGJveCBtdXN0IGluY2x1ZGUgdHJhbnNmb3JtLlwiKTtcbiAgICAgIH1cbiAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmb3JtLCBYWSk7XG4gICAgICBjb25zdCB4U3Ryb2tlUGFkID0gWFlbMF0gKiB0aGlzLmxpbmVXaWR0aCAvIDI7XG4gICAgICBjb25zdCB5U3Ryb2tlUGFkID0gWFlbMV0gKiB0aGlzLmxpbmVXaWR0aCAvIDI7XG4gICAgICBib3hbMF0gLT0geFN0cm9rZVBhZDtcbiAgICAgIGJveFsxXSAtPSB5U3Ryb2tlUGFkO1xuICAgICAgYm94WzJdICs9IHhTdHJva2VQYWQ7XG4gICAgICBib3hbM10gKz0geVN0cm9rZVBhZDtcbiAgICB9XG4gICAgcmV0dXJuIGJveDtcbiAgfVxuICB1cGRhdGVDbGlwRnJvbVBhdGgoKSB7XG4gICAgY29uc3QgaW50ZXJzZWN0ID0gVXRpbC5pbnRlcnNlY3QodGhpcy5jbGlwQm94LCB0aGlzLmdldFBhdGhCb3VuZGluZ0JveCgpKTtcbiAgICB0aGlzLnN0YXJ0TmV3UGF0aEFuZENsaXBCb3goaW50ZXJzZWN0IHx8IFswLCAwLCAwLCAwXSk7XG4gIH1cbiAgaXNFbXB0eUNsaXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluTWF4WzBdID09PSBJbmZpbml0eTtcbiAgfVxuICBzdGFydE5ld1BhdGhBbmRDbGlwQm94KGJveCkge1xuICAgIHRoaXMuY2xpcEJveC5zZXQoYm94LCAwKTtcbiAgICB0aGlzLm1pbk1heC5zZXQoTUlOX01BWF9JTklULCAwKTtcbiAgfVxuICBnZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlID0gUGF0aFR5cGUuRklMTCwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIHJldHVybiBVdGlsLmludGVyc2VjdCh0aGlzLmNsaXBCb3gsIHRoaXMuZ2V0UGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlLCB0cmFuc2Zvcm0pKTtcbiAgfVxufVxuZnVuY3Rpb24gcHV0QmluYXJ5SW1hZ2VEYXRhKGN0eCwgaW1nRGF0YSkge1xuICBpZiAoaW1nRGF0YSBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgY29uc3QgcGFydGlhbENodW5rSGVpZ2h0ID0gaGVpZ2h0ICUgRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IGZ1bGxDaHVua3MgPSAoaGVpZ2h0IC0gcGFydGlhbENodW5rSGVpZ2h0KSAvIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCB0b3RhbENodW5rcyA9IHBhcnRpYWxDaHVua0hlaWdodCA9PT0gMCA/IGZ1bGxDaHVua3MgOiBmdWxsQ2h1bmtzICsgMTtcbiAgY29uc3QgY2h1bmtJbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgRlVMTF9DSFVOS19IRUlHSFQpO1xuICBsZXQgc3JjUG9zID0gMCxcbiAgICBkZXN0UG9zO1xuICBjb25zdCBzcmMgPSBpbWdEYXRhLmRhdGE7XG4gIGNvbnN0IGRlc3QgPSBjaHVua0ltZ0RhdGEuZGF0YTtcbiAgbGV0IGksIGosIHRoaXNDaHVua0hlaWdodCwgZWxlbXNJblRoaXNDaHVuaztcbiAgaWYgKGltZ0RhdGEua2luZCA9PT0gdXRpbF9JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFApIHtcbiAgICBjb25zdCBzcmNMZW5ndGggPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBkZXN0MzIgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIsIDAsIGRlc3QuYnl0ZUxlbmd0aCA+PiAyKTtcbiAgICBjb25zdCBkZXN0MzJEYXRhTGVuZ3RoID0gZGVzdDMyLmxlbmd0aDtcbiAgICBjb25zdCBmdWxsU3JjRGlmZiA9IHdpZHRoICsgNyA+PiAzO1xuICAgIGNvbnN0IHdoaXRlID0gMHhmZmZmZmZmZjtcbiAgICBjb25zdCBibGFjayA9IHV0aWxfRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyAweGZmMDAwMDAwIDogMHgwMDAwMDBmZjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXNDaHVua0hlaWdodDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNyY0RpZmYgPSBzcmNMZW5ndGggLSBzcmNQb3M7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgY29uc3Qga0VuZCA9IHNyY0RpZmYgPiBmdWxsU3JjRGlmZiA/IHdpZHRoIDogc3JjRGlmZiAqIDggLSA3O1xuICAgICAgICBjb25zdCBrRW5kVW5yb2xsZWQgPSBrRW5kICYgfjc7XG4gICAgICAgIGxldCBtYXNrID0gMDtcbiAgICAgICAgbGV0IHNyY0J5dGUgPSAwO1xuICAgICAgICBmb3IgKDsgayA8IGtFbmRVbnJvbGxlZDsgayArPSA4KSB7XG4gICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTI4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA2NCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMzIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDE2ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgayA8IGtFbmQ7IGsrKykge1xuICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICBzcmNCeXRlID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICAgIG1hc2sgPSAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIG1hc2sgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChkZXN0UG9zIDwgZGVzdDMyRGF0YUxlbmd0aCkge1xuICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IDA7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSB1dGlsX0ltYWdlS2luZC5SR0JBXzMyQlBQKSB7XG4gICAgaiA9IDA7XG4gICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogRlVMTF9DSFVOS19IRUlHSFQgKiA0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIHNyY1BvcyArPSBlbGVtc0luVGhpc0NodW5rO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgICAgaiArPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICB9XG4gICAgaWYgKGkgPCB0b3RhbENodW5rcykge1xuICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogcGFydGlhbENodW5rSGVpZ2h0ICogNDtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSB1dGlsX0ltYWdlS2luZC5SR0JfMjRCUFApIHtcbiAgICB0aGlzQ2h1bmtIZWlnaHQgPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGlmIChpID49IGZ1bGxDaHVua3MpIHtcbiAgICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG4gICAgICB9XG4gICAgICBkZXN0UG9zID0gMDtcbiAgICAgIGZvciAoaiA9IGVsZW1zSW5UaGlzQ2h1bms7IGotLTspIHtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgYmFkIGltYWdlIGtpbmQ6ICR7aW1nRGF0YS5raW5kfWApO1xuICB9XG59XG5mdW5jdGlvbiBwdXRCaW5hcnlJbWFnZU1hc2soY3R4LCBpbWdEYXRhKSB7XG4gIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1nRGF0YS5iaXRtYXAsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gIGNvbnN0IHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gIGNvbnN0IGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgbGV0IHNyY1BvcyA9IDA7XG4gIGNvbnN0IHNyYyA9IGltZ0RhdGEuZGF0YTtcbiAgY29uc3QgZGVzdCA9IGNodW5rSW1nRGF0YS5kYXRhO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICBjb25zdCB0aGlzQ2h1bmtIZWlnaHQgPSBpIDwgZnVsbENodW5rcyA/IEZVTExfQ0hVTktfSEVJR0hUIDogcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICh7XG4gICAgICBzcmNQb3NcbiAgICB9ID0gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEoe1xuICAgICAgc3JjLFxuICAgICAgc3JjUG9zLFxuICAgICAgZGVzdCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzQ2h1bmtIZWlnaHQsXG4gICAgICBub25CbGFja0NvbG9yOiAwXG4gICAgfSkpO1xuICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICB9XG59XG5mdW5jdGlvbiBjb3B5Q3R4U3RhdGUoc291cmNlQ3R4LCBkZXN0Q3R4KSB7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBbXCJzdHJva2VTdHlsZVwiLCBcImZpbGxTdHlsZVwiLCBcImZpbGxSdWxlXCIsIFwiZ2xvYmFsQWxwaGFcIiwgXCJsaW5lV2lkdGhcIiwgXCJsaW5lQ2FwXCIsIFwibGluZUpvaW5cIiwgXCJtaXRlckxpbWl0XCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIFwiZm9udFwiLCBcImZpbHRlclwiXTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHNvdXJjZUN0eFtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdEN0eFtwcm9wZXJ0eV0gPSBzb3VyY2VDdHhbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuICBpZiAoc291cmNlQ3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZXN0Q3R4LnNldExpbmVEYXNoKHNvdXJjZUN0eC5nZXRMaW5lRGFzaCgpKTtcbiAgICBkZXN0Q3R4LmxpbmVEYXNoT2Zmc2V0ID0gc291cmNlQ3R4LmxpbmVEYXNoT2Zmc2V0O1xuICB9XG59XG5mdW5jdGlvbiByZXNldEN0eFRvRGVmYXVsdChjdHgpIHtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IFwiIzAwMDAwMFwiO1xuICBjdHguZmlsbFJ1bGUgPSBcIm5vbnplcm9cIjtcbiAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gIGN0eC5saW5lQ2FwID0gXCJidXR0XCI7XG4gIGN0eC5saW5lSm9pbiA9IFwibWl0ZXJcIjtcbiAgY3R4Lm1pdGVyTGltaXQgPSAxMDtcbiAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgY3R4LmZvbnQgPSBcIjEwcHggc2Fucy1zZXJpZlwiO1xuICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG4gIH1cbiAgY29uc3Qge1xuICAgIGZpbHRlclxuICB9ID0gY3R4O1xuICBpZiAoZmlsdGVyICE9PSBcIm5vbmVcIiAmJiBmaWx0ZXIgIT09IFwiXCIpIHtcbiAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEltYWdlU21vb3RoaW5nRW5hYmxlZCh0cmFuc2Zvcm0sIGludGVycG9sYXRlKSB7XG4gIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmb3JtLCBYWSk7XG4gIGNvbnN0IGFjdHVhbFNjYWxlID0gTWF0aC5mcm91bmQoT3V0cHV0U2NhbGUucGl4ZWxSYXRpbyAqIFBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gIHJldHVybiBYWVswXSA8PSBhY3R1YWxTY2FsZSAmJiBYWVsxXSA8PSBhY3R1YWxTY2FsZTtcbn1cbmNvbnN0IExJTkVfQ0FQX1NUWUxFUyA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcbmNvbnN0IExJTkVfSk9JTl9TVFlMRVMgPSBbXCJtaXRlclwiLCBcInJvdW5kXCIsIFwiYmV2ZWxcIl07XG5jb25zdCBOT1JNQUxfQ0xJUCA9IHt9O1xuY29uc3QgRU9fQ0xJUCA9IHt9O1xuY2xhc3MgQ2FudmFzR3JhcGhpY3Mge1xuICBjb25zdHJ1Y3RvcihjYW52YXNDdHgsIGNvbW1vbk9ianMsIG9ianMsIGNhbnZhc0ZhY3RvcnksIGZpbHRlckZhY3RvcnksIHtcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWcsXG4gICAgbWFya2VkQ29udGVudFN0YWNrID0gbnVsbFxuICB9LCBhbm5vdGF0aW9uQ2FudmFzTWFwLCBwYWdlQ29sb3JzLCBkZXBlbmRlbmN5VHJhY2tlcikge1xuICAgIHRoaXMuY3R4ID0gY2FudmFzQ3R4O1xuICAgIHRoaXMuY3VycmVudCA9IG5ldyBDYW52YXNFeHRyYVN0YXRlKHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5zdGF0ZVN0YWNrID0gW107XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gZmFsc2U7XG4gICAgdGhpcy5yZXMgPSBudWxsO1xuICAgIHRoaXMueG9ianMgPSBudWxsO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5ncm91cFN0YWNrID0gW107XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gbnVsbDtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCA9IDA7XG4gICAgdGhpcy5zbWFza1N0YWNrID0gW107XG4gICAgdGhpcy5zbWFza0NvdW50ZXIgPSAwO1xuICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IG51bGw7XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sgPSBtYXJrZWRDb250ZW50U3RhY2sgfHwgW107XG4gICAgdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcgPSBvcHRpb25hbENvbnRlbnRDb25maWc7XG4gICAgdGhpcy5jYWNoZWRDYW52YXNlcyA9IG5ldyBDYWNoZWRDYW52YXNlcyh0aGlzLmNhbnZhc0ZhY3RvcnkpO1xuICAgIHRoaXMuY2FjaGVkUGF0dGVybnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLnZpZXdwb3J0U2NhbGUgPSAxO1xuICAgIHRoaXMub3V0cHV0U2NhbGVYID0gMTtcbiAgICB0aGlzLm91dHB1dFNjYWxlWSA9IDE7XG4gICAgdGhpcy5wYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nID0gWy0xLCAwXTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgPSBkZXBlbmRlbmN5VHJhY2tlciA/PyBudWxsO1xuICB9XG4gIGdldE9iamVjdChvcElkeCwgZGF0YSwgZmFsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmROYW1lZERlcGVuZGVuY3kob3BJZHgsIGRhdGEpO1xuICAgICAgcmV0dXJuIGRhdGEuc3RhcnRzV2l0aChcImdfXCIpID8gdGhpcy5jb21tb25PYmpzLmdldChkYXRhKSA6IHRoaXMub2Jqcy5nZXQoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxuICBiZWdpbkRyYXdpbmcoe1xuICAgIHRyYW5zZm9ybSxcbiAgICB2aWV3cG9ydCxcbiAgICB0cmFuc3BhcmVuY3kgPSBmYWxzZSxcbiAgICBiYWNrZ3JvdW5kID0gbnVsbFxuICB9KSB7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmN0eC5jYW52YXMud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jdHguY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBzYXZlZEZpbGxTdHlsZSA9IHRoaXMuY3R4LmZpbGxTdHlsZTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kIHx8IFwiI2ZmZmZmZlwiO1xuICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHNhdmVkRmlsbFN0eWxlO1xuICAgIGlmICh0cmFuc3BhcmVuY3kpIHtcbiAgICAgIGNvbnN0IHRyYW5zcGFyZW50Q2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJ0cmFuc3BhcmVudFwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY29tcG9zaXRlQ3R4ID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLnRyYW5zcGFyZW50Q2FudmFzID0gdHJhbnNwYXJlbnRDYW52YXMuY2FudmFzO1xuICAgICAgdGhpcy5jdHggPSB0cmFuc3BhcmVudENhbnZhcy5jb250ZXh0O1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLmdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jb21wb3NpdGVDdHgpKTtcbiAgICB9XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4udHJhbnNmb3JtKTtcbiAgICAgIHRoaXMub3V0cHV0U2NhbGVYID0gdHJhbnNmb3JtWzBdO1xuICAgICAgdGhpcy5vdXRwdXRTY2FsZVkgPSB0cmFuc2Zvcm1bMF07XG4gICAgfVxuICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi52aWV3cG9ydC50cmFuc2Zvcm0pO1xuICAgIHRoaXMudmlld3BvcnRTY2FsZSA9IHZpZXdwb3J0LnNjYWxlO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICB9XG4gIGV4ZWN1dGVPcGVyYXRvckxpc3Qob3BlcmF0b3JMaXN0LCBleGVjdXRpb25TdGFydElkeCwgY29udGludWVDYWxsYmFjaywgc3RlcHBlciwgZmlsdGVyZWRPcGVyYXRpb25JbmRleGVzKSB7XG4gICAgY29uc3QgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICBjb25zdCBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgbGV0IGkgPSBleGVjdXRpb25TdGFydElkeCB8fCAwO1xuICAgIGNvbnN0IGFyZ3NBcnJheUxlbiA9IGFyZ3NBcnJheS5sZW5ndGg7XG4gICAgaWYgKGFyZ3NBcnJheUxlbiA9PT0gaSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rT3BlcmF0aW9ucyA9IGFyZ3NBcnJheUxlbiAtIGkgPiBFWEVDVVRJT05fU1RFUFMgJiYgdHlwZW9mIGNvbnRpbnVlQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBjb25zdCBlbmRUaW1lID0gY2h1bmtPcGVyYXRpb25zID8gRGF0ZS5ub3coKSArIEVYRUNVVElPTl9USU1FIDogMDtcbiAgICBsZXQgc3RlcHMgPSAwO1xuICAgIGNvbnN0IGNvbW1vbk9ianMgPSB0aGlzLmNvbW1vbk9ianM7XG4gICAgY29uc3Qgb2JqcyA9IHRoaXMub2JqcztcbiAgICBsZXQgZm5JZCwgZm5BcmdzO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoc3RlcHBlciAhPT0gdW5kZWZpbmVkICYmIGkgPT09IHN0ZXBwZXIubmV4dEJyZWFrUG9pbnQpIHtcbiAgICAgICAgc3RlcHBlci5icmVha0l0KGksIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIGlmICghZmlsdGVyZWRPcGVyYXRpb25JbmRleGVzIHx8IGZpbHRlcmVkT3BlcmF0aW9uSW5kZXhlcy5oYXMoaSkpIHtcbiAgICAgICAgZm5JZCA9IGZuQXJyYXlbaV07XG4gICAgICAgIGZuQXJncyA9IGFyZ3NBcnJheVtpXSA/PyBudWxsO1xuICAgICAgICBpZiAoZm5JZCAhPT0gT1BTLmRlcGVuZGVuY3kpIHtcbiAgICAgICAgICBpZiAoZm5BcmdzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzW2ZuSWRdKGkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW2ZuSWRdKGksIC4uLmZuQXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgZGVwT2JqSWQgb2YgZm5BcmdzKSB7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmROYW1lZERhdGEoZGVwT2JqSWQsIGkpO1xuICAgICAgICAgICAgY29uc3Qgb2Jqc1Bvb2wgPSBkZXBPYmpJZC5zdGFydHNXaXRoKFwiZ19cIikgPyBjb21tb25PYmpzIDogb2JqcztcbiAgICAgICAgICAgIGlmICghb2Jqc1Bvb2wuaGFzKGRlcE9iaklkKSkge1xuICAgICAgICAgICAgICBvYmpzUG9vbC5nZXQoZGVwT2JqSWQsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICAgIGlmIChpID09PSBhcmdzQXJyYXlMZW4pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmtPcGVyYXRpb25zICYmICsrc3RlcHMgPiBFWEVDVVRJT05fU1RFUFMpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgPiBlbmRUaW1lKSB7XG4gICAgICAgICAgY29udGludWVDYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXBzID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI3Jlc3RvcmVJbml0aWFsU3RhdGUoKSB7XG4gICAgd2hpbGUgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggfHwgdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IG51bGw7XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgIGlmICh0aGlzLnRyYW5zcGFyZW50Q2FudmFzKSB7XG4gICAgICB0aGlzLmN0eCA9IHRoaXMuY29tcG9zaXRlQ3R4O1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMudHJhbnNwYXJlbnRDYW52YXMsIDAsIDApO1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGVuZERyYXdpbmcoKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuY2xlYXIoKTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBjYWNoZSBvZiB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGNhbnZhcyBvZiBjYWNoZS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuY2xlYXIoKTtcbiAgICB0aGlzLiNkcmF3RmlsdGVyKCk7XG4gIH1cbiAgI2RyYXdGaWx0ZXIoKSB7XG4gICAgaWYgKHRoaXMucGFnZUNvbG9ycykge1xuICAgICAgY29uc3QgaGNtRmlsdGVySWQgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkSENNRmlsdGVyKHRoaXMucGFnZUNvbG9ycy5mb3JlZ3JvdW5kLCB0aGlzLnBhZ2VDb2xvcnMuYmFja2dyb3VuZCk7XG4gICAgICBpZiAoaGNtRmlsdGVySWQgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGNvbnN0IHNhdmVkRmlsdGVyID0gdGhpcy5jdHguZmlsdGVyO1xuICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSBoY21GaWx0ZXJJZDtcbiAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMuY3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICAgIHRoaXMuY3R4LmZpbHRlciA9IHNhdmVkRmlsdGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2NhbGVJbWFnZShpbWcsIGludmVyc2VUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCB3aWR0aCA9IGltZy53aWR0aCA/PyBpbWcuZGlzcGxheVdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZy5oZWlnaHQgPz8gaW1nLmRpc3BsYXlIZWlnaHQ7XG4gICAgbGV0IHdpZHRoU2NhbGUgPSBNYXRoLm1heChNYXRoLmh5cG90KGludmVyc2VUcmFuc2Zvcm1bMF0sIGludmVyc2VUcmFuc2Zvcm1bMV0pLCAxKTtcbiAgICBsZXQgaGVpZ2h0U2NhbGUgPSBNYXRoLm1heChNYXRoLmh5cG90KGludmVyc2VUcmFuc2Zvcm1bMl0sIGludmVyc2VUcmFuc2Zvcm1bM10pLCAxKTtcbiAgICBsZXQgcGFpbnRXaWR0aCA9IHdpZHRoLFxuICAgICAgcGFpbnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgbGV0IHRtcENhbnZhc0lkID0gXCJwcmVzY2FsZTFcIjtcbiAgICBsZXQgdG1wQ2FudmFzLCB0bXBDdHg7XG4gICAgd2hpbGUgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxIHx8IGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgIGxldCBuZXdXaWR0aCA9IHBhaW50V2lkdGgsXG4gICAgICAgIG5ld0hlaWdodCA9IHBhaW50SGVpZ2h0O1xuICAgICAgaWYgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxKSB7XG4gICAgICAgIG5ld1dpZHRoID0gcGFpbnRXaWR0aCA+PSAxNjM4NCA/IE1hdGguZmxvb3IocGFpbnRXaWR0aCAvIDIpIC0gMSB8fCAxIDogTWF0aC5jZWlsKHBhaW50V2lkdGggLyAyKTtcbiAgICAgICAgd2lkdGhTY2FsZSAvPSBwYWludFdpZHRoIC8gbmV3V2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0U2NhbGUgPiAyICYmIHBhaW50SGVpZ2h0ID4gMSkge1xuICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodCA+PSAxNjM4NCA/IE1hdGguZmxvb3IocGFpbnRIZWlnaHQgLyAyKSAtIDEgfHwgMSA6IE1hdGguY2VpbChwYWludEhlaWdodCkgLyAyO1xuICAgICAgICBoZWlnaHRTY2FsZSAvPSBwYWludEhlaWdodCAvIG5ld0hlaWdodDtcbiAgICAgIH1cbiAgICAgIHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKHRtcENhbnZhc0lkLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIHRtcEN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBwYWludFdpZHRoLCBwYWludEhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBpbWcgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgICAgcGFpbnRXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgcGFpbnRIZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICB0bXBDYW52YXNJZCA9IHRtcENhbnZhc0lkID09PSBcInByZXNjYWxlMVwiID8gXCJwcmVzY2FsZTJcIiA6IFwicHJlc2NhbGUxXCI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpbWcsXG4gICAgICBwYWludFdpZHRoLFxuICAgICAgcGFpbnRIZWlnaHRcbiAgICB9O1xuICB9XG4gIF9jcmVhdGVNYXNrQ2FudmFzKG9wSWR4LCBpbWcpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWc7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gICAgbGV0IGNhY2hlLCBjYWNoZUtleSwgc2NhbGVkLCBtYXNrQ2FudmFzO1xuICAgIGlmICgoaW1nLmJpdG1hcCB8fCBpbWcuZGF0YSkgJiYgaW1nLmNvdW50ID4gMSkge1xuICAgICAgY29uc3QgbWFpbktleSA9IGltZy5iaXRtYXAgfHwgaW1nLmRhdGEuYnVmZmVyO1xuICAgICAgY2FjaGVLZXkgPSBKU09OLnN0cmluZ2lmeShpc1BhdHRlcm5GaWxsID8gY3VycmVudFRyYW5zZm9ybSA6IFtjdXJyZW50VHJhbnNmb3JtLnNsaWNlKDAsIDQpLCBmaWxsQ29sb3JdKTtcbiAgICAgIGNhY2hlID0gdGhpcy5fY2FjaGVkQml0bWFwc01hcC5nZXQobWFpbktleSk7XG4gICAgICBpZiAoIWNhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnNldChtYWluS2V5LCBjYWNoZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWNoZWRJbWFnZSA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVkSW1hZ2UgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVswXSwgY3VycmVudFRyYW5zZm9ybVsyXSkgKyBjdXJyZW50VHJhbnNmb3JtWzRdKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVsxXSwgY3VycmVudFRyYW5zZm9ybVszXSkgKyBjdXJyZW50VHJhbnNmb3JtWzVdKTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMudHJhbnNmb3JtQW5kRmlsbCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FudmFzOiBjYWNoZWRJbWFnZSxcbiAgICAgICAgICBvZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHNjYWxlZCA9IGNhY2hlZEltYWdlO1xuICAgIH1cbiAgICBpZiAoIXNjYWxlZCkge1xuICAgICAgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ2FudmFzLmNvbnRleHQsIGltZyk7XG4gICAgfVxuICAgIGxldCBtYXNrVG9DYW52YXMgPSBVdGlsLnRyYW5zZm9ybShjdXJyZW50VHJhbnNmb3JtLCBbMSAvIHdpZHRoLCAwLCAwLCAtMSAvIGhlaWdodCwgMCwgMF0pO1xuICAgIG1hc2tUb0NhbnZhcyA9IFV0aWwudHJhbnNmb3JtKG1hc2tUb0NhbnZhcywgWzEsIDAsIDAsIDEsIDAsIC1oZWlnaHRdKTtcbiAgICBjb25zdCBtaW5NYXggPSBNSU5fTUFYX0lOSVQuc2xpY2UoKTtcbiAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgbWFza1RvQ2FudmFzLCBtaW5NYXgpO1xuICAgIGNvbnN0IFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSA9IG1pbk1heDtcbiAgICBjb25zdCBkcmF3bldpZHRoID0gTWF0aC5yb3VuZChtYXhYIC0gbWluWCkgfHwgMTtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IE1hdGgucm91bmQobWF4WSAtIG1pblkpIHx8IDE7XG4gICAgY29uc3QgZmlsbENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiZmlsbENhbnZhc1wiLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgY29uc3QgZmlsbEN0eCA9IGZpbGxDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBvZmZzZXRYID0gbWluWDtcbiAgICBjb25zdCBvZmZzZXRZID0gbWluWTtcbiAgICBmaWxsQ3R4LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICAgIGZpbGxDdHgudHJhbnNmb3JtKC4uLm1hc2tUb0NhbnZhcyk7XG4gICAgaWYgKCFzY2FsZWQpIHtcbiAgICAgIHNjYWxlZCA9IHRoaXMuX3NjYWxlSW1hZ2UobWFza0NhbnZhcy5jYW52YXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGZpbGxDdHgpKTtcbiAgICAgIHNjYWxlZCA9IHNjYWxlZC5pbWc7XG4gICAgICBpZiAoY2FjaGUgJiYgaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHNjYWxlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZpbGxDdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKGdldEN1cnJlbnRUcmFuc2Zvcm0oZmlsbEN0eCksIGltZy5pbnRlcnBvbGF0ZSk7XG4gICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGZpbGxDdHgsIHNjYWxlZCwgMCwgMCwgc2NhbGVkLndpZHRoLCBzY2FsZWQuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBmaWxsQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgY29uc3QgaW52ZXJzZSA9IFV0aWwudHJhbnNmb3JtKGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGZpbGxDdHgpLCBbMSwgMCwgMCwgMSwgLW9mZnNldFgsIC1vZmZzZXRZXSk7XG4gICAgZmlsbEN0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBpbnZlcnNlLCBQYXRoVHlwZS5GSUxMKSA6IGZpbGxDb2xvcjtcbiAgICBmaWxsQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChjYWNoZSAmJiAhaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgdGhpcy5jYWNoZWRDYW52YXNlcy5kZWxldGUoXCJmaWxsQ2FudmFzXCIpO1xuICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBmaWxsQ2FudmFzLmNhbnZhcyk7XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnRyYW5zZm9ybUFuZEZpbGwpO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXM6IGZpbGxDYW52YXMuY2FudmFzLFxuICAgICAgb2Zmc2V0WDogTWF0aC5yb3VuZChvZmZzZXRYKSxcbiAgICAgIG9mZnNldFk6IE1hdGgucm91bmQob2Zmc2V0WSlcbiAgICB9O1xuICB9XG4gIHNldExpbmVXaWR0aChvcElkeCwgd2lkdGgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwibGluZVdpZHRoXCIsIG9wSWR4KTtcbiAgICBpZiAod2lkdGggIT09IHRoaXMuY3VycmVudC5saW5lV2lkdGgpIHtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuICB9XG4gIHNldExpbmVDYXAob3BJZHgsIHN0eWxlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImxpbmVDYXBcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3R4LmxpbmVDYXAgPSBMSU5FX0NBUF9TVFlMRVNbc3R5bGVdO1xuICB9XG4gIHNldExpbmVKb2luKG9wSWR4LCBzdHlsZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJsaW5lSm9pblwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHgubGluZUpvaW4gPSBMSU5FX0pPSU5fU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRNaXRlckxpbWl0KG9wSWR4LCBsaW1pdCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJtaXRlckxpbWl0XCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5taXRlckxpbWl0ID0gbGltaXQ7XG4gIH1cbiAgc2V0RGFzaChvcElkeCwgZGFzaEFycmF5LCBkYXNoUGhhc2UpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZGFzaFwiLCBvcElkeCk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdHguc2V0TGluZURhc2goZGFzaEFycmF5KTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hQaGFzZTtcbiAgICB9XG4gIH1cbiAgc2V0UmVuZGVyaW5nSW50ZW50KG9wSWR4LCBpbnRlbnQpIHt9XG4gIHNldEZsYXRuZXNzKG9wSWR4LCBmbGF0bmVzcykge31cbiAgc2V0R1N0YXRlKG9wSWR4LCBzdGF0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdGF0ZXMpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJMV1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKG9wSWR4LCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMQ1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUNhcChvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTEpcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVKb2luKG9wSWR4LCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJNTFwiOlxuICAgICAgICAgIHRoaXMuc2V0TWl0ZXJMaW1pdChvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgIHRoaXMuc2V0RGFzaChvcElkeCwgdmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJJXCI6XG4gICAgICAgICAgdGhpcy5zZXRSZW5kZXJpbmdJbnRlbnQob3BJZHgsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZMXCI6XG4gICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyhvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIHRoaXMuc2V0Rm9udChvcElkeCwgdmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkNBXCI6XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInN0cm9rZUFscGhhXCIsIG9wSWR4KTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImZpbGxBbHBoYVwiLCBvcElkeCk7XG4gICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuZmlsbEFscGhhID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJCTVwiOlxuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIiwgb3BJZHgpO1xuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU01hc2tcIjpcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiU01hc2tcIiwgb3BJZHgpO1xuICAgICAgICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IHZhbHVlID8gdGhpcy50ZW1wU01hc2sgOiBudWxsO1xuICAgICAgICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmNoZWNrU01hc2tTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVFJcIjpcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZmlsdGVyXCIsIG9wSWR4KTtcbiAgICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEZpbHRlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBpblNNYXNrTW9kZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLnN1c3BlbmRlZEN0eDtcbiAgfVxuICBjaGVja1NNYXNrU3RhdGUoKSB7XG4gICAgY29uc3QgaW5TTWFza01vZGUgPSB0aGlzLmluU01hc2tNb2RlO1xuICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgJiYgIWluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmJlZ2luU01hc2tNb2RlKCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmIGluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgIH1cbiAgfVxuICBiZWdpblNNYXNrTW9kZShvcElkeCkge1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiZWdpblNNYXNrTW9kZSBjYWxsZWQgd2hpbGUgYWxyZWFkeSBpbiBzbWFzayBtb2RlXCIpO1xuICAgIH1cbiAgICBjb25zdCBkcmF3bldpZHRoID0gdGhpcy5jdHguY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gdGhpcy5jdHguY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBjYWNoZUlkID0gXCJzbWFza0dyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICBjb25zdCBzY3JhdGNoQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoY2FjaGVJZCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQpO1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHggPSBzY3JhdGNoQ2FudmFzLmNvbnRleHQ7XG4gICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnN1c3BlbmRlZEN0eC5nZXRUcmFuc2Zvcm0oKSk7XG4gICAgY29weUN0eFN0YXRlKHRoaXMuc3VzcGVuZGVkQ3R4LCBjdHgpO1xuICAgIG1pcnJvckNvbnRleHRPcGVyYXRpb25zKGN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgIHRoaXMuc2V0R1N0YXRlKG9wSWR4LCBbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXV0pO1xuICB9XG4gIGVuZFNNYXNrTW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImVuZFNNYXNrTW9kZSBjYWxsZWQgd2hpbGUgbm90IGluIHNtYXNrIG1vZGVcIik7XG4gICAgfVxuICAgIHRoaXMuY3R4Ll9yZW1vdmVNaXJyb3JpbmcoKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gbnVsbDtcbiAgfVxuICBjb21wb3NlKGRpcnR5Qm94KSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkaXJ0eUJveCkge1xuICAgICAgZGlydHlCb3ggPSBbMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlCb3hbMF0gPSBNYXRoLmZsb29yKGRpcnR5Qm94WzBdKTtcbiAgICAgIGRpcnR5Qm94WzFdID0gTWF0aC5mbG9vcihkaXJ0eUJveFsxXSk7XG4gICAgICBkaXJ0eUJveFsyXSA9IE1hdGguY2VpbChkaXJ0eUJveFsyXSk7XG4gICAgICBkaXJ0eUJveFszXSA9IE1hdGguY2VpbChkaXJ0eUJveFszXSk7XG4gICAgfVxuICAgIGNvbnN0IHNtYXNrID0gdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrO1xuICAgIGNvbnN0IHN1c3BlbmRlZEN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuY29tcG9zZVNNYXNrKHN1c3BlbmRlZEN0eCwgc21hc2ssIHRoaXMuY3R4LCBkaXJ0eUJveCk7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgY29tcG9zZVNNYXNrKGN0eCwgc21hc2ssIGxheWVyQ3R4LCBsYXllckJveCkge1xuICAgIGNvbnN0IGxheWVyT2Zmc2V0WCA9IGxheWVyQm94WzBdO1xuICAgIGNvbnN0IGxheWVyT2Zmc2V0WSA9IGxheWVyQm94WzFdO1xuICAgIGNvbnN0IGxheWVyV2lkdGggPSBsYXllckJveFsyXSAtIGxheWVyT2Zmc2V0WDtcbiAgICBjb25zdCBsYXllckhlaWdodCA9IGxheWVyQm94WzNdIC0gbGF5ZXJPZmZzZXRZO1xuICAgIGlmIChsYXllcldpZHRoID09PSAwIHx8IGxheWVySGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ2VuZXJpY0NvbXBvc2VTTWFzayhzbWFzay5jb250ZXh0LCBsYXllckN0eCwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHQsIHNtYXNrLnN1YnR5cGUsIHNtYXNrLmJhY2tkcm9wLCBzbWFzay50cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHNtYXNrLm9mZnNldFgsIHNtYXNrLm9mZnNldFkpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmRyYXdJbWFnZShsYXllckN0eC5jYW52YXMsIDAsIDApO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZ2VuZXJpY0NvbXBvc2VTTWFzayhtYXNrQ3R4LCBsYXllckN0eCwgd2lkdGgsIGhlaWdodCwgc3VidHlwZSwgYmFja2Ryb3AsIHRyYW5zZmVyTWFwLCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgbWFza09mZnNldFgsIG1hc2tPZmZzZXRZKSB7XG4gICAgbGV0IG1hc2tDYW52YXMgPSBtYXNrQ3R4LmNhbnZhcztcbiAgICBsZXQgbWFza1ggPSBsYXllck9mZnNldFggLSBtYXNrT2Zmc2V0WDtcbiAgICBsZXQgbWFza1kgPSBsYXllck9mZnNldFkgLSBtYXNrT2Zmc2V0WTtcbiAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgIGlmIChtYXNrWCA8IDAgfHwgbWFza1kgPCAwIHx8IG1hc2tYICsgd2lkdGggPiBtYXNrQ2FudmFzLndpZHRoIHx8IG1hc2tZICsgaGVpZ2h0ID4gbWFza0NhbnZhcy5oZWlnaHQpIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrRXh0ZW5zaW9uXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuY29udGV4dDtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCAtbWFza1gsIC1tYXNrWSk7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWF0b3BcIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgIG1hc2tDYW52YXMgPSBjYW52YXMuY2FudmFzO1xuICAgICAgICBtYXNrWCA9IG1hc2tZID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgICBtYXNrQ3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgbWFza0N0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIGNvbnN0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIGNsaXAucmVjdChtYXNrWCwgbWFza1ksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBtYXNrQ3R4LmNsaXAoY2xpcCk7XG4gICAgICAgIG1hc2tDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1hdG9wXCI7XG4gICAgICAgIG1hc2tDdHguZmlsbFN0eWxlID0gYmFja2Ryb3A7XG4gICAgICAgIG1hc2tDdHguZmlsbFJlY3QobWFza1gsIG1hc2tZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWFza0N0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxheWVyQ3R4LnNhdmUoKTtcbiAgICBsYXllckN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgbGF5ZXJDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGlmIChzdWJ0eXBlID09PSBcIkFscGhhXCIgJiYgdHJhbnNmZXJNYXApIHtcbiAgICAgIGxheWVyQ3R4LmZpbHRlciA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRBbHBoYUZpbHRlcih0cmFuc2Zlck1hcCk7XG4gICAgfSBlbHNlIGlmIChzdWJ0eXBlID09PSBcIkx1bWlub3NpdHlcIikge1xuICAgICAgbGF5ZXJDdHguZmlsdGVyID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEx1bWlub3NpdHlGaWx0ZXIodHJhbnNmZXJNYXApO1xuICAgIH1cbiAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgIGNsaXAucmVjdChsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgd2lkdGgsIGhlaWdodCk7XG4gICAgbGF5ZXJDdHguY2xpcChjbGlwKTtcbiAgICBsYXllckN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWluXCI7XG4gICAgbGF5ZXJDdHguZHJhd0ltYWdlKG1hc2tDYW52YXMsIG1hc2tYLCBtYXNrWSwgd2lkdGgsIGhlaWdodCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGxheWVyQ3R4LnJlc3RvcmUoKTtcbiAgfVxuICBzYXZlKG9wSWR4KSB7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIGNvcHlDdHhTdGF0ZSh0aGlzLmN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgY29uc3Qgb2xkID0gdGhpcy5jdXJyZW50O1xuICAgIHRoaXMuc3RhdGVTdGFjay5wdXNoKG9sZCk7XG4gICAgdGhpcy5jdXJyZW50ID0gb2xkLmNsb25lKCk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8uc2F2ZShvcElkeCk7XG4gIH1cbiAgcmVzdG9yZShvcElkeCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc3RvcmUob3BJZHgpO1xuICAgIGlmICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnN0YXRlU3RhY2sucG9wKCk7XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICBjb3B5Q3R4U3RhdGUodGhpcy5zdXNwZW5kZWRDdHgsIHRoaXMuY3R4KTtcbiAgICB9XG4gICAgdGhpcy5jaGVja1NNYXNrU3RhdGUoKTtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gIH1cbiAgdHJhbnNmb3JtKG9wSWR4LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkSW5jcmVtZW50YWxEYXRhKFwidHJhbnNmb3JtXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICB9XG4gIGNvbnN0cnVjdFBhdGgob3BJZHgsIG9wLCBkYXRhLCBtaW5NYXgpIHtcbiAgICBsZXQgW3BhdGhdID0gZGF0YTtcbiAgICBpZiAoIW1pbk1heCkge1xuICAgICAgcGF0aCB8fD0gZGF0YVswXSA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHRoaXNbb3BdKG9wSWR4LCBwYXRoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG91dGVyRXh0cmFTaXplID0gb3AgPT09IE9QUy5zdHJva2UgPyB0aGlzLmN1cnJlbnQubGluZVdpZHRoIC8gMiA6IDA7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyLnJlc2V0QkJveChvcElkeCkucmVjb3JkQkJveChvcElkeCwgdGhpcy5jdHgsIG1pbk1heFswXSAtIG91dGVyRXh0cmFTaXplLCBtaW5NYXhbMl0gKyBvdXRlckV4dHJhU2l6ZSwgbWluTWF4WzFdIC0gb3V0ZXJFeHRyYVNpemUsIG1pbk1heFszXSArIG91dGVyRXh0cmFTaXplKS5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIFtcInRyYW5zZm9ybVwiXSk7XG4gICAgfVxuICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBQYXRoMkQpKSB7XG4gICAgICBjb25zdCBwYXRoMmQgPSBkYXRhWzBdID0gbmV3IFBhdGgyRCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTspIHtcbiAgICAgICAgc3dpdGNoIChwYXRoW2krK10pIHtcbiAgICAgICAgICBjYXNlIERyYXdPUFMubW92ZVRvOlxuICAgICAgICAgICAgcGF0aDJkLm1vdmVUbyhwYXRoW2krK10sIHBhdGhbaSsrXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIERyYXdPUFMubGluZVRvOlxuICAgICAgICAgICAgcGF0aDJkLmxpbmVUbyhwYXRoW2krK10sIHBhdGhbaSsrXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIERyYXdPUFMuY3VydmVUbzpcbiAgICAgICAgICAgIHBhdGgyZC5iZXppZXJDdXJ2ZVRvKHBhdGhbaSsrXSwgcGF0aFtpKytdLCBwYXRoW2krK10sIHBhdGhbaSsrXSwgcGF0aFtpKytdLCBwYXRoW2krK10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBEcmF3T1BTLmNsb3NlUGF0aDpcbiAgICAgICAgICAgIHBhdGgyZC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB3YXJuKGBVbnJlY29nbml6ZWQgZHJhd2luZyBwYXRoIG9wZXJhdG9yOiAke3BhdGhbaSAtIDFdfWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhdGggPSBwYXRoMmQ7XG4gICAgfVxuICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3gobWluTWF4LCBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KSwgdGhpcy5jdXJyZW50Lm1pbk1heCk7XG4gICAgdGhpc1tvcF0ob3BJZHgsIHBhdGgpO1xuICAgIHRoaXMuX3BhdGhTdGFydElkeCA9IG9wSWR4O1xuICB9XG4gIGNsb3NlUGF0aChvcElkeCkge1xuICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICB9XG4gIHN0cm9rZShvcElkeCwgcGF0aCwgY29uc3VtZVBhdGggPSB0cnVlKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3I7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhO1xuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cm9rZUNvbG9yID09PSBcIm9iamVjdFwiICYmIHN0cm9rZUNvbG9yPy5nZXRQYXR0ZXJuKSB7XG4gICAgICAgIGNvbnN0IGJhc2VUcmFuc2Zvcm0gPSBzdHJva2VDb2xvci5pc01vZGlmeWluZ0N1cnJlbnRUcmFuc2Zvcm0oKSA/IGN0eC5nZXRUcmFuc2Zvcm0oKSA6IG51bGw7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5TVFJPS0UpO1xuICAgICAgICBpZiAoYmFzZVRyYW5zZm9ybSkge1xuICAgICAgICAgIGNvbnN0IG5ld1BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgICAgbmV3UGF0aC5hZGRQYXRoKHBhdGgsIGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCkubXVsdGlwbHlTZWxmKGJhc2VUcmFuc2Zvcm0pKTtcbiAgICAgICAgICBwYXRoID0gbmV3UGF0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2NhbGVBbmRTdHJva2UocGF0aCwgZmFsc2UpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXNjYWxlQW5kU3Ryb2tlKHBhdGgsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy5zdHJva2UpO1xuICAgIGlmIChjb25zdW1lUGF0aCkge1xuICAgICAgdGhpcy5jb25zdW1lUGF0aChvcElkeCwgcGF0aCwgdGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goUGF0aFR5cGUuU1RST0tFLCBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KSkpO1xuICAgIH1cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuZmlsbEFscGhhO1xuICB9XG4gIGNsb3NlU3Ryb2tlKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5zdHJva2Uob3BJZHgsIHBhdGgpO1xuICB9XG4gIGZpbGwob3BJZHgsIHBhdGgsIGNvbnN1bWVQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3QgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBsZXQgbmVlZFJlc3RvcmUgPSBmYWxzZTtcbiAgICBpZiAoaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgY29uc3QgYmFzZVRyYW5zZm9ybSA9IGZpbGxDb2xvci5pc01vZGlmeWluZ0N1cnJlbnRUcmFuc2Zvcm0oKSA/IGN0eC5nZXRUcmFuc2Zvcm0oKSA6IG51bGw7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5zYXZlKG9wSWR4KTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5GSUxMKTtcbiAgICAgIGlmIChiYXNlVHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IG5ld1BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBjdHguZ2V0VHJhbnNmb3JtKCkuaW52ZXJ0U2VsZigpLm11bHRpcGx5U2VsZihiYXNlVHJhbnNmb3JtKSk7XG4gICAgICAgIHBhdGggPSBuZXdQYXRoO1xuICAgICAgfVxuICAgICAgbmVlZFJlc3RvcmUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnNlY3QgPSB0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpO1xuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIGludGVyc2VjdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ0VPRmlsbCkge1xuICAgICAgICBjdHguZmlsbChwYXRoLCBcImV2ZW5vZGRcIik7XG4gICAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwocGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLmZpbGwpO1xuICAgIGlmIChuZWVkUmVzdG9yZSkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc3RvcmUob3BJZHgpO1xuICAgIH1cbiAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgIHRoaXMuY29uc3VtZVBhdGgob3BJZHgsIHBhdGgsIGludGVyc2VjdCk7XG4gICAgfVxuICB9XG4gIGVvRmlsbChvcElkeCwgcGF0aCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBmaWxsU3Ryb2tlKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5maWxsKG9wSWR4LCBwYXRoLCBmYWxzZSk7XG4gICAgdGhpcy5zdHJva2Uob3BJZHgsIHBhdGgsIGZhbHNlKTtcbiAgICB0aGlzLmNvbnN1bWVQYXRoKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBlb0ZpbGxTdHJva2Uob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbFN0cm9rZShvcElkeCwgcGF0aCk7XG4gIH1cbiAgY2xvc2VGaWxsU3Ryb2tlKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5maWxsU3Ryb2tlKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBjbG9zZUVPRmlsbFN0cm9rZShvcElkeCwgcGF0aCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsU3Ryb2tlKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBlbmRQYXRoKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5jb25zdW1lUGF0aChvcElkeCwgcGF0aCk7XG4gIH1cbiAgcmF3RmlsbFBhdGgob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLmN0eC5maWxsKHBhdGgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnJhd0ZpbGxQYXRoKS5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICB9XG4gIGNsaXAob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwiY2xpcE1vZGVcIiwgb3BJZHgpO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBOT1JNQUxfQ0xJUDtcbiAgfVxuICBlb0NsaXAob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwiY2xpcE1vZGVcIiwgb3BJZHgpO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBFT19DTElQO1xuICB9XG4gIGJlZ2luVGV4dChvcElkeCkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4ID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCA9IDA7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgPSAwO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZW5NYXJrZXIob3BJZHgpLnJlc2V0SW5jcmVtZW50YWxEYXRhKFwic2FtZUxpbmVUZXh0XCIpLnJlc2V0SW5jcmVtZW50YWxEYXRhKFwibW92ZVRleHRcIiwgb3BJZHgpO1xuICB9XG4gIGVuZFRleHQob3BJZHgpIHtcbiAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAodGhpcy5kZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkZXBlbmRlbmN5VHJhY2tlclxuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAocGF0aHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwidGV4dENsaXBcIiwgZGVwZW5kZW5jeVRyYWNrZXIuZ2V0T3Blbk1hcmtlcigpKS5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwidGV4dENsaXBcIiwgb3BJZHgpO1xuICAgICAgfVxuICAgICAgZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkQ2xvc2VNYXJrZXIob3BJZHgpO1xuICAgIH1cbiAgICBpZiAocGF0aHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbmV3UGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIGNvbnN0IGludlRyYW5zZiA9IGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCk7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgcGF0aFxuICAgICAgfSBvZiBwYXRocykge1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuZXdQYXRoLmFkZFBhdGgocGF0aCwgbmV3IERPTU1hdHJpeCh0cmFuc2Zvcm0pLnByZU11bHRpcGx5U2VsZihpbnZUcmFuc2YpLnRyYW5zbGF0ZSh4LCB5KS5zY2FsZShmb250U2l6ZSwgLWZvbnRTaXplKSk7XG4gICAgICB9XG4gICAgICBjdHguY2xpcChuZXdQYXRoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgfVxuICBzZXRDaGFyU3BhY2luZyhvcElkeCwgc3BhY2luZykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJjaGFyU3BhY2luZ1wiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LmNoYXJTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRXb3JkU3BhY2luZyhvcElkeCwgc3BhY2luZykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJ3b3JkU3BhY2luZ1wiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LndvcmRTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRIU2NhbGUob3BJZHgsIHNjYWxlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImhTY2FsZVwiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LnRleHRIU2NhbGUgPSBzY2FsZSAvIDEwMDtcbiAgfVxuICBzZXRMZWFkaW5nKG9wSWR4LCBsZWFkaW5nKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImxlYWRpbmdcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC5sZWFkaW5nID0gLWxlYWRpbmc7XG4gIH1cbiAgc2V0Rm9udChvcElkeCwgZm9udFJlZk5hbWUsIHNpemUpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZm9udFwiLCBvcElkeCkucmVjb3JkTmFtZWREZXBlbmRlbmN5KG9wSWR4LCBmb250UmVmTmFtZSk7XG4gICAgY29uc3QgZm9udE9iaiA9IHRoaXMuY29tbW9uT2Jqcy5nZXQoZm9udFJlZk5hbWUpO1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgaWYgKCFmb250T2JqKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGZpbmQgZm9udCBmb3IgJHtmb250UmVmTmFtZX1gKTtcbiAgICB9XG4gICAgY3VycmVudC5mb250TWF0cml4ID0gZm9udE9iai5mb250TWF0cml4IHx8IEZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIGlmIChjdXJyZW50LmZvbnRNYXRyaXhbMF0gPT09IDAgfHwgY3VycmVudC5mb250TWF0cml4WzNdID09PSAwKSB7XG4gICAgICB3YXJuKFwiSW52YWxpZCBmb250IG1hdHJpeCBmb3IgZm9udCBcIiArIGZvbnRSZWZOYW1lKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICBzaXplID0gLXNpemU7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gMTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmZvbnQgPSBmb250T2JqO1xuICAgIHRoaXMuY3VycmVudC5mb250U2l6ZSA9IHNpemU7XG4gICAgaWYgKGZvbnRPYmouaXNUeXBlM0ZvbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IGZvbnRPYmoubG9hZGVkTmFtZSB8fCBcInNhbnMtc2VyaWZcIjtcbiAgICBjb25zdCB0eXBlZmFjZSA9IGZvbnRPYmouc3lzdGVtRm9udEluZm8/LmNzcyB8fCBgXCIke25hbWV9XCIsICR7Zm9udE9iai5mYWxsYmFja05hbWV9YDtcbiAgICBsZXQgYm9sZCA9IFwibm9ybWFsXCI7XG4gICAgaWYgKGZvbnRPYmouYmxhY2spIHtcbiAgICAgIGJvbGQgPSBcIjkwMFwiO1xuICAgIH0gZWxzZSBpZiAoZm9udE9iai5ib2xkKSB7XG4gICAgICBib2xkID0gXCJib2xkXCI7XG4gICAgfVxuICAgIGNvbnN0IGl0YWxpYyA9IGZvbnRPYmouaXRhbGljID8gXCJpdGFsaWNcIiA6IFwibm9ybWFsXCI7XG4gICAgbGV0IGJyb3dzZXJGb250U2l6ZSA9IHNpemU7XG4gICAgaWYgKHNpemUgPCBNSU5fRk9OVF9TSVpFKSB7XG4gICAgICBicm93c2VyRm9udFNpemUgPSBNSU5fRk9OVF9TSVpFO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA+IE1BWF9GT05UX1NJWkUpIHtcbiAgICAgIGJyb3dzZXJGb250U2l6ZSA9IE1BWF9GT05UX1NJWkU7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5mb250U2l6ZVNjYWxlID0gc2l6ZSAvIGJyb3dzZXJGb250U2l6ZTtcbiAgICB0aGlzLmN0eC5mb250ID0gYCR7aXRhbGljfSAke2JvbGR9ICR7YnJvd3NlckZvbnRTaXplfXB4ICR7dHlwZWZhY2V9YDtcbiAgfVxuICBzZXRUZXh0UmVuZGVyaW5nTW9kZShvcElkeCwgbW9kZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJ0ZXh0UmVuZGVyaW5nTW9kZVwiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID0gbW9kZTtcbiAgfVxuICBzZXRUZXh0UmlzZShvcElkeCwgcmlzZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJ0ZXh0UmlzZVwiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LnRleHRSaXNlID0gcmlzZTtcbiAgfVxuICBtb3ZlVGV4dChvcElkeCwgeCwgeSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0SW5jcmVtZW50YWxEYXRhKFwic2FtZUxpbmVUZXh0XCIpLnJlY29yZEluY3JlbWVudGFsRGF0YShcIm1vdmVUZXh0XCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCArPSB4O1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZICs9IHk7XG4gIH1cbiAgc2V0TGVhZGluZ01vdmVUZXh0KG9wSWR4LCB4LCB5KSB7XG4gICAgdGhpcy5zZXRMZWFkaW5nKG9wSWR4LCAteSk7XG4gICAgdGhpcy5tb3ZlVGV4dChvcElkeCwgeCwgeSk7XG4gIH1cbiAgc2V0VGV4dE1hdHJpeChvcElkeCwgbWF0cml4KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInRleHRNYXRyaXhcIiwgb3BJZHgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRcbiAgICB9ID0gdGhpcztcbiAgICBjdXJyZW50LnRleHRNYXRyaXggPSBtYXRyaXg7XG4gICAgY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSBNYXRoLmh5cG90KG1hdHJpeFswXSwgbWF0cml4WzFdKTtcbiAgICBjdXJyZW50LnggPSBjdXJyZW50LmxpbmVYID0gMDtcbiAgICBjdXJyZW50LnkgPSBjdXJyZW50LmxpbmVZID0gMDtcbiAgfVxuICBuZXh0TGluZShvcElkeCkge1xuICAgIHRoaXMubW92ZVRleHQob3BJZHgsIDAsIHRoaXMuY3VycmVudC5sZWFkaW5nKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRJbmNyZW1lbnRhbERhdGEoXCJtb3ZlVGV4dFwiLCB0aGlzLmRlcGVuZGVuY3lUcmFja2VyLmdldFNpbXBsZUluZGV4KFwibGVhZGluZ1wiKSA/PyBvcElkeCk7XG4gIH1cbiAgI2dldFNjYWxlZFBhdGgocGF0aCwgY3VycmVudFRyYW5zZm9ybSwgdHJhbnNmb3JtKSB7XG4gICAgY29uc3QgbmV3UGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICBuZXdQYXRoLmFkZFBhdGgocGF0aCwgbmV3IERPTU1hdHJpeCh0cmFuc2Zvcm0pLmludmVydFNlbGYoKS5tdWx0aXBseVNlbGYoY3VycmVudFRyYW5zZm9ybSkpO1xuICAgIHJldHVybiBuZXdQYXRoO1xuICB9XG4gIHBhaW50Q2hhcihvcElkeCwgY2hhcmFjdGVyLCB4LCB5LCBwYXR0ZXJuRmlsbFRyYW5zZm9ybSwgcGF0dGVyblN0cm9rZVRyYW5zZm9ybSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBjb25zdCB0ZXh0UmVuZGVyaW5nTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGU7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplIC8gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGZpbGxTdHJva2VNb2RlID0gdGV4dFJlbmRlcmluZ01vZGUgJiBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgIGNvbnN0IGlzQWRkVG9QYXRoU2V0ID0gISEodGV4dFJlbmRlcmluZ01vZGUgJiBUZXh0UmVuZGVyaW5nTW9kZS5BRERfVE9fUEFUSF9GTEFHKTtcbiAgICBjb25zdCBwYXR0ZXJuRmlsbCA9IGN1cnJlbnQucGF0dGVybkZpbGwgJiYgIWZvbnQubWlzc2luZ0ZpbGU7XG4gICAgY29uc3QgcGF0dGVyblN0cm9rZSA9IGN1cnJlbnQucGF0dGVyblN0cm9rZSAmJiAhZm9udC5taXNzaW5nRmlsZTtcbiAgICBsZXQgcGF0aDtcbiAgICBpZiAoKGZvbnQuZGlzYWJsZUZvbnRGYWNlIHx8IGlzQWRkVG9QYXRoU2V0IHx8IHBhdHRlcm5GaWxsIHx8IHBhdHRlcm5TdHJva2UpICYmICFmb250Lm1pc3NpbmdGaWxlKSB7XG4gICAgICBwYXRoID0gZm9udC5nZXRQYXRoR2VuZXJhdG9yKHRoaXMuY29tbW9uT2JqcywgY2hhcmFjdGVyKTtcbiAgICB9XG4gICAgaWYgKHBhdGggJiYgKGZvbnQuZGlzYWJsZUZvbnRGYWNlIHx8IHBhdHRlcm5GaWxsIHx8IHBhdHRlcm5TdHJva2UpKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5zY2FsZShmb250U2l6ZSwgLWZvbnRTaXplKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZENoYXJhY3RlckJCb3gob3BJZHgsIGN0eCwgZm9udCk7XG4gICAgICBsZXQgY3VycmVudFRyYW5zZm9ybTtcbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgaWYgKHBhdHRlcm5GaWxsVHJhbnNmb3JtKSB7XG4gICAgICAgICAgY3VycmVudFRyYW5zZm9ybSA9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKC4uLnBhdHRlcm5GaWxsVHJhbnNmb3JtKTtcbiAgICAgICAgICBjb25zdCBzY2FsZWRQYXRoID0gdGhpcy4jZ2V0U2NhbGVkUGF0aChwYXRoLCBjdXJyZW50VHJhbnNmb3JtLCBwYXR0ZXJuRmlsbFRyYW5zZm9ybSk7XG4gICAgICAgICAgY3R4LmZpbGwoc2NhbGVkUGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmZpbGwocGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBpZiAocGF0dGVyblN0cm9rZVRyYW5zZm9ybSkge1xuICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0gfHw9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKC4uLnBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIGRcbiAgICAgICAgICB9ID0gY3VycmVudFRyYW5zZm9ybTtcbiAgICAgICAgICBjb25zdCBpbnZQYXR0ZXJuVHJhbnNmb3JtID0gVXRpbC5pbnZlcnNlVHJhbnNmb3JtKHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pO1xuICAgICAgICAgIGNvbnN0IHRyYW5zZiA9IFV0aWwudHJhbnNmb3JtKFthLCBiLCBjLCBkLCAwLCAwXSwgaW52UGF0dGVyblRyYW5zZm9ybSk7XG4gICAgICAgICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0cmFuc2YsIFhZKTtcbiAgICAgICAgICBjdHgubGluZVdpZHRoICo9IE1hdGgubWF4KFhZWzBdLCBYWVsxXSkgLyBmb250U2l6ZTtcbiAgICAgICAgICBjdHguc3Ryb2tlKHRoaXMuI2dldFNjYWxlZFBhdGgocGF0aCwgY3VycmVudFRyYW5zZm9ybSwgcGF0dGVyblN0cm9rZVRyYW5zZm9ybSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggLz0gZm9udFNpemU7XG4gICAgICAgICAgY3R4LnN0cm9rZShwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBjdHguZmlsbFRleHQoY2hhcmFjdGVyLCB4LCB5KTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2hhcmFjdGVyQkJveChvcElkeCwgY3R4LCBmb250LCBmb250U2l6ZSwgeCwgeSwgKCkgPT4gY3R4Lm1lYXN1cmVUZXh0KGNoYXJhY3RlcikpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGlmICh0aGlzLmRlcGVuZGVuY3lUcmFja2VyKSB7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2hhcmFjdGVyQkJveChvcElkeCwgY3R4LCBmb250LCBmb250U2l6ZSwgeCwgeSwgKCkgPT4gY3R4Lm1lYXN1cmVUZXh0KGNoYXJhY3RlcikpLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnN0cm9rZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZVRleHQoY2hhcmFjdGVyLCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQWRkVG9QYXRoU2V0KSB7XG4gICAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocyB8fD0gW107XG4gICAgICBwYXRocy5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBwYXRoXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZENoYXJhY3RlckJCb3gob3BJZHgsIGN0eCwgZm9udCwgZm9udFNpemUsIHgsIHkpO1xuICAgIH1cbiAgfVxuICBnZXQgaXNGb250U3VicGl4ZWxBQUVuYWJsZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dDogY3R4XG4gICAgfSA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWRcIiwgMTAsIDEwKTtcbiAgICBjdHguc2NhbGUoMS41LCAxKTtcbiAgICBjdHguZmlsbFRleHQoXCJJXCIsIDAsIDEwKTtcbiAgICBjb25zdCBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxMCwgMTApLmRhdGE7XG4gICAgbGV0IGVuYWJsZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMzsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGlmIChkYXRhW2ldID4gMCAmJiBkYXRhW2ldIDwgMjU1KSB7XG4gICAgICAgIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzRm9udFN1YnBpeGVsQUFFbmFibGVkXCIsIGVuYWJsZWQpO1xuICB9XG4gIHNob3dUZXh0KG9wSWR4LCBnbHlwaHMpIHtcbiAgICBpZiAodGhpcy5kZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlci5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy5zaG93VGV4dCkuY29weURlcGVuZGVuY2llc0Zyb21JbmNyZW1lbnRhbE9wZXJhdGlvbihvcElkeCwgXCJzYW1lTGluZVRleHRcIikucmVzZXRCQm94KG9wSWR4KTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiBUZXh0UmVuZGVyaW5nTW9kZS5BRERfVE9fUEFUSF9GTEFHKSB7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShcInRleHRDbGlwXCIsIG9wSWR4KS5pbmhlcml0UGVuZGluZ0RlcGVuZGVuY2llc0FzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBpZiAoZm9udC5pc1R5cGUzRm9udCkge1xuICAgICAgdGhpcy5zaG93VHlwZTNUZXh0KG9wSWR4LCBnbHlwaHMpO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkT3BlcmF0aW9uKG9wSWR4KS5yZWNvcmRJbmNyZW1lbnRhbERhdGEoXCJzYW1lTGluZVRleHRcIiwgb3BJZHgpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGlmIChmb250U2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZvbnRTaXplU2NhbGUgPSBjdXJyZW50LmZvbnRTaXplU2NhbGU7XG4gICAgY29uc3QgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgIGNvbnN0IHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICBjb25zdCBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IHRleHRIU2NhbGUgPSBjdXJyZW50LnRleHRIU2NhbGUgKiBmb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IGdseXBoc0xlbmd0aCA9IGdseXBocy5sZW5ndGg7XG4gICAgY29uc3QgdmVydGljYWwgPSBmb250LnZlcnRpY2FsO1xuICAgIGNvbnN0IHNwYWNpbmdEaXIgPSB2ZXJ0aWNhbCA/IDEgOiAtMTtcbiAgICBjb25zdCBkZWZhdWx0Vk1ldHJpY3MgPSBmb250LmRlZmF1bHRWTWV0cmljcztcbiAgICBjb25zdCB3aWR0aEFkdmFuY2VTY2FsZSA9IGZvbnRTaXplICogY3VycmVudC5mb250TWF0cml4WzBdO1xuICAgIGNvbnN0IHNpbXBsZUZpbGxUZXh0ID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTCAmJiAhZm9udC5kaXNhYmxlRm9udEZhY2UgJiYgIWN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAoY3VycmVudC50ZXh0TWF0cml4KSB7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLmN1cnJlbnQudGV4dE1hdHJpeCk7XG4gICAgfVxuICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkgKyBjdXJyZW50LnRleHRSaXNlKTtcbiAgICBpZiAoZm9udERpcmVjdGlvbiA+IDApIHtcbiAgICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCAtMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCAxKTtcbiAgICB9XG4gICAgbGV0IHBhdHRlcm5GaWxsVHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtO1xuICAgIGlmIChjdXJyZW50LnBhdHRlcm5GaWxsKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJlbnQuZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5GSUxMKTtcbiAgICAgIHBhdHRlcm5GaWxsVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudC5wYXR0ZXJuU3Ryb2tlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJlbnQuc3Ryb2tlQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLlNUUk9LRSk7XG4gICAgICBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHBhdHRlcm47XG4gICAgfVxuICAgIGxldCBsaW5lV2lkdGggPSBjdXJyZW50LmxpbmVXaWR0aDtcbiAgICBjb25zdCBzY2FsZSA9IGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlO1xuICAgIGlmIChzY2FsZSA9PT0gMCB8fCBsaW5lV2lkdGggPT09IDApIHtcbiAgICAgIGNvbnN0IGZpbGxTdHJva2VNb2RlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFX01BU0s7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgbGluZVdpZHRoID0gdGhpcy5nZXRTaW5nbGVQaXhlbFdpZHRoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVXaWR0aCAvPSBzY2FsZTtcbiAgICB9XG4gICAgaWYgKGZvbnRTaXplU2NhbGUgIT09IDEuMCkge1xuICAgICAgY3R4LnNjYWxlKGZvbnRTaXplU2NhbGUsIGZvbnRTaXplU2NhbGUpO1xuICAgICAgbGluZVdpZHRoIC89IGZvbnRTaXplU2NhbGU7XG4gICAgfVxuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgaWYgKGZvbnQuaXNJbnZhbGlkUERGanNGb250KSB7XG4gICAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgIGZvciAoY29uc3QgZ2x5cGggb2YgZ2x5cGhzKSB7XG4gICAgICAgIGNoYXJzLnB1c2goZ2x5cGgudW5pY29kZSk7XG4gICAgICAgIHdpZHRoICs9IGdseXBoLndpZHRoO1xuICAgICAgfVxuICAgICAgY29uc3Qgam9pbmVkQ2hhcnMgPSBjaGFycy5qb2luKFwiXCIpO1xuICAgICAgY3R4LmZpbGxUZXh0KGpvaW5lZENoYXJzLCAwLCAwKTtcbiAgICAgIGlmICh0aGlzLmRlcGVuZGVuY3lUcmFja2VyICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmUgPSBjdHgubWVhc3VyZVRleHQoam9pbmVkQ2hhcnMpO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyLnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCAtbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveExlZnQsIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hSaWdodCwgLW1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50KS5yZWNvcmRPcGVyYXRpb24ob3BJZHgpLnJlY29yZEluY3JlbWVudGFsRGF0YShcInNhbWVMaW5lVGV4dFwiLCBvcElkeCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50LnggKz0gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSAqIHRleHRIU2NhbGU7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy5jb21wb3NlKCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgeCA9IDAsXG4gICAgICBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHNMZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICBpZiAodHlwZW9mIGdseXBoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHggKz0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN0b3JlTmVlZGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBjaGFyYWN0ZXIgPSBnbHlwaC5mb250Q2hhcjtcbiAgICAgIGNvbnN0IGFjY2VudCA9IGdseXBoLmFjY2VudDtcbiAgICAgIGxldCBzY2FsZWRYLCBzY2FsZWRZO1xuICAgICAgbGV0IHdpZHRoID0gZ2x5cGgud2lkdGg7XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgY29uc3Qgdm1ldHJpYyA9IGdseXBoLnZtZXRyaWMgfHwgZGVmYXVsdFZNZXRyaWNzO1xuICAgICAgICBjb25zdCB2eCA9IC0oZ2x5cGgudm1ldHJpYyA/IHZtZXRyaWNbMV0gOiB3aWR0aCAqIDAuNSkgKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgY29uc3QgdnkgPSB2bWV0cmljWzJdICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIHdpZHRoID0gdm1ldHJpYyA/IC12bWV0cmljWzBdIDogd2lkdGg7XG4gICAgICAgIHNjYWxlZFggPSB2eCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIHNjYWxlZFkgPSAoeCArIHZ5KSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZWRYID0geCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIHNjYWxlZFkgPSAwO1xuICAgICAgfVxuICAgICAgbGV0IG1lYXN1cmU7XG4gICAgICBpZiAoZm9udC5yZW1lYXN1cmUgJiYgd2lkdGggPiAwKSB7XG4gICAgICAgIG1lYXN1cmUgPSBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKTtcbiAgICAgICAgY29uc3QgbWVhc3VyZWRXaWR0aCA9IG1lYXN1cmUud2lkdGggKiAxMDAwIC8gZm9udFNpemUgKiBmb250U2l6ZVNjYWxlO1xuICAgICAgICBpZiAod2lkdGggPCBtZWFzdXJlZFdpZHRoICYmIHRoaXMuaXNGb250U3VicGl4ZWxBQUVuYWJsZWQpIHtcbiAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJTY2FsZVggPSB3aWR0aCAvIG1lYXN1cmVkV2lkdGg7XG4gICAgICAgICAgcmVzdG9yZU5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBjdHguc2NhbGUoY2hhcmFjdGVyU2NhbGVYLCAxKTtcbiAgICAgICAgICBzY2FsZWRYIC89IGNoYXJhY3RlclNjYWxlWDtcbiAgICAgICAgfSBlbHNlIGlmICh3aWR0aCAhPT0gbWVhc3VyZWRXaWR0aCkge1xuICAgICAgICAgIHNjYWxlZFggKz0gKHdpZHRoIC0gbWVhc3VyZWRXaWR0aCkgLyAyMDAwICogZm9udFNpemUgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSAmJiAoZ2x5cGguaXNJbkZvbnQgfHwgZm9udC5taXNzaW5nRmlsZSkpIHtcbiAgICAgICAgaWYgKHNpbXBsZUZpbGxUZXh0ICYmICFhY2NlbnQpIHtcbiAgICAgICAgICBjdHguZmlsbFRleHQoY2hhcmFjdGVyLCBzY2FsZWRYLCBzY2FsZWRZKTtcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRDaGFyYWN0ZXJCQm94KG9wSWR4LCBjdHgsIG1lYXN1cmUgPyB7XG4gICAgICAgICAgICBiYm94OiBudWxsXG4gICAgICAgICAgfSA6IGZvbnQsIGZvbnRTaXplIC8gZm9udFNpemVTY2FsZSwgc2NhbGVkWCwgc2NhbGVkWSwgKCkgPT4gbWVhc3VyZSA/PyBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYWludENoYXIob3BJZHgsIGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pO1xuICAgICAgICAgIGlmIChhY2NlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZEFjY2VudFggPSBzY2FsZWRYICsgZm9udFNpemUgKiBhY2NlbnQub2Zmc2V0LnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkQWNjZW50WSA9IHNjYWxlZFkgLSBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICB0aGlzLnBhaW50Q2hhcihvcElkeCwgYWNjZW50LmZvbnRDaGFyLCBzY2FsZWRBY2NlbnRYLCBzY2FsZWRBY2NlbnRZLCBwYXR0ZXJuRmlsbFRyYW5zZm9ybSwgcGF0dGVyblN0cm9rZVRyYW5zZm9ybSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFyV2lkdGggPSB2ZXJ0aWNhbCA/IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgLSBzcGFjaW5nICogZm9udERpcmVjdGlvbiA6IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKyBzcGFjaW5nICogZm9udERpcmVjdGlvbjtcbiAgICAgIHggKz0gY2hhcldpZHRoO1xuICAgICAgaWYgKHJlc3RvcmVOZWVkZWQpIHtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICBjdXJyZW50LnkgLT0geDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC54ICs9IHggKiB0ZXh0SFNjYWxlO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZXJhdGlvbihvcElkeCkucmVjb3JkSW5jcmVtZW50YWxEYXRhKFwic2FtZUxpbmVUZXh0XCIsIG9wSWR4KTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHNob3dUeXBlM1RleHQob3BJZHgsIGdseXBocykge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemU7XG4gICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBzcGFjaW5nRGlyID0gZm9udC52ZXJ0aWNhbCA/IDEgOiAtMTtcbiAgICBjb25zdCBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgIGNvbnN0IHRleHRIU2NhbGUgPSBjdXJyZW50LnRleHRIU2NhbGUgKiBmb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IGZvbnRNYXRyaXggPSBjdXJyZW50LmZvbnRNYXRyaXggfHwgRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgY29uc3QgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICBjb25zdCBpc1RleHRJbnZpc2libGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5JTlZJU0lCTEU7XG4gICAgbGV0IGksIGdseXBoLCB3aWR0aCwgc3BhY2luZ0xlbmd0aDtcbiAgICBpZiAoaXNUZXh0SW52aXNpYmxlIHx8IGZvbnRTaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmIChjdXJyZW50LnRleHRNYXRyaXgpIHtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4uY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICB9XG4gICAgY3R4LnRyYW5zbGF0ZShjdXJyZW50LngsIGN1cnJlbnQueSArIGN1cnJlbnQudGV4dFJpc2UpO1xuICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCBmb250RGlyZWN0aW9uKTtcbiAgICBjb25zdCBkZXBlbmRlbmN5VHJhY2tlciA9IHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlciA9IGRlcGVuZGVuY3lUcmFja2VyID8gbmV3IENhbnZhc05lc3RlZERlcGVuZGVuY3lUcmFja2VyKGRlcGVuZGVuY3lUcmFja2VyLCBvcElkeCkgOiBudWxsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHNMZW5ndGg7ICsraSkge1xuICAgICAgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICBpZiAodHlwZW9mIGdseXBoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHNwYWNpbmdMZW5ndGggPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgIHRoaXMuY3R4LnRyYW5zbGF0ZShzcGFjaW5nTGVuZ3RoLCAwKTtcbiAgICAgICAgY3VycmVudC54ICs9IHNwYWNpbmdMZW5ndGggKiB0ZXh0SFNjYWxlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgIGNvbnN0IG9wZXJhdG9yTGlzdCA9IGZvbnQuY2hhclByb2NPcGVyYXRvckxpc3RbZ2x5cGgub3BlcmF0b3JMaXN0SWRdO1xuICAgICAgaWYgKCFvcGVyYXRvckxpc3QpIHtcbiAgICAgICAgd2FybihgVHlwZTMgY2hhcmFjdGVyIFwiJHtnbHlwaC5vcGVyYXRvckxpc3RJZH1cIiBpcyBub3QgYXZhaWxhYmxlLmApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICBjdHguc2NhbGUoZm9udFNpemUsIGZvbnRTaXplKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi5mb250TWF0cml4KTtcbiAgICAgICAgdGhpcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcCA9IFtnbHlwaC53aWR0aCwgMF07XG4gICAgICBVdGlsLmFwcGx5VHJhbnNmb3JtKHAsIGZvbnRNYXRyaXgpO1xuICAgICAgd2lkdGggPSBwWzBdICogZm9udFNpemUgKyBzcGFjaW5nO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCwgMCk7XG4gICAgICBjdXJyZW50LnggKz0gd2lkdGggKiB0ZXh0SFNjYWxlO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGlmIChkZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlci5yZWNvcmROZXN0ZWREZXBlbmRlbmNpZXMoKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgPSBkZXBlbmRlbmN5VHJhY2tlcjtcbiAgICB9XG4gIH1cbiAgc2V0Q2hhcldpZHRoKG9wSWR4LCB4V2lkdGgsIHlXaWR0aCkge31cbiAgc2V0Q2hhcldpZHRoQW5kQm91bmRzKG9wSWR4LCB4V2lkdGgsIHlXaWR0aCwgbGx4LCBsbHksIHVyeCwgdXJ5KSB7XG4gICAgY29uc3QgY2xpcCA9IG5ldyBQYXRoMkQoKTtcbiAgICBjbGlwLnJlY3QobGx4LCBsbHksIHVyeCAtIGxseCwgdXJ5IC0gbGx5KTtcbiAgICB0aGlzLmN0eC5jbGlwKGNsaXApO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCBsbHgsIHVyeCwgbGx5LCB1cnkpLnJlY29yZENsaXBCb3gob3BJZHgsIHRoaXMuY3R4LCBsbHgsIHVyeCwgbGx5LCB1cnkpO1xuICAgIHRoaXMuZW5kUGF0aChvcElkeCk7XG4gIH1cbiAgZ2V0Q29sb3JOX1BhdHRlcm4ob3BJZHgsIElSKSB7XG4gICAgbGV0IHBhdHRlcm47XG4gICAgaWYgKElSWzBdID09PSBcIlRpbGluZ1BhdHRlcm5cIikge1xuICAgICAgY29uc3QgYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybSB8fCBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICAgIGNvbnN0IGNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IHtcbiAgICAgICAgY3JlYXRlQ2FudmFzR3JhcGhpY3M6IGN0eCA9PiBuZXcgQ2FudmFzR3JhcGhpY3MoY3R4LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLmZpbHRlckZhY3RvcnksIHtcbiAgICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWc6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgICAgICAgIG1hcmtlZENvbnRlbnRTdGFjazogdGhpcy5tYXJrZWRDb250ZW50U3RhY2tcbiAgICAgICAgfSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgPyBuZXcgQ2FudmFzTmVzdGVkRGVwZW5kZW5jeVRyYWNrZXIodGhpcy5kZXBlbmRlbmN5VHJhY2tlciwgb3BJZHgpIDogbnVsbClcbiAgICAgIH07XG4gICAgICBwYXR0ZXJuID0gbmV3IFRpbGluZ1BhdHRlcm4oSVIsIHRoaXMuY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihvcElkeCwgSVJbMV0sIElSWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgc2V0U3Ryb2tlQ29sb3JOKG9wSWR4LCAuLi5hcmdzKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInN0cm9rZUNvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKG9wSWR4LCBhcmdzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVyblN0cm9rZSA9IHRydWU7XG4gIH1cbiAgc2V0RmlsbENvbG9yTihvcElkeCwgLi4uYXJncykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJmaWxsQ29sb3JcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKG9wSWR4LCBhcmdzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSB0cnVlO1xuICB9XG4gIHNldFN0cm9rZVJHQkNvbG9yKG9wSWR4LCBjb2xvcikge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJzdHJva2VDb2xvclwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVyblN0cm9rZSA9IGZhbHNlO1xuICB9XG4gIHNldFN0cm9rZVRyYW5zcGFyZW50KG9wSWR4KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInN0cm9rZUNvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVyblN0cm9rZSA9IGZhbHNlO1xuICB9XG4gIHNldEZpbGxSR0JDb2xvcihvcElkeCwgY29sb3IpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZmlsbENvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gY29sb3I7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gIH1cbiAgc2V0RmlsbFRyYW5zcGFyZW50KG9wSWR4KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImZpbGxDb2xvclwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgfVxuICBfZ2V0UGF0dGVybihvcElkeCwgb2JqSWQsIG1hdHJpeCA9IG51bGwpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAodGhpcy5jYWNoZWRQYXR0ZXJucy5oYXMob2JqSWQpKSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5jYWNoZWRQYXR0ZXJucy5nZXQob2JqSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gZ2V0U2hhZGluZ1BhdHRlcm4odGhpcy5nZXRPYmplY3Qob3BJZHgsIG9iaklkKSk7XG4gICAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLnNldChvYmpJZCwgcGF0dGVybik7XG4gICAgfVxuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHBhdHRlcm4ubWF0cml4ID0gbWF0cml4O1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBzaGFkaW5nRmlsbChvcElkeCwgb2JqSWQpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5zYXZlKG9wSWR4KTtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihvcElkeCwgb2JqSWQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5TSEFESU5HKTtcbiAgICBjb25zdCBpbnYgPSBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpO1xuICAgIGlmIChpbnYpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IGN0eC5jYW52YXM7XG4gICAgICBjb25zdCBtaW5NYXggPSBNSU5fTUFYX0lOSVQuc2xpY2UoKTtcbiAgICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdLCBpbnYsIG1pbk1heCk7XG4gICAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gbWluTWF4O1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoLTFlMTAsIC0xZTEwLCAyZTEwLCAyZTEwKTtcbiAgICB9XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KS5yZWNvcmRGdWxsUGFnZUJCb3gob3BJZHgpLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnRyYW5zZm9ybSkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMuZmlsbCkucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgICB0aGlzLmNvbXBvc2UodGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5yZXN0b3JlKG9wSWR4KTtcbiAgfVxuICBiZWdpbklubGluZUltYWdlKCkge1xuICAgIHVucmVhY2hhYmxlKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW5saW5lSW1hZ2VcIik7XG4gIH1cbiAgYmVnaW5JbWFnZURhdGEoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJTaG91bGQgbm90IGNhbGwgYmVnaW5JbWFnZURhdGFcIik7XG4gIH1cbiAgcGFpbnRGb3JtWE9iamVjdEJlZ2luKG9wSWR4LCBtYXRyaXgsIGJib3gpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zYXZlKG9wSWR4KTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wdXNoKHRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgdGhpcy50cmFuc2Zvcm0ob3BJZHgsIC4uLm1hdHJpeCk7XG4gICAgfVxuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICAgIGlmIChiYm94KSB7XG4gICAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KGJib3gsIHRoaXMuYmFzZVRyYW5zZm9ybSwgdGhpcy5jdXJyZW50Lm1pbk1heCk7XG4gICAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gYmJveDtcbiAgICAgIGNvbnN0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgICBjbGlwLnJlY3QoeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcbiAgICAgIHRoaXMuY3R4LmNsaXAoY2xpcCk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRDbGlwQm94KG9wSWR4LCB0aGlzLmN0eCwgeDAsIHgxLCB5MCwgeTEpO1xuICAgICAgdGhpcy5lbmRQYXRoKG9wSWR4KTtcbiAgICB9XG4gIH1cbiAgcGFpbnRGb3JtWE9iamVjdEVuZChvcElkeCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlc3RvcmUob3BJZHgpO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuICB9XG4gIGJlZ2luR3JvdXAob3BJZHgsIGdyb3VwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2F2ZShvcElkeCk7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMuZW5kU01hc2tNb2RlKCk7XG4gICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50Q3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKCFncm91cC5pc29sYXRlZCkge1xuICAgICAgaW5mbyhcIlRPRE86IFN1cHBvcnQgbm9uLWlzb2xhdGVkIGdyb3Vwcy5cIik7XG4gICAgfVxuICAgIGlmIChncm91cC5rbm9ja291dCkge1xuICAgICAgd2FybihcIktub2Nrb3V0IGdyb3VwcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3VycmVudEN0eCk7XG4gICAgaWYgKGdyb3VwLm1hdHJpeCkge1xuICAgICAgY3VycmVudEN0eC50cmFuc2Zvcm0oLi4uZ3JvdXAubWF0cml4KTtcbiAgICB9XG4gICAgaWYgKCFncm91cC5iYm94KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3VuZGluZyBib3ggaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBsZXQgYm91bmRzID0gTUlOX01BWF9JTklULnNsaWNlKCk7XG4gICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChncm91cC5iYm94LCBnZXRDdXJyZW50VHJhbnNmb3JtKGN1cnJlbnRDdHgpLCBib3VuZHMpO1xuICAgIGNvbnN0IGNhbnZhc0JvdW5kcyA9IFswLCAwLCBjdXJyZW50Q3R4LmNhbnZhcy53aWR0aCwgY3VycmVudEN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICBib3VuZHMgPSBVdGlsLmludGVyc2VjdChib3VuZHMsIGNhbnZhc0JvdW5kcykgfHwgWzAsIDAsIDAsIDBdO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmZsb29yKGJvdW5kc1swXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IoYm91bmRzWzFdKTtcbiAgICBjb25zdCBkcmF3bldpZHRoID0gTWF0aC5tYXgoTWF0aC5jZWlsKGJvdW5kc1syXSkgLSBvZmZzZXRYLCAxKTtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbM10pIC0gb2Zmc2V0WSwgMSk7XG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3goWzAsIDAsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0XSk7XG4gICAgbGV0IGNhY2hlSWQgPSBcImdyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIGNhY2hlSWQgKz0gXCJfc21hc2tfXCIgKyB0aGlzLnNtYXNrQ291bnRlcisrICUgMjtcbiAgICB9XG4gICAgY29uc3Qgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBncm91cEN0eCA9IHNjcmF0Y2hDYW52YXMuY29udGV4dDtcbiAgICBncm91cEN0eC50cmFuc2xhdGUoLW9mZnNldFgsIC1vZmZzZXRZKTtcbiAgICBncm91cEN0eC50cmFuc2Zvcm0oLi4uY3VycmVudFRyYW5zZm9ybSk7XG4gICAgbGV0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IGdyb3VwLmJib3g7XG4gICAgY2xpcC5yZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgaWYgKGdyb3VwLm1hdHJpeCkge1xuICAgICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHBhdGguYWRkUGF0aChjbGlwLCBuZXcgRE9NTWF0cml4KGdyb3VwLm1hdHJpeCkpO1xuICAgICAgY2xpcCA9IHBhdGg7XG4gICAgfVxuICAgIGdyb3VwQ3R4LmNsaXAoY2xpcCk7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnNtYXNrU3RhY2sucHVzaCh7XG4gICAgICAgIGNhbnZhczogc2NyYXRjaENhbnZhcy5jYW52YXMsXG4gICAgICAgIGNvbnRleHQ6IGdyb3VwQ3R4LFxuICAgICAgICBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZLFxuICAgICAgICBzdWJ0eXBlOiBncm91cC5zbWFzay5zdWJ0eXBlLFxuICAgICAgICBiYWNrZHJvcDogZ3JvdXAuc21hc2suYmFja2Ryb3AsXG4gICAgICAgIHRyYW5zZmVyTWFwOiBncm91cC5zbWFzay50cmFuc2Zlck1hcCB8fCBudWxsLFxuICAgICAgICBzdGFydFRyYW5zZm9ybUludmVyc2U6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWdyb3VwLnNtYXNrIHx8IHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICAgIGN1cnJlbnRDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY3VycmVudEN0eC50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICBjdXJyZW50Q3R4LnNhdmUoKTtcbiAgICB9XG4gICAgY29weUN0eFN0YXRlKGN1cnJlbnRDdHgsIGdyb3VwQ3R4KTtcbiAgICB0aGlzLmN0eCA9IGdyb3VwQ3R4O1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LmluaGVyaXRTaW1wbGVEYXRhQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMoW1wiZmlsbEFscGhhXCIsIFwic3Ryb2tlQWxwaGFcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIl0pLnB1c2hCYXNlVHJhbnNmb3JtKGN1cnJlbnRDdHgpO1xuICAgIHRoaXMuc2V0R1N0YXRlKG9wSWR4LCBbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXSwgW1wiY2FcIiwgMV0sIFtcIkNBXCIsIDFdXSk7XG4gICAgdGhpcy5ncm91cFN0YWNrLnB1c2goY3VycmVudEN0eCk7XG4gICAgdGhpcy5ncm91cExldmVsKys7XG4gIH1cbiAgZW5kR3JvdXAob3BJZHgsIGdyb3VwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ3JvdXBMZXZlbC0tO1xuICAgIGNvbnN0IGdyb3VwQ3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5ncm91cFN0YWNrLnBvcCgpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnBvcEJhc2VUcmFuc2Zvcm0oKTtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIHRoaXMudGVtcFNNYXNrID0gdGhpcy5zbWFza1N0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5yZXN0b3JlKG9wSWR4KTtcbiAgICAgIGlmICh0aGlzLmRlcGVuZGVuY3lUcmFja2VyKSB7XG4gICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgY29uc3QgY3VycmVudE10eCA9IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICAgICAgdGhpcy5yZXN0b3JlKG9wSWR4KTtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSguLi5jdXJyZW50TXR4KTtcbiAgICAgIGNvbnN0IGRpcnR5Qm94ID0gTUlOX01BWF9JTklULnNsaWNlKCk7XG4gICAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCBncm91cEN0eC5jYW52YXMud2lkdGgsIGdyb3VwQ3R4LmNhbnZhcy5oZWlnaHRdLCBjdXJyZW50TXR4LCBkaXJ0eUJveCk7XG4gICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoZ3JvdXBDdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZShkaXJ0eUJveCk7XG4gICAgfVxuICB9XG4gIGJlZ2luQW5ub3RhdGlvbihvcElkeCwgaWQsIHJlY3QsIHRyYW5zZm9ybSwgbWF0cml4LCBoYXNPd25DYW52YXMpIHtcbiAgICB0aGlzLiNyZXN0b3JlSW5pdGlhbFN0YXRlKCk7XG4gICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB0aGlzLnNhdmUob3BJZHgpO1xuICAgIGlmICh0aGlzLmJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSguLi50aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAocmVjdCkge1xuICAgICAgY29uc3Qgd2lkdGggPSByZWN0WzJdIC0gcmVjdFswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHJlY3RbM10gLSByZWN0WzFdO1xuICAgICAgaWYgKGhhc093bkNhbnZhcyAmJiB0aGlzLmFubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtLnNsaWNlKCk7XG4gICAgICAgIHRyYW5zZm9ybVs0XSAtPSByZWN0WzBdO1xuICAgICAgICB0cmFuc2Zvcm1bNV0gLT0gcmVjdFsxXTtcbiAgICAgICAgcmVjdCA9IHJlY3Quc2xpY2UoKTtcbiAgICAgICAgcmVjdFswXSA9IHJlY3RbMV0gPSAwO1xuICAgICAgICByZWN0WzJdID0gd2lkdGg7XG4gICAgICAgIHJlY3RbM10gPSBoZWlnaHQ7XG4gICAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUoZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCksIFhZKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHZpZXdwb3J0U2NhbGVcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogdGhpcy5vdXRwdXRTY2FsZVggKiB2aWV3cG9ydFNjYWxlKTtcbiAgICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIHRoaXMub3V0cHV0U2NhbGVZICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhcyA9IHRoaXMuY2FudmFzRmFjdG9yeS5jcmVhdGUoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9ID0gdGhpcy5hbm5vdGF0aW9uQ2FudmFzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAuc2V0KGlkLCBjYW52YXMpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHggPSB0aGlzLmN0eDtcbiAgICAgICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybShYWVswXSwgMCwgMCwgLVhZWzFdLCAwLCBoZWlnaHQgKiBYWVsxXSk7XG4gICAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy5lbmRQYXRoKG9wSWR4KTtcbiAgICAgICAgY29uc3QgY2xpcCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgY2xpcC5yZWN0KHJlY3RbMF0sIHJlY3RbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmN0eC5jbGlwKGNsaXApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSh0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMudHJhbnNmb3JtKG9wSWR4LCAuLi50cmFuc2Zvcm0pO1xuICAgIHRoaXMudHJhbnNmb3JtKG9wSWR4LCAuLi5tYXRyaXgpO1xuICB9XG4gIGVuZEFubm90YXRpb24ob3BJZHgpIHtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uQ2FudmFzKSB7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLiNkcmF3RmlsdGVyKCk7XG4gICAgICB0aGlzLmN0eCA9IHRoaXMuYW5ub3RhdGlvbkNhbnZhcy5zYXZlZEN0eDtcbiAgICAgIGRlbGV0ZSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzO1xuICAgIH1cbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3Qob3BJZHgsIGltZykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb3VudCA9IGltZy5jb3VudDtcbiAgICBpbWcgPSB0aGlzLmdldE9iamVjdChvcElkeCwgaW1nLmRhdGEsIGltZyk7XG4gICAgaW1nLmNvdW50ID0gY291bnQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgbWFzayA9IHRoaXMuX2NyZWF0ZU1hc2tDYW52YXMob3BJZHgsIGltZyk7XG4gICAgY29uc3QgbWFza0NhbnZhcyA9IG1hc2suY2FudmFzO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBjdHguZHJhd0ltYWdlKG1hc2tDYW52YXMsIG1hc2sub2Zmc2V0WCwgbWFzay5vZmZzZXRZKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXNldEJCb3gob3BJZHgpLnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCBtYXNrLm9mZnNldFgsIG1hc2sub2Zmc2V0WCArIG1hc2tDYW52YXMud2lkdGgsIG1hc2sub2Zmc2V0WSwgbWFzay5vZmZzZXRZICsgbWFza0NhbnZhcy5oZWlnaHQpLnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQob3BJZHgsIGltZywgc2NhbGVYLCBza2V3WCA9IDAsIHNrZXdZID0gMCwgc2NhbGVZLCBwb3NpdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW1nID0gdGhpcy5nZXRPYmplY3Qob3BJZHgsIGltZy5kYXRhLCBpbWcpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICBjdHgudHJhbnNmb3JtKHNjYWxlWCwgc2tld1gsIHNrZXdZLCBzY2FsZVksIDAsIDApO1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKG9wSWR4LCBpbWcpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgbWFzay5vZmZzZXRYIC0gY3VycmVudFRyYW5zZm9ybVs0XSwgbWFzay5vZmZzZXRZIC0gY3VycmVudFRyYW5zZm9ybVs1XSk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgY29uc3QgdHJhbnMgPSBVdGlsLnRyYW5zZm9ybShjdXJyZW50VHJhbnNmb3JtLCBbc2NhbGVYLCBza2V3WCwgc2tld1ksIHNjYWxlWSwgcG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdXSk7XG4gICAgICBjdHguZHJhd0ltYWdlKG1hc2suY2FudmFzLCB0cmFuc1s0XSwgdHJhbnNbNV0pO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQkJveChvcElkeCwgdGhpcy5jdHgsIHRyYW5zWzRdLCB0cmFuc1s0XSArIG1hc2suY2FudmFzLndpZHRoLCB0cmFuc1s1XSwgdHJhbnNbNV0gKyBtYXNrLmNhbnZhcy5oZWlnaHQpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXAob3BJZHgsIGltYWdlcykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KS5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy50cmFuc2Zvcm1BbmRGaWxsKTtcbiAgICBmb3IgKGNvbnN0IGltYWdlIG9mIGltYWdlcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB0cmFuc2Zvcm1cbiAgICAgIH0gPSBpbWFnZTtcbiAgICAgIGNvbnN0IG1hc2tDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tDYW52YXNcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBtYXNrQ3R4ID0gbWFza0NhbnZhcy5jb250ZXh0O1xuICAgICAgbWFza0N0eC5zYXZlKCk7XG4gICAgICBjb25zdCBpbWcgPSB0aGlzLmdldE9iamVjdChvcElkeCwgZGF0YSwgaW1hZ2UpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDdHgsIGltZyk7XG4gICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihtYXNrQ3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5GSUxMKSA6IGZpbGxDb2xvcjtcbiAgICAgIG1hc2tDdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBtYXNrQ3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgbWFza0NhbnZhcy5jYW52YXMsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIC0xLCAxLCAxKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEJCb3gob3BJZHgsIGN0eCwgMCwgd2lkdGgsIDAsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICB9XG4gIHBhaW50SW1hZ2VYT2JqZWN0KG9wSWR4LCBvYmpJZCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob3BJZHgsIG9iaklkKTtcbiAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgIHdhcm4oXCJEZXBlbmRlbnQgaW1hZ2UgaXNuJ3QgcmVhZHkgeWV0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KG9wSWR4LCBpbWdEYXRhKTtcbiAgfVxuICBwYWludEltYWdlWE9iamVjdFJlcGVhdChvcElkeCwgb2JqSWQsIHNjYWxlWCwgc2NhbGVZLCBwb3NpdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW1nRGF0YSA9IHRoaXMuZ2V0T2JqZWN0KG9wSWR4LCBvYmpJZCk7XG4gICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICB3YXJuKFwiRGVwZW5kZW50IGltYWdlIGlzbid0IHJlYWR5IHlldFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgIGNvbnN0IG1hcCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBtYXAucHVzaCh7XG4gICAgICAgIHRyYW5zZm9ybTogW3NjYWxlWCwgMCwgMCwgc2NhbGVZLCBwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV1dLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgaDogaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdEdyb3VwKG9wSWR4LCBpbWdEYXRhLCBtYXApO1xuICB9XG4gIGFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXMoY3R4KSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHMgIT09IFwibm9uZVwiKSB7XG4gICAgICBjdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcztcbiAgICAgIGN0eC5kcmF3SW1hZ2UoY3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgfVxuICAgIHJldHVybiBjdHguY2FudmFzO1xuICB9XG4gIGFwcGx5VHJhbnNmZXJNYXBzVG9CaXRtYXAoaW1nRGF0YSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzID09PSBcIm5vbmVcIikge1xuICAgICAgcmV0dXJuIGltZ0RhdGEuYml0bWFwO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBiaXRtYXAsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWdEYXRhO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgdG1wQ3R4LmZpbHRlciA9IHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHM7XG4gICAgdG1wQ3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApO1xuICAgIHRtcEN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICByZXR1cm4gdG1wQ2FudmFzLmNhbnZhcztcbiAgfVxuICBwYWludElubGluZUltYWdlWE9iamVjdChvcElkeCwgaW1nRGF0YSkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5zYXZlKG9wSWR4KTtcbiAgICBjb25zdCB7XG4gICAgICBmaWx0ZXJcbiAgICB9ID0gY3R4O1xuICAgIGlmIChmaWx0ZXIgIT09IFwibm9uZVwiICYmIGZpbHRlciAhPT0gXCJcIikge1xuICAgICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIH1cbiAgICBjdHguc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgbGV0IGltZ1RvUGFpbnQ7XG4gICAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwKGltZ0RhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgaW1nRGF0YSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8ICFpbWdEYXRhLmRhdGEpIHtcbiAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhKTtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXModG1wQ3R4KTtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVkID0gdGhpcy5fc2NhbGVJbWFnZShpbWdUb1BhaW50LCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpKTtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSwgaW1nRGF0YS5pbnRlcnBvbGF0ZSk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KS5yZWNvcmRCQm94KG9wSWR4LCBjdHgsIDAsIHdpZHRoLCAtaGVpZ2h0LCAwKS5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy5pbWFnZVhPYmplY3QpLnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgc2NhbGVkLmltZywgMCwgMCwgc2NhbGVkLnBhaW50V2lkdGgsIHNjYWxlZC5wYWludEhlaWdodCwgMCwgLWhlaWdodCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gICAgdGhpcy5yZXN0b3JlKG9wSWR4KTtcbiAgfVxuICBwYWludElubGluZUltYWdlWE9iamVjdEdyb3VwKG9wSWR4LCBpbWdEYXRhLCBtYXApIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgbGV0IGltZ1RvUGFpbnQ7XG4gICAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgICBpbWdUb1BhaW50ID0gaW1nRGF0YS5iaXRtYXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHcgPSBpbWdEYXRhLndpZHRoO1xuICAgICAgY29uc3QgaCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3LCBoKTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgcHV0QmluYXJ5SW1hZ2VEYXRhKHRtcEN0eCwgaW1nRGF0YSk7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKHRtcEN0eCk7XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCk7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBtYXApIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLmVudHJ5LnRyYW5zZm9ybSk7XG4gICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgaW1nVG9QYWludCwgZW50cnkueCwgZW50cnkueSwgZW50cnkudywgZW50cnkuaCwgMCwgLTEsIDEsIDEpO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQkJveChvcElkeCwgY3R4LCAwLCAxLCAtMSwgMCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50U29saWRDb2xvckltYWdlTWFzayhvcElkeCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXNldEJCb3gob3BJZHgpLnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCAwLCAxLCAwLCAxKS5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy5maWxsKS5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIG1hcmtQb2ludChvcElkeCwgdGFnKSB7fVxuICBtYXJrUG9pbnRQcm9wcyhvcElkeCwgdGFnLCBwcm9wZXJ0aWVzKSB7fVxuICBiZWdpbk1hcmtlZENvbnRlbnQob3BJZHgsIHRhZykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LmJlZ2luTWFya2VkQ29udGVudChvcElkeCk7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICB2aXNpYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgYmVnaW5NYXJrZWRDb250ZW50UHJvcHMob3BJZHgsIHRhZywgcHJvcGVydGllcykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LmJlZ2luTWFya2VkQ29udGVudChvcElkeCk7XG4gICAgaWYgKHRhZyA9PT0gXCJPQ1wiKSB7XG4gICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgdmlzaWJsZTogdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcuaXNWaXNpYmxlKHByb3BlcnRpZXMpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gIH1cbiAgZW5kTWFya2VkQ29udGVudChvcElkeCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LmVuZE1hcmtlZENvbnRlbnQob3BJZHgpO1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnBvcCgpO1xuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0aGlzLmlzQ29udGVudFZpc2libGUoKTtcbiAgfVxuICBiZWdpbkNvbXBhdChvcElkeCkge31cbiAgZW5kQ29tcGF0KG9wSWR4KSB7fVxuICBjb25zdW1lUGF0aChvcElkeCwgcGF0aCwgY2xpcEJveCkge1xuICAgIGNvbnN0IGlzRW1wdHkgPSB0aGlzLmN1cnJlbnQuaXNFbXB0eUNsaXAoKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgdGhpcy5jdXJyZW50LnVwZGF0ZUNsaXBGcm9tUGF0aCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIHRoaXMuY29tcG9zZShjbGlwQm94KTtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCA9PT0gRU9fQ0xJUCkge1xuICAgICAgICAgIGN0eC5jbGlwKHBhdGgsIFwiZXZlbm9kZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHguY2xpcChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5iYm94VG9DbGlwQm94RHJvcE9wZXJhdGlvbihvcElkeCkucmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShcImNsaXBQYXRoXCIsIG9wSWR4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3godGhpcy5jdXJyZW50LmNsaXBCb3gpO1xuICB9XG4gIGdldFNpbmdsZVBpeGVsV2lkdGgoKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoKSB7XG4gICAgICBjb25zdCBtID0gZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gICAgICBpZiAobVsxXSA9PT0gMCAmJiBtWzJdID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSAxIC8gTWF0aC5taW4oTWF0aC5hYnMobVswXSksIE1hdGguYWJzKG1bM10pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFic0RldCA9IE1hdGguYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pO1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguaHlwb3QobVswXSwgbVsyXSk7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5oeXBvdChtWzFdLCBtWzNdKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IE1hdGgubWF4KG5vcm1YLCBub3JtWSkgLyBhYnNEZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoO1xuICB9XG4gIGdldFNjYWxlRm9yU3Ryb2tpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPT09IC0xKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxpbmVXaWR0aFxuICAgICAgfSA9IHRoaXMuY3VycmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYSxcbiAgICAgICAgYixcbiAgICAgICAgYyxcbiAgICAgICAgZFxuICAgICAgfSA9IHRoaXMuY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgbGV0IHNjYWxlWCwgc2NhbGVZO1xuICAgICAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMCkge1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguYWJzKGEpO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguYWJzKGQpO1xuICAgICAgICBpZiAobm9ybVggPT09IG5vcm1ZKSB7XG4gICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gMSAvIG5vcm1YO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRMaW5lV2lkdGggPSBub3JtWCAqIGxpbmVXaWR0aDtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IHNjYWxlZExpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkTGluZVdpZHRoIDogMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gMSAvIG5vcm1YO1xuICAgICAgICAgIHNjYWxlWSA9IDEgLyBub3JtWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzY2FsZWRYTGluZVdpZHRoID0gbm9ybVggKiBsaW5lV2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkWUxpbmVXaWR0aCA9IG5vcm1ZICogbGluZVdpZHRoO1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlZFhMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFhMaW5lV2lkdGggOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IHNjYWxlZFlMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFlMaW5lV2lkdGggOiAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhhICogZCAtIGIgKiBjKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KGEsIGIpO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QoYywgZCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICBzY2FsZVggPSBub3JtWSAvIGFic0RldDtcbiAgICAgICAgICBzY2FsZVkgPSBub3JtWCAvIGFic0RldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBiYXNlQXJlYSA9IGxpbmVXaWR0aCAqIGFic0RldDtcbiAgICAgICAgICBzY2FsZVggPSBub3JtWSA+IGJhc2VBcmVhID8gbm9ybVkgLyBiYXNlQXJlYSA6IDE7XG4gICAgICAgICAgc2NhbGVZID0gbm9ybVggPiBiYXNlQXJlYSA/IG5vcm1YIC8gYmFzZUFyZWEgOiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gc2NhbGVYO1xuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1sxXSA9IHNjYWxlWTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmc7XG4gIH1cbiAgcmVzY2FsZUFuZFN0cm9rZShwYXRoLCBzYXZlUmVzdG9yZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eCxcbiAgICAgIGN1cnJlbnQ6IHtcbiAgICAgICAgbGluZVdpZHRoXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgW3NjYWxlWCwgc2NhbGVZXSA9IHRoaXMuZ2V0U2NhbGVGb3JTdHJva2luZygpO1xuICAgIGlmIChzY2FsZVggPT09IHNjYWxlWSkge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IChsaW5lV2lkdGggfHwgMSkgKiBzY2FsZVg7XG4gICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXNoZXMgPSBjdHguZ2V0TGluZURhc2goKTtcbiAgICBpZiAoc2F2ZVJlc3RvcmUpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgU0NBTEVfTUFUUklYLmEgPSAxIC8gc2NhbGVYO1xuICAgIFNDQUxFX01BVFJJWC5kID0gMSAvIHNjYWxlWTtcbiAgICBjb25zdCBuZXdQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBTQ0FMRV9NQVRSSVgpO1xuICAgIGlmIChkYXNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XG4gICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzLm1hcCh4ID0+IHggLyBzY2FsZSkpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0IC89IHNjYWxlO1xuICAgIH1cbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIHx8IDE7XG4gICAgY3R4LnN0cm9rZShuZXdQYXRoKTtcbiAgICBpZiAoc2F2ZVJlc3RvcmUpIHtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGlzQ29udGVudFZpc2libGUoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMubWFya2VkQ29udGVudFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoIXRoaXMubWFya2VkQ29udGVudFN0YWNrW2ldLnZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZm9yIChjb25zdCBvcCBpbiBPUFMpIHtcbiAgaWYgKENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgIENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtPUFNbb3BdXSA9IENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtvcF07XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvd29ya2VyX29wdGlvbnMuanNcbmNsYXNzIEdsb2JhbFdvcmtlck9wdGlvbnMge1xuICBzdGF0aWMgI3BvcnQgPSBudWxsO1xuICBzdGF0aWMgI3NyYyA9IFwiXCI7XG4gIHN0YXRpYyBnZXQgd29ya2VyUG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9ydDtcbiAgfVxuICBzdGF0aWMgc2V0IHdvcmtlclBvcnQodmFsKSB7XG4gICAgaWYgKCEodHlwZW9mIFdvcmtlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgaW5zdGFuY2VvZiBXb3JrZXIpICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBgd29ya2VyUG9ydGAgdHlwZS5cIik7XG4gICAgfVxuICAgIHRoaXMuI3BvcnQgPSB2YWw7XG4gIH1cbiAgc3RhdGljIGdldCB3b3JrZXJTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NyYztcbiAgfVxuICBzdGF0aWMgc2V0IHdvcmtlclNyYyh2YWwpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBgd29ya2VyU3JjYCB0eXBlLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jc3JjID0gdmFsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L21ldGFkYXRhLmpzXG5jbGFzcyBNZXRhZGF0YSB7XG4gICNtYXA7XG4gICNkYXRhO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFyc2VkRGF0YSxcbiAgICByYXdEYXRhXG4gIH0pIHtcbiAgICB0aGlzLiNtYXAgPSBwYXJzZWREYXRhO1xuICAgIHRoaXMuI2RhdGEgPSByYXdEYXRhO1xuICB9XG4gIGdldFJhdygpIHtcbiAgICByZXR1cm4gdGhpcy4jZGF0YTtcbiAgfVxuICBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNtYXAuZ2V0KG5hbWUpID8/IG51bGw7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hcC5lbnRyaWVzKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvb3B0aW9uYWxfY29udGVudF9jb25maWcuanNcblxuXG5jb25zdCBJTlRFUk5BTCA9IFN5bWJvbChcIklOVEVSTkFMXCIpO1xuY2xhc3MgT3B0aW9uYWxDb250ZW50R3JvdXAge1xuICAjaXNEaXNwbGF5ID0gZmFsc2U7XG4gICNpc1ByaW50ID0gZmFsc2U7XG4gICN1c2VyU2V0ID0gZmFsc2U7XG4gICN2aXNpYmxlID0gdHJ1ZTtcbiAgY29uc3RydWN0b3IocmVuZGVyaW5nSW50ZW50LCB7XG4gICAgbmFtZSxcbiAgICBpbnRlbnQsXG4gICAgdXNhZ2UsXG4gICAgcmJHcm91cHNcbiAgfSkge1xuICAgIHRoaXMuI2lzRGlzcGxheSA9ICEhKHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWSk7XG4gICAgdGhpcy4jaXNQcmludCA9ICEhKHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5pbnRlbnQgPSBpbnRlbnQ7XG4gICAgdGhpcy51c2FnZSA9IHVzYWdlO1xuICAgIHRoaXMucmJHcm91cHMgPSByYkdyb3VwcztcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICBpZiAodGhpcy4jdXNlclNldCkge1xuICAgICAgcmV0dXJuIHRoaXMuI3Zpc2libGU7XG4gICAgfVxuICAgIGlmICghdGhpcy4jdmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwcmludCxcbiAgICAgIHZpZXdcbiAgICB9ID0gdGhpcy51c2FnZTtcbiAgICBpZiAodGhpcy4jaXNEaXNwbGF5KSB7XG4gICAgICByZXR1cm4gdmlldz8udmlld1N0YXRlICE9PSBcIk9GRlwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jaXNQcmludCkge1xuICAgICAgcmV0dXJuIHByaW50Py5wcmludFN0YXRlICE9PSBcIk9GRlwiO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc2V0VmlzaWJsZShpbnRlcm5hbCwgdmlzaWJsZSwgdXNlclNldCA9IGZhbHNlKSB7XG4gICAgaWYgKGludGVybmFsICE9PSBJTlRFUk5BTCkge1xuICAgICAgdW5yZWFjaGFibGUoXCJJbnRlcm5hbCBtZXRob2QgYF9zZXRWaXNpYmxlYCBjYWxsZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLiN1c2VyU2V0ID0gdXNlclNldDtcbiAgICB0aGlzLiN2aXNpYmxlID0gdmlzaWJsZTtcbiAgfVxufVxuY2xhc3MgT3B0aW9uYWxDb250ZW50Q29uZmlnIHtcbiAgI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICAjZ3JvdXBzID0gbmV3IE1hcCgpO1xuICAjaW5pdGlhbEhhc2ggPSBudWxsO1xuICAjb3JkZXIgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihkYXRhLCByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVkpIHtcbiAgICB0aGlzLnJlbmRlcmluZ0ludGVudCA9IHJlbmRlcmluZ0ludGVudDtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuY3JlYXRvciA9IG51bGw7XG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgIHRoaXMuY3JlYXRvciA9IGRhdGEuY3JlYXRvcjtcbiAgICB0aGlzLiNvcmRlciA9IGRhdGEub3JkZXI7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBkYXRhLmdyb3Vwcykge1xuICAgICAgdGhpcy4jZ3JvdXBzLnNldChncm91cC5pZCwgbmV3IE9wdGlvbmFsQ29udGVudEdyb3VwKHJlbmRlcmluZ0ludGVudCwgZ3JvdXApKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuYmFzZVN0YXRlID09PSBcIk9GRlwiKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHRoaXMuI2dyb3Vwcy52YWx1ZXMoKSkge1xuICAgICAgICBncm91cC5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9uIG9mIGRhdGEub24pIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob24pLl9zZXRWaXNpYmxlKElOVEVSTkFMLCB0cnVlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBvZmYgb2YgZGF0YS5vZmYpIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob2ZmKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLiNpbml0aWFsSGFzaCA9IHRoaXMuZ2V0SGFzaCgpO1xuICB9XG4gICNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGFycmF5KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgb3BlcmF0b3IgPSBhcnJheVswXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgICBsZXQgc3RhdGU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI2dyb3Vwcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLiNncm91cHMuZ2V0KGVsZW1lbnQpLnZpc2libGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtlbGVtZW50fWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIkFuZFwiOlxuICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPclwiOlxuICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTm90XCI6XG4gICAgICAgICAgcmV0dXJuICFzdGF0ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIkFuZFwiO1xuICB9XG4gIGlzVmlzaWJsZShncm91cCkge1xuICAgIGlmICh0aGlzLiNncm91cHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIGluZm8oXCJPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ0dcIikge1xuICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGdyb3VwLmlkKSkge1xuICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtncm91cC5pZH1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLmdldChncm91cC5pZCkudmlzaWJsZTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NNRFwiKSB7XG4gICAgICBpZiAoZ3JvdXAuZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy4jZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihncm91cC5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICghZ3JvdXAucG9saWN5IHx8IGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQW55T2ZmXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPZmZcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgd2FybihgVW5rbm93biBvcHRpb25hbCBjb250ZW50IHBvbGljeSAke2dyb3VwLnBvbGljeX0uYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2FybihgVW5rbm93biBncm91cCB0eXBlICR7Z3JvdXAudHlwZX0uYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2V0VmlzaWJpbGl0eShpZCwgdmlzaWJsZSA9IHRydWUsIHByZXNlcnZlUkIgPSB0cnVlKSB7XG4gICAgY29uc3QgZ3JvdXAgPSB0aGlzLiNncm91cHMuZ2V0KGlkKTtcbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXNlcnZlUkIgJiYgdmlzaWJsZSAmJiBncm91cC5yYkdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgcmJHcm91cCBvZiBncm91cC5yYkdyb3Vwcykge1xuICAgICAgICBmb3IgKGNvbnN0IG90aGVySWQgb2YgcmJHcm91cCkge1xuICAgICAgICAgIGlmIChvdGhlcklkICE9PSBpZCkge1xuICAgICAgICAgICAgdGhpcy4jZ3JvdXBzLmdldChvdGhlcklkKT8uX3NldFZpc2libGUoSU5URVJOQUwsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ3JvdXAuX3NldFZpc2libGUoSU5URVJOQUwsICEhdmlzaWJsZSwgdHJ1ZSk7XG4gICAgdGhpcy4jY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gIH1cbiAgc2V0T0NHU3RhdGUoe1xuICAgIHN0YXRlLFxuICAgIHByZXNlcnZlUkJcbiAgfSkge1xuICAgIGxldCBvcGVyYXRvcjtcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2Ygc3RhdGUpIHtcbiAgICAgIHN3aXRjaCAoZWxlbSkge1xuICAgICAgICBjYXNlIFwiT05cIjpcbiAgICAgICAgY2FzZSBcIk9GRlwiOlxuICAgICAgICBjYXNlIFwiVG9nZ2xlXCI6XG4gICAgICAgICAgb3BlcmF0b3IgPSBlbGVtO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLiNncm91cHMuZ2V0KGVsZW0pO1xuICAgICAgaWYgKCFncm91cCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIk9OXCI6XG4gICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KGVsZW0sIHRydWUsIHByZXNlcnZlUkIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiT0ZGXCI6XG4gICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KGVsZW0sIGZhbHNlLCBwcmVzZXJ2ZVJCKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlRvZ2dsZVwiOlxuICAgICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eShlbGVtLCAhZ3JvdXAudmlzaWJsZSwgcHJlc2VydmVSQik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICB9XG4gIGdldCBoYXNJbml0aWFsVmlzaWJpbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5pdGlhbEhhc2ggPT09IG51bGwgfHwgdGhpcy5nZXRIYXNoKCkgPT09IHRoaXMuI2luaXRpYWxIYXNoO1xuICB9XG4gIGdldE9yZGVyKCkge1xuICAgIGlmICghdGhpcy4jZ3JvdXBzLnNpemUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy4jb3JkZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLiNvcmRlci5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gWy4uLnRoaXMuI2dyb3Vwcy5rZXlzKCldO1xuICB9XG4gIGdldEdyb3VwKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5nZXQoaWQpIHx8IG51bGw7XG4gIH1cbiAgZ2V0SGFzaCgpIHtcbiAgICBpZiAodGhpcy4jY2FjaGVkR2V0SGFzaCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuI2NhY2hlZEdldEhhc2g7XG4gICAgfVxuICAgIGNvbnN0IGhhc2ggPSBuZXcgTXVybXVySGFzaDNfNjQoKTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZ3JvdXBdIG9mIHRoaXMuI2dyb3Vwcykge1xuICAgICAgaGFzaC51cGRhdGUoYCR7aWR9OiR7Z3JvdXAudmlzaWJsZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlZEdldEhhc2ggPSBoYXNoLmhleGRpZ2VzdCgpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuZW50cmllcygpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3RyYW5zcG9ydF9zdHJlYW0uanNcblxuXG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtIHtcbiAgY29uc3RydWN0b3IocGRmRGF0YVJhbmdlVHJhbnNwb3J0LCB7XG4gICAgZGlzYWJsZVJhbmdlID0gZmFsc2UsXG4gICAgZGlzYWJsZVN0cmVhbSA9IGZhbHNlXG4gIH0pIHtcbiAgICBhc3NlcnQocGRmRGF0YVJhbmdlVHJhbnNwb3J0LCAnUERGRGF0YVRyYW5zcG9ydFN0cmVhbSAtIG1pc3NpbmcgcmVxdWlyZWQgXCJwZGZEYXRhUmFuZ2VUcmFuc3BvcnRcIiBhcmd1bWVudC4nKTtcbiAgICBjb25zdCB7XG4gICAgICBsZW5ndGgsXG4gICAgICBpbml0aWFsRGF0YSxcbiAgICAgIHByb2dyZXNzaXZlRG9uZSxcbiAgICAgIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lXG4gICAgfSA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSBwcm9ncmVzc2l2ZURvbmU7XG4gICAgdGhpcy5fY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTtcbiAgICBpZiAoaW5pdGlhbERhdGE/Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGluaXRpYWxEYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBpbml0aWFsRGF0YS5ieXRlTGVuZ3RoID09PSBpbml0aWFsRGF0YS5idWZmZXIuYnl0ZUxlbmd0aCA/IGluaXRpYWxEYXRhLmJ1ZmZlciA6IG5ldyBVaW50OEFycmF5KGluaXRpYWxEYXRhKS5idWZmZXI7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgIH1cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIWRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMgPSBbXTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUmFuZ2VMaXN0ZW5lcigoYmVnaW4sIGNodW5rKSA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgYmVnaW4sXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NMaXN0ZW5lcigobG9hZGVkLCB0b3RhbCkgPT4ge1xuICAgICAgdGhpcy5fb25Qcm9ncmVzcyh7XG4gICAgICAgIGxvYWRlZCxcbiAgICAgICAgdG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcihjaHVuayA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzaXZlRG9uZSgpO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC50cmFuc3BvcnRSZWFkeSgpO1xuICB9XG4gIF9vblJlY2VpdmVEYXRhKHtcbiAgICBiZWdpbixcbiAgICBjaHVua1xuICB9KSB7XG4gICAgY29uc3QgYnVmZmVyID0gY2h1bmsgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGNodW5rLmJ5dGVMZW5ndGggPT09IGNodW5rLmJ1ZmZlci5ieXRlTGVuZ3RoID8gY2h1bmsuYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICBpZiAoYmVnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLl9lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmb3VuZCA9IHRoaXMuX3JhbmdlUmVhZGVycy5zb21lKGZ1bmN0aW9uIChyYW5nZVJlYWRlcikge1xuICAgICAgICBpZiAocmFuZ2VSZWFkZXIuX2JlZ2luICE9PSBiZWdpbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByYW5nZVJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgYXNzZXJ0KGZvdW5kLCBcIl9vblJlY2VpdmVEYXRhIC0gbm8gYFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcmAgaW5zdGFuY2UgZm91bmQuXCIpO1xuICAgIH1cbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICBpZiAoZXZ0LnRvdGFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVhZGVyc1swXT8ub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Lm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9vblByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8ucHJvZ3Jlc3NpdmVEb25lKCk7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lID0gdHJ1ZTtcbiAgfVxuICBfcmVtb3ZlUmFuZ2VSZWFkZXIocmVhZGVyKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3JhbmdlUmVhZGVycy5pbmRleE9mKHJlYWRlcik7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkRhdGFUcmFuc3BvcnRTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgY29uc3QgcXVldWVkQ2h1bmtzID0gdGhpcy5fcXVldWVkQ2h1bmtzO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IG51bGw7XG4gICAgcmV0dXJuIG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyKHRoaXMsIHF1ZXVlZENodW5rcywgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lLCB0aGlzLl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSk7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgcXVldWVkQ2h1bmtzLCBwcm9ncmVzc2l2ZURvbmUgPSBmYWxzZSwgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX2RvbmUgPSBwcm9ncmVzc2l2ZURvbmUgfHwgZmFsc2U7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBpc1BkZkZpbGUoY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUpID8gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgOiBudWxsO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IHF1ZXVlZENodW5rcyB8fCBbXTtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdGhpcy5fcXVldWVkQ2h1bmtzKSB7XG4gICAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9oZWFkZXJzUmVhZHkgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBzdHJlYW0uX2Z1bGxSZXF1ZXN0UmVhZGVyID0gdGhpcztcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9lbnF1ZXVlKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzUmVhZHk7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rcy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBwcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9iZWdpbiA9IGJlZ2luO1xuICAgIHRoaXMuX2VuZCA9IGVuZDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfZW5xdWV1ZShjaHVuaykge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzQ2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0c0NhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB0aGlzLl9zdHJlYW0uX3JlbW92ZVJhbmdlUmVhZGVyKHRoaXMpO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmspIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvY29udGVudF9kaXNwb3NpdGlvbi5qc1xuXG5mdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIoY29udGVudERpc3Bvc2l0aW9uKSB7XG4gIGxldCBuZWVkc0VuY29kaW5nRml4dXAgPSB0cnVlO1xuICBsZXQgdG1wID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCpcIiwgXCJpXCIpLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uKTtcbiAgaWYgKHRtcCkge1xuICAgIHRtcCA9IHRtcFsxXTtcbiAgICBsZXQgZmlsZW5hbWUgPSByZmMyNjE2dW5xdW90ZSh0bXApO1xuICAgIGZpbGVuYW1lID0gdW5lc2NhcGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjNTk4N2RlY29kZShmaWxlbmFtZSk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgdG1wID0gcmZjMjIzMWdldHBhcmFtKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICBjb25zdCBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUodG1wKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgdG1wID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuICBmdW5jdGlvbiB0b1BhcmFtUmVnRXhwKGF0dHJpYnV0ZVBhdHRlcm4sIGZsYWdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpefDspXFxcXHMqXCIgKyBhdHRyaWJ1dGVQYXR0ZXJuICsgXCJcXFxccyo9XFxcXHMqXCIgKyBcIihcIiArICdbXlwiO1xcXFxzXVteO1xcXFxzXSonICsgXCJ8XCIgKyAnXCIoPzpbXlwiXFxcXFxcXFxdfFxcXFxcXFxcXCI/KStcIj8nICsgXCIpXCIsIGZsYWdzKTtcbiAgfVxuICBmdW5jdGlvbiB0ZXh0ZGVjb2RlKGVuY29kaW5nLCB2YWx1ZSkge1xuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgaWYgKCEvXltcXHgwMC1cXHhGRl0rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywge1xuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgICBuZWVkc0VuY29kaW5nRml4dXAgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGZpeHVwRW5jb2RpbmcodmFsdWUpIHtcbiAgICBpZiAobmVlZHNFbmNvZGluZ0ZpeHVwICYmIC9bXFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwidXRmLThcIiwgdmFsdWUpO1xuICAgICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCkge1xuICAgICAgICB2YWx1ZSA9IHRleHRkZWNvZGUoXCJpc28tODg1OS0xXCIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb25TdHIpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgbGV0IG1hdGNoO1xuICAgIGNvbnN0IGl0ZXIgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcXFxcKigoPyEwXFxcXGQpXFxcXGQrKShcXFxcKj8pXCIsIFwiaWdcIik7XG4gICAgd2hpbGUgKChtYXRjaCA9IGl0ZXIuZXhlYyhjb250ZW50RGlzcG9zaXRpb25TdHIpKSAhPT0gbnVsbCkge1xuICAgICAgbGV0IFssIG4sIHF1b3QsIHBhcnRdID0gbWF0Y2g7XG4gICAgICBuID0gcGFyc2VJbnQobiwgMTApO1xuICAgICAgaWYgKG4gaW4gbWF0Y2hlcykge1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbWF0Y2hlc1tuXSA9IFtxdW90LCBwYXJ0XTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IG1hdGNoZXMubGVuZ3RoOyArK24pIHtcbiAgICAgIGlmICghKG4gaW4gbWF0Y2hlcykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgW3F1b3QsIHBhcnRdID0gbWF0Y2hlc1tuXTtcbiAgICAgIHBhcnQgPSByZmMyNjE2dW5xdW90ZShwYXJ0KTtcbiAgICAgIGlmIChxdW90KSB7XG4gICAgICAgIHBhcnQgPSB1bmVzY2FwZShwYXJ0KTtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBwYXJ0ID0gcmZjNTk4N2RlY29kZShwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gcmZjMjYxNnVucXVvdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnXCInKSkge1xuICAgICAgY29uc3QgcGFydHMgPSB2YWx1ZS5zbGljZSgxKS5zcGxpdCgnXFxcXFwiJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHF1b3RpbmRleCA9IHBhcnRzW2ldLmluZGV4T2YoJ1wiJyk7XG4gICAgICAgIGlmIChxdW90aW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcGFydHNbaV0gPSBwYXJ0c1tpXS5zbGljZSgwLCBxdW90aW5kZXgpO1xuICAgICAgICAgIHBhcnRzLmxlbmd0aCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0ucmVwbGFjZUFsbCgvXFxcXCguKS9nLCBcIiQxXCIpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCdcIicpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcmZjNTk4N2RlY29kZShleHR2YWx1ZSkge1xuICAgIGNvbnN0IGVuY29kaW5nZW5kID0gZXh0dmFsdWUuaW5kZXhPZihcIidcIik7XG4gICAgaWYgKGVuY29kaW5nZW5kID09PSAtMSkge1xuICAgICAgcmV0dXJuIGV4dHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGluZyA9IGV4dHZhbHVlLnNsaWNlKDAsIGVuY29kaW5nZW5kKTtcbiAgICBjb25zdCBsYW5ndmFsdWUgPSBleHR2YWx1ZS5zbGljZShlbmNvZGluZ2VuZCArIDEpO1xuICAgIGNvbnN0IHZhbHVlID0gbGFuZ3ZhbHVlLnJlcGxhY2UoL15bXiddKicvLCBcIlwiKTtcbiAgICByZXR1cm4gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzIwNDdkZWNvZGUodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoXCI9P1wiKSB8fCAvW1xceDAwLVxceDE5XFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZUFsbCgvPVxcPyhbXFx3LV0qKVxcPyhbUXFCYl0pXFw/KCg/OlteP118XFw/KD8hPSkpKilcXD89L2csIGZ1bmN0aW9uIChtYXRjaGVzLCBjaGFyc2V0LCBlbmNvZGluZywgdGV4dCkge1xuICAgICAgaWYgKGVuY29kaW5nID09PSBcInFcIiB8fCBlbmNvZGluZyA9PT0gXCJRXCIpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbChcIl9cIiwgXCIgXCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlQWxsKC89KFswLTlhLWZBLUZdezJ9KS9nLCBmdW5jdGlvbiAobWF0Y2gsIGhleCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleCwgMTYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ZXh0ZGVjb2RlKGNoYXJzZXQsIHRleHQpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGV4dCA9IGF0b2IodGV4dCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgICByZXR1cm4gdGV4dGRlY29kZShjaGFyc2V0LCB0ZXh0KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbmV0d29ya191dGlscy5qc1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlSGVhZGVycyhpc0h0dHAsIGh0dHBIZWFkZXJzKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICBpZiAoIWlzSHR0cCB8fCAhaHR0cEhlYWRlcnMgfHwgdHlwZW9mIGh0dHBIZWFkZXJzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gaHR0cEhlYWRlcnMpIHtcbiAgICBjb25zdCB2YWwgPSBodHRwSGVhZGVyc1trZXldO1xuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIGdldFJlc3BvbnNlT3JpZ2luKHVybCkge1xuICByZXR1cm4gVVJMLnBhcnNlKHVybCk/Lm9yaWdpbiA/PyBudWxsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMoe1xuICByZXNwb25zZUhlYWRlcnMsXG4gIGlzSHR0cCxcbiAgcmFuZ2VDaHVua1NpemUsXG4gIGRpc2FibGVSYW5nZVxufSkge1xuICBjb25zdCByZXR1cm5WYWx1ZXMgPSB7XG4gICAgYWxsb3dSYW5nZVJlcXVlc3RzOiBmYWxzZSxcbiAgICBzdWdnZXN0ZWRMZW5ndGg6IHVuZGVmaW5lZFxuICB9O1xuICBjb25zdCBsZW5ndGggPSBwYXJzZUludChyZXNwb25zZUhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIiksIDEwKTtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIHJldHVyblZhbHVlcy5zdWdnZXN0ZWRMZW5ndGggPSBsZW5ndGg7XG4gIGlmIChsZW5ndGggPD0gMiAqIHJhbmdlQ2h1bmtTaXplKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBpZiAoZGlzYWJsZVJhbmdlIHx8ICFpc0h0dHApIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGlmIChyZXNwb25zZUhlYWRlcnMuZ2V0KFwiQWNjZXB0LVJhbmdlc1wiKSAhPT0gXCJieXRlc1wiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBjb25zdCBjb250ZW50RW5jb2RpbmcgPSByZXNwb25zZUhlYWRlcnMuZ2V0KFwiQ29udGVudC1FbmNvZGluZ1wiKSB8fCBcImlkZW50aXR5XCI7XG4gIGlmIChjb250ZW50RW5jb2RpbmcgIT09IFwiaWRlbnRpdHlcIikge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgcmV0dXJuVmFsdWVzLmFsbG93UmFuZ2VSZXF1ZXN0cyA9IHRydWU7XG4gIHJldHVybiByZXR1cm5WYWx1ZXM7XG59XG5mdW5jdGlvbiBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKHJlc3BvbnNlSGVhZGVycykge1xuICBjb25zdCBjb250ZW50RGlzcG9zaXRpb24gPSByZXNwb25zZUhlYWRlcnMuZ2V0KFwiQ29udGVudC1EaXNwb3NpdGlvblwiKTtcbiAgaWYgKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICAgIGxldCBmaWxlbmFtZSA9IGdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcihjb250ZW50RGlzcG9zaXRpb24pO1xuICAgIGlmIChmaWxlbmFtZS5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbGVuYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KGZpbGVuYW1lKTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgaWYgKGlzUGRmRmlsZShmaWxlbmFtZSkpIHtcbiAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZUVycm9yKHN0YXR1cywgdXJsKSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2VFeGNlcHRpb24oYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlICgke3N0YXR1c30pIHdoaWxlIHJldHJpZXZpbmcgUERGIFwiJHt1cmx9XCIuYCwgc3RhdHVzLCBzdGF0dXMgPT09IDQwNCB8fCBzdGF0dXMgPT09IDAgJiYgdXJsLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKHN0YXR1cykge1xuICByZXR1cm4gc3RhdHVzID09PSAyMDAgfHwgc3RhdHVzID09PSAyMDY7XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2ZldGNoX3N0cmVhbS5qc1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoT3B0aW9ucyhoZWFkZXJzLCB3aXRoQ3JlZGVudGlhbHMsIGFib3J0Q29udHJvbGxlcikge1xuICByZXR1cm4ge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBoZWFkZXJzLFxuICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBjcmVkZW50aWFsczogd2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgcmVkaXJlY3Q6IFwiZm9sbG93XCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEFycmF5QnVmZmVyKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiB2YWwuYnVmZmVyO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgd2FybihgZ2V0QXJyYXlCdWZmZXIgLSB1bmV4cGVjdGVkIGRhdGEgZm9ybWF0OiAke3ZhbH1gKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbCkuYnVmZmVyO1xufVxuY2xhc3MgUERGRmV0Y2hTdHJlYW0ge1xuICBfcmVzcG9uc2VPcmlnaW4gPSBudWxsO1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmlzSHR0cCA9IC9eaHR0cHM/Oi9pLnRlc3Qoc291cmNlLnVybCk7XG4gICAgdGhpcy5oZWFkZXJzID0gY3JlYXRlSGVhZGVycyh0aGlzLmlzSHR0cCwgc291cmNlLmh0dHBIZWFkZXJzKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIGdldCBfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uX2xvYWRlZCA/PyAwO1xuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgYXNzZXJ0KCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZGZXRjaFN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZGZXRjaFN0cmVhbVJlYWRlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJlYWRlcik7XG4gICAgcmV0dXJuIHJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGRmV0Y2hTdHJlYW1SZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHNvdXJjZS53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIGlmICghdGhpcy5fcmFuZ2VDaHVua1NpemUgJiYgIXRoaXMuX2Rpc2FibGVSYW5nZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVSYW5nZTtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoc3RyZWFtLmhlYWRlcnMpO1xuICAgIGNvbnN0IHVybCA9IHNvdXJjZS51cmw7XG4gICAgZmV0Y2godXJsLCBjcmVhdGVGZXRjaE9wdGlvbnMoaGVhZGVycywgdGhpcy5fd2l0aENyZWRlbnRpYWxzLCB0aGlzLl9hYm9ydENvbnRyb2xsZXIpKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIHN0cmVhbS5fcmVzcG9uc2VPcmlnaW4gPSBnZXRSZXNwb25zZU9yaWdpbihyZXNwb25zZS51cmwpO1xuICAgICAgaWYgKCF2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlUmVzcG9uc2VFcnJvcihyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2UuaGVhZGVycztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICAgIH0gPSB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgaXNIdHRwOiBzdHJlYW0uaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZTogdGhpcy5fZGlzYWJsZVJhbmdlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBhbGxvd1JhbmdlUmVxdWVzdHM7XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgICB0aGlzLl9maWxlbmFtZSA9IGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIocmVzcG9uc2VIZWFkZXJzKTtcbiAgICAgIGlmICghdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgJiYgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICB0aGlzLmNhbmNlbChuZXcgQWJvcnRFeGNlcHRpb24oXCJTdHJlYW1pbmcgaXMgZGlzYWJsZWQuXCIpKTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaCh0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZG9uZVxuICAgIH0gPSBhd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWQsXG4gICAgICB0b3RhbDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZ2V0QXJyYXlCdWZmZXIodmFsdWUpLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9yZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHNvdXJjZS53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHN0cmVhbS5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLmFwcGVuZChcIlJhbmdlXCIsIGBieXRlcz0ke2JlZ2lufS0ke2VuZCAtIDF9YCk7XG4gICAgY29uc3QgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyhoZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2VPcmlnaW4gPSBnZXRSZXNwb25zZU9yaWdpbihyZXNwb25zZS51cmwpO1xuICAgICAgaWYgKHJlc3BvbnNlT3JpZ2luICE9PSBzdHJlYW0uX3Jlc3BvbnNlT3JpZ2luKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgcmFuZ2UgcmVzcG9uc2Utb3JpZ2luIFwiJHtyZXNwb25zZU9yaWdpbn1cIiB0byBtYXRjaCBcIiR7c3RyZWFtLl9yZXNwb25zZU9yaWdpbn1cIi5gKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsaWRhdGVSZXNwb25zZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZVJlc3BvbnNlRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCB1cmwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICB9KS5jYXRjaCh0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfSA9IGF3YWl0IHRoaXMuX3JlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZ2V0QXJyYXlCdWZmZXIodmFsdWUpLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9yZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L25ldHdvcmsuanNcblxuXG5jb25zdCBPS19SRVNQT05TRSA9IDIwMDtcbmNvbnN0IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRSA9IDIwNjtcbmZ1bmN0aW9uIG5ldHdvcmtfZ2V0QXJyYXlCdWZmZXIoeGhyKSB7XG4gIGNvbnN0IGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBzdHJpbmdUb0J5dGVzKGRhdGEpLmJ1ZmZlcjtcbn1cbmNsYXNzIE5ldHdvcmtNYW5hZ2VyIHtcbiAgX3Jlc3BvbnNlT3JpZ2luID0gbnVsbDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCxcbiAgICBodHRwSGVhZGVycyxcbiAgICB3aXRoQ3JlZGVudGlhbHNcbiAgfSkge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdCh1cmwpO1xuICAgIHRoaXMuaGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5pc0h0dHAsIGh0dHBIZWFkZXJzKTtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IHdpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLmN1cnJYaHJJZCA9IDA7XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIHJlcXVlc3QoYXJncykge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIGNvbnN0IHhocklkID0gdGhpcy5jdXJyWGhySWQrKztcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXSA9IHtcbiAgICAgIHhoclxuICAgIH07XG4gICAgeGhyLm9wZW4oXCJHRVRcIiwgdGhpcy51cmwpO1xuICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy5oZWFkZXJzKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSHR0cCAmJiBcImJlZ2luXCIgaW4gYXJncyAmJiBcImVuZFwiIGluIGFyZ3MpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIiwgYGJ5dGVzPSR7YXJncy5iZWdpbn0tJHthcmdzLmVuZCAtIDF9YCk7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPSBPS19SRVNQT05TRTtcbiAgICB9XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICBhc3NlcnQoYXJncy5vbkVycm9yLCBcIkV4cGVjdGVkIGBvbkVycm9yYCBjYWxsYmFjayB0byBiZSBwcm92aWRlZC5cIik7XG4gICAgeGhyLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICBhcmdzLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgfTtcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5vblByb2dyZXNzLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkID0gYXJncy5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUgPSBhcmdzLm9uRG9uZTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yID0gYXJncy5vbkVycm9yO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3MgPSBhcmdzLm9uUHJvZ3Jlc3M7XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gICAgcmV0dXJuIHhocklkO1xuICB9XG4gIG9uUHJvZ3Jlc3MoeGhySWQsIGV2dCkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Qcm9ncmVzcz8uKGV2dCk7XG4gIH1cbiAgb25TdGF0ZUNoYW5nZSh4aHJJZCwgZXZ0KSB7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKCFwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHIgPSBwZW5kaW5nUmVxdWVzdC54aHI7XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlID49IDIgJiYgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkKCk7XG4gICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgfVxuICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCAmJiB0aGlzLmlzSHR0cCkge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeGhyU3RhdHVzID0geGhyLnN0YXR1cyB8fCBPS19SRVNQT05TRTtcbiAgICBjb25zdCBva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0ID0geGhyU3RhdHVzID09PSBPS19SRVNQT05TRSAmJiBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9PT0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFO1xuICAgIGlmICghb2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCAmJiB4aHJTdGF0dXMgIT09IHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IG5ldHdvcmtfZ2V0QXJyYXlCdWZmZXIoeGhyKTtcbiAgICBpZiAoeGhyU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UpIHtcbiAgICAgIGNvbnN0IHJhbmdlSGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1SYW5nZVwiKTtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSAvYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKS8uZXhlYyhyYW5nZUhlYWRlcik7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICAgIGJlZ2luOiBwYXJzZUludChtYXRjaGVzWzFdLCAxMCksXG4gICAgICAgICAgY2h1bmtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKGBNaXNzaW5nIG9yIGludmFsaWQgXCJDb250ZW50LVJhbmdlXCIgaGVhZGVyLmApO1xuICAgICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yKDApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2h1bmspIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgIGJlZ2luOiAwLFxuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGdldFJlcXVlc3RYaHIoeGhySWQpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdLnhocjtcbiAgfVxuICBpc1BlbmRpbmdSZXF1ZXN0KHhocklkKSB7XG4gICAgcmV0dXJuIHhocklkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzO1xuICB9XG4gIGFib3J0UmVxdWVzdCh4aHJJZCkge1xuICAgIGNvbnN0IHhociA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICB4aHIuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbmV3IE5ldHdvcmtNYW5hZ2VyKHNvdXJjZSk7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBfb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQocmVhZGVyKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuaW5kZXhPZihyZWFkZXIpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGTmV0d29ya1N0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIodGhpcy5fbWFuYWdlciwgdGhpcy5fc291cmNlKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIGJlZ2luLCBlbmQpO1xuICAgIHJlYWRlci5vbkNsb3NlZCA9IHRoaXMuX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJlYWRlcik7XG4gICAgcmV0dXJuIHJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlciwgc291cmNlKSB7XG4gICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5fdXJsID0gc291cmNlLnVybDtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdElkID0gbWFuYWdlci5yZXF1ZXN0KHtcbiAgICAgIG9uSGVhZGVyc1JlY2VpdmVkOiB0aGlzLl9vbkhlYWRlcnNSZWNlaXZlZC5iaW5kKHRoaXMpLFxuICAgICAgb25Eb25lOiB0aGlzLl9vbkRvbmUuYmluZCh0aGlzKSxcbiAgICAgIG9uRXJyb3I6IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uUHJvZ3Jlc3M6IHRoaXMuX29uUHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhY2hlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9vbkhlYWRlcnNSZWNlaXZlZCgpIHtcbiAgICBjb25zdCBmdWxsUmVxdWVzdFhocklkID0gdGhpcy5fZnVsbFJlcXVlc3RJZDtcbiAgICBjb25zdCBmdWxsUmVxdWVzdFhociA9IHRoaXMuX21hbmFnZXIuZ2V0UmVxdWVzdFhocihmdWxsUmVxdWVzdFhocklkKTtcbiAgICB0aGlzLl9tYW5hZ2VyLl9yZXNwb25zZU9yaWdpbiA9IGdldFJlc3BvbnNlT3JpZ2luKGZ1bGxSZXF1ZXN0WGhyLnJlc3BvbnNlVVJMKTtcbiAgICBjb25zdCByYXdSZXNwb25zZUhlYWRlcnMgPSBmdWxsUmVxdWVzdFhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBuZXcgSGVhZGVycyhyYXdSZXNwb25zZUhlYWRlcnMgPyByYXdSZXNwb25zZUhlYWRlcnMudHJpbVN0YXJ0KCkucmVwbGFjZSgvW15cXFMgXSskLywgXCJcIikuc3BsaXQoL1tcXHJcXG5dKy8pLm1hcCh4ID0+IHtcbiAgICAgIGNvbnN0IFtrZXksIC4uLnZhbF0gPSB4LnNwbGl0KFwiOiBcIik7XG4gICAgICByZXR1cm4gW2tleSwgdmFsLmpvaW4oXCI6IFwiKV07XG4gICAgfSkgOiBbXSk7XG4gICAgY29uc3Qge1xuICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgc3VnZ2VzdGVkTGVuZ3RoXG4gICAgfSA9IHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIGlzSHR0cDogdGhpcy5fbWFuYWdlci5pc0h0dHAsXG4gICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgIH0pO1xuICAgIGlmIChhbGxvd1JhbmdlUmVxdWVzdHMpIHtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKHJlc3BvbnNlSGVhZGVycyk7XG4gICAgaWYgKHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KGZ1bGxSZXF1ZXN0WGhySWQpO1xuICAgIH1cbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGRhdGEuY2h1bmssXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRDaHVua3MucHVzaChkYXRhLmNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGNyZWF0ZVJlc3BvbnNlRXJyb3Ioc3RhdHVzLCB0aGlzLl91cmwpO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID0gMDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICB0b3RhbDogZXZ0Lmxlbmd0aENvbXB1dGFibGUgPyBldnQudG90YWwgOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jYWNoZWRDaHVua3Muc2hpZnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9mdWxsUmVxdWVzdElkKSkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCk7XG4gICAgfVxuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLl91cmwgPSBtYW5hZ2VyLnVybDtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgPSBtYW5hZ2VyLnJlcXVlc3Qoe1xuICAgICAgYmVnaW4sXG4gICAgICBlbmQsXG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLm9uQ2xvc2VkID0gbnVsbDtcbiAgfVxuICBfb25IZWFkZXJzUmVjZWl2ZWQoKSB7XG4gICAgY29uc3QgcmVzcG9uc2VPcmlnaW4gPSBnZXRSZXNwb25zZU9yaWdpbih0aGlzLl9tYW5hZ2VyLmdldFJlcXVlc3RYaHIodGhpcy5fcmVxdWVzdElkKT8ucmVzcG9uc2VVUkwpO1xuICAgIGlmIChyZXNwb25zZU9yaWdpbiAhPT0gdGhpcy5fbWFuYWdlci5fcmVzcG9uc2VPcmlnaW4pIHtcbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbmV3IEVycm9yKGBFeHBlY3RlZCByYW5nZSByZXNwb25zZS1vcmlnaW4gXCIke3Jlc3BvbnNlT3JpZ2lufVwiIHRvIG1hdGNoIFwiJHt0aGlzLl9tYW5hZ2VyLl9yZXNwb25zZU9yaWdpbn1cIi5gKTtcbiAgICAgIHRoaXMuX29uRXJyb3IoMCk7XG4gICAgfVxuICB9XG4gIF9jbG9zZSgpIHtcbiAgICB0aGlzLm9uQ2xvc2VkPy4odGhpcyk7XG4gIH1cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgY29uc3QgY2h1bmsgPSBkYXRhLmNodW5rO1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jbG9zZSgpO1xuICB9XG4gIF9vbkVycm9yKHN0YXR1cykge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID8/PSBjcmVhdGVSZXNwb25zZUVycm9yKHN0YXR1cywgdGhpcy5fdXJsKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICBpZiAoIXRoaXMuaXNTdHJlYW1pbmdTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVuayAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVuaztcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpO1xuICAgIH1cbiAgICB0aGlzLl9jbG9zZSgpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L25vZGVfc3RyZWFtLmpzXG5cblxuY29uc3QgdXJsUmVnZXggPSAvXlthLXpdW2EtejAtOVxcLSsuXSs6L2k7XG5mdW5jdGlvbiBwYXJzZVVybE9yUGF0aChzb3VyY2VVcmwpIHtcbiAgaWYgKHVybFJlZ2V4LnRlc3Qoc291cmNlVXJsKSkge1xuICAgIHJldHVybiBuZXcgVVJMKHNvdXJjZVVybCk7XG4gIH1cbiAgY29uc3QgdXJsID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwidXJsXCIpO1xuICByZXR1cm4gbmV3IFVSTCh1cmwucGF0aFRvRmlsZVVSTChzb3VyY2VVcmwpKTtcbn1cbmNsYXNzIFBERk5vZGVTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnVybCA9IHBhcnNlVXJsT3JQYXRoKHNvdXJjZS51cmwpO1xuICAgIGFzc2VydCh0aGlzLnVybC5wcm90b2NvbCA9PT0gXCJmaWxlOlwiLCBcIlBERk5vZGVTdHJlYW0gb25seSBzdXBwb3J0cyBmaWxlOi8vIFVSTHMuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5vZGVTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoc3RhcnQsIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2VSZWFkZXIgPSBuZXcgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJhbmdlUmVhZGVyKTtcbiAgICByZXR1cm4gcmFuZ2VSZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICBjb25zdCBmcyA9IHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShcImZzXCIpO1xuICAgIGZzLnByb21pc2VzLmxzdGF0KHRoaXMuX3VybCkudGhlbihzdGF0ID0+IHtcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdGF0LnNpemU7XG4gICAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHRoaXMuX3VybCkpO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0sIGVycm9yID0+IHtcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgIGVycm9yID0gY3JlYXRlUmVzcG9uc2VFcnJvcigwLCB0aGlzLl91cmwuaHJlZik7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICB9XG4gIF9lcnJvcihyZWFzb24pIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX3NldFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSByZWFkYWJsZVN0cmVhbTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcInJlYWRhYmxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICByZWFkYWJsZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgIH0pO1xuICAgIGlmICghdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgJiYgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5fZXJyb3IobmV3IEFib3J0RXhjZXB0aW9uKFwic3RyZWFtaW5nIGlzIGRpc2FibGVkXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5fdXJsID0gc3RyZWFtLnVybDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIGNvbnN0IGZzID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwiZnNcIik7XG4gICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbSh0aGlzLl91cmwsIHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kOiBlbmQgLSAxXG4gICAgfSkpO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IHRoaXMuX3JlYWRhYmxlU3RyZWFtLnJlYWQoKTtcbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkKCk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWRcbiAgICB9KTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHJlYXNvbik7XG4gIH1cbiAgX2Vycm9yKHJlYXNvbikge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBfc2V0UmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwicmVhZGFibGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvcGRmX29iamVjdHMuanNcbmNvbnN0IElOSVRJQUxfREFUQSA9IFN5bWJvbChcIklOSVRJQUxfREFUQVwiKTtcbmNsYXNzIFBERk9iamVjdHMge1xuICAjb2JqcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICNlbnN1cmVPYmoob2JqSWQpIHtcbiAgICByZXR1cm4gdGhpcy4jb2Jqc1tvYmpJZF0gfHw9IHtcbiAgICAgIC4uLlByb21pc2Uud2l0aFJlc29sdmVycygpLFxuICAgICAgZGF0YTogSU5JVElBTF9EQVRBXG4gICAgfTtcbiAgfVxuICBnZXQob2JqSWQsIGNhbGxiYWNrID0gbnVsbCkge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY29uc3Qgb2JqID0gdGhpcy4jZW5zdXJlT2JqKG9iaklkKTtcbiAgICAgIG9iai5wcm9taXNlLnRoZW4oKCkgPT4gY2FsbGJhY2sob2JqLmRhdGEpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICBpZiAoIW9iaiB8fCBvYmouZGF0YSA9PT0gSU5JVElBTF9EQVRBKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3Rpbmcgb2JqZWN0IHRoYXQgaXNuJ3QgcmVzb2x2ZWQgeWV0ICR7b2JqSWR9LmApO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLmRhdGE7XG4gIH1cbiAgaGFzKG9iaklkKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgcmV0dXJuICEhb2JqICYmIG9iai5kYXRhICE9PSBJTklUSUFMX0RBVEE7XG4gIH1cbiAgZGVsZXRlKG9iaklkKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgaWYgKCFvYmogfHwgb2JqLmRhdGEgPT09IElOSVRJQUxfREFUQSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmVzb2x2ZShvYmpJZCwgZGF0YSA9IG51bGwpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNlbnN1cmVPYmoob2JqSWQpO1xuICAgIG9iai5kYXRhID0gZGF0YTtcbiAgICBvYmoucmVzb2x2ZSgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3Qgb2JqSWQgaW4gdGhpcy4jb2Jqcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhXG4gICAgICB9ID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgICBkYXRhPy5iaXRtYXA/LmNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuI29ianMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBmb3IgKGNvbnN0IG9iaklkIGluIHRoaXMuI29ianMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YVxuICAgICAgfSA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgICAgaWYgKGRhdGEgPT09IElOSVRJQUxfREFUQSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIFtvYmpJZCwgZGF0YV07XG4gICAgfVxuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3RleHRfbGF5ZXIuanNcblxuXG5jb25zdCBNQVhfVEVYVF9ESVZTX1RPX1JFTkRFUiA9IDEwMDAwMDtcbmNvbnN0IERFRkFVTFRfRk9OVF9TSVpFID0gMzA7XG5jbGFzcyBUZXh0TGF5ZXIge1xuICAjY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgI2Rpc2FibGVQcm9jZXNzSXRlbXMgPSBmYWxzZTtcbiAgI2ZvbnRJbnNwZWN0b3JFbmFibGVkID0gISFnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3I/LmVuYWJsZWQ7XG4gICNsYW5nID0gbnVsbDtcbiAgI2xheW91dFRleHRQYXJhbXMgPSBudWxsO1xuICAjcGFnZUhlaWdodCA9IDA7XG4gICNwYWdlV2lkdGggPSAwO1xuICAjcmVhZGVyID0gbnVsbDtcbiAgI3Jvb3RDb250YWluZXIgPSBudWxsO1xuICAjcm90YXRpb24gPSAwO1xuICAjc2NhbGUgPSAwO1xuICAjc3R5bGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICN0ZXh0Q29udGVudEl0ZW1zU3RyID0gW107XG4gICN0ZXh0Q29udGVudFNvdXJjZSA9IG51bGw7XG4gICN0ZXh0RGl2cyA9IFtdO1xuICAjdGV4dERpdlByb3BlcnRpZXMgPSBuZXcgV2Vha01hcCgpO1xuICAjdHJhbnNmb3JtID0gbnVsbDtcbiAgc3RhdGljICNhc2NlbnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgc3RhdGljICNjYW52YXNDb250ZXh0cyA9IG5ldyBNYXAoKTtcbiAgc3RhdGljICNjYW52YXNDdHhGb250cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHN0YXRpYyAjbWluRm9udFNpemUgPSBudWxsO1xuICBzdGF0aWMgI3BlbmRpbmdUZXh0TGF5ZXJzID0gbmV3IFNldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdGV4dENvbnRlbnRTb3VyY2UsXG4gICAgY29udGFpbmVyLFxuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICBpZiAodGV4dENvbnRlbnRTb3VyY2UgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy4jdGV4dENvbnRlbnRTb3VyY2UgPSB0ZXh0Q29udGVudFNvdXJjZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0ZXh0Q29udGVudFNvdXJjZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdGhpcy4jdGV4dENvbnRlbnRTb3VyY2UgPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRDb250ZW50U291cmNlKTtcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwidGV4dENvbnRlbnRTb3VyY2VcIiBwYXJhbWV0ZXIgc3BlY2lmaWVkLicpO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIgPSB0aGlzLiNyb290Q29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3NjYWxlID0gdmlld3BvcnQuc2NhbGUgKiBPdXRwdXRTY2FsZS5waXhlbFJhdGlvO1xuICAgIHRoaXMuI3JvdGF0aW9uID0gdmlld3BvcnQucm90YXRpb247XG4gICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcyA9IHtcbiAgICAgIGRpdjogbnVsbCxcbiAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICBjdHg6IG51bGxcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgdGhpcy4jdHJhbnNmb3JtID0gWzEsIDAsIDAsIC0xLCAtcGFnZVgsIHBhZ2VZICsgcGFnZUhlaWdodF07XG4gICAgdGhpcy4jcGFnZVdpZHRoID0gcGFnZVdpZHRoO1xuICAgIHRoaXMuI3BhZ2VIZWlnaHQgPSBwYWdlSGVpZ2h0O1xuICAgIFRleHRMYXllci4jZW5zdXJlTWluRm9udFNpemVDb21wdXRlZCgpO1xuICAgIHNldExheWVyRGltZW5zaW9ucyhjb250YWluZXIsIHZpZXdwb3J0KTtcbiAgICB0aGlzLiNjYXBhYmlsaXR5LnByb21pc2UuZmluYWxseSgoKSA9PiB7XG4gICAgICBUZXh0TGF5ZXIuI3BlbmRpbmdUZXh0TGF5ZXJzLmRlbGV0ZSh0aGlzKTtcbiAgICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMgPSBudWxsO1xuICAgICAgdGhpcy4jc3R5bGVDYWNoZSA9IG51bGw7XG4gICAgfSkuY2F0Y2goKCkgPT4ge30pO1xuICB9XG4gIHN0YXRpYyBnZXQgZm9udEZhbWlseU1hcCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1dpbmRvd3MsXG4gICAgICBpc0ZpcmVmb3hcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiZm9udEZhbWlseU1hcFwiLCBuZXcgTWFwKFtbXCJzYW5zLXNlcmlmXCIsIGAke2lzV2luZG93cyAmJiBpc0ZpcmVmb3ggPyBcIkNhbGlicmksIFwiIDogXCJcIn1zYW5zLXNlcmlmYF0sIFtcIm1vbm9zcGFjZVwiLCBgJHtpc1dpbmRvd3MgJiYgaXNGaXJlZm94ID8gXCJMdWNpZGEgQ29uc29sZSwgXCIgOiBcIlwifW1vbm9zcGFjZWBdXSkpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBwdW1wID0gKCkgPT4ge1xuICAgICAgdGhpcy4jcmVhZGVyLnJlYWQoKS50aGVuKCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgdGhpcy4jY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2xhbmcgPz89IHZhbHVlLmxhbmc7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy4jc3R5bGVDYWNoZSwgdmFsdWUuc3R5bGVzKTtcbiAgICAgICAgdGhpcy4jcHJvY2Vzc0l0ZW1zKHZhbHVlLml0ZW1zKTtcbiAgICAgICAgcHVtcCgpO1xuICAgICAgfSwgdGhpcy4jY2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIH07XG4gICAgdGhpcy4jcmVhZGVyID0gdGhpcy4jdGV4dENvbnRlbnRTb3VyY2UuZ2V0UmVhZGVyKCk7XG4gICAgVGV4dExheWVyLiNwZW5kaW5nVGV4dExheWVycy5hZGQodGhpcyk7XG4gICAgcHVtcCgpO1xuICAgIHJldHVybiB0aGlzLiNjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydCxcbiAgICBvbkJlZm9yZSA9IG51bGxcbiAgfSkge1xuICAgIGNvbnN0IHNjYWxlID0gdmlld3BvcnQuc2NhbGUgKiBPdXRwdXRTY2FsZS5waXhlbFJhdGlvO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdmlld3BvcnQucm90YXRpb247XG4gICAgaWYgKHJvdGF0aW9uICE9PSB0aGlzLiNyb3RhdGlvbikge1xuICAgICAgb25CZWZvcmU/LigpO1xuICAgICAgdGhpcy4jcm90YXRpb24gPSByb3RhdGlvbjtcbiAgICAgIHNldExheWVyRGltZW5zaW9ucyh0aGlzLiNyb290Q29udGFpbmVyLCB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjYWxlICE9PSB0aGlzLiNzY2FsZSkge1xuICAgICAgb25CZWZvcmU/LigpO1xuICAgICAgdGhpcy4jc2NhbGUgPSBzY2FsZTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICBjdHg6IFRleHRMYXllci4jZ2V0Q3R4KHRoaXMuI2xhbmcpXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBkaXYgb2YgdGhpcy4jdGV4dERpdnMpIHtcbiAgICAgICAgcGFyYW1zLnByb3BlcnRpZXMgPSB0aGlzLiN0ZXh0RGl2UHJvcGVydGllcy5nZXQoZGl2KTtcbiAgICAgICAgcGFyYW1zLmRpdiA9IGRpdjtcbiAgICAgICAgdGhpcy4jbGF5b3V0KHBhcmFtcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbmNlbCgpIHtcbiAgICBjb25zdCBhYm9ydEV4ID0gbmV3IEFib3J0RXhjZXB0aW9uKFwiVGV4dExheWVyIHRhc2sgY2FuY2VsbGVkLlwiKTtcbiAgICB0aGlzLiNyZWFkZXI/LmNhbmNlbChhYm9ydEV4KS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgdGhpcy4jcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLiNjYXBhYmlsaXR5LnJlamVjdChhYm9ydEV4KTtcbiAgfVxuICBnZXQgdGV4dERpdnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RleHREaXZzO1xuICB9XG4gIGdldCB0ZXh0Q29udGVudEl0ZW1zU3RyKCkge1xuICAgIHJldHVybiB0aGlzLiN0ZXh0Q29udGVudEl0ZW1zU3RyO1xuICB9XG4gICNwcm9jZXNzSXRlbXMoaXRlbXMpIHtcbiAgICBpZiAodGhpcy4jZGlzYWJsZVByb2Nlc3NJdGVtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zLmN0eCA/Pz0gVGV4dExheWVyLiNnZXRDdHgodGhpcy4jbGFuZyk7XG4gICAgY29uc3QgdGV4dERpdnMgPSB0aGlzLiN0ZXh0RGl2cyxcbiAgICAgIHRleHRDb250ZW50SXRlbXNTdHIgPSB0aGlzLiN0ZXh0Q29udGVudEl0ZW1zU3RyO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgaWYgKHRleHREaXZzLmxlbmd0aCA+IE1BWF9URVhUX0RJVlNfVE9fUkVOREVSKSB7XG4gICAgICAgIHdhcm4oXCJJZ25vcmluZyBhZGRpdGlvbmFsIHRleHREaXZzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlwiKTtcbiAgICAgICAgdGhpcy4jZGlzYWJsZVByb2Nlc3NJdGVtcyA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtLnN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwiYmVnaW5NYXJrZWRDb250ZW50UHJvcHNcIiB8fCBpdGVtLnR5cGUgPT09IFwiYmVnaW5NYXJrZWRDb250ZW50XCIpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLiNjb250YWluZXI7XG4gICAgICAgICAgdGhpcy4jY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXJrZWRDb250ZW50XCIpO1xuICAgICAgICAgIGlmIChpdGVtLmlkKSB7XG4gICAgICAgICAgICB0aGlzLiNjb250YWluZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgYCR7aXRlbS5pZH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50LmFwcGVuZCh0aGlzLiNjb250YWluZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gXCJlbmRNYXJrZWRDb250ZW50XCIpIHtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIgPSB0aGlzLiNjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRleHRDb250ZW50SXRlbXNTdHIucHVzaChpdGVtLnN0cik7XG4gICAgICB0aGlzLiNhcHBlbmRUZXh0KGl0ZW0pO1xuICAgIH1cbiAgfVxuICAjYXBwZW5kVGV4dChnZW9tKSB7XG4gICAgY29uc3QgdGV4dERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGNvbnN0IHRleHREaXZQcm9wZXJ0aWVzID0ge1xuICAgICAgYW5nbGU6IDAsXG4gICAgICBjYW52YXNXaWR0aDogMCxcbiAgICAgIGhhc1RleHQ6IGdlb20uc3RyICE9PSBcIlwiLFxuICAgICAgaGFzRU9MOiBnZW9tLmhhc0VPTCxcbiAgICAgIGZvbnRTaXplOiAwXG4gICAgfTtcbiAgICB0aGlzLiN0ZXh0RGl2cy5wdXNoKHRleHREaXYpO1xuICAgIGNvbnN0IHR4ID0gVXRpbC50cmFuc2Zvcm0odGhpcy4jdHJhbnNmb3JtLCBnZW9tLnRyYW5zZm9ybSk7XG4gICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih0eFsxXSwgdHhbMF0pO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy4jc3R5bGVDYWNoZVtnZW9tLmZvbnROYW1lXTtcbiAgICBpZiAoc3R5bGUudmVydGljYWwpIHtcbiAgICAgIGFuZ2xlICs9IE1hdGguUEkgLyAyO1xuICAgIH1cbiAgICBsZXQgZm9udEZhbWlseSA9IHRoaXMuI2ZvbnRJbnNwZWN0b3JFbmFibGVkICYmIHN0eWxlLmZvbnRTdWJzdGl0dXRpb24gfHwgc3R5bGUuZm9udEZhbWlseTtcbiAgICBmb250RmFtaWx5ID0gVGV4dExheWVyLmZvbnRGYW1pbHlNYXAuZ2V0KGZvbnRGYW1pbHkpIHx8IGZvbnRGYW1pbHk7XG4gICAgY29uc3QgZm9udEhlaWdodCA9IE1hdGguaHlwb3QodHhbMl0sIHR4WzNdKTtcbiAgICBjb25zdCBmb250QXNjZW50ID0gZm9udEhlaWdodCAqIFRleHRMYXllci4jZ2V0QXNjZW50KGZvbnRGYW1pbHksIHN0eWxlLCB0aGlzLiNsYW5nKTtcbiAgICBsZXQgbGVmdCwgdG9wO1xuICAgIGlmIChhbmdsZSA9PT0gMCkge1xuICAgICAgbGVmdCA9IHR4WzRdO1xuICAgICAgdG9wID0gdHhbNV0gLSBmb250QXNjZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gdHhbNF0gKyBmb250QXNjZW50ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgdG9wID0gdHhbNV0gLSBmb250QXNjZW50ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZUZhY3RvclN0ciA9IFwiY2FsYyh2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpICpcIjtcbiAgICBjb25zdCBkaXZTdHlsZSA9IHRleHREaXYuc3R5bGU7XG4gICAgaWYgKHRoaXMuI2NvbnRhaW5lciA9PT0gdGhpcy4jcm9vdENvbnRhaW5lcikge1xuICAgICAgZGl2U3R5bGUubGVmdCA9IGAkeygxMDAgKiBsZWZ0IC8gdGhpcy4jcGFnZVdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgICAgZGl2U3R5bGUudG9wID0gYCR7KDEwMCAqIHRvcCAvIHRoaXMuI3BhZ2VIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpdlN0eWxlLmxlZnQgPSBgJHtzY2FsZUZhY3RvclN0cn0ke2xlZnQudG9GaXhlZCgyKX1weClgO1xuICAgICAgZGl2U3R5bGUudG9wID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHt0b3AudG9GaXhlZCgyKX1weClgO1xuICAgIH1cbiAgICBkaXZTdHlsZS5mb250U2l6ZSA9IGAke3NjYWxlRmFjdG9yU3RyfSR7KFRleHRMYXllci4jbWluRm9udFNpemUgKiBmb250SGVpZ2h0KS50b0ZpeGVkKDIpfXB4KWA7XG4gICAgZGl2U3R5bGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgdGV4dERpdlByb3BlcnRpZXMuZm9udFNpemUgPSBmb250SGVpZ2h0O1xuICAgIHRleHREaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICB0ZXh0RGl2LnRleHRDb250ZW50ID0gZ2VvbS5zdHI7XG4gICAgdGV4dERpdi5kaXIgPSBnZW9tLmRpcjtcbiAgICBpZiAodGhpcy4jZm9udEluc3BlY3RvckVuYWJsZWQpIHtcbiAgICAgIHRleHREaXYuZGF0YXNldC5mb250TmFtZSA9IHN0eWxlLmZvbnRTdWJzdGl0dXRpb25Mb2FkZWROYW1lIHx8IGdlb20uZm9udE5hbWU7XG4gICAgfVxuICAgIGlmIChhbmdsZSAhPT0gMCkge1xuICAgICAgdGV4dERpdlByb3BlcnRpZXMuYW5nbGUgPSBhbmdsZSAqICgxODAgLyBNYXRoLlBJKTtcbiAgICB9XG4gICAgbGV0IHNob3VsZFNjYWxlVGV4dCA9IGZhbHNlO1xuICAgIGlmIChnZW9tLnN0ci5sZW5ndGggPiAxKSB7XG4gICAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZ2VvbS5zdHIgIT09IFwiIFwiICYmIGdlb20udHJhbnNmb3JtWzBdICE9PSBnZW9tLnRyYW5zZm9ybVszXSkge1xuICAgICAgY29uc3QgYWJzU2NhbGVYID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bMF0pLFxuICAgICAgICBhYnNTY2FsZVkgPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVszXSk7XG4gICAgICBpZiAoYWJzU2NhbGVYICE9PSBhYnNTY2FsZVkgJiYgTWF0aC5tYXgoYWJzU2NhbGVYLCBhYnNTY2FsZVkpIC8gTWF0aC5taW4oYWJzU2NhbGVYLCBhYnNTY2FsZVkpID4gMS41KSB7XG4gICAgICAgIHNob3VsZFNjYWxlVGV4dCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRTY2FsZVRleHQpIHtcbiAgICAgIHRleHREaXZQcm9wZXJ0aWVzLmNhbnZhc1dpZHRoID0gc3R5bGUudmVydGljYWwgPyBnZW9tLmhlaWdodCA6IGdlb20ud2lkdGg7XG4gICAgfVxuICAgIHRoaXMuI3RleHREaXZQcm9wZXJ0aWVzLnNldCh0ZXh0RGl2LCB0ZXh0RGl2UHJvcGVydGllcyk7XG4gICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcy5kaXYgPSB0ZXh0RGl2O1xuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMucHJvcGVydGllcyA9IHRleHREaXZQcm9wZXJ0aWVzO1xuICAgIHRoaXMuI2xheW91dCh0aGlzLiNsYXlvdXRUZXh0UGFyYW1zKTtcbiAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuaGFzVGV4dCkge1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZCh0ZXh0RGl2KTtcbiAgICB9XG4gICAgaWYgKHRleHREaXZQcm9wZXJ0aWVzLmhhc0VPTCkge1xuICAgICAgY29uc3QgYnIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICBici5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZChicik7XG4gICAgfVxuICB9XG4gICNsYXlvdXQocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2LFxuICAgICAgcHJvcGVydGllcyxcbiAgICAgIGN0eFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIGxldCB0cmFuc2Zvcm0gPSBcIlwiO1xuICAgIGlmIChUZXh0TGF5ZXIuI21pbkZvbnRTaXplID4gMSkge1xuICAgICAgdHJhbnNmb3JtID0gYHNjYWxlKCR7MSAvIFRleHRMYXllci4jbWluRm9udFNpemV9KWA7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0aWVzLmNhbnZhc1dpZHRoICE9PSAwICYmIHByb3BlcnRpZXMuaGFzVGV4dCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmb250RmFtaWx5XG4gICAgICB9ID0gc3R5bGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNhbnZhc1dpZHRoLFxuICAgICAgICBmb250U2l6ZVxuICAgICAgfSA9IHByb3BlcnRpZXM7XG4gICAgICBUZXh0TGF5ZXIuI2Vuc3VyZUN0eEZvbnQoY3R4LCBmb250U2l6ZSAqIHRoaXMuI3NjYWxlLCBmb250RmFtaWx5KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGhcbiAgICAgIH0gPSBjdHgubWVhc3VyZVRleHQoZGl2LnRleHRDb250ZW50KTtcbiAgICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gYHNjYWxlWCgke2NhbnZhc1dpZHRoICogdGhpcy4jc2NhbGUgLyB3aWR0aH0pICR7dHJhbnNmb3JtfWA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0aWVzLmFuZ2xlICE9PSAwKSB7XG4gICAgICB0cmFuc2Zvcm0gPSBgcm90YXRlKCR7cHJvcGVydGllcy5hbmdsZX1kZWcpICR7dHJhbnNmb3JtfWA7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0ubGVuZ3RoID4gMCkge1xuICAgICAgc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy4jcGVuZGluZ1RleHRMYXllcnMuc2l6ZSA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYXNjZW50Q2FjaGUuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGNhbnZhc1xuICAgIH0gb2YgdGhpcy4jY2FudmFzQ29udGV4dHMudmFsdWVzKCkpIHtcbiAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy4jY2FudmFzQ29udGV4dHMuY2xlYXIoKTtcbiAgfVxuICBzdGF0aWMgI2dldEN0eChsYW5nID0gbnVsbCkge1xuICAgIGxldCBjdHggPSB0aGlzLiNjYW52YXNDb250ZXh0cy5nZXQobGFuZyB8fD0gXCJcIik7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICBjYW52YXMuY2xhc3NOYW1lID0gXCJoaWRkZW5DYW52YXNFbGVtZW50XCI7XG4gICAgICBjYW52YXMubGFuZyA9IGxhbmc7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChjYW52YXMpO1xuICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuI2NhbnZhc0NvbnRleHRzLnNldChsYW5nLCBjdHgpO1xuICAgICAgdGhpcy4jY2FudmFzQ3R4Rm9udHMuc2V0KGN0eCwge1xuICAgICAgICBzaXplOiAwLFxuICAgICAgICBmYW1pbHk6IFwiXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3R4O1xuICB9XG4gIHN0YXRpYyAjZW5zdXJlQ3R4Rm9udChjdHgsIHNpemUsIGZhbWlseSkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuI2NhbnZhc0N0eEZvbnRzLmdldChjdHgpO1xuICAgIGlmIChzaXplID09PSBjYWNoZWQuc2l6ZSAmJiBmYW1pbHkgPT09IGNhY2hlZC5mYW1pbHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LmZvbnQgPSBgJHtzaXplfXB4ICR7ZmFtaWx5fWA7XG4gICAgY2FjaGVkLnNpemUgPSBzaXplO1xuICAgIGNhY2hlZC5mYW1pbHkgPSBmYW1pbHk7XG4gIH1cbiAgc3RhdGljICNlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkKCkge1xuICAgIGlmICh0aGlzLiNtaW5Gb250U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICBkaXYuc3R5bGUubGluZUhlaWdodCA9IDE7XG4gICAgZGl2LnN0eWxlLmZvbnRTaXplID0gXCIxcHhcIjtcbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgZGl2LnRleHRDb250ZW50ID0gXCJYXCI7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICB0aGlzLiNtaW5Gb250U2l6ZSA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgZGl2LnJlbW92ZSgpO1xuICB9XG4gIHN0YXRpYyAjZ2V0QXNjZW50KGZvbnRGYW1pbHksIHN0eWxlLCBsYW5nKSB7XG4gICAgY29uc3QgY2FjaGVkQXNjZW50ID0gdGhpcy4jYXNjZW50Q2FjaGUuZ2V0KGZvbnRGYW1pbHkpO1xuICAgIGlmIChjYWNoZWRBc2NlbnQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRBc2NlbnQ7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuI2dldEN0eChsYW5nKTtcbiAgICBjdHguY2FudmFzLndpZHRoID0gY3R4LmNhbnZhcy5oZWlnaHQgPSBERUZBVUxUX0ZPTlRfU0laRTtcbiAgICB0aGlzLiNlbnN1cmVDdHhGb250KGN0eCwgREVGQVVMVF9GT05UX1NJWkUsIGZvbnRGYW1pbHkpO1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQoXCJcIik7XG4gICAgY29uc3QgYXNjZW50ID0gbWV0cmljcy5mb250Qm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgY29uc3QgZGVzY2VudCA9IE1hdGguYWJzKG1ldHJpY3MuZm9udEJvdW5kaW5nQm94RGVzY2VudCk7XG4gICAgY3R4LmNhbnZhcy53aWR0aCA9IGN0eC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICBsZXQgcmF0aW8gPSAwLjg7XG4gICAgaWYgKGFzY2VudCkge1xuICAgICAgcmF0aW8gPSBhc2NlbnQgLyAoYXNjZW50ICsgZGVzY2VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtLmlzRmlyZWZveCkge1xuICAgICAgICB3YXJuKFwiRW5hYmxlIHRoZSBgZG9tLnRleHRNZXRyaWNzLmZvbnRCb3VuZGluZ0JveC5lbmFibGVkYCBwcmVmZXJlbmNlIFwiICsgXCJpbiBgYWJvdXQ6Y29uZmlnYCB0byBpbXByb3ZlIFRleHRMYXllciByZW5kZXJpbmcuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlLmFzY2VudCkge1xuICAgICAgICByYXRpbyA9IHN0eWxlLmFzY2VudDtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGUuZGVzY2VudCkge1xuICAgICAgICByYXRpbyA9IDEgKyBzdHlsZS5kZXNjZW50O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNhc2NlbnRDYWNoZS5zZXQoZm9udEZhbWlseSwgcmF0aW8pO1xuICAgIHJldHVybiByYXRpbztcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS94ZmFfdGV4dC5qc1xuY2xhc3MgWGZhVGV4dCB7XG4gIHN0YXRpYyB0ZXh0Q29udGVudCh4ZmEpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIGl0ZW1zLFxuICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RyID0gbnVsbDtcbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICBpZiAobmFtZSA9PT0gXCIjdGV4dFwiKSB7XG4gICAgICAgIHN0ciA9IG5vZGUudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKCFYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKG5vZGU/LmF0dHJpYnV0ZXM/LnRleHRDb250ZW50KSB7XG4gICAgICAgIHN0ciA9IG5vZGUuYXR0cmlidXRlcy50ZXh0Q29udGVudDtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICBzdHIgPSBub2RlLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0ciAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICBzdHJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICB3YWxrKHhmYSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICBzdGF0aWMgc2hvdWxkQnVpbGRUZXh0KG5hbWUpIHtcbiAgICByZXR1cm4gIShuYW1lID09PSBcInRleHRhcmVhXCIgfHwgbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwib3B0aW9uXCIgfHwgbmFtZSA9PT0gXCJzZWxlY3RcIik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvYXBpLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQgPSAxMDA7XG5mdW5jdGlvbiBnZXREb2N1bWVudChzcmMgPSB7fSkge1xuICBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIiB8fCBzcmMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBzcmMgPSB7XG4gICAgICB1cmw6IHNyY1xuICAgIH07XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHNyYykpIHtcbiAgICBzcmMgPSB7XG4gICAgICBkYXRhOiBzcmNcbiAgICB9O1xuICB9XG4gIGNvbnN0IHRhc2sgPSBuZXcgUERGRG9jdW1lbnRMb2FkaW5nVGFzaygpO1xuICBjb25zdCB7XG4gICAgZG9jSWRcbiAgfSA9IHRhc2s7XG4gIGNvbnN0IHVybCA9IHNyYy51cmwgPyBnZXRVcmxQcm9wKHNyYy51cmwpIDogbnVsbDtcbiAgY29uc3QgZGF0YSA9IHNyYy5kYXRhID8gZ2V0RGF0YVByb3Aoc3JjLmRhdGEpIDogbnVsbDtcbiAgY29uc3QgaHR0cEhlYWRlcnMgPSBzcmMuaHR0cEhlYWRlcnMgfHwgbnVsbDtcbiAgY29uc3Qgd2l0aENyZWRlbnRpYWxzID0gc3JjLndpdGhDcmVkZW50aWFscyA9PT0gdHJ1ZTtcbiAgY29uc3QgcGFzc3dvcmQgPSBzcmMucGFzc3dvcmQgPz8gbnVsbDtcbiAgY29uc3QgcmFuZ2VUcmFuc3BvcnQgPSBzcmMucmFuZ2UgaW5zdGFuY2VvZiBQREZEYXRhUmFuZ2VUcmFuc3BvcnQgPyBzcmMucmFuZ2UgOiBudWxsO1xuICBjb25zdCByYW5nZUNodW5rU2l6ZSA9IE51bWJlci5pc0ludGVnZXIoc3JjLnJhbmdlQ2h1bmtTaXplKSAmJiBzcmMucmFuZ2VDaHVua1NpemUgPiAwID8gc3JjLnJhbmdlQ2h1bmtTaXplIDogMiAqKiAxNjtcbiAgbGV0IHdvcmtlciA9IHNyYy53b3JrZXIgaW5zdGFuY2VvZiBQREZXb3JrZXIgPyBzcmMud29ya2VyIDogbnVsbDtcbiAgY29uc3QgdmVyYm9zaXR5ID0gc3JjLnZlcmJvc2l0eTtcbiAgY29uc3QgZG9jQmFzZVVybCA9IHR5cGVvZiBzcmMuZG9jQmFzZVVybCA9PT0gXCJzdHJpbmdcIiAmJiAhaXNEYXRhU2NoZW1lKHNyYy5kb2NCYXNlVXJsKSA/IHNyYy5kb2NCYXNlVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFVybCA9IGdldEZhY3RvcnlVcmxQcm9wKHNyYy5jTWFwVXJsKTtcbiAgY29uc3QgY01hcFBhY2tlZCA9IHNyYy5jTWFwUGFja2VkICE9PSBmYWxzZTtcbiAgY29uc3QgQ01hcFJlYWRlckZhY3RvcnkgPSBzcmMuQ01hcFJlYWRlckZhY3RvcnkgfHwgKGlzTm9kZUpTID8gTm9kZUNNYXBSZWFkZXJGYWN0b3J5IDogRE9NQ01hcFJlYWRlckZhY3RvcnkpO1xuICBjb25zdCBpY2NVcmwgPSBnZXRGYWN0b3J5VXJsUHJvcChzcmMuaWNjVXJsKTtcbiAgY29uc3Qgc3RhbmRhcmRGb250RGF0YVVybCA9IGdldEZhY3RvcnlVcmxQcm9wKHNyYy5zdGFuZGFyZEZvbnREYXRhVXJsKTtcbiAgY29uc3QgU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBzcmMuU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgfHwgKGlzTm9kZUpTID8gTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IDogRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkpO1xuICBjb25zdCB3YXNtVXJsID0gZ2V0RmFjdG9yeVVybFByb3Aoc3JjLndhc21VcmwpO1xuICBjb25zdCBXYXNtRmFjdG9yeSA9IHNyYy5XYXNtRmFjdG9yeSB8fCAoaXNOb2RlSlMgPyBOb2RlV2FzbUZhY3RvcnkgOiBET01XYXNtRmFjdG9yeSk7XG4gIGNvbnN0IGlnbm9yZUVycm9ycyA9IHNyYy5zdG9wQXRFcnJvcnMgIT09IHRydWU7XG4gIGNvbnN0IG1heEltYWdlU2l6ZSA9IE51bWJlci5pc0ludGVnZXIoc3JjLm1heEltYWdlU2l6ZSkgJiYgc3JjLm1heEltYWdlU2l6ZSA+IC0xID8gc3JjLm1heEltYWdlU2l6ZSA6IC0xO1xuICBjb25zdCBpc0V2YWxTdXBwb3J0ZWQgPSBzcmMuaXNFdmFsU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgY29uc3QgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA6ICFpc05vZGVKUztcbiAgY29uc3QgaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc0ltYWdlRGVjb2RlclN1cHBvcnRlZCA6ICFpc05vZGVKUyAmJiAodXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc0ZpcmVmb3ggfHwgIWdsb2JhbFRoaXMuY2hyb21lKTtcbiAgY29uc3QgY2FudmFzTWF4QXJlYUluQnl0ZXMgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5jYW52YXNNYXhBcmVhSW5CeXRlcykgPyBzcmMuY2FudmFzTWF4QXJlYUluQnl0ZXMgOiAtMTtcbiAgY29uc3QgZGlzYWJsZUZvbnRGYWNlID0gdHlwZW9mIHNyYy5kaXNhYmxlRm9udEZhY2UgPT09IFwiYm9vbGVhblwiID8gc3JjLmRpc2FibGVGb250RmFjZSA6IGlzTm9kZUpTO1xuICBjb25zdCBmb250RXh0cmFQcm9wZXJ0aWVzID0gc3JjLmZvbnRFeHRyYVByb3BlcnRpZXMgPT09IHRydWU7XG4gIGNvbnN0IGVuYWJsZVhmYSA9IHNyYy5lbmFibGVYZmEgPT09IHRydWU7XG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBzcmMub3duZXJEb2N1bWVudCB8fCBnbG9iYWxUaGlzLmRvY3VtZW50O1xuICBjb25zdCBkaXNhYmxlUmFuZ2UgPSBzcmMuZGlzYWJsZVJhbmdlID09PSB0cnVlO1xuICBjb25zdCBkaXNhYmxlU3RyZWFtID0gc3JjLmRpc2FibGVTdHJlYW0gPT09IHRydWU7XG4gIGNvbnN0IGRpc2FibGVBdXRvRmV0Y2ggPSBzcmMuZGlzYWJsZUF1dG9GZXRjaCA9PT0gdHJ1ZTtcbiAgY29uc3QgcGRmQnVnID0gc3JjLnBkZkJ1ZyA9PT0gdHJ1ZTtcbiAgY29uc3QgQ2FudmFzRmFjdG9yeSA9IHNyYy5DYW52YXNGYWN0b3J5IHx8IChpc05vZGVKUyA/IE5vZGVDYW52YXNGYWN0b3J5IDogRE9NQ2FudmFzRmFjdG9yeSk7XG4gIGNvbnN0IEZpbHRlckZhY3RvcnkgPSBzcmMuRmlsdGVyRmFjdG9yeSB8fCAoaXNOb2RlSlMgPyBOb2RlRmlsdGVyRmFjdG9yeSA6IERPTUZpbHRlckZhY3RvcnkpO1xuICBjb25zdCBlbmFibGVIV0EgPSBzcmMuZW5hYmxlSFdBID09PSB0cnVlO1xuICBjb25zdCB1c2VXYXNtID0gc3JjLnVzZVdhc20gIT09IGZhbHNlO1xuICBjb25zdCBsZW5ndGggPSByYW5nZVRyYW5zcG9ydCA/IHJhbmdlVHJhbnNwb3J0Lmxlbmd0aCA6IHNyYy5sZW5ndGggPz8gTmFOO1xuICBjb25zdCB1c2VTeXN0ZW1Gb250cyA9IHR5cGVvZiBzcmMudXNlU3lzdGVtRm9udHMgPT09IFwiYm9vbGVhblwiID8gc3JjLnVzZVN5c3RlbUZvbnRzIDogIWlzTm9kZUpTICYmICFkaXNhYmxlRm9udEZhY2U7XG4gIGNvbnN0IHVzZVdvcmtlckZldGNoID0gdHlwZW9mIHNyYy51c2VXb3JrZXJGZXRjaCA9PT0gXCJib29sZWFuXCIgPyBzcmMudXNlV29ya2VyRmV0Y2ggOiAhIShDTWFwUmVhZGVyRmFjdG9yeSA9PT0gRE9NQ01hcFJlYWRlckZhY3RvcnkgJiYgU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPT09IERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ICYmIFdhc21GYWN0b3J5ID09PSBET01XYXNtRmFjdG9yeSAmJiBjTWFwVXJsICYmIHN0YW5kYXJkRm9udERhdGFVcmwgJiYgd2FzbVVybCAmJiBpc1ZhbGlkRmV0Y2hVcmwoY01hcFVybCwgZG9jdW1lbnQuYmFzZVVSSSkgJiYgaXNWYWxpZEZldGNoVXJsKHN0YW5kYXJkRm9udERhdGFVcmwsIGRvY3VtZW50LmJhc2VVUkkpICYmIGlzVmFsaWRGZXRjaFVybCh3YXNtVXJsLCBkb2N1bWVudC5iYXNlVVJJKSk7XG4gIGNvbnN0IHN0eWxlRWxlbWVudCA9IG51bGw7XG4gIHNldFZlcmJvc2l0eUxldmVsKHZlcmJvc2l0eSk7XG4gIGNvbnN0IHRyYW5zcG9ydEZhY3RvcnkgPSB7XG4gICAgY2FudmFzRmFjdG9yeTogbmV3IENhbnZhc0ZhY3Rvcnkoe1xuICAgICAgb3duZXJEb2N1bWVudCxcbiAgICAgIGVuYWJsZUhXQVxuICAgIH0pLFxuICAgIGZpbHRlckZhY3Rvcnk6IG5ldyBGaWx0ZXJGYWN0b3J5KHtcbiAgICAgIGRvY0lkLFxuICAgICAgb3duZXJEb2N1bWVudFxuICAgIH0pLFxuICAgIGNNYXBSZWFkZXJGYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgQ01hcFJlYWRlckZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogY01hcFVybCxcbiAgICAgIGlzQ29tcHJlc3NlZDogY01hcFBhY2tlZFxuICAgIH0pLFxuICAgIHN0YW5kYXJkRm9udERhdGFGYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogc3RhbmRhcmRGb250RGF0YVVybFxuICAgIH0pLFxuICAgIHdhc21GYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgV2FzbUZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogd2FzbVVybFxuICAgIH0pXG4gIH07XG4gIGlmICghd29ya2VyKSB7XG4gICAgd29ya2VyID0gUERGV29ya2VyLmNyZWF0ZSh7XG4gICAgICB2ZXJib3NpdHksXG4gICAgICBwb3J0OiBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclBvcnRcbiAgICB9KTtcbiAgICB0YXNrLl93b3JrZXIgPSB3b3JrZXI7XG4gIH1cbiAgY29uc3QgZG9jUGFyYW1zID0ge1xuICAgIGRvY0lkLFxuICAgIGFwaVZlcnNpb246IFwiNS40LjE0OVwiLFxuICAgIGRhdGEsXG4gICAgcGFzc3dvcmQsXG4gICAgZGlzYWJsZUF1dG9GZXRjaCxcbiAgICByYW5nZUNodW5rU2l6ZSxcbiAgICBsZW5ndGgsXG4gICAgZG9jQmFzZVVybCxcbiAgICBlbmFibGVYZmEsXG4gICAgZXZhbHVhdG9yT3B0aW9uczoge1xuICAgICAgbWF4SW1hZ2VTaXplLFxuICAgICAgZGlzYWJsZUZvbnRGYWNlLFxuICAgICAgaWdub3JlRXJyb3JzLFxuICAgICAgaXNFdmFsU3VwcG9ydGVkLFxuICAgICAgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQsXG4gICAgICBpc0ltYWdlRGVjb2RlclN1cHBvcnRlZCxcbiAgICAgIGNhbnZhc01heEFyZWFJbkJ5dGVzLFxuICAgICAgZm9udEV4dHJhUHJvcGVydGllcyxcbiAgICAgIHVzZVN5c3RlbUZvbnRzLFxuICAgICAgdXNlV2FzbSxcbiAgICAgIHVzZVdvcmtlckZldGNoLFxuICAgICAgY01hcFVybCxcbiAgICAgIGljY1VybCxcbiAgICAgIHN0YW5kYXJkRm9udERhdGFVcmwsXG4gICAgICB3YXNtVXJsXG4gICAgfVxuICB9O1xuICBjb25zdCB0cmFuc3BvcnRQYXJhbXMgPSB7XG4gICAgb3duZXJEb2N1bWVudCxcbiAgICBwZGZCdWcsXG4gICAgc3R5bGVFbGVtZW50LFxuICAgIGxvYWRpbmdQYXJhbXM6IHtcbiAgICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICBlbmFibGVYZmFcbiAgICB9XG4gIH07XG4gIHdvcmtlci5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgIH1cbiAgICBpZiAod29ya2VyLmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHdvcmtlcklkUHJvbWlzZSA9IHdvcmtlci5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREb2NSZXF1ZXN0XCIsIGRvY1BhcmFtcywgZGF0YSA/IFtkYXRhLmJ1ZmZlcl0gOiBudWxsKTtcbiAgICBsZXQgbmV0d29ya1N0cmVhbTtcbiAgICBpZiAocmFuZ2VUcmFuc3BvcnQpIHtcbiAgICAgIG5ldHdvcmtTdHJlYW0gPSBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbShyYW5nZVRyYW5zcG9ydCwge1xuICAgICAgICBkaXNhYmxlUmFuZ2UsXG4gICAgICAgIGRpc2FibGVTdHJlYW1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWRhdGEpIHtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImdldERvY3VtZW50IC0gbm8gYHVybGAgcGFyYW1ldGVyIHByb3ZpZGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IE5ldHdvcmtTdHJlYW0gPSBpc1ZhbGlkRmV0Y2hVcmwodXJsKSA/IFBERkZldGNoU3RyZWFtIDogaXNOb2RlSlMgPyBQREZOb2RlU3RyZWFtIDogUERGTmV0d29ya1N0cmVhbTtcbiAgICAgIG5ldHdvcmtTdHJlYW0gPSBuZXcgTmV0d29ya1N0cmVhbSh7XG4gICAgICAgIHVybCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBodHRwSGVhZGVycyxcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzLFxuICAgICAgICByYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlLFxuICAgICAgICBkaXNhYmxlU3RyZWFtXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtlcklkUHJvbWlzZS50aGVuKHdvcmtlcklkID0+IHtcbiAgICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGFib3J0ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAod29ya2VyLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKGRvY0lkLCB3b3JrZXJJZCwgd29ya2VyLnBvcnQpO1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFdvcmtlclRyYW5zcG9ydChtZXNzYWdlSGFuZGxlciwgdGFzaywgbmV0d29ya1N0cmVhbSwgdHJhbnNwb3J0UGFyYW1zLCB0cmFuc3BvcnRGYWN0b3J5LCBlbmFibGVIV0EpO1xuICAgICAgdGFzay5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcIlJlYWR5XCIsIG51bGwpO1xuICAgIH0pO1xuICB9KS5jYXRjaCh0YXNrLl9jYXBhYmlsaXR5LnJlamVjdCk7XG4gIHJldHVybiB0YXNrO1xufVxuY2xhc3MgUERGRG9jdW1lbnRMb2FkaW5nVGFzayB7XG4gIHN0YXRpYyAjZG9jSWQgPSAwO1xuICBfY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICBfdHJhbnNwb3J0ID0gbnVsbDtcbiAgX3dvcmtlciA9IG51bGw7XG4gIGRvY0lkID0gYGQke1BERkRvY3VtZW50TG9hZGluZ1Rhc2suI2RvY0lkKyt9YDtcbiAgZGVzdHJveWVkID0gZmFsc2U7XG4gIG9uUGFzc3dvcmQgPSBudWxsO1xuICBvblByb2dyZXNzID0gbnVsbDtcbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuX3dvcmtlcj8ucG9ydCkge1xuICAgICAgICB0aGlzLl93b3JrZXIuX3BlbmRpbmdEZXN0cm95ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydD8uZGVzdHJveSgpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAodGhpcy5fd29ya2VyPy5wb3J0KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl93b3JrZXIuX3BlbmRpbmdEZXN0cm95O1xuICAgICAgfVxuICAgICAgdGhyb3cgZXg7XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy5fd29ya2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy5fd29ya2VyID0gbnVsbDtcbiAgfVxuICBhc3luYyBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGF0YSgpO1xuICB9XG59XG5jbGFzcyBQREZEYXRhUmFuZ2VUcmFuc3BvcnQge1xuICAjY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAjcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzID0gW107XG4gICNwcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMgPSBbXTtcbiAgI3Byb2dyZXNzTGlzdGVuZXJzID0gW107XG4gICNyYW5nZUxpc3RlbmVycyA9IFtdO1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIGluaXRpYWxEYXRhLCBwcm9ncmVzc2l2ZURvbmUgPSBmYWxzZSwgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIHRoaXMucHJvZ3Jlc3NpdmVEb25lID0gcHJvZ3Jlc3NpdmVEb25lO1xuICAgIHRoaXMuY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTtcbiAgfVxuICBhZGRSYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy4jcmFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuI3Byb2dyZXNzTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy4jcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy4jcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIG9uRGF0YVJhbmdlKGJlZ2luLCBjaHVuaykge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jcmFuZ2VMaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVyKGJlZ2luLCBjaHVuayk7XG4gICAgfVxuICB9XG4gIG9uRGF0YVByb2dyZXNzKGxvYWRlZCwgdG90YWwpIHtcbiAgICB0aGlzLiNjYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuI3Byb2dyZXNzTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKGxvYWRlZCwgdG90YWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG9uRGF0YVByb2dyZXNzaXZlUmVhZChjaHVuaykge1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvbkRhdGFQcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNwcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0cmFuc3BvcnRSZWFkeSgpIHtcbiAgICB0aGlzLiNjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICByZXF1ZXN0RGF0YVJhbmdlKGJlZ2luLCBlbmQpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBQREZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZVwiKTtcbiAgfVxuICBhYm9ydCgpIHt9XG59XG5jbGFzcyBQREZEb2N1bWVudFByb3h5IHtcbiAgY29uc3RydWN0b3IocGRmSW5mbywgdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fcGRmSW5mbyA9IHBkZkluZm87XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB9XG4gIGdldCBhbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmFubm90YXRpb25TdG9yYWdlO1xuICB9XG4gIGdldCBjYW52YXNGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuY2FudmFzRmFjdG9yeTtcbiAgfVxuICBnZXQgZmlsdGVyRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3Rvcnk7XG4gIH1cbiAgZ2V0IG51bVBhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9wZGZJbmZvLm51bVBhZ2VzO1xuICB9XG4gIGdldCBmaW5nZXJwcmludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8uZmluZ2VycHJpbnRzO1xuICB9XG4gIGdldCBpc1B1cmVYZmEoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzUHVyZVhmYVwiLCAhIXRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSk7XG4gIH1cbiAgZ2V0IGFsbFhmYUh0bWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYTtcbiAgfVxuICBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2UocGFnZU51bWJlcik7XG4gIH1cbiAgZ2V0UGFnZUluZGV4KHJlZikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUluZGV4KHJlZik7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGVzdGluYXRpb25zKCk7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9uKGlkKTtcbiAgfVxuICBnZXRQYWdlTGFiZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxhYmVscygpO1xuICB9XG4gIGdldFBhZ2VMYXlvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGF5b3V0KCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTW9kZSgpO1xuICB9XG4gIGdldFZpZXdlclByZWZlcmVuY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKTtcbiAgfVxuICBnZXRPcGVuQWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3BlbkFjdGlvbigpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QXR0YWNobWVudHMoKTtcbiAgfVxuICBnZXRBbm5vdGF0aW9uc0J5VHlwZSh0eXBlcywgcGFnZUluZGV4ZXNUb1NraXApIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEFubm90YXRpb25zQnlUeXBlKHR5cGVzLCBwYWdlSW5kZXhlc1RvU2tpcCk7XG4gIH1cbiAgZ2V0SlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RG9jSlNBY3Rpb25zKCk7XG4gIH1cbiAgZ2V0T3V0bGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE91dGxpbmUoKTtcbiAgfVxuICBnZXRPcHRpb25hbENvbnRlbnRDb25maWcoe1xuICAgIGludGVudCA9IFwiZGlzcGxheVwiXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlcmluZ0ludGVudFxuICAgIH0gPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcocmVuZGVyaW5nSW50ZW50KTtcbiAgfVxuICBnZXRQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBlcm1pc3Npb25zKCk7XG4gIH1cbiAgZ2V0TWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRNZXRhZGF0YSgpO1xuICB9XG4gIGdldE1hcmtJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWFya0luZm8oKTtcbiAgfVxuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGF0YSgpO1xuICB9XG4gIHNhdmVEb2N1bWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnNhdmVEb2N1bWVudCgpO1xuICB9XG4gIGdldERvd25sb2FkSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmRvd25sb2FkSW5mb0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjbGVhbnVwKGtlZXBMb2FkZWRGb250cyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zdGFydENsZWFudXAoa2VlcExvYWRlZEZvbnRzIHx8IHRoaXMuaXNQdXJlWGZhKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRpbmdUYXNrLmRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZWRQYWdlTnVtYmVyKHJlZikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuY2FjaGVkUGFnZU51bWJlcihyZWYpO1xuICB9XG4gIGdldCBsb2FkaW5nUGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1BhcmFtcztcbiAgfVxuICBnZXQgbG9hZGluZ1Rhc2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5sb2FkaW5nVGFzaztcbiAgfVxuICBnZXRGaWVsZE9iamVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRGaWVsZE9iamVjdHMoKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5oYXNKU0FjdGlvbnMoKTtcbiAgfVxuICBnZXRDYWxjdWxhdGlvbk9yZGVySWRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpO1xuICB9XG59XG5jbGFzcyBQREZQYWdlUHJveHkge1xuICAjcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IocGFnZUluZGV4LCBwYWdlSW5mbywgdHJhbnNwb3J0LCBwZGZCdWcgPSBmYWxzZSkge1xuICAgIHRoaXMuX3BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLl9wYWdlSW5mbyA9IHBhZ2VJbmZvO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0aGlzLl9zdGF0cyA9IHBkZkJ1ZyA/IG5ldyBTdGF0VGltZXIoKSA6IG51bGw7XG4gICAgdGhpcy5fcGRmQnVnID0gcGRmQnVnO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IHRyYW5zcG9ydC5jb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG5ldyBQREZPYmplY3RzKCk7XG4gICAgdGhpcy5faW50ZW50U3RhdGVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5yZWNvcmRlZEdyb3VwcyA9IG51bGw7XG4gIH1cbiAgZ2V0IHBhZ2VOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmRleCArIDE7XG4gIH1cbiAgZ2V0IHJvdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8ucm90YXRlO1xuICB9XG4gIGdldCByZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnJlZjtcbiAgfVxuICBnZXQgdXNlclVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnVzZXJVbml0O1xuICB9XG4gIGdldCB2aWV3KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby52aWV3O1xuICB9XG4gIGdldFZpZXdwb3J0KHtcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvbiA9IHRoaXMucm90YXRlLFxuICAgIG9mZnNldFggPSAwLFxuICAgIG9mZnNldFkgPSAwLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgICAgdmlld0JveDogdGhpcy52aWV3LFxuICAgICAgdXNlclVuaXQ6IHRoaXMudXNlclVuaXQsXG4gICAgICBzY2FsZSxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBkb250RmxpcFxuICAgIH0pO1xuICB9XG4gIGdldEFubm90YXRpb25zKHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIlxuICB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJpbmdJbnRlbnRcbiAgICB9ID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQpO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QW5ub3RhdGlvbnModGhpcy5fcGFnZUluZGV4LCByZW5kZXJpbmdJbnRlbnQpO1xuICB9XG4gIGdldEpTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VKU0FjdGlvbnModGhpcy5fcGFnZUluZGV4KTtcbiAgfVxuICBnZXQgZmlsdGVyRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3Rvcnk7XG4gIH1cbiAgZ2V0IGlzUHVyZVhmYSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNQdXJlWGZhXCIsICEhdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKTtcbiAgfVxuICBhc3luYyBnZXRYZmEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYT8uY2hpbGRyZW5bdGhpcy5fcGFnZUluZGV4XSB8fCBudWxsO1xuICB9XG4gIHJlbmRlcih7XG4gICAgY2FudmFzQ29udGV4dCxcbiAgICBjYW52YXMgPSBjYW52YXNDb250ZXh0LmNhbnZhcyxcbiAgICB2aWV3cG9ydCxcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIixcbiAgICBhbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlLkVOQUJMRSxcbiAgICB0cmFuc2Zvcm0gPSBudWxsLFxuICAgIGJhY2tncm91bmQgPSBudWxsLFxuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgPSBudWxsLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAgPSBudWxsLFxuICAgIHBhZ2VDb2xvcnMgPSBudWxsLFxuICAgIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsLFxuICAgIGlzRWRpdGluZyA9IGZhbHNlLFxuICAgIHJlY29yZE9wZXJhdGlvbnMgPSBmYWxzZSxcbiAgICBmaWx0ZXJlZE9wZXJhdGlvbkluZGV4ZXMgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLl9zdGF0cz8udGltZShcIk92ZXJhbGxcIik7XG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSwgaXNFZGl0aW5nKTtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleVxuICAgIH0gPSBpbnRlbnRBcmdzO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSB8fD0gdGhpcy5fdHJhbnNwb3J0LmdldE9wdGlvbmFsQ29udGVudENvbmZpZyhyZW5kZXJpbmdJbnRlbnQpO1xuICAgIGxldCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIGludGVudFN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5zZXQoY2FjaGVLZXksIGludGVudFN0YXRlKTtcbiAgICB9XG4gICAgaWYgKGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KTtcbiAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpbnRlbnRQcmludCA9ICEhKHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQpO1xuICAgIGlmICghaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgbGFzdENodW5rOiBmYWxzZSxcbiAgICAgICAgc2VwYXJhdGVBbm5vdHM6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3QoaW50ZW50QXJncyk7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZFJlY29yZE9wZXJhdGlvbnMgPSAhdGhpcy5yZWNvcmRlZEdyb3VwcyAmJiAocmVjb3JkT3BlcmF0aW9ucyB8fCB0aGlzLl9wZGZCdWcgJiYgZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlcj8uZW5hYmxlZCk7XG4gICAgY29uc3QgY29tcGxldGUgPSBlcnJvciA9PiB7XG4gICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5kZWxldGUoaW50ZXJuYWxSZW5kZXJUYXNrKTtcbiAgICAgIGlmIChzaG91bGRSZWNvcmRPcGVyYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlY29yZGVkR3JvdXBzID0gaW50ZXJuYWxSZW5kZXJUYXNrLmdmeD8uZGVwZW5kZW5jeVRyYWNrZXIudGFrZSgpO1xuICAgICAgICBpZiAocmVjb3JkZWRHcm91cHMpIHtcbiAgICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suc3RlcHBlcj8uc2V0T3BlcmF0b3JHcm91cHMocmVjb3JkZWRHcm91cHMpO1xuICAgICAgICAgIGlmIChyZWNvcmRPcGVyYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29yZGVkR3JvdXBzID0gcmVjb3JkZWRHcm91cHM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZE9wZXJhdGlvbnMpIHtcbiAgICAgICAgICB0aGlzLnJlY29yZGVkR3JvdXBzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnRlbnRQcmludCkge1xuICAgICAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLiN0cnlDbGVhbnVwKCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcbiAgICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zdGF0cykge1xuICAgICAgICB0aGlzLl9zdGF0cy50aW1lRW5kKFwiUmVuZGVyaW5nXCIpO1xuICAgICAgICB0aGlzLl9zdGF0cy50aW1lRW5kKFwiT3ZlcmFsbFwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuU3RhdHM/LmVuYWJsZWQpIHtcbiAgICAgICAgICBnbG9iYWxUaGlzLlN0YXRzLmFkZCh0aGlzLnBhZ2VOdW1iZXIsIHRoaXMuX3N0YXRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrID0gbmV3IEludGVybmFsUmVuZGVyVGFzayh7XG4gICAgICBjYWxsYmFjazogY29tcGxldGUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgY2FudmFzLFxuICAgICAgICBjYW52YXNDb250ZXh0LFxuICAgICAgICBkZXBlbmRlbmN5VHJhY2tlcjogc2hvdWxkUmVjb3JkT3BlcmF0aW9ucyA/IG5ldyBDYW52YXNEZXBlbmRlbmN5VHJhY2tlcihjYW52YXMpIDogbnVsbCxcbiAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgYmFja2dyb3VuZFxuICAgICAgfSxcbiAgICAgIG9ianM6IHRoaXMub2JqcyxcbiAgICAgIGNvbW1vbk9ianM6IHRoaXMuY29tbW9uT2JqcyxcbiAgICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgICBvcGVyYXRvckxpc3Q6IGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgY2FudmFzRmFjdG9yeTogdGhpcy5fdHJhbnNwb3J0LmNhbnZhc0ZhY3RvcnksXG4gICAgICBmaWx0ZXJGYWN0b3J5OiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeSxcbiAgICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZTogIWludGVudFByaW50LFxuICAgICAgcGRmQnVnOiB0aGlzLl9wZGZCdWcsXG4gICAgICBwYWdlQ29sb3JzLFxuICAgICAgZW5hYmxlSFdBOiB0aGlzLl90cmFuc3BvcnQuZW5hYmxlSFdBLFxuICAgICAgZmlsdGVyZWRPcGVyYXRpb25JbmRleGVzXG4gICAgfSk7XG4gICAgKGludGVudFN0YXRlLnJlbmRlclRhc2tzIHx8PSBuZXcgU2V0KCkpLmFkZChpbnRlcm5hbFJlbmRlclRhc2spO1xuICAgIGNvbnN0IHJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2sudGFzaztcbiAgICBQcm9taXNlLmFsbChbaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLCBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlXSkudGhlbigoW3RyYW5zcGFyZW5jeSwgb3B0aW9uYWxDb250ZW50Q29uZmlnXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUmVuZGVyaW5nXCIpO1xuICAgICAgaWYgKCEob3B0aW9uYWxDb250ZW50Q29uZmlnLnJlbmRlcmluZ0ludGVudCAmIHJlbmRlcmluZ0ludGVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCB1c2UgdGhlIHNhbWUgYGludGVudGAtYXJndW1lbnQgd2hlbiBjYWxsaW5nIHRoZSBgUERGUGFnZVByb3h5LnJlbmRlcmAgXCIgKyBcImFuZCBgUERGRG9jdW1lbnRQcm94eS5nZXRPcHRpb25hbENvbnRlbnRDb25maWdgIG1ldGhvZHMuXCIpO1xuICAgICAgfVxuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmluaXRpYWxpemVHcmFwaGljcyh7XG4gICAgICAgIHRyYW5zcGFyZW5jeSxcbiAgICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gICAgICB9KTtcbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgfSkuY2F0Y2goY29tcGxldGUpO1xuICAgIHJldHVybiByZW5kZXJUYXNrO1xuICB9XG4gIGdldE9wZXJhdG9yTGlzdCh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCIsXG4gICAgYW5ub3RhdGlvbk1vZGUgPSBBbm5vdGF0aW9uTW9kZS5FTkFCTEUsXG4gICAgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsXG4gICAgaXNFZGl0aW5nID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgZnVuY3Rpb24gb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnJlc29sdmUoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KTtcbiAgICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MuZGVsZXRlKG9wTGlzdFRhc2spO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnRlbnRBcmdzID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlLCBwcmludEFubm90YXRpb25TdG9yYWdlLCBpc0VkaXRpbmcsIHRydWUpO1xuICAgIGxldCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoaW50ZW50QXJncy5jYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLnNldChpbnRlbnRBcmdzLmNhY2hlS2V5LCBpbnRlbnRTdGF0ZSk7XG4gICAgfVxuICAgIGxldCBvcExpc3RUYXNrO1xuICAgIGlmICghaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgIG9wTGlzdFRhc2sgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgb3BMaXN0VGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkID0gb3BlcmF0b3JMaXN0Q2hhbmdlZDtcbiAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAoaW50ZW50U3RhdGUucmVuZGVyVGFza3MgfHw9IG5ldyBTZXQoKSkuYWRkKG9wTGlzdFRhc2spO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgbGFzdENodW5rOiBmYWxzZSxcbiAgICAgICAgc2VwYXJhdGVBbm5vdHM6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3QoaW50ZW50QXJncyk7XG4gICAgfVxuICAgIHJldHVybiBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHN0cmVhbVRleHRDb250ZW50KHtcbiAgICBpbmNsdWRlTWFya2VkQ29udGVudCA9IGZhbHNlLFxuICAgIGRpc2FibGVOb3JtYWxpemF0aW9uID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgVEVYVF9DT05URU5UX0NIVU5LX1NJWkUgPSAxMDA7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldFRleHRDb250ZW50XCIsIHtcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgaW5jbHVkZU1hcmtlZENvbnRlbnQ6IGluY2x1ZGVNYXJrZWRDb250ZW50ID09PSB0cnVlLFxuICAgICAgZGlzYWJsZU5vcm1hbGl6YXRpb246IGRpc2FibGVOb3JtYWxpemF0aW9uID09PSB0cnVlXG4gICAgfSwge1xuICAgICAgaGlnaFdhdGVyTWFyazogVEVYVF9DT05URU5UX0NIVU5LX1NJWkUsXG4gICAgICBzaXplKHRleHRDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0ZXh0Q29udGVudC5pdGVtcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnQocGFyYW1zID0ge30pIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRYZmEoKS50aGVuKHhmYSA9PiBYZmFUZXh0LnRleHRDb250ZW50KHhmYSkpO1xuICAgIH1cbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuc3RyZWFtVGV4dENvbnRlbnQocGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0Q29udGVudC5sYW5nID8/PSB2YWx1ZS5sYW5nO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24odGV4dENvbnRlbnQuc3R5bGVzLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICAgIHRleHRDb250ZW50Lml0ZW1zLnB1c2goLi4udmFsdWUuaXRlbXMpO1xuICAgICAgICAgIHB1bXAoKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSB7XG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBsYW5nOiBudWxsXG4gICAgICB9O1xuICAgICAgcHVtcCgpO1xuICAgIH0pO1xuICB9XG4gIGdldFN0cnVjdFRyZWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRTdHJ1Y3RUcmVlKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHdhaXRPbiA9IFtdO1xuICAgIGZvciAoY29uc3QgaW50ZW50U3RhdGUgb2YgdGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICByZWFzb246IG5ldyBFcnJvcihcIlBhZ2Ugd2FzIGRlc3Ryb3llZC5cIiksXG4gICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICAgIHdhaXRPbi5wdXNoKGludGVybmFsUmVuZGVyVGFzay5jb21wbGV0ZWQpO1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHdhaXRPbik7XG4gIH1cbiAgY2xlYW51cChyZXNldFN0YXRzID0gZmFsc2UpIHtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgY29uc3Qgc3VjY2VzcyA9IHRoaXMuI3RyeUNsZWFudXAoKTtcbiAgICBpZiAocmVzZXRTdGF0cyAmJiBzdWNjZXNzKSB7XG4gICAgICB0aGlzLl9zdGF0cyAmJj0gbmV3IFN0YXRUaW1lcigpO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuICAjdHJ5Q2xlYW51cCgpIHtcbiAgICBpZiAoIXRoaXMuI3BlbmRpbmdDbGVhbnVwIHx8IHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qge1xuICAgICAgcmVuZGVyVGFza3MsXG4gICAgICBvcGVyYXRvckxpc3RcbiAgICB9IG9mIHRoaXMuX2ludGVudFN0YXRlcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHJlbmRlclRhc2tzLnNpemUgPiAwIHx8ICFvcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faW50ZW50U3RhdGVzLmNsZWFyKCk7XG4gICAgdGhpcy5vYmpzLmNsZWFyKCk7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc3RhcnRSZW5kZXJQYWdlKHRyYW5zcGFyZW5jeSwgY2FjaGVLZXkpIHtcbiAgICBjb25zdCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHM/LnRpbWVFbmQoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eT8ucmVzb2x2ZSh0cmFuc3BhcmVuY3kpO1xuICB9XG4gIF9yZW5kZXJQYWdlQ2h1bmsob3BlcmF0b3JMaXN0Q2h1bmssIGludGVudFN0YXRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3BlcmF0b3JMaXN0Q2h1bmsubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmZuQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5mbkFycmF5W2ldKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5hcmdzQXJyYXlbaV0pO1xuICAgIH1cbiAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gb3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rO1xuICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5zZXBhcmF0ZUFubm90cyA9IG9wZXJhdG9yTGlzdENodW5rLnNlcGFyYXRlQW5ub3RzO1xuICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH1cbiAgICBpZiAob3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rKSB7XG4gICAgICB0aGlzLiN0cnlDbGVhbnVwKCk7XG4gICAgfVxuICB9XG4gIF9wdW1wT3BlcmF0b3JMaXN0KHtcbiAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgY2FjaGVLZXksXG4gICAgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUsXG4gICAgbW9kaWZpZWRJZHNcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA9IGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlO1xuICAgIGNvbnN0IHJlYWRhYmxlU3RyZWFtID0gdGhpcy5fdHJhbnNwb3J0Lm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoU3RyZWFtKFwiR2V0T3BlcmF0b3JMaXN0XCIsIHtcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgaW50ZW50OiByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleSxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBtYXAsXG4gICAgICBtb2RpZmllZElkc1xuICAgIH0sIHRyYW5zZmVyKTtcbiAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IHJlYWRlcjtcbiAgICBjb25zdCBwdW1wID0gKCkgPT4ge1xuICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVuZGVyUGFnZUNodW5rKHZhbHVlLCBpbnRlbnRTdGF0ZSk7XG4gICAgICAgIHB1bXAoKTtcbiAgICAgIH0sIHJlYXNvbiA9PiB7XG4gICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gdHJ1ZTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy4jdHJ5Q2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBwdW1wKCk7XG4gIH1cbiAgX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICBpbnRlbnRTdGF0ZSxcbiAgICByZWFzb24sXG4gICAgZm9yY2UgPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KTtcbiAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICBpZiAoaW50ZW50U3RhdGUucmVuZGVyVGFza3Muc2l6ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlYXNvbiBpbnN0YW5jZW9mIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbikge1xuICAgICAgICBsZXQgZGVsYXkgPSBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQ7XG4gICAgICAgIGlmIChyZWFzb24uZXh0cmFEZWxheSA+IDAgJiYgcmVhc29uLmV4dHJhRGVsYXkgPCAxMDAwKSB7XG4gICAgICAgICAgZGVsYXkgKz0gcmVhc29uLmV4dHJhRGVsYXk7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlci5jYW5jZWwobmV3IEFib3J0RXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKSkuY2F0Y2goKCkgPT4ge30pO1xuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbY3VyQ2FjaGVLZXksIGN1ckludGVudFN0YXRlXSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMpIHtcbiAgICAgIGlmIChjdXJJbnRlbnRTdGF0ZSA9PT0gaW50ZW50U3RhdGUpIHtcbiAgICAgICAgdGhpcy5faW50ZW50U3RhdGVzLmRlbGV0ZShjdXJDYWNoZUtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICBnZXQgc3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRzO1xuICB9XG59XG5jbGFzcyBQREZXb3JrZXIge1xuICAjY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAjbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAjcG9ydCA9IG51bGw7XG4gICN3ZWJXb3JrZXIgPSBudWxsO1xuICBzdGF0aWMgI2Zha2VXb3JrZXJJZCA9IDA7XG4gIHN0YXRpYyAjaXNXb3JrZXJEaXNhYmxlZCA9IGZhbHNlO1xuICBzdGF0aWMgI3dvcmtlclBvcnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgc3RhdGljIHtcbiAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgIHRoaXMuI2lzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgfHw9IFwiLi9wZGYud29ya2VyLm1qc1wiO1xuICAgIH1cbiAgICB0aGlzLl9pc1NhbWVPcmlnaW4gPSAoYmFzZVVybCwgb3RoZXJVcmwpID0+IHtcbiAgICAgIGNvbnN0IGJhc2UgPSBVUkwucGFyc2UoYmFzZVVybCk7XG4gICAgICBpZiAoIWJhc2U/Lm9yaWdpbiB8fCBiYXNlLm9yaWdpbiA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3RoZXIgPSBuZXcgVVJMKG90aGVyVXJsLCBiYXNlKTtcbiAgICAgIHJldHVybiBiYXNlLm9yaWdpbiA9PT0gb3RoZXIub3JpZ2luO1xuICAgIH07XG4gICAgdGhpcy5fY3JlYXRlQ0ROV3JhcHBlciA9IHVybCA9PiB7XG4gICAgICBjb25zdCB3cmFwcGVyID0gYGF3YWl0IGltcG9ydChcIiR7dXJsfVwiKTtgO1xuICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dyYXBwZXJdLCB7XG4gICAgICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIHRoaXMuZnJvbVBvcnQgPSBwYXJhbXMgPT4ge1xuICAgICAgZGVwcmVjYXRlZChcImBQREZXb3JrZXIuZnJvbVBvcnRgIC0gcGxlYXNlIHVzZSBgUERGV29ya2VyLmNyZWF0ZWAgaW5zdGVhZC5cIik7XG4gICAgICBpZiAoIXBhcmFtcz8ucG9ydCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuZnJvbVBvcnQgLSBpbnZhbGlkIG1ldGhvZCBzaWduYXR1cmUuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHBhcmFtcyk7XG4gICAgfTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZSA9IG51bGwsXG4gICAgcG9ydCA9IG51bGwsXG4gICAgdmVyYm9zaXR5ID0gZ2V0VmVyYm9zaXR5TGV2ZWwoKVxuICB9ID0ge30pIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy52ZXJib3NpdHkgPSB2ZXJib3NpdHk7XG4gICAgaWYgKHBvcnQpIHtcbiAgICAgIGlmIChQREZXb3JrZXIuI3dvcmtlclBvcnRzLmhhcyhwb3J0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIG1vcmUgdGhhbiBvbmUgUERGV29ya2VyIHBlciBwb3J0LlwiKTtcbiAgICAgIH1cbiAgICAgIFBERldvcmtlci4jd29ya2VyUG9ydHMuc2V0KHBvcnQsIHRoaXMpO1xuICAgICAgdGhpcy4jaW5pdGlhbGl6ZUZyb21Qb3J0KHBvcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNpbml0aWFsaXplKCk7XG4gICAgfVxuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLiNjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgI3Jlc29sdmUoKSB7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgdGhpcy4jbWVzc2FnZUhhbmRsZXIuc2VuZChcImNvbmZpZ3VyZVwiLCB7XG4gICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHBvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvcnQ7XG4gIH1cbiAgZ2V0IG1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIHJldHVybiB0aGlzLiNtZXNzYWdlSGFuZGxlcjtcbiAgfVxuICAjaW5pdGlhbGl6ZUZyb21Qb3J0KHBvcnQpIHtcbiAgICB0aGlzLiNwb3J0ID0gcG9ydDtcbiAgICB0aGlzLiNtZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihcIm1haW5cIiwgXCJ3b3JrZXJcIiwgcG9ydCk7XG4gICAgdGhpcy4jbWVzc2FnZUhhbmRsZXIub24oXCJyZWFkeVwiLCAoKSA9PiB7fSk7XG4gICAgdGhpcy4jcmVzb2x2ZSgpO1xuICB9XG4gICNpbml0aWFsaXplKCkge1xuICAgIGlmIChQREZXb3JrZXIuI2lzV29ya2VyRGlzYWJsZWQgfHwgUERGV29ya2VyLiNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMuI3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQge1xuICAgICAgd29ya2VyU3JjXG4gICAgfSA9IFBERldvcmtlcjtcbiAgICB0cnkge1xuICAgICAgaWYgKCFQREZXb3JrZXIuX2lzU2FtZU9yaWdpbih3aW5kb3cubG9jYXRpb24sIHdvcmtlclNyYykpIHtcbiAgICAgICAgd29ya2VyU3JjID0gUERGV29ya2VyLl9jcmVhdGVDRE5XcmFwcGVyKG5ldyBVUkwod29ya2VyU3JjLCB3aW5kb3cubG9jYXRpb24pLmhyZWYpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJTcmMsIHtcbiAgICAgICAgdHlwZTogXCJtb2R1bGVcIlxuICAgICAgfSk7XG4gICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihcIm1haW5cIiwgXCJ3b3JrZXJcIiwgd29ya2VyKTtcbiAgICAgIGNvbnN0IHRlcm1pbmF0ZUVhcmx5ID0gKCkgPT4ge1xuICAgICAgICBhYy5hYm9ydCgpO1xuICAgICAgICBtZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhpcy4jY2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLiN3ZWJXb3JrZXIpIHtcbiAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbDogYWMuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwidGVzdFwiLCBkYXRhID0+IHtcbiAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkIHx8ICFkYXRhKSB7XG4gICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICAgICAgdGhpcy4jcG9ydCA9IHdvcmtlcjtcbiAgICAgICAgdGhpcy4jd2ViV29ya2VyID0gd29ya2VyO1xuICAgICAgICB0aGlzLiNyZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwicmVhZHlcIiwgZGF0YSA9PiB7XG4gICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2VuZFRlc3QoKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgdGhpcy4jc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2VuZFRlc3QgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlc3RPYmogPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwidGVzdFwiLCB0ZXN0T2JqLCBbdGVzdE9iai5idWZmZXJdKTtcbiAgICAgIH07XG4gICAgICBzZW5kVGVzdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2gge1xuICAgICAgaW5mbyhcIlRoZSB3b3JrZXIgaGFzIGJlZW4gZGlzYWJsZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzZXR1cEZha2VXb3JrZXIoKTtcbiAgfVxuICAjc2V0dXBGYWtlV29ya2VyKCkge1xuICAgIGlmICghUERGV29ya2VyLiNpc1dvcmtlckRpc2FibGVkKSB7XG4gICAgICB3YXJuKFwiU2V0dGluZyB1cCBmYWtlIHdvcmtlci5cIik7XG4gICAgICBQREZXb3JrZXIuI2lzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBQREZXb3JrZXIuX3NldHVwRmFrZVdvcmtlckdsb2JhbC50aGVuKFdvcmtlck1lc3NhZ2VIYW5kbGVyID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aGlzLiNjYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvcnQgPSBuZXcgTG9vcGJhY2tQb3J0KCk7XG4gICAgICB0aGlzLiNwb3J0ID0gcG9ydDtcbiAgICAgIGNvbnN0IGlkID0gYGZha2Uke1BERldvcmtlci4jZmFrZVdvcmtlcklkKyt9YDtcbiAgICAgIGNvbnN0IHdvcmtlckhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoaWQgKyBcIl93b3JrZXJcIiwgaWQsIHBvcnQpO1xuICAgICAgV29ya2VyTWVzc2FnZUhhbmRsZXIuc2V0dXAod29ya2VySGFuZGxlciwgcG9ydCk7XG4gICAgICB0aGlzLiNtZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihpZCwgaWQgKyBcIl93b3JrZXJcIiwgcG9ydCk7XG4gICAgICB0aGlzLiNyZXNvbHZlKCk7XG4gICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRoaXMuI2NhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihgU2V0dGluZyB1cCBmYWtlIHdvcmtlciBmYWlsZWQ6IFwiJHtyZWFzb24ubWVzc2FnZX1cIi5gKSk7XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy4jd2ViV29ya2VyPy50ZXJtaW5hdGUoKTtcbiAgICB0aGlzLiN3ZWJXb3JrZXIgPSBudWxsO1xuICAgIFBERldvcmtlci4jd29ya2VyUG9ydHMuZGVsZXRlKHRoaXMuI3BvcnQpO1xuICAgIHRoaXMuI3BvcnQgPSBudWxsO1xuICAgIHRoaXMuI21lc3NhZ2VIYW5kbGVyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgY29uc3QgY2FjaGVkUG9ydCA9IHRoaXMuI3dvcmtlclBvcnRzLmdldChwYXJhbXM/LnBvcnQpO1xuICAgIGlmIChjYWNoZWRQb3J0KSB7XG4gICAgICBpZiAoY2FjaGVkUG9ydC5fcGVuZGluZ0Rlc3Ryb3kpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUERGV29ya2VyLmNyZWF0ZSAtIHRoZSB3b3JrZXIgaXMgYmVpbmcgZGVzdHJveWVkLlxcblwiICsgXCJQbGVhc2UgcmVtZW1iZXIgdG8gYXdhaXQgYFBERkRvY3VtZW50TG9hZGluZ1Rhc2suZGVzdHJveSgpYC1jYWxscy5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVkUG9ydDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQREZXb3JrZXIocGFyYW1zKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHdvcmtlclNyYygpIHtcbiAgICBpZiAoR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMpIHtcbiAgICAgIHJldHVybiBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBcIkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjXCIgc3BlY2lmaWVkLicpO1xuICB9XG4gIHN0YXRpYyBnZXQgI21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGdsb2JhbFRoaXMucGRmanNXb3JrZXI/Lldvcmtlck1lc3NhZ2VIYW5kbGVyIHx8IG51bGw7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBfc2V0dXBGYWtlV29ya2VyR2xvYmFsKCkge1xuICAgIGNvbnN0IGxvYWRlciA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICh0aGlzLiNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdvcmtlciA9IGF3YWl0IGltcG9ydChcbiAgICAgIC8qd2VicGFja0lnbm9yZTogdHJ1ZSovXG4gICAgICAvKkB2aXRlLWlnbm9yZSovXG4gICAgICB0aGlzLndvcmtlclNyYyk7XG4gICAgICByZXR1cm4gd29ya2VyLldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgIH07XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9zZXR1cEZha2VXb3JrZXJHbG9iYWxcIiwgbG9hZGVyKCkpO1xuICB9XG59XG5jbGFzcyBXb3JrZXJUcmFuc3BvcnQge1xuICAjbWV0aG9kUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICNwYWdlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICNwYWdlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICNwYWdlUmVmQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICNwYXNzd29yZENhcGFiaWxpdHkgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlSGFuZGxlciwgbG9hZGluZ1Rhc2ssIG5ldHdvcmtTdHJlYW0sIHBhcmFtcywgZmFjdG9yeSwgZW5hYmxlSFdBKSB7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2VIYW5kbGVyO1xuICAgIHRoaXMubG9hZGluZ1Rhc2sgPSBsb2FkaW5nVGFzaztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBuZXcgUERGT2JqZWN0cygpO1xuICAgIHRoaXMuZm9udExvYWRlciA9IG5ldyBGb250TG9hZGVyKHtcbiAgICAgIG93bmVyRG9jdW1lbnQ6IHBhcmFtcy5vd25lckRvY3VtZW50LFxuICAgICAgc3R5bGVFbGVtZW50OiBwYXJhbXMuc3R5bGVFbGVtZW50XG4gICAgfSk7XG4gICAgdGhpcy5sb2FkaW5nUGFyYW1zID0gcGFyYW1zLmxvYWRpbmdQYXJhbXM7XG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGZhY3RvcnkuY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmYWN0b3J5LmZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5jTWFwUmVhZGVyRmFjdG9yeSA9IGZhY3RvcnkuY01hcFJlYWRlckZhY3Rvcnk7XG4gICAgdGhpcy5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IGZhY3Rvcnkuc3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG4gICAgdGhpcy53YXNtRmFjdG9yeSA9IGZhY3Rvcnkud2FzbUZhY3Rvcnk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5ID0gbnVsbDtcbiAgICB0aGlzLl9uZXR3b3JrU3RyZWFtID0gbmV0d29ya1N0cmVhbTtcbiAgICB0aGlzLl9mdWxsUmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuZW5hYmxlSFdBID0gZW5hYmxlSFdBO1xuICAgIHRoaXMuc2V0dXBNZXNzYWdlSGFuZGxlcigpO1xuICB9XG4gICNjYWNoZVNpbXBsZU1ldGhvZChuYW1lLCBkYXRhID0gbnVsbCkge1xuICAgIGNvbnN0IGNhY2hlZFByb21pc2UgPSB0aGlzLiNtZXRob2RQcm9taXNlcy5nZXQobmFtZSk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UobmFtZSwgZGF0YSk7XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuc2V0KG5hbWUsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldCBhbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiYW5ub3RhdGlvblN0b3JhZ2VcIiwgbmV3IEFubm90YXRpb25TdG9yYWdlKCkpO1xuICB9XG4gIGdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlID0gQW5ub3RhdGlvbk1vZGUuRU5BQkxFLCBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbCwgaXNFZGl0aW5nID0gZmFsc2UsIGlzT3BMaXN0ID0gZmFsc2UpIHtcbiAgICBsZXQgcmVuZGVyaW5nSW50ZW50ID0gUmVuZGVyaW5nSW50ZW50RmxhZy5ESVNQTEFZO1xuICAgIGxldCBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSA9IFNlcmlhbGl6YWJsZUVtcHR5O1xuICAgIHN3aXRjaCAoaW50ZW50KSB7XG4gICAgICBjYXNlIFwiYW55XCI6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuQU5ZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5XCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInByaW50XCI6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgd2FybihgZ2V0UmVuZGVyaW5nSW50ZW50IC0gaW52YWxpZCBpbnRlbnQ6ICR7aW50ZW50fWApO1xuICAgIH1cbiAgICBjb25zdCBhbm5vdGF0aW9uU3RvcmFnZSA9IHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQgJiYgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSBpbnN0YW5jZW9mIFByaW50QW5ub3RhdGlvblN0b3JhZ2UgPyBwcmludEFubm90YXRpb25TdG9yYWdlIDogdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBzd2l0Y2ggKGFubm90YXRpb25Nb2RlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25Nb2RlLkRJU0FCTEU6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX0RJU0FCTEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uTW9kZS5FTkFCTEU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uTW9kZS5FTkFCTEVfRk9STVM6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX0ZPUk1TO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRU5BQkxFX1NUT1JBR0U6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX1NUT1JBR0U7XG4gICAgICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlID0gYW5ub3RhdGlvblN0b3JhZ2Uuc2VyaWFsaXphYmxlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdhcm4oYGdldFJlbmRlcmluZ0ludGVudCAtIGludmFsaWQgYW5ub3RhdGlvbk1vZGU6ICR7YW5ub3RhdGlvbk1vZGV9YCk7XG4gICAgfVxuICAgIGlmIChpc0VkaXRpbmcpIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLklTX0VESVRJTkc7XG4gICAgfVxuICAgIGlmIChpc09wTGlzdCkge1xuICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuT1BMSVNUO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpZHM6IG1vZGlmaWVkSWRzLFxuICAgICAgaGFzaDogbW9kaWZpZWRJZHNIYXNoXG4gICAgfSA9IGFubm90YXRpb25TdG9yYWdlLm1vZGlmaWVkSWRzO1xuICAgIGNvbnN0IGNhY2hlS2V5QnVmID0gW3JlbmRlcmluZ0ludGVudCwgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUuaGFzaCwgbW9kaWZpZWRJZHNIYXNoXTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXk6IGNhY2hlS2V5QnVmLmpvaW4oXCJfXCIpLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUsXG4gICAgICBtb2RpZmllZElkc1xuICAgIH07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95Q2FwYWJpbGl0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHk/LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZCBkdXJpbmcgb25QYXNzd29yZCBjYWxsYmFja1wiKSk7XG4gICAgY29uc3Qgd2FpdE9uID0gW107XG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgd2FpdE9uLnB1c2gocGFnZS5fZGVzdHJveSgpKTtcbiAgICB9XG4gICAgdGhpcy4jcGFnZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy4jcGFnZVByb21pc2VzLmNsZWFyKCk7XG4gICAgdGhpcy4jcGFnZVJlZkNhY2hlLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoXCJhbm5vdGF0aW9uU3RvcmFnZVwiKSkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5yZXNldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHRlcm1pbmF0ZWQgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIlRlcm1pbmF0ZVwiLCBudWxsKTtcbiAgICB3YWl0T24ucHVzaCh0ZXJtaW5hdGVkKTtcbiAgICBQcm9taXNlLmFsbCh3YWl0T24pLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5jb21tb25PYmpzLmNsZWFyKCk7XG4gICAgICB0aGlzLmZvbnRMb2FkZXIuY2xlYXIoKTtcbiAgICAgIHRoaXMuI21ldGhvZFByb21pc2VzLmNsZWFyKCk7XG4gICAgICB0aGlzLmZpbHRlckZhY3RvcnkuZGVzdHJveSgpO1xuICAgICAgVGV4dExheWVyLmNsZWFudXAoKTtcbiAgICAgIHRoaXMuX25ldHdvcmtTdHJlYW0/LmNhbmNlbEFsbFJlcXVlc3RzKG5ldyBBYm9ydEV4Y2VwdGlvbihcIldvcmtlciB3YXMgdGVybWluYXRlZC5cIikpO1xuICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcj8uZGVzdHJveSgpO1xuICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9LCB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBzZXR1cE1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLFxuICAgICAgbG9hZGluZ1Rhc2tcbiAgICB9ID0gdGhpcztcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldFJlYWRlclwiLCAoZGF0YSwgc2luaykgPT4ge1xuICAgICAgYXNzZXJ0KHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmVhZGVyIC0gbm8gYElQREZTdHJlYW1gIGluc3RhbmNlIGF2YWlsYWJsZS5cIik7XG4gICAgICB0aGlzLl9mdWxsUmVhZGVyID0gdGhpcy5fbmV0d29ya1N0cmVhbS5nZXRGdWxsUmVhZGVyKCk7XG4gICAgICB0aGlzLl9mdWxsUmVhZGVyLm9uUHJvZ3Jlc3MgPSBldnQgPT4ge1xuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyLCBcIkdldFJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNpbmsub25DYW5jZWwgPSByZWFzb24gPT4ge1xuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgICBzaW5rLnJlYWR5LmNhdGNoKHJlYWR5UmVhc29uID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlJlYWRlckhlYWRlcnNSZWFkeVwiLCBhc3luYyBkYXRhID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuX2Z1bGxSZWFkZXIuaGVhZGVyc1JlYWR5O1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc1N0cmVhbWluZ1N1cHBvcnRlZCxcbiAgICAgICAgaXNSYW5nZVN1cHBvcnRlZCxcbiAgICAgICAgY29udGVudExlbmd0aFxuICAgICAgfSA9IHRoaXMuX2Z1bGxSZWFkZXI7XG4gICAgICBpZiAoIWlzU3RyZWFtaW5nU3VwcG9ydGVkIHx8ICFpc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0UHJvZ3Jlc3MpIHtcbiAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4odGhpcy5fbGFzdFByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLm9uUHJvZ3Jlc3MgPSBldnQgPT4ge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1N0cmVhbWluZ1N1cHBvcnRlZCxcbiAgICAgICAgaXNSYW5nZVN1cHBvcnRlZCxcbiAgICAgICAgY29udGVudExlbmd0aFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldFJhbmdlUmVhZGVyXCIsIChkYXRhLCBzaW5rKSA9PiB7XG4gICAgICBhc3NlcnQodGhpcy5fbmV0d29ya1N0cmVhbSwgXCJHZXRSYW5nZVJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgY29uc3QgcmFuZ2VSZWFkZXIgPSB0aGlzLl9uZXR3b3JrU3RyZWFtLmdldFJhbmdlUmVhZGVyKGRhdGEuYmVnaW4sIGRhdGEuZW5kKTtcbiAgICAgIGlmICghcmFuZ2VSZWFkZXIpIHtcbiAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJHZXRSYW5nZVJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNpbmsub25DYW5jZWwgPSByZWFzb24gPT4ge1xuICAgICAgICByYW5nZVJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXREb2NcIiwgKHtcbiAgICAgIHBkZkluZm9cbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLl9udW1QYWdlcyA9IHBkZkluZm8ubnVtUGFnZXM7XG4gICAgICB0aGlzLl9odG1sRm9yWGZhID0gcGRmSW5mby5odG1sRm9yWGZhO1xuICAgICAgZGVsZXRlIHBkZkluZm8uaHRtbEZvclhmYTtcbiAgICAgIGxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnJlc29sdmUobmV3IFBERkRvY3VtZW50UHJveHkocGRmSW5mbywgdGhpcykpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRG9jRXhjZXB0aW9uXCIsIGV4ID0+IHtcbiAgICAgIGxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGV4KSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJQYXNzd29yZFJlcXVlc3RcIiwgZXggPT4ge1xuICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWxvYWRpbmdUYXNrLm9uUGFzc3dvcmQpIHtcbiAgICAgICAgICB0aHJvdyB3cmFwUmVhc29uKGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVQYXNzd29yZCA9IHBhc3N3b3JkID0+IHtcbiAgICAgICAgICBpZiAocGFzc3dvcmQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChwYXNzd29yZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgcGFzc3dvcmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbG9hZGluZ1Rhc2sub25QYXNzd29yZCh1cGRhdGVQYXNzd29yZCwgZXguY29kZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRGF0YUxvYWRlZFwiLCBkYXRhID0+IHtcbiAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZGF0YS5sZW5ndGgsXG4gICAgICAgIHRvdGFsOiBkYXRhLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICB0aGlzLmRvd25sb2FkSW5mb0NhcGFiaWxpdHkucmVzb2x2ZShkYXRhKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlN0YXJ0UmVuZGVyUGFnZVwiLCBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlID0gdGhpcy4jcGFnZUNhY2hlLmdldChkYXRhLnBhZ2VJbmRleCk7XG4gICAgICBwYWdlLl9zdGFydFJlbmRlclBhZ2UoZGF0YS50cmFuc3BhcmVuY3ksIGRhdGEuY2FjaGVLZXkpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiY29tbW9ub2JqXCIsIChbaWQsIHR5cGUsIGV4cG9ydGVkRGF0YV0pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbW1vbk9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gZXhwb3J0ZWREYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZEVycm9yID0gZXhwb3J0ZWREYXRhLmVycm9yO1xuICAgICAgICAgICAgd2FybihgRXJyb3IgZHVyaW5nIGZvbnQgbG9hZGluZzogJHtleHBvcnRlZEVycm9yfWApO1xuICAgICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGV4cG9ydGVkRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGluc3BlY3RGb250ID0gdGhpcy5fcGFyYW1zLnBkZkJ1ZyAmJiBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3I/LmVuYWJsZWQgPyAoZm9udCwgdXJsKSA9PiBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3IuZm9udEFkZGVkKGZvbnQsIHVybCkgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGZvbnQgPSBuZXcgRm9udEZhY2VPYmplY3QoZXhwb3J0ZWREYXRhLCBpbnNwZWN0Rm9udCk7XG4gICAgICAgICAgdGhpcy5mb250TG9hZGVyLmJpbmQoZm9udCkuY2F0Y2goKCkgPT4gbWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiRm9udEZhbGxiYWNrXCIsIHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSkpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFmb250LmZvbnRFeHRyYVByb3BlcnRpZXMgJiYgZm9udC5kYXRhKSB7XG4gICAgICAgICAgICAgIGZvbnQuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZm9udCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDb3B5TG9jYWxJbWFnZVwiOlxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGltYWdlUmVmXG4gICAgICAgICAgfSA9IGV4cG9ydGVkRGF0YTtcbiAgICAgICAgICBhc3NlcnQoaW1hZ2VSZWYsIFwiVGhlIGltYWdlUmVmIG11c3QgYmUgZGVmaW5lZC5cIik7XG4gICAgICAgICAgZm9yIChjb25zdCBwYWdlUHJveHkgb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIGRhdGFdIG9mIHBhZ2VQcm94eS5vYmpzKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhPy5yZWYgIT09IGltYWdlUmVmKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhLmRhdGFMZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgc3RydWN0dXJlZENsb25lKGRhdGEpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZGF0YUxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGb250UGF0aFwiOlxuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZXhwb3J0ZWREYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIGNvbW1vbiBvYmplY3QgdHlwZSAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIm9ialwiLCAoW2lkLCBwYWdlSW5kZXgsIHR5cGUsIGltYWdlRGF0YV0pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlUHJveHkgPSB0aGlzLiNwYWdlQ2FjaGUuZ2V0KHBhZ2VJbmRleCk7XG4gICAgICBpZiAocGFnZVByb3h5Lm9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocGFnZVByb3h5Ll9pbnRlbnRTdGF0ZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBpbWFnZURhdGE/LmJpdG1hcD8uY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJJbWFnZVwiOlxuICAgICAgICBjYXNlIFwiUGF0dGVyblwiOlxuICAgICAgICAgIHBhZ2VQcm94eS5vYmpzLnJlc29sdmUoaWQsIGltYWdlRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5rbm93biBvYmplY3QgdHlwZSAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEb2NQcm9ncmVzc1wiLCBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGRhdGEubG9hZGVkLFxuICAgICAgICB0b3RhbDogZGF0YS50b3RhbFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJGZXRjaEJpbmFyeURhdGFcIiwgYXN5bmMgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXNbZGF0YS50eXBlXTtcbiAgICAgIGlmICghZmFjdG9yeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZGF0YS50eXBlfSBub3QgaW5pdGlhbGl6ZWQsIHNlZSB0aGUgXFxgdXNlV29ya2VyRmV0Y2hcXGAgcGFyYW1ldGVyLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhY3RvcnkuZmV0Y2goZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREYXRhXCIsIG51bGwpO1xuICB9XG4gIHNhdmVEb2N1bWVudCgpIHtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zaXplIDw9IDApIHtcbiAgICAgIHdhcm4oXCJzYXZlRG9jdW1lbnQgY2FsbGVkIHdoaWxlIGBhbm5vdGF0aW9uU3RvcmFnZWAgaXMgZW1wdHksIFwiICsgXCJwbGVhc2UgdXNlIHRoZSBnZXREYXRhLW1ldGhvZCBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgdHJhbnNmZXJcbiAgICB9ID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXJpYWxpemFibGU7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiU2F2ZURvY3VtZW50XCIsIHtcbiAgICAgIGlzUHVyZVhmYTogISF0aGlzLl9odG1sRm9yWGZhLFxuICAgICAgbnVtUGFnZXM6IHRoaXMuX251bVBhZ2VzLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IG1hcCxcbiAgICAgIGZpbGVuYW1lOiB0aGlzLl9mdWxsUmVhZGVyPy5maWxlbmFtZSA/PyBudWxsXG4gICAgfSwgdHJhbnNmZXIpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5yZXNldE1vZGlmaWVkKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0UGFnZShwYWdlTnVtYmVyKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHBhZ2VOdW1iZXIpIHx8IHBhZ2VOdW1iZXIgPD0gMCB8fCBwYWdlTnVtYmVyID4gdGhpcy5fbnVtUGFnZXMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZ2UgcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICBjb25zdCBwYWdlSW5kZXggPSBwYWdlTnVtYmVyIC0gMSxcbiAgICAgIGNhY2hlZFByb21pc2UgPSB0aGlzLiNwYWdlUHJvbWlzZXMuZ2V0KHBhZ2VJbmRleCk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pLnRoZW4ocGFnZUluZm8gPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydCBkZXN0cm95ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAocGFnZUluZm8ucmVmU3RyKSB7XG4gICAgICAgIHRoaXMuI3BhZ2VSZWZDYWNoZS5zZXQocGFnZUluZm8ucmVmU3RyLCBwYWdlTnVtYmVyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2UgPSBuZXcgUERGUGFnZVByb3h5KHBhZ2VJbmRleCwgcGFnZUluZm8sIHRoaXMsIHRoaXMuX3BhcmFtcy5wZGZCdWcpO1xuICAgICAgdGhpcy4jcGFnZUNhY2hlLnNldChwYWdlSW5kZXgsIHBhZ2UpO1xuICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfSk7XG4gICAgdGhpcy4jcGFnZVByb21pc2VzLnNldChwYWdlSW5kZXgsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldFBhZ2VJbmRleChyZWYpIHtcbiAgICBpZiAoIWlzUmVmUHJveHkocmVmKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZUluZGV4IHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUluZGV4XCIsIHtcbiAgICAgIG51bTogcmVmLm51bSxcbiAgICAgIGdlbjogcmVmLmdlblxuICAgIH0pO1xuICB9XG4gIGdldEFubm90YXRpb25zKHBhZ2VJbmRleCwgaW50ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0QW5ub3RhdGlvbnNcIiwge1xuICAgICAgcGFnZUluZGV4LFxuICAgICAgaW50ZW50XG4gICAgfSk7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldEZpZWxkT2JqZWN0c1wiKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiSGFzSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Q2FsY3VsYXRpb25PcmRlcklkc1wiLCBudWxsKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25zXCIsIG51bGwpO1xuICB9XG4gIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgZGVzdGluYXRpb24gcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvblwiLCB7XG4gICAgICBpZFxuICAgIH0pO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUxhYmVsc1wiLCBudWxsKTtcbiAgfVxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VMYXlvdXRcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZU1vZGVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Vmlld2VyUHJlZmVyZW5jZXNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPcGVuQWN0aW9uXCIsIG51bGwpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEF0dGFjaG1lbnRzXCIsIG51bGwpO1xuICB9XG4gIGdldEFubm90YXRpb25zQnlUeXBlKHR5cGVzLCBwYWdlSW5kZXhlc1RvU2tpcCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEFubm90YXRpb25zQnlUeXBlXCIsIHtcbiAgICAgIHR5cGVzLFxuICAgICAgcGFnZUluZGV4ZXNUb1NraXBcbiAgICB9KTtcbiAgfVxuICBnZXREb2NKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiR2V0RG9jSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldFBhZ2VKU0FjdGlvbnMocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUpTQWN0aW9uc1wiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuICBnZXRTdHJ1Y3RUcmVlKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFN0cnVjdFRyZWVcIiwge1xuICAgICAgcGFnZUluZGV4XG4gICAgfSk7XG4gIH1cbiAgZ2V0T3V0bGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPdXRsaW5lXCIsIG51bGwpO1xuICB9XG4gIGdldE9wdGlvbmFsQ29udGVudENvbmZpZyhyZW5kZXJpbmdJbnRlbnQpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXRPcHRpb25hbENvbnRlbnRDb25maWdcIikudGhlbihkYXRhID0+IG5ldyBPcHRpb25hbENvbnRlbnRDb25maWcoZGF0YSwgcmVuZGVyaW5nSW50ZW50KSk7XG4gIH1cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGVybWlzc2lvbnNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0TWV0YWRhdGEoKSB7XG4gICAgY29uc3QgbmFtZSA9IFwiR2V0TWV0YWRhdGFcIixcbiAgICAgIGNhY2hlZFByb21pc2UgPSB0aGlzLiNtZXRob2RQcm9taXNlcy5nZXQobmFtZSk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UobmFtZSwgbnVsbCkudGhlbihyZXN1bHRzID0+ICh7XG4gICAgICBpbmZvOiByZXN1bHRzWzBdLFxuICAgICAgbWV0YWRhdGE6IHJlc3VsdHNbMV0gPyBuZXcgTWV0YWRhdGEocmVzdWx0c1sxXSkgOiBudWxsLFxuICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU6IHRoaXMuX2Z1bGxSZWFkZXI/LmZpbGVuYW1lID8/IG51bGwsXG4gICAgICBjb250ZW50TGVuZ3RoOiB0aGlzLl9mdWxsUmVhZGVyPy5jb250ZW50TGVuZ3RoID8/IG51bGxcbiAgICB9KSk7XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuc2V0KG5hbWUsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldE1hcmtJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE1hcmtJbmZvXCIsIG51bGwpO1xuICB9XG4gIGFzeW5jIHN0YXJ0Q2xlYW51cChrZWVwTG9hZGVkRm9udHMgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkNsZWFudXBcIiwgbnVsbCk7XG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgY29uc3QgY2xlYW51cFN1Y2Nlc3NmdWwgPSBwYWdlLmNsZWFudXAoKTtcbiAgICAgIGlmICghY2xlYW51cFN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdGFydENsZWFudXA6IFBhZ2UgJHtwYWdlLnBhZ2VOdW1iZXJ9IGlzIGN1cnJlbnRseSByZW5kZXJpbmcuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29tbW9uT2Jqcy5jbGVhcigpO1xuICAgIGlmICgha2VlcExvYWRlZEZvbnRzKSB7XG4gICAgICB0aGlzLmZvbnRMb2FkZXIuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuY2xlYXIoKTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkuZGVzdHJveSh0cnVlKTtcbiAgICBUZXh0TGF5ZXIuY2xlYW51cCgpO1xuICB9XG4gIGNhY2hlZFBhZ2VOdW1iZXIocmVmKSB7XG4gICAgaWYgKCFpc1JlZlByb3h5KHJlZikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWZTdHIgPSByZWYuZ2VuID09PSAwID8gYCR7cmVmLm51bX1SYCA6IGAke3JlZi5udW19UiR7cmVmLmdlbn1gO1xuICAgIHJldHVybiB0aGlzLiNwYWdlUmVmQ2FjaGUuZ2V0KHJlZlN0cikgPz8gbnVsbDtcbiAgfVxufVxuY2xhc3MgUmVuZGVyVGFzayB7XG4gICNpbnRlcm5hbFJlbmRlclRhc2sgPSBudWxsO1xuICBvbkNvbnRpbnVlID0gbnVsbDtcbiAgb25FcnJvciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGludGVybmFsUmVuZGVyVGFzaykge1xuICAgIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzaztcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwoZXh0cmFEZWxheSA9IDApIHtcbiAgICB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2suY2FuY2VsKG51bGwsIGV4dHJhRGVsYXkpO1xuICB9XG4gIGdldCBzZXBhcmF0ZUFubm90cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBzZXBhcmF0ZUFubm90c1xuICAgIH0gPSB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0O1xuICAgIGlmICghc2VwYXJhdGVBbm5vdHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkNhbnZhc01hcFxuICAgIH0gPSB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2s7XG4gICAgcmV0dXJuIHNlcGFyYXRlQW5ub3RzLmZvcm0gfHwgc2VwYXJhdGVBbm5vdHMuY2FudmFzICYmIGFubm90YXRpb25DYW52YXNNYXA/LnNpemUgPiAwO1xuICB9XG59XG5jbGFzcyBJbnRlcm5hbFJlbmRlclRhc2sge1xuICAjckFGID0gbnVsbDtcbiAgc3RhdGljICNjYW52YXNJblVzZSA9IG5ldyBXZWFrU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjYWxsYmFjayxcbiAgICBwYXJhbXMsXG4gICAgb2JqcyxcbiAgICBjb21tb25PYmpzLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgb3BlcmF0b3JMaXN0LFxuICAgIHBhZ2VJbmRleCxcbiAgICBjYW52YXNGYWN0b3J5LFxuICAgIGZpbHRlckZhY3RvcnksXG4gICAgdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZmFsc2UsXG4gICAgcGRmQnVnID0gZmFsc2UsXG4gICAgcGFnZUNvbG9ycyA9IG51bGwsXG4gICAgZW5hYmxlSFdBID0gZmFsc2UsXG4gICAgZmlsdGVyZWRPcGVyYXRpb25JbmRleGVzID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gbnVsbDtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IG9wZXJhdG9yTGlzdDtcbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmaWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLnBhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHRydWUgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMudGFzayA9IG5ldyBSZW5kZXJUYXNrKHRoaXMpO1xuICAgIHRoaXMuX2NhbmNlbEJvdW5kID0gdGhpcy5jYW5jZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jb250aW51ZUJvdW5kID0gdGhpcy5fY29udGludWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCA9IHRoaXMuX3NjaGVkdWxlTmV4dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX25leHRCb3VuZCA9IHRoaXMuX25leHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jYW52YXMgPSBwYXJhbXMuY2FudmFzO1xuICAgIHRoaXMuX2NhbnZhc0NvbnRleHQgPSBwYXJhbXMuY2FudmFzID8gbnVsbCA6IHBhcmFtcy5jYW52YXNDb250ZXh0O1xuICAgIHRoaXMuX2VuYWJsZUhXQSA9IGVuYWJsZUhXQTtcbiAgICB0aGlzLl9kZXBlbmRlbmN5VHJhY2tlciA9IHBhcmFtcy5kZXBlbmRlbmN5VHJhY2tlcjtcbiAgICB0aGlzLl9maWx0ZXJlZE9wZXJhdGlvbkluZGV4ZXMgPSBmaWx0ZXJlZE9wZXJhdGlvbkluZGV4ZXM7XG4gIH1cbiAgZ2V0IGNvbXBsZXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYXBhYmlsaXR5LnByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICB9XG4gIGluaXRpYWxpemVHcmFwaGljcyh7XG4gICAgdHJhbnNwYXJlbmN5ID0gZmFsc2UsXG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gIH0pIHtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhbnZhcykge1xuICAgICAgaWYgKEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuaGFzKHRoaXMuX2NhbnZhcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSB0aGUgc2FtZSBjYW52YXMgZHVyaW5nIG11bHRpcGxlIHJlbmRlcigpIG9wZXJhdGlvbnMuIFwiICsgXCJVc2UgZGlmZmVyZW50IGNhbnZhcyBvciBlbnN1cmUgcHJldmlvdXMgb3BlcmF0aW9ucyB3ZXJlIFwiICsgXCJjYW5jZWxsZWQgb3IgY29tcGxldGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuYWRkKHRoaXMuX2NhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wZGZCdWcgJiYgZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlcj8uZW5hYmxlZCkge1xuICAgICAgdGhpcy5zdGVwcGVyID0gZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlci5jcmVhdGUodGhpcy5fcGFnZUluZGV4KTtcbiAgICAgIHRoaXMuc3RlcHBlci5pbml0KHRoaXMub3BlcmF0b3JMaXN0KTtcbiAgICAgIHRoaXMuc3RlcHBlci5uZXh0QnJlYWtQb2ludCA9IHRoaXMuc3RlcHBlci5nZXROZXh0QnJlYWtQb2ludCgpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIGJhY2tncm91bmQsXG4gICAgICBkZXBlbmRlbmN5VHJhY2tlclxuICAgIH0gPSB0aGlzLnBhcmFtcztcbiAgICBjb25zdCBjYW52YXNDb250ZXh0ID0gdGhpcy5fY2FudmFzQ29udGV4dCB8fCB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogIXRoaXMuX2VuYWJsZUhXQVxuICAgIH0pO1xuICAgIHRoaXMuZ2Z4ID0gbmV3IENhbnZhc0dyYXBoaWNzKGNhbnZhc0NvbnRleHQsIHRoaXMuY29tbW9uT2JqcywgdGhpcy5vYmpzLCB0aGlzLmNhbnZhc0ZhY3RvcnksIHRoaXMuZmlsdGVyRmFjdG9yeSwge1xuICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gICAgfSwgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwLCB0aGlzLnBhZ2VDb2xvcnMsIGRlcGVuZGVuY3lUcmFja2VyKTtcbiAgICB0aGlzLmdmeC5iZWdpbkRyYXdpbmcoe1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc3BhcmVuY3ksXG4gICAgICBiYWNrZ3JvdW5kXG4gICAgfSk7XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSAwO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeSA9IHRydWU7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2s/LigpO1xuICB9XG4gIGNhbmNlbChlcnJvciA9IG51bGwsIGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIHRoaXMuZ2Z4Py5lbmREcmF3aW5nKCk7XG4gICAgaWYgKHRoaXMuI3JBRikge1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuI3JBRik7XG4gICAgICB0aGlzLiNyQUYgPSBudWxsO1xuICAgIH1cbiAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmRlbGV0ZSh0aGlzLl9jYW52YXMpO1xuICAgIGVycm9yIHx8PSBuZXcgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKGBSZW5kZXJpbmcgY2FuY2VsbGVkLCBwYWdlICR7dGhpcy5fcGFnZUluZGV4ICsgMX1gLCBleHRyYURlbGF5KTtcbiAgICB0aGlzLmNhbGxiYWNrKGVycm9yKTtcbiAgICB0aGlzLnRhc2sub25FcnJvcj8uKGVycm9yKTtcbiAgfVxuICBvcGVyYXRvckxpc3RDaGFuZ2VkKCkge1xuICAgIGlmICghdGhpcy5ncmFwaGljc1JlYWR5KSB7XG4gICAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjayB8fD0gdGhpcy5fY29udGludWVCb3VuZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGVwcGVyPy51cGRhdGVPcGVyYXRvckxpc3QodGhpcy5vcGVyYXRvckxpc3QpO1xuICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY29udGludWUoKTtcbiAgfVxuICBfY29udGludWUoKSB7XG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFzay5vbkNvbnRpbnVlKSB7XG4gICAgICB0aGlzLnRhc2sub25Db250aW51ZSh0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlTmV4dCgpO1xuICAgIH1cbiAgfVxuICBfc2NoZWR1bGVOZXh0KCkge1xuICAgIGlmICh0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHRoaXMuI3JBRiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLiNyQUYgPSBudWxsO1xuICAgICAgICB0aGlzLl9uZXh0Qm91bmQoKS5jYXRjaCh0aGlzLl9jYW5jZWxCb3VuZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbih0aGlzLl9uZXh0Qm91bmQpLmNhdGNoKHRoaXMuX2NhbmNlbEJvdW5kKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX25leHQoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gdGhpcy5nZnguZXhlY3V0ZU9wZXJhdG9yTGlzdCh0aGlzLm9wZXJhdG9yTGlzdCwgdGhpcy5vcGVyYXRvckxpc3RJZHgsIHRoaXMuX2NvbnRpbnVlQm91bmQsIHRoaXMuc3RlcHBlciwgdGhpcy5fZmlsdGVyZWRPcGVyYXRpb25JbmRleGVzKTtcbiAgICBpZiAodGhpcy5vcGVyYXRvckxpc3RJZHggPT09IHRoaXMub3BlcmF0b3JMaXN0LmFyZ3NBcnJheS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICB0aGlzLmdmeC5lbmREcmF3aW5nKCk7XG4gICAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuZGVsZXRlKHRoaXMuX2NhbnZhcyk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHZlcnNpb24gPSBcIjUuNC4xNDlcIjtcbmNvbnN0IGJ1aWxkID0gXCI5ZTJlOWUyMDlcIjtcblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2NvbG9yX3BpY2tlci5qc1xuXG5cblxuY2xhc3MgQ29sb3JQaWNrZXIge1xuICAjYnV0dG9uID0gbnVsbDtcbiAgI2J1dHRvblN3YXRjaCA9IG51bGw7XG4gICNkZWZhdWx0Q29sb3I7XG4gICNkcm9wZG93biA9IG51bGw7XG4gICNkcm9wZG93bldhc0Zyb21LZXlib2FyZCA9IGZhbHNlO1xuICAjaXNNYWluQ29sb3JQaWNrZXIgPSBmYWxzZTtcbiAgI2VkaXRvciA9IG51bGw7XG4gICNldmVudEJ1cztcbiAgI29wZW5Ecm9wZG93bkFDID0gbnVsbDtcbiAgI3VpTWFuYWdlciA9IG51bGw7XG4gIHN0YXRpYyAjbDEwbkNvbG9yID0gbnVsbDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZF0sIFtbXCIgXCIsIFwibWFjKyBcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fY29sb3JTZWxlY3RGcm9tS2V5Ym9hcmRdLCBbW1wiQXJyb3dEb3duXCIsIFwiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9OZXh0XSwgW1tcIkFycm93VXBcIiwgXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dVcFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fbW92ZVRvUHJldmlvdXNdLCBbW1wiSG9tZVwiLCBcIm1hYytIb21lXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb0JlZ2lubmluZ10sIFtbXCJFbmRcIiwgXCJtYWMrRW5kXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb0VuZF1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3Ioe1xuICAgIGVkaXRvciA9IG51bGwsXG4gICAgdWlNYW5hZ2VyID0gbnVsbFxuICB9KSB7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy4jaXNNYWluQ29sb3JQaWNrZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaXNNYWluQ29sb3JQaWNrZXIgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIgPSBlZGl0b3I/Ll91aU1hbmFnZXIgfHwgdWlNYW5hZ2VyO1xuICAgIHRoaXMuI2V2ZW50QnVzID0gdGhpcy4jdWlNYW5hZ2VyLl9ldmVudEJ1cztcbiAgICB0aGlzLiNkZWZhdWx0Q29sb3IgPSBlZGl0b3I/LmNvbG9yPy50b1VwcGVyQ2FzZSgpIHx8IHRoaXMuI3VpTWFuYWdlcj8uaGlnaGxpZ2h0Q29sb3JzLnZhbHVlcygpLm5leHQoKS52YWx1ZSB8fCBcIiNGRkZGOThcIjtcbiAgICBDb2xvclBpY2tlci4jbDEwbkNvbG9yIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIGJsdWU6IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWJsdWVcIixcbiAgICAgIGdyZWVuOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1ncmVlblwiLFxuICAgICAgcGluazogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItcGlua1wiLFxuICAgICAgcmVkOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1yZWRcIixcbiAgICAgIHllbGxvdzogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXIteWVsbG93XCJcbiAgICB9KTtcbiAgfVxuICByZW5kZXJCdXR0b24oKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NOYW1lID0gXCJjb2xvclBpY2tlclwiO1xuICAgIGJ1dHRvbi50YWJJbmRleCA9IFwiMFwiO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5hcmlhSGFzUG9wdXAgPSBcInRydWVcIjtcbiAgICBpZiAodGhpcy4jZWRpdG9yKSB7XG4gICAgICBidXR0b24uYXJpYUNvbnRyb2xzID0gYCR7dGhpcy4jZWRpdG9yLmlkfV9jb2xvcnBpY2tlcl9kcm9wZG93bmA7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jb3BlbkRyb3Bkb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNrZXlEb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHN3YXRjaCA9IHRoaXMuI2J1dHRvblN3YXRjaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHN3YXRjaC5jbGFzc05hbWUgPSBcInN3YXRjaFwiO1xuICAgIHN3YXRjaC5hcmlhSGlkZGVuID0gXCJ0cnVlXCI7XG4gICAgc3dhdGNoLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuI2RlZmF1bHRDb2xvcjtcbiAgICBidXR0b24uYXBwZW5kKHN3YXRjaCk7XG4gICAgcmV0dXJuIGJ1dHRvbjtcbiAgfVxuICByZW5kZXJNYWluRHJvcGRvd24oKSB7XG4gICAgY29uc3QgZHJvcGRvd24gPSB0aGlzLiNkcm9wZG93biA9IHRoaXMuI2dldERyb3Bkb3duUm9vdCgpO1xuICAgIGRyb3Bkb3duLmFyaWFPcmllbnRhdGlvbiA9IFwiaG9yaXpvbnRhbFwiO1xuICAgIGRyb3Bkb3duLmFyaWFMYWJlbGxlZEJ5ID0gXCJoaWdobGlnaHRDb2xvclBpY2tlckxhYmVsXCI7XG4gICAgcmV0dXJuIGRyb3Bkb3duO1xuICB9XG4gICNnZXREcm9wZG93blJvb3QoKSB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGRpdi5jbGFzc05hbWUgPSBcImRyb3Bkb3duXCI7XG4gICAgZGl2LnJvbGUgPSBcImxpc3Rib3hcIjtcbiAgICBkaXYuYXJpYU11bHRpU2VsZWN0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICBkaXYuYXJpYU9yaWVudGF0aW9uID0gXCJ2ZXJ0aWNhbFwiO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItZHJvcGRvd25cIik7XG4gICAgaWYgKHRoaXMuI2VkaXRvcikge1xuICAgICAgZGl2LmlkID0gYCR7dGhpcy4jZWRpdG9yLmlkfV9jb2xvcnBpY2tlcl9kcm9wZG93bmA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW25hbWUsIGNvbG9yXSBvZiB0aGlzLiN1aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JzKSB7XG4gICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgYnV0dG9uLnRhYkluZGV4ID0gXCIwXCI7XG4gICAgICBidXR0b24ucm9sZSA9IFwib3B0aW9uXCI7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiLCBjb2xvcik7XG4gICAgICBidXR0b24udGl0bGUgPSBuYW1lO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBDb2xvclBpY2tlci4jbDEwbkNvbG9yW25hbWVdKTtcbiAgICAgIGNvbnN0IHN3YXRjaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgYnV0dG9uLmFwcGVuZChzd2F0Y2gpO1xuICAgICAgc3dhdGNoLmNsYXNzTmFtZSA9IFwic3dhdGNoXCI7XG4gICAgICBzd2F0Y2guc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgICBidXR0b24uYXJpYVNlbGVjdGVkID0gY29sb3IgPT09IHRoaXMuI2RlZmF1bHRDb2xvcjtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jY29sb3JTZWxlY3QuYmluZCh0aGlzLCBjb2xvciksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGRpdi5hcHBlbmQoYnV0dG9uKTtcbiAgICB9XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2tleURvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuICAjY29sb3JTZWxlY3QoY29sb3IsIGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy4jZXZlbnRCdXMuZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ycGFyYW1zXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUixcbiAgICAgIHZhbHVlOiBjb2xvclxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlQ29sb3IoY29sb3IpO1xuICB9XG4gIF9jb2xvclNlbGVjdEZyb21LZXlib2FyZChldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuI2J1dHRvbikge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29sb3IgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiKTtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbG9yU2VsZWN0KGNvbG9yLCBldmVudCk7XG4gIH1cbiAgX21vdmVUb05leHQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIHRoaXMuI2Ryb3Bkb3duLmZpcnN0Q2hpbGQ/LmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnRhcmdldC5uZXh0U2libGluZz8uZm9jdXMoKTtcbiAgfVxuICBfbW92ZVRvUHJldmlvdXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNkcm9wZG93bj8uZmlyc3RDaGlsZCB8fCBldmVudC50YXJnZXQgPT09IHRoaXMuI2J1dHRvbikge1xuICAgICAgaWYgKHRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgIH1cbiAgICBldmVudC50YXJnZXQucHJldmlvdXNTaWJsaW5nPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9CZWdpbm5pbmcoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bi5maXJzdENoaWxkPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9FbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bi5sYXN0Q2hpbGQ/LmZvY3VzKCk7XG4gIH1cbiAgI2tleURvd24oZXZlbnQpIHtcbiAgICBDb2xvclBpY2tlci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gICNvcGVuRHJvcGRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jaXNEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHRoaXMuaGlkZURyb3Bkb3duKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2Ryb3Bkb3duV2FzRnJvbUtleWJvYXJkID0gZXZlbnQuZGV0YWlsID09PSAwO1xuICAgIGlmICghdGhpcy4jb3BlbkRyb3Bkb3duQUMpIHtcbiAgICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNwb2ludGVyRG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI29wZW5Ecm9wZG93bkFDKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuI2J1dHRvbi5hcmlhRXhwYW5kZWQgPSBcInRydWVcIjtcbiAgICBpZiAodGhpcy4jZHJvcGRvd24pIHtcbiAgICAgIHRoaXMuI2Ryb3Bkb3duLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvb3QgPSB0aGlzLiNkcm9wZG93biA9IHRoaXMuI2dldERyb3Bkb3duUm9vdCgpO1xuICAgIHRoaXMuI2J1dHRvbi5hcHBlbmQocm9vdCk7XG4gIH1cbiAgI3BvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI2Ryb3Bkb3duPy5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaGlkZURyb3Bkb3duKCk7XG4gIH1cbiAgaGlkZURyb3Bkb3duKCkge1xuICAgIHRoaXMuI2Ryb3Bkb3duPy5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuI2J1dHRvbi5hcmlhRXhwYW5kZWQgPSBcImZhbHNlXCI7XG4gICAgdGhpcy4jb3BlbkRyb3Bkb3duQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jb3BlbkRyb3Bkb3duQUMgPSBudWxsO1xuICB9XG4gIGdldCAjaXNEcm9wZG93blZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Ryb3Bkb3duICYmICF0aGlzLiNkcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoXCJoaWRkZW5cIik7XG4gIH1cbiAgX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCgpIHtcbiAgICBpZiAodGhpcy4jaXNNYWluQ29sb3JQaWNrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jZWRpdG9yPy51bnNlbGVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICAgIHRoaXMuI2J1dHRvbi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgZm9jdXNWaXNpYmxlOiB0aGlzLiNkcm9wZG93bldhc0Zyb21LZXlib2FyZFxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKHRoaXMuI2J1dHRvblN3YXRjaCkge1xuICAgICAgdGhpcy4jYnV0dG9uU3dhdGNoLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2Ryb3Bkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0aGlzLiN1aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JzLnZhbHVlcygpO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy4jZHJvcGRvd24uY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkLmFyaWFTZWxlY3RlZCA9IGkubmV4dCgpLnZhbHVlID09PSBjb2xvci50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2J1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jYnV0dG9uID0gbnVsbDtcbiAgICB0aGlzLiNidXR0b25Td2F0Y2ggPSBudWxsO1xuICAgIHRoaXMuI2Ryb3Bkb3duPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNkcm9wZG93biA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIEJhc2ljQ29sb3JQaWNrZXIge1xuICAjaW5wdXQgPSBudWxsO1xuICAjZWRpdG9yID0gbnVsbDtcbiAgI3VpTWFuYWdlciA9IG51bGw7XG4gIHN0YXRpYyAjbDEwbkNvbG9yID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuI3VpTWFuYWdlciA9IGVkaXRvci5fdWlNYW5hZ2VyO1xuICAgIEJhc2ljQ29sb3JQaWNrZXIuI2wxMG5Db2xvciB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBmcmVldGV4dDogXCJwZGZqcy1lZGl0b3ItY29sb3ItcGlja2VyLWZyZWUtdGV4dC1pbnB1dFwiLFxuICAgICAgaW5rOiBcInBkZmpzLWVkaXRvci1jb2xvci1waWNrZXItaW5rLWlucHV0XCJcbiAgICB9KTtcbiAgfVxuICByZW5kZXJCdXR0b24oKSB7XG4gICAgaWYgKHRoaXMuI2lucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy4jaW5wdXQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGVkaXRvclR5cGUsXG4gICAgICBjb2xvclR5cGUsXG4gICAgICBjb2xvclZhbHVlXG4gICAgfSA9IHRoaXMuI2VkaXRvcjtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuI2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnR5cGUgPSBcImNvbG9yXCI7XG4gICAgaW5wdXQudmFsdWUgPSBjb2xvclZhbHVlIHx8IFwiIzAwMDAwMFwiO1xuICAgIGlucHV0LmNsYXNzTmFtZSA9IFwiYmFzaWNDb2xvclBpY2tlclwiO1xuICAgIGlucHV0LnRhYkluZGV4ID0gMDtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQmFzaWNDb2xvclBpY2tlci4jbDEwbkNvbG9yW2VkaXRvclR5cGVdKTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZVBhcmFtcyhjb2xvclR5cGUsIGlucHV0LnZhbHVlKTtcbiAgICB9LCB7XG4gICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghdGhpcy4jaW5wdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2lucHV0Py5yZW1vdmUoKTtcbiAgICB0aGlzLiNpbnB1dCA9IG51bGw7XG4gIH1cbiAgaGlkZURyb3Bkb3duKCkge31cbn1cblxuOy8vIC4vc3JjL3NoYXJlZC9zY3JpcHRpbmdfdXRpbHMuanNcbmZ1bmN0aW9uIG1ha2VDb2xvckNvbXAobikge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBuKSkgKiAyNTUpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG59XG5mdW5jdGlvbiBzY2FsZUFuZENsYW1wKHgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgMjU1ICogeCkpO1xufVxuY2xhc3MgQ29sb3JDb252ZXJ0ZXJzIHtcbiAgc3RhdGljIENNWUtfRyhbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW1wiR1wiLCAxIC0gTWF0aC5taW4oMSwgMC4zICogYyArIDAuNTkgKiBtICsgMC4xMSAqIHkgKyBrKV07XG4gIH1cbiAgc3RhdGljIEdfQ01ZSyhbZ10pIHtcbiAgICByZXR1cm4gW1wiQ01ZS1wiLCAwLCAwLCAwLCAxIC0gZ107XG4gIH1cbiAgc3RhdGljIEdfUkdCKFtnXSkge1xuICAgIHJldHVybiBbXCJSR0JcIiwgZywgZywgZ107XG4gIH1cbiAgc3RhdGljIEdfcmdiKFtnXSkge1xuICAgIGcgPSBzY2FsZUFuZENsYW1wKGcpO1xuICAgIHJldHVybiBbZywgZywgZ107XG4gIH1cbiAgc3RhdGljIEdfSFRNTChbZ10pIHtcbiAgICBjb25zdCBHID0gbWFrZUNvbG9yQ29tcChnKTtcbiAgICByZXR1cm4gYCMke0d9JHtHfSR7R31gO1xuICB9XG4gIHN0YXRpYyBSR0JfRyhbciwgZywgYl0pIHtcbiAgICByZXR1cm4gW1wiR1wiLCAwLjMgKiByICsgMC41OSAqIGcgKyAwLjExICogYl07XG4gIH1cbiAgc3RhdGljIFJHQl9yZ2IoY29sb3IpIHtcbiAgICByZXR1cm4gY29sb3IubWFwKHNjYWxlQW5kQ2xhbXApO1xuICB9XG4gIHN0YXRpYyBSR0JfSFRNTChjb2xvcikge1xuICAgIHJldHVybiBgIyR7Y29sb3IubWFwKG1ha2VDb2xvckNvbXApLmpvaW4oXCJcIil9YDtcbiAgfVxuICBzdGF0aWMgVF9IVE1MKCkge1xuICAgIHJldHVybiBcIiMwMDAwMDAwMFwiO1xuICB9XG4gIHN0YXRpYyBUX3JnYigpIHtcbiAgICByZXR1cm4gW251bGxdO1xuICB9XG4gIHN0YXRpYyBDTVlLX1JHQihbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW1wiUkdCXCIsIDEgLSBNYXRoLm1pbigxLCBjICsgayksIDEgLSBNYXRoLm1pbigxLCBtICsgayksIDEgLSBNYXRoLm1pbigxLCB5ICsgayldO1xuICB9XG4gIHN0YXRpYyBDTVlLX3JnYihbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW3NjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIGMgKyBrKSksIHNjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIG0gKyBrKSksIHNjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIHkgKyBrKSldO1xuICB9XG4gIHN0YXRpYyBDTVlLX0hUTUwoY29tcG9uZW50cykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuQ01ZS19SR0IoY29tcG9uZW50cykuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHRoaXMuUkdCX0hUTUwocmdiKTtcbiAgfVxuICBzdGF0aWMgUkdCX0NNWUsoW3IsIGcsIGJdKSB7XG4gICAgY29uc3QgYyA9IDEgLSByO1xuICAgIGNvbnN0IG0gPSAxIC0gZztcbiAgICBjb25zdCB5ID0gMSAtIGI7XG4gICAgY29uc3QgayA9IE1hdGgubWluKGMsIG0sIHkpO1xuICAgIHJldHVybiBbXCJDTVlLXCIsIGMsIG0sIHksIGtdO1xuICB9XG59XG5jb25zdCBEYXRlRm9ybWF0cyA9ICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKFtcIm0vZFwiLCBcIm0vZC95eVwiLCBcIm1tL2RkL3l5XCIsIFwibW0veXlcIiwgXCJkLW1tbVwiLCBcImQtbW1tLXl5XCIsIFwiZGQtbW1tLXl5XCIsIFwieXktbW0tZGRcIiwgXCJtbW0teXlcIiwgXCJtbW1tLXl5XCIsIFwibW1tIGQsIHl5eXlcIiwgXCJtbW1tIGQsIHl5eXlcIiwgXCJtL2QveXkgaDpNTSB0dFwiLCBcIm0vZC95eSBISDpNTVwiXSkpO1xuY29uc3QgVGltZUZvcm1hdHMgPSAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChbXCJISDpNTVwiLCBcImg6TU0gdHRcIiwgXCJISDpNTTpzc1wiLCBcImg6TU06c3MgdHRcIl0pKTtcblxuOy8vIC4vc3JjL2Rpc3BsYXkvc3ZnX2ZhY3RvcnkuanNcblxuXG5jbGFzcyBCYXNlU1ZHRmFjdG9yeSB7XG4gIGNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCBza2lwRGltZW5zaW9ucyA9IGZhbHNlKSB7XG4gICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgU1ZHIGRpbWVuc2lvbnNcIik7XG4gICAgfVxuICAgIGNvbnN0IHN2ZyA9IHRoaXMuX2NyZWF0ZVNWRyhcInN2ZzpzdmdcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInZlcnNpb25cIiwgXCIxLjFcIik7XG4gICAgaWYgKCFza2lwRGltZW5zaW9ucykge1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGAke3dpZHRofXB4YCk7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGAke2hlaWdodH1weGApO1xuICAgIH1cbiAgICBzdmcuc2V0QXR0cmlidXRlKFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLCBcIm5vbmVcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgYDAgMCAke3dpZHRofSAke2hlaWdodH1gKTtcbiAgICByZXR1cm4gc3ZnO1xuICB9XG4gIGNyZWF0ZUVsZW1lbnQodHlwZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTVkcgZWxlbWVudCB0eXBlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlU1ZHKHR5cGUpO1xuICB9XG4gIF9jcmVhdGVTVkcodHlwZSkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfY3JlYXRlU1ZHYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01TVkdGYWN0b3J5IGV4dGVuZHMgQmFzZVNWR0ZhY3Rvcnkge1xuICBfY3JlYXRlU1ZHKHR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgdHlwZSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkveGZhX2xheWVyLmpzXG5cbmNsYXNzIFhmYUxheWVyIHtcbiAgc3RhdGljIHNldHVwU3RvcmFnZShodG1sLCBpZCwgZWxlbWVudCwgc3RvcmFnZSwgaW50ZW50KSB7XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSk7XG4gICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGh0bWwudGV4dENvbnRlbnQgPSBzdG9yZWREYXRhLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICBpZiAoZWxlbWVudC5hdHRyaWJ1dGVzLnR5cGUgPT09IFwicmFkaW9cIiB8fCBlbGVtZW50LmF0dHJpYnV0ZXMudHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gICAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgPT09IGVsZW1lbnQuYXR0cmlidXRlcy54ZmFPbikge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RvcmVkRGF0YS52YWx1ZSA9PT0gZWxlbWVudC5hdHRyaWJ1dGVzLnhmYU9mZikge1xuICAgICAgICAgICAgaHRtbC5yZW1vdmVBdHRyaWJ1dGUoXCJjaGVja2VkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LmNoZWNrZWQgPyBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwieGZhT25cIikgOiBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwieGZhT2ZmXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBzdG9yZWREYXRhLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHN0b3JlZERhdGEudmFsdWUpO1xuICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGVsZW1lbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb24uYXR0cmlidXRlcy52YWx1ZSA9PT0gc3RvcmVkRGF0YS52YWx1ZSkge1xuICAgICAgICAgICAgICBvcHRpb24uYXR0cmlidXRlcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbi5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KFwic2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbi5hdHRyaWJ1dGVzLnNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50LnRhcmdldC5vcHRpb25zO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy5zZWxlY3RlZEluZGV4ID09PSAtMSA/IFwiXCIgOiBvcHRpb25zW29wdGlvbnMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgc2V0QXR0cmlidXRlcyh7XG4gICAgaHRtbCxcbiAgICBlbGVtZW50LFxuICAgIHN0b3JhZ2UgPSBudWxsLFxuICAgIGludGVudCxcbiAgICBsaW5rU2VydmljZVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYXR0cmlidXRlc1xuICAgIH0gPSBlbGVtZW50O1xuICAgIGNvbnN0IGlzSFRNTEFuY2hvckVsZW1lbnQgPSBodG1sIGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQ7XG4gICAgaWYgKGF0dHJpYnV0ZXMudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5hbWUgPSBgJHthdHRyaWJ1dGVzLm5hbWV9LSR7aW50ZW50fWA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUuam9pbihcIiBcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhdGFJZFwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oaHRtbC5zdHlsZSwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGV4dENvbnRlbnRcIjpcbiAgICAgICAgICBodG1sLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFpc0hUTUxBbmNob3JFbGVtZW50IHx8IGtleSAhPT0gXCJocmVmXCIgJiYga2V5ICE9PSBcIm5ld1dpbmRvd1wiKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0hUTUxBbmNob3JFbGVtZW50KSB7XG4gICAgICBsaW5rU2VydmljZS5hZGRMaW5rQXR0cmlidXRlcyhodG1sLCBhdHRyaWJ1dGVzLmhyZWYsIGF0dHJpYnV0ZXMubmV3V2luZG93KTtcbiAgICB9XG4gICAgaWYgKHN0b3JhZ2UgJiYgYXR0cmlidXRlcy5kYXRhSWQpIHtcbiAgICAgIHRoaXMuc2V0dXBTdG9yYWdlKGh0bWwsIGF0dHJpYnV0ZXMuZGF0YUlkLCBlbGVtZW50LCBzdG9yYWdlKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHJlbmRlcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHBhcmFtZXRlcnMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgbGlua1NlcnZpY2UgPSBwYXJhbWV0ZXJzLmxpbmtTZXJ2aWNlO1xuICAgIGNvbnN0IHJvb3QgPSBwYXJhbWV0ZXJzLnhmYUh0bWw7XG4gICAgY29uc3QgaW50ZW50ID0gcGFyYW1ldGVycy5pbnRlbnQgfHwgXCJkaXNwbGF5XCI7XG4gICAgY29uc3Qgcm9vdEh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHJvb3QubmFtZSk7XG4gICAgaWYgKHJvb3QuYXR0cmlidXRlcykge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgaHRtbDogcm9vdEh0bWwsXG4gICAgICAgIGVsZW1lbnQ6IHJvb3QsXG4gICAgICAgIGludGVudCxcbiAgICAgICAgbGlua1NlcnZpY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBpc05vdEZvclJpY2hUZXh0ID0gaW50ZW50ICE9PSBcInJpY2hUZXh0XCI7XG4gICAgY29uc3Qgcm9vdERpdiA9IHBhcmFtZXRlcnMuZGl2O1xuICAgIHJvb3REaXYuYXBwZW5kKHJvb3RIdG1sKTtcbiAgICBpZiAocGFyYW1ldGVycy52aWV3cG9ydCkge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gYG1hdHJpeCgke3BhcmFtZXRlcnMudmlld3BvcnQudHJhbnNmb3JtLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgcm9vdERpdi5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfVxuICAgIGlmIChpc05vdEZvclJpY2hUZXh0KSB7XG4gICAgICByb290RGl2LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwieGZhTGF5ZXIgeGZhRm9udFwiKTtcbiAgICB9XG4gICAgY29uc3QgdGV4dERpdnMgPSBbXTtcbiAgICBpZiAocm9vdC5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChyb290LnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyb290LnZhbHVlKTtcbiAgICAgICAgcm9vdEh0bWwuYXBwZW5kKG5vZGUpO1xuICAgICAgICBpZiAoaXNOb3RGb3JSaWNoVGV4dCAmJiBYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChyb290Lm5hbWUpKSB7XG4gICAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dERpdnNcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gW1tyb290LCAtMSwgcm9vdEh0bWxdXTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgW3BhcmVudCwgaSwgaHRtbF0gPSBzdGFjay5hdCgtMSk7XG4gICAgICBpZiAoaSArIDEgPT09IHBhcmVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5bKytzdGFjay5hdCgtMSlbMV1dO1xuICAgICAgaWYgKGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lXG4gICAgICB9ID0gY2hpbGQ7XG4gICAgICBpZiAobmFtZSA9PT0gXCIjdGV4dFwiKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZC52YWx1ZSk7XG4gICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIGh0bWwuYXBwZW5kKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkSHRtbCA9IGNoaWxkPy5hdHRyaWJ1dGVzPy54bWxucyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhjaGlsZC5hdHRyaWJ1dGVzLnhtbG5zLCBuYW1lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG4gICAgICBodG1sLmFwcGVuZChjaGlsZEh0bWwpO1xuICAgICAgaWYgKGNoaWxkLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICBodG1sOiBjaGlsZEh0bWwsXG4gICAgICAgICAgZWxlbWVudDogY2hpbGQsXG4gICAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgICBpbnRlbnQsXG4gICAgICAgICAgbGlua1NlcnZpY2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RhY2sucHVzaChbY2hpbGQsIC0xLCBjaGlsZEh0bWxdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQudmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkLnZhbHVlKTtcbiAgICAgICAgaWYgKGlzTm90Rm9yUmljaFRleHQgJiYgWGZhVGV4dC5zaG91bGRCdWlsZFRleHQobmFtZSkpIHtcbiAgICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkSHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWwgb2Ygcm9vdERpdi5xdWVyeVNlbGVjdG9yQWxsKFwiLnhmYU5vbkludGVyYWN0aXZlIGlucHV0LCAueGZhTm9uSW50ZXJhY3RpdmUgdGV4dGFyZWFcIikpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcInJlYWRPbmx5XCIsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dERpdnNcbiAgICB9O1xuICB9XG4gIHN0YXRpYyB1cGRhdGUocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGBtYXRyaXgoJHtwYXJhbWV0ZXJzLnZpZXdwb3J0LnRyYW5zZm9ybS5qb2luKFwiLFwiKX0pYDtcbiAgICBwYXJhbWV0ZXJzLmRpdi5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgcGFyYW1ldGVycy5kaXYuaGlkZGVuID0gZmFsc2U7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvYW5ub3RhdGlvbl9sYXllci5qc1xuXG5cblxuXG5cblxuY29uc3QgYW5ub3RhdGlvbl9sYXllcl9ERUZBVUxUX0ZPTlRfU0laRSA9IDk7XG5jb25zdCBHZXRFbGVtZW50c0J5TmFtZVNldCA9IG5ldyBXZWFrU2V0KCk7XG5jb25zdCBUSU1FWk9ORV9PRkZTRVQgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCAqIDEwMDA7XG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudEZhY3Rvcnkge1xuICBzdGF0aWMgY3JlYXRlKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdWJ0eXBlID0gcGFyYW1ldGVycy5kYXRhLmFubm90YXRpb25UeXBlO1xuICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5MSU5LOlxuICAgICAgICByZXR1cm4gbmV3IExpbmtBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuVEVYVDpcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLldJREdFVDpcbiAgICAgICAgY29uc3QgZmllbGRUeXBlID0gcGFyYW1ldGVycy5kYXRhLmZpZWxkVHlwZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiVHhcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJCdG5cIjpcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmRhdGEucmFkaW9CdXR0b24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzLmRhdGEuY2hlY2tCb3gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIkNoXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJTaWdcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuUE9QVVA6XG4gICAgICAgIHJldHVybiBuZXcgUG9wdXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNRVUFSRTpcbiAgICAgICAgcmV0dXJuIG5ldyBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuQ0lSQ0xFOlxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5QT0xZTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5DQVJFVDpcbiAgICAgICAgcmV0dXJuIG5ldyBDYXJldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5JTks6XG4gICAgICAgIHJldHVybiBuZXcgSW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlBPTFlHT046XG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbkFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5ISUdITElHSFQ6XG4gICAgICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlVOREVSTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1FVSUdHTFk6XG4gICAgICAgIHJldHVybiBuZXcgU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1RSSUtFT1VUOlxuICAgICAgICByZXR1cm4gbmV3IFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5TVEFNUDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFtcEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5GSUxFQVRUQUNITUVOVDpcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3VwZGF0ZXMgPSBudWxsO1xuICAjaGFzQm9yZGVyID0gZmFsc2U7XG4gICNwb3B1cEVsZW1lbnQgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCB7XG4gICAgaXNSZW5kZXJhYmxlID0gZmFsc2UsXG4gICAgaWdub3JlQm9yZGVyID0gZmFsc2UsXG4gICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICB0aGlzLmlzUmVuZGVyYWJsZSA9IGlzUmVuZGVyYWJsZTtcbiAgICB0aGlzLmRhdGEgPSBwYXJhbWV0ZXJzLmRhdGE7XG4gICAgdGhpcy5sYXllciA9IHBhcmFtZXRlcnMubGF5ZXI7XG4gICAgdGhpcy5saW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXIgPSBwYXJhbWV0ZXJzLmRvd25sb2FkTWFuYWdlcjtcbiAgICB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCA9IHBhcmFtZXRlcnMuaW1hZ2VSZXNvdXJjZXNQYXRoO1xuICAgIHRoaXMucmVuZGVyRm9ybXMgPSBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zO1xuICAgIHRoaXMuc3ZnRmFjdG9yeSA9IHBhcmFtZXRlcnMuc3ZnRmFjdG9yeTtcbiAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLmVuYWJsZUNvbW1lbnQgPSBwYXJhbWV0ZXJzLmVuYWJsZUNvbW1lbnQ7XG4gICAgdGhpcy5lbmFibGVTY3JpcHRpbmcgPSBwYXJhbWV0ZXJzLmVuYWJsZVNjcmlwdGluZztcbiAgICB0aGlzLmhhc0pTQWN0aW9ucyA9IHBhcmFtZXRlcnMuaGFzSlNBY3Rpb25zO1xuICAgIHRoaXMuX2ZpZWxkT2JqZWN0cyA9IHBhcmFtZXRlcnMuZmllbGRPYmplY3RzO1xuICAgIHRoaXMucGFyZW50ID0gcGFyYW1ldGVycy5wYXJlbnQ7XG4gICAgaWYgKGlzUmVuZGVyYWJsZSkge1xuICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLl9jcmVhdGVDb250YWluZXIoaWdub3JlQm9yZGVyKTtcbiAgICB9XG4gICAgaWYgKGNyZWF0ZVF1YWRyaWxhdGVyYWxzKSB7XG4gICAgICB0aGlzLl9jcmVhdGVRdWFkcmlsYXRlcmFscygpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX2hhc1BvcHVwRGF0YSh7XG4gICAgY29udGVudHNPYmosXG4gICAgcmljaFRleHRcbiAgfSkge1xuICAgIHJldHVybiAhIShjb250ZW50c09iaj8uc3RyIHx8IHJpY2hUZXh0Py5zdHIpO1xuICB9XG4gIGdldCBfaXNFZGl0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmlzRWRpdGFibGU7XG4gIH1cbiAgZ2V0IGhhc1BvcHVwRGF0YSgpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVsZW1lbnQuX2hhc1BvcHVwRGF0YSh0aGlzLmRhdGEpO1xuICB9XG4gIGdldCBoYXNDb21tZW50QnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZUNvbW1lbnQgJiYgdGhpcy5faXNFZGl0YWJsZSAmJiB0aGlzLmhhc1BvcHVwRWxlbWVudDtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHF1YWRQb2ludHMsXG4gICAgICByZWN0XG4gICAgfSA9IHRoaXMuZGF0YTtcbiAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWF4WSA9IC1JbmZpbml0eTtcbiAgICBpZiAocXVhZFBvaW50cz8ubGVuZ3RoID49IDgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhZFBvaW50cy5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICBpZiAocXVhZFBvaW50c1tpICsgMV0gPiBtYXhZKSB7XG4gICAgICAgICAgbWF4WSA9IHF1YWRQb2ludHNbaSArIDFdO1xuICAgICAgICAgIG1heFggPSBxdWFkUG9pbnRzW2kgKyAyXTtcbiAgICAgICAgfSBlbHNlIGlmIChxdWFkUG9pbnRzW2kgKyAxXSA9PT0gbWF4WSkge1xuICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBxdWFkUG9pbnRzW2kgKyAyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbbWF4WCwgbWF4WV07XG4gICAgfVxuICAgIGlmIChyZWN0KSB7XG4gICAgICByZXR1cm4gW3JlY3RbMl0sIHJlY3RbM11dO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvbkNvbG9yKCkge1xuICAgIGlmICghdGhpcy5kYXRhLmNvbG9yKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5kYXRhLmNvbG9yO1xuICAgIGNvbnN0IG9wYWNpdHkgPSB0aGlzLmRhdGEub3BhY2l0eSA/PyAxO1xuICAgIGNvbnN0IG9wcG9zaXRlT3BhY2l0eSA9IDI1NSAqICgxIC0gb3BhY2l0eSk7XG4gICAgcmV0dXJuIHRoaXMuI2NoYW5nZUxpZ2h0bmVzcyhNYXRoLm1pbihyICsgb3Bwb3NpdGVPcGFjaXR5LCAyNTUpLCBNYXRoLm1pbihnICsgb3Bwb3NpdGVPcGFjaXR5LCAyNTUpLCBNYXRoLm1pbihiICsgb3Bwb3NpdGVPcGFjaXR5LCAyNTUpKTtcbiAgfVxuICAjY2hhbmdlTGlnaHRuZXNzKHIsIGcsIGIpIHtcbiAgICByIC89IDI1NTtcbiAgICBnIC89IDI1NTtcbiAgICBiIC89IDI1NTtcbiAgICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICBjb25zdCBsID0gKG1heCArIG1pbikgLyAyO1xuICAgIGNvbnN0IG5ld0wgPSAoKDEgKyBNYXRoLnNxcnQobCkpIC8gMiAqIDEwMCkudG9GaXhlZCgyKTtcbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIHJldHVybiBgaHNsKDAsIDAlLCAke25ld0x9JSlgO1xuICAgIH1cbiAgICBjb25zdCBkID0gbWF4IC0gbWluO1xuICAgIGxldCBoO1xuICAgIGlmIChtYXggPT09IHIpIHtcbiAgICAgIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTtcbiAgICB9IGVsc2UgaWYgKG1heCA9PT0gZykge1xuICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICB9XG4gICAgaCA9IChoICogNjApLnRvRml4ZWQoMik7XG4gICAgY29uc3QgcyA9IChkIC8gKDEgLSBNYXRoLmFicygyICogbCAtIDEpKSAqIDEwMCkudG9GaXhlZCgyKTtcbiAgICByZXR1cm4gYGhzbCgke2h9LCAke3N9JSwgJHtuZXdMfSUpYDtcbiAgfVxuICBfbm9ybWFsaXplUG9pbnQocG9pbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHZpZXdcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICByYXdEaW1zOiB7XG4gICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgcGFnZVlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzLnBhcmVudDtcbiAgICBwb2ludFsxXSA9IHZpZXdbM10gLSBwb2ludFsxXSArIHZpZXdbMV07XG4gICAgcG9pbnRbMF0gPSAxMDAgKiAocG9pbnRbMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgcG9pbnRbMV0gPSAxMDAgKiAocG9pbnRbMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuICB1cGRhdGVFZGl0ZWQocGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnJlY3QpIHtcbiAgICAgIHRoaXMuI3VwZGF0ZXMgfHw9IHtcbiAgICAgICAgcmVjdDogdGhpcy5kYXRhLnJlY3Quc2xpY2UoMClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHJlY3QsXG4gICAgICBwb3B1cDogbmV3UG9wdXBcbiAgICB9ID0gcGFyYW1zO1xuICAgIGlmIChyZWN0KSB7XG4gICAgICB0aGlzLiNzZXRSZWN0RWRpdGVkKHJlY3QpO1xuICAgIH1cbiAgICBsZXQgcG9wdXAgPSB0aGlzLiNwb3B1cEVsZW1lbnQ/LnBvcHVwIHx8IHRoaXMucG9wdXA7XG4gICAgaWYgKCFwb3B1cCAmJiBuZXdQb3B1cD8udGV4dCkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAobmV3UG9wdXApO1xuICAgICAgcG9wdXAgPSB0aGlzLiNwb3B1cEVsZW1lbnQucG9wdXA7XG4gICAgfVxuICAgIGlmICghcG9wdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcG9wdXAudXBkYXRlRWRpdGVkKHBhcmFtcyk7XG4gICAgaWYgKG5ld1BvcHVwPy5kZWxldGVkKSB7XG4gICAgICBwb3B1cC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI3BvcHVwRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLnBvcHVwID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmVzZXRFZGl0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLiN1cGRhdGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NldFJlY3RFZGl0ZWQodGhpcy4jdXBkYXRlcy5yZWN0KTtcbiAgICB0aGlzLiNwb3B1cEVsZW1lbnQ/LnBvcHVwLnJlc2V0RWRpdGVkKCk7XG4gICAgdGhpcy4jdXBkYXRlcyA9IG51bGw7XG4gIH1cbiAgI3NldFJlY3RFZGl0ZWQocmVjdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICBzdHlsZVxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVjdDogY3VycmVudFJlY3QsXG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9LFxuICAgICAgcGFyZW50OiB7XG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgcmF3RGltczoge1xuICAgICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjdXJyZW50UmVjdD8uc3BsaWNlKDAsIDQsIC4uLnJlY3QpO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiAocmVjdFswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aH0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiAocGFnZUhlaWdodCAtIHJlY3RbM10gKyBwYWdlWSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIGlmIChyb3RhdGlvbiA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSBgJHsxMDAgKiAocmVjdFsyXSAtIHJlY3RbMF0pIC8gcGFnZVdpZHRofSVgO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogKHJlY3RbM10gLSByZWN0WzFdKSAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24pO1xuICAgIH1cbiAgfVxuICBfY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBwYXJlbnQ6IHtcbiAgICAgICAgcGFnZSxcbiAgICAgICAgdmlld3BvcnRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiKTtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1hbm5vdGF0aW9uLWlkXCIsIGRhdGEuaWQpO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCkgJiYgISh0aGlzIGluc3RhbmNlb2YgTGlua0Fubm90YXRpb25FbGVtZW50KSkge1xuICAgICAgY29udGFpbmVyLnRhYkluZGV4ID0gMDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gY29udGFpbmVyO1xuICAgIHN0eWxlLnpJbmRleCA9IHRoaXMucGFyZW50LnpJbmRleDtcbiAgICB0aGlzLnBhcmVudC56SW5kZXggKz0gMjtcbiAgICBpZiAoZGF0YS5hbHRlcm5hdGl2ZVRleHQpIHtcbiAgICAgIGNvbnRhaW5lci50aXRsZSA9IGRhdGEuYWx0ZXJuYXRpdmVUZXh0O1xuICAgIH1cbiAgICBpZiAoZGF0YS5ub1JvdGF0ZSkge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJub3JvdGF0ZVwiKTtcbiAgICB9XG4gICAgaWYgKCFkYXRhLnJlY3QgfHwgdGhpcyBpbnN0YW5jZW9mIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaWYgKCFkYXRhLmhhc093bkNhbnZhcyAmJiByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uLCBjb250YWluZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWlnbm9yZUJvcmRlciAmJiBkYXRhLmJvcmRlclN0eWxlLndpZHRoID4gMCkge1xuICAgICAgc3R5bGUuYm9yZGVyV2lkdGggPSBgJHtkYXRhLmJvcmRlclN0eWxlLndpZHRofXB4YDtcbiAgICAgIGNvbnN0IGhvcml6b250YWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLmhvcml6b250YWxDb3JuZXJSYWRpdXM7XG4gICAgICBjb25zdCB2ZXJ0aWNhbFJhZGl1cyA9IGRhdGEuYm9yZGVyU3R5bGUudmVydGljYWxDb3JuZXJSYWRpdXM7XG4gICAgICBpZiAoaG9yaXpvbnRhbFJhZGl1cyA+IDAgfHwgdmVydGljYWxSYWRpdXMgPiAwKSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7aG9yaXpvbnRhbFJhZGl1c31weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpIC8gY2FsYygke3ZlcnRpY2FsUmFkaXVzfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgICBzdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7d2lkdGh9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKSAvIGNhbGMoJHtoZWlnaHR9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICAgIHN0eWxlLmJvcmRlclJhZGl1cyA9IHJhZGl1cztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGF0YS5ib3JkZXJTdHlsZS5zdHlsZSkge1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuU09MSUQ6XG4gICAgICAgICAgc3R5bGUuYm9yZGVyU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5EQVNIRUQ6XG4gICAgICAgICAgc3R5bGUuYm9yZGVyU3R5bGUgPSBcImRhc2hlZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuQkVWRUxFRDpcbiAgICAgICAgICB3YXJuKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGJldmVsZWRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5JTlNFVDpcbiAgICAgICAgICB3YXJuKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGluc2V0XCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuVU5ERVJMSU5FOlxuICAgICAgICAgIHN0eWxlLmJvcmRlckJvdHRvbVN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9yZGVyQ29sb3IgPSBkYXRhLmJvcmRlckNvbG9yIHx8IG51bGw7XG4gICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgdGhpcy4jaGFzQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgc3R5bGUuYm9yZGVyQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihib3JkZXJDb2xvclswXSB8IDAsIGJvcmRlckNvbG9yWzFdIHwgMCwgYm9yZGVyQ29sb3JbMl0gfCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVjdCA9IFV0aWwubm9ybWFsaXplUmVjdChbZGF0YS5yZWN0WzBdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbMV0gKyBwYWdlLnZpZXdbMV0sIGRhdGEucmVjdFsyXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzNdICsgcGFnZS52aWV3WzFdXSk7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICBzdHlsZS5sZWZ0ID0gYCR7MTAwICogKHJlY3RbMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGh9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7MTAwICogKHJlY3RbMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIGNvbnN0IHtcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGRhdGEuaGFzT3duQ2FudmFzIHx8IHJvdGF0aW9uID09PSAwKSB7XG4gICAgICBzdHlsZS53aWR0aCA9IGAkezEwMCAqIHdpZHRoIC8gcGFnZVdpZHRofSVgO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogaGVpZ2h0IC8gcGFnZUhlaWdodH0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBzZXRSb3RhdGlvbihhbmdsZSwgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5yZWN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQucmF3RGltcztcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoYW5nbGUgJSAxODAgIT09IDApIHtcbiAgICAgIFt3aWR0aCwgaGVpZ2h0XSA9IFtoZWlnaHQsIHdpZHRoXTtcbiAgICB9XG4gICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGggLyBwYWdlV2lkdGh9JWA7XG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCAoMzYwIC0gYW5nbGUpICUgMzYwKTtcbiAgfVxuICBnZXQgX2NvbW1vbkFjdGlvbnMoKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSAoanNOYW1lLCBzdHlsZU5hbWUsIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBjb2xvciA9IGV2ZW50LmRldGFpbFtqc05hbWVdO1xuICAgICAgY29uc3QgY29sb3JUeXBlID0gY29sb3JbMF07XG4gICAgICBjb25zdCBjb2xvckFycmF5ID0gY29sb3Iuc2xpY2UoMSk7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGVbc3R5bGVOYW1lXSA9IENvbG9yQ29udmVydGVyc1tgJHtjb2xvclR5cGV9X0hUTUxgXShjb2xvckFycmF5KTtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgIFtzdHlsZU5hbWVdOiBDb2xvckNvbnZlcnRlcnNbYCR7Y29sb3JUeXBlfV9yZ2JgXShjb2xvckFycmF5KVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2NvbW1vbkFjdGlvbnNcIiwge1xuICAgICAgZGlzcGxheTogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGlzcGxheVxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zdCBoaWRkZW4gPSBkaXNwbGF5ICUgMiA9PT0gMTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IGhpZGRlbiA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlbixcbiAgICAgICAgICBub1ByaW50OiBkaXNwbGF5ID09PSAxIHx8IGRpc3BsYXkgPT09IDJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcHJpbnQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ByaW50OiAhZXZlbnQuZGV0YWlsLnByaW50XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGhpZGRlbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaGlkZGVuXG4gICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogaGlkZGVuLFxuICAgICAgICAgIG5vVmlldzogaGlkZGVuXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZvY3VzOiBldmVudCA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZXZlbnQudGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBmYWxzZVxuICAgICAgICB9KSwgMCk7XG4gICAgICB9LFxuICAgICAgdXNlck5hbWU6IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQudGFyZ2V0LnRpdGxlID0gZXZlbnQuZGV0YWlsLnVzZXJOYW1lO1xuICAgICAgfSxcbiAgICAgIHJlYWRvbmx5OiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9IGV2ZW50LmRldGFpbC5yZWFkb25seTtcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9zZXRSZXF1aXJlZChldmVudC50YXJnZXQsIGV2ZW50LmRldGFpbC5yZXF1aXJlZCk7XG4gICAgICB9LFxuICAgICAgYmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJnQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZpbGxDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZpbGxDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgZmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZnQ29sb3JcIiwgXCJjb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgdGV4dENvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwidGV4dENvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGJvcmRlckNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwiYm9yZGVyQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgc3Ryb2tlQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJzdHJva2VDb2xvclwiLCBcImJvcmRlckNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICByb3RhdGlvbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhbmdsZSA9IGV2ZW50LmRldGFpbC5yb3RhdGlvbjtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihhbmdsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgcm90YXRpb246IGFuZ2xlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCkge1xuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhqc0V2ZW50LmRldGFpbCkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNbbmFtZV0gfHwgY29tbW9uQWN0aW9uc1tuYW1lXTtcbiAgICAgIGFjdGlvbj8uKGpzRXZlbnQpO1xuICAgIH1cbiAgfVxuICBfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUodGhpcy5kYXRhLmlkKTtcbiAgICBpZiAoIXN0b3JlZERhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29tbW9uQWN0aW9ucyA9IHRoaXMuX2NvbW1vbkFjdGlvbnM7XG4gICAgZm9yIChjb25zdCBbYWN0aW9uTmFtZSwgZGV0YWlsXSBvZiBPYmplY3QuZW50cmllcyhzdG9yZWREYXRhKSkge1xuICAgICAgY29uc3QgYWN0aW9uID0gY29tbW9uQWN0aW9uc1thY3Rpb25OYW1lXTtcbiAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXZlbnRQcm94eSA9IHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIFthY3Rpb25OYW1lXTogZGV0YWlsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0YXJnZXQ6IGVsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgYWN0aW9uKGV2ZW50UHJveHkpO1xuICAgICAgICBkZWxldGUgc3RvcmVkRGF0YVthY3Rpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCkge1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcXVhZFBvaW50c1xuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgaWYgKCFxdWFkUG9pbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtyZWN0QmxYLCByZWN0QmxZLCByZWN0VHJYLCByZWN0VHJZXSA9IHRoaXMuZGF0YS5yZWN0Lm1hcCh4ID0+IE1hdGguZnJvdW5kKHgpKTtcbiAgICBpZiAocXVhZFBvaW50cy5sZW5ndGggPT09IDgpIHtcbiAgICAgIGNvbnN0IFt0clgsIHRyWSwgYmxYLCBibFldID0gcXVhZFBvaW50cy5zdWJhcnJheSgyLCA2KTtcbiAgICAgIGlmIChyZWN0VHJYID09PSB0clggJiYgcmVjdFRyWSA9PT0gdHJZICYmIHJlY3RCbFggPT09IGJsWCAmJiByZWN0QmxZID09PSBibFkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmNvbnRhaW5lcjtcbiAgICBsZXQgc3ZnQnVmZmVyO1xuICAgIGlmICh0aGlzLiNoYXNCb3JkZXIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYm9yZGVyQ29sb3IsXG4gICAgICAgIGJvcmRlcldpZHRoXG4gICAgICB9ID0gc3R5bGU7XG4gICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICBzdmdCdWZmZXIgPSBbXCJ1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LFwiLCBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJgLCBgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCIgdmlld0JveD1cIjAgMCAxIDFcIj5gLCBgPGcgZmlsbD1cInRyYW5zcGFyZW50XCIgc3Ryb2tlPVwiJHtib3JkZXJDb2xvcn1cIiBzdHJva2Utd2lkdGg9XCIke2JvcmRlcldpZHRofVwiPmBdO1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc0JvcmRlclwiKTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSByZWN0VHJYIC0gcmVjdEJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0VHJZIC0gcmVjdEJsWTtcbiAgICBjb25zdCB7XG4gICAgICBzdmdGYWN0b3J5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3ZnID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnXCIpO1xuICAgIHN2Zy5jbGFzc0xpc3QuYWRkKFwicXVhZHJpbGF0ZXJhbHNDb250YWluZXJcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDApO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgc3ZnLnJvbGUgPSBcIm5vbmVcIjtcbiAgICBjb25zdCBkZWZzID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICBzdmcuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IGNsaXBQYXRoID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIik7XG4gICAgY29uc3QgaWQgPSBgY2xpcHBhdGhfJHt0aGlzLmRhdGEuaWR9YDtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiY2xpcFBhdGhVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgIGRlZnMuYXBwZW5kKGNsaXBQYXRoKTtcbiAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBxdWFkUG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDgpIHtcbiAgICAgIGNvbnN0IHRyWCA9IHF1YWRQb2ludHNbaV07XG4gICAgICBjb25zdCB0clkgPSBxdWFkUG9pbnRzW2kgKyAxXTtcbiAgICAgIGNvbnN0IGJsWCA9IHF1YWRQb2ludHNbaSArIDJdO1xuICAgICAgY29uc3QgYmxZID0gcXVhZFBvaW50c1tpICsgM107XG4gICAgICBjb25zdCByZWN0ID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicmVjdFwiKTtcbiAgICAgIGNvbnN0IHggPSAoYmxYIC0gcmVjdEJsWCkgLyB3aWR0aDtcbiAgICAgIGNvbnN0IHkgPSAocmVjdFRyWSAtIHRyWSkgLyBoZWlnaHQ7XG4gICAgICBjb25zdCByZWN0V2lkdGggPSAodHJYIC0gYmxYKSAvIHdpZHRoO1xuICAgICAgY29uc3QgcmVjdEhlaWdodCA9ICh0clkgLSBibFkpIC8gaGVpZ2h0O1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ4XCIsIHgpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ5XCIsIHkpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCByZWN0V2lkdGgpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgcmVjdEhlaWdodCk7XG4gICAgICBjbGlwUGF0aC5hcHBlbmQocmVjdCk7XG4gICAgICBzdmdCdWZmZXI/LnB1c2goYDxyZWN0IHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiB4PVwiJHt4fVwiIHk9XCIke3l9XCIgd2lkdGg9XCIke3JlY3RXaWR0aH1cIiBoZWlnaHQ9XCIke3JlY3RIZWlnaHR9XCIvPmApO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaGFzQm9yZGVyKSB7XG4gICAgICBzdmdCdWZmZXIucHVzaChgPC9nPjwvc3ZnPicpYCk7XG4gICAgICBzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBzdmdCdWZmZXIuam9pbihcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUuY2xpcFBhdGggPSBgdXJsKCMke2lkfSlgO1xuICB9XG4gIF9jcmVhdGVQb3B1cChwb3B1cERhdGEgPSBudWxsKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBjb250ZW50c09iaiwgbW9kaWZpY2F0aW9uRGF0ZTtcbiAgICBpZiAocG9wdXBEYXRhKSB7XG4gICAgICBjb250ZW50c09iaiA9IHtcbiAgICAgICAgc3RyOiBwb3B1cERhdGEudGV4dFxuICAgICAgfTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUgPSBwb3B1cERhdGEuZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudHNPYmogPSBkYXRhLmNvbnRlbnRzT2JqO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZSA9IGRhdGEubW9kaWZpY2F0aW9uRGF0ZTtcbiAgICB9XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLiNwb3B1cEVsZW1lbnQgPSBuZXcgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNvbG9yOiBkYXRhLmNvbG9yLFxuICAgICAgICB0aXRsZU9iajogZGF0YS50aXRsZU9iaixcbiAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZSxcbiAgICAgICAgY29udGVudHNPYmosXG4gICAgICAgIHJpY2hUZXh0OiBkYXRhLnJpY2hUZXh0LFxuICAgICAgICBwYXJlbnRSZWN0OiBkYXRhLnJlY3QsXG4gICAgICAgIGJvcmRlclN0eWxlOiAwLFxuICAgICAgICBpZDogYHBvcHVwXyR7ZGF0YS5pZH1gLFxuICAgICAgICByb3RhdGlvbjogZGF0YS5yb3RhdGlvbixcbiAgICAgICAgbm9Sb3RhdGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBsaW5rU2VydmljZTogdGhpcy5saW5rU2VydmljZSxcbiAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQsXG4gICAgICBlbGVtZW50czogW3RoaXNdXG4gICAgfSk7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmFwcGVuZChwb3B1cC5yZW5kZXIoKSk7XG4gIH1cbiAgZ2V0IGhhc1BvcHVwRWxlbWVudCgpIHtcbiAgICByZXR1cm4gISEodGhpcy4jcG9wdXBFbGVtZW50IHx8IHRoaXMucG9wdXAgfHwgdGhpcy5kYXRhLnBvcHVwUmVmKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYEFubm90YXRpb25FbGVtZW50LnJlbmRlcmAgY2FsbGVkXCIpO1xuICB9XG4gIF9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBza2lwSWQgPSBudWxsKSB7XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgaWYgKHRoaXMuX2ZpZWxkT2JqZWN0cykge1xuICAgICAgY29uc3QgZmllbGRPYmogPSB0aGlzLl9maWVsZE9iamVjdHNbbmFtZV07XG4gICAgICBpZiAoZmllbGRPYmopIHtcbiAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgcGFnZSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBleHBvcnRWYWx1ZXNcbiAgICAgICAgfSBvZiBmaWVsZE9iaikge1xuICAgICAgICAgIGlmIChwYWdlID09PSAtMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpZCA9PT0gc2tpcElkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXhwb3J0VmFsdWUgPSB0eXBlb2YgZXhwb3J0VmFsdWVzID09PSBcInN0cmluZ1wiID8gZXhwb3J0VmFsdWVzIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtZWxlbWVudC1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICAgICAgaWYgKGRvbUVsZW1lbnQgJiYgIUdldEVsZW1lbnRzQnlOYW1lU2V0Lmhhcyhkb21FbGVtZW50KSkge1xuICAgICAgICAgICAgd2FybihgX2dldEVsZW1lbnRzQnlOYW1lIC0gZWxlbWVudCBub3QgYWxsb3dlZDogJHtpZH1gKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGV4cG9ydFZhbHVlLFxuICAgICAgICAgICAgZG9tRWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmllbGRzO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRvbUVsZW1lbnQgb2YgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUobmFtZSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXhwb3J0VmFsdWVcbiAgICAgIH0gPSBkb21FbGVtZW50O1xuICAgICAgY29uc3QgaWQgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiKTtcbiAgICAgIGlmIChpZCA9PT0gc2tpcElkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBleHBvcnRWYWx1ZSxcbiAgICAgICAgZG9tRWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnBvcHVwPy5tYXliZVNob3coKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5wb3B1cD8uZm9yY2VIaWRlKCk7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRyaWdnZXJzKSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRyaWdnZXJzKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJzLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICAgIH1cbiAgfVxuICBfZWRpdE9uRG91YmxlQ2xpY2soKSB7XG4gICAgaWYgKCF0aGlzLl9pc0VkaXRhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25FZGl0b3JUeXBlOiBtb2RlLFxuICAgICAgZGF0YToge1xuICAgICAgICBpZDogZWRpdElkXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcm1vZGVcIiwge1xuICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGVkaXRJZCxcbiAgICAgICAgbXVzdEVudGVySW5FZGl0TW9kZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEucmVjdFsyXSAtIHRoaXMuZGF0YS5yZWN0WzBdO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV07XG4gIH1cbn1cbmNsYXNzIExpbmtBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycywgb3B0aW9ucyA9IG51bGwpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6ICEhb3B0aW9ucz8uaWdub3JlQm9yZGVyLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmlzVG9vbHRpcE9ubHkgPSBwYXJhbWV0ZXJzLmRhdGEuaXNUb29sdGlwT25seTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIGxpbmtTZXJ2aWNlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGRhdGEuaWQpO1xuICAgIGxldCBpc0JvdW5kID0gZmFsc2U7XG4gICAgaWYgKGRhdGEudXJsKSB7XG4gICAgICBsaW5rU2VydmljZS5hZGRMaW5rQXR0cmlidXRlcyhsaW5rLCBkYXRhLnVybCwgZGF0YS5uZXdXaW5kb3cpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmFjdGlvbikge1xuICAgICAgdGhpcy5fYmluZE5hbWVkQWN0aW9uKGxpbmssIGRhdGEuYWN0aW9uLCBkYXRhLm92ZXJsYWlkVGV4dCk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuYXR0YWNobWVudCkge1xuICAgICAgdGhpcy4jYmluZEF0dGFjaG1lbnQobGluaywgZGF0YS5hdHRhY2htZW50LCBkYXRhLm92ZXJsYWlkVGV4dCwgZGF0YS5hdHRhY2htZW50RGVzdCk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuc2V0T0NHU3RhdGUpIHtcbiAgICAgIHRoaXMuI2JpbmRTZXRPQ0dTdGF0ZShsaW5rLCBkYXRhLnNldE9DR1N0YXRlLCBkYXRhLm92ZXJsYWlkVGV4dCk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZGVzdCkge1xuICAgICAgdGhpcy5fYmluZExpbmsobGluaywgZGF0YS5kZXN0LCBkYXRhLm92ZXJsYWlkVGV4dCk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRhdGEuYWN0aW9ucyAmJiAoZGF0YS5hY3Rpb25zLkFjdGlvbiB8fCBkYXRhLmFjdGlvbnNbXCJNb3VzZSBVcFwiXSB8fCBkYXRhLmFjdGlvbnNbXCJNb3VzZSBEb3duXCJdKSAmJiB0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgICB0aGlzLl9iaW5kSlNBY3Rpb24obGluaywgZGF0YSk7XG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEucmVzZXRGb3JtKSB7XG4gICAgICAgIHRoaXMuX2JpbmRSZXNldEZvcm1BY3Rpb24obGluaywgZGF0YS5yZXNldEZvcm0pO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1Rvb2x0aXBPbmx5ICYmICFpc0JvdW5kKSB7XG4gICAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIFwiXCIpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImxpbmtBbm5vdGF0aW9uXCIpO1xuICAgIGlmIChpc0JvdW5kKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQobGluayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICAjc2V0SW50ZXJuYWxMaW5rKCkge1xuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtaW50ZXJuYWwtbGlua1wiLCBcIlwiKTtcbiAgfVxuICBfYmluZExpbmsobGluaywgZGVzdGluYXRpb24sIG92ZXJsYWlkVGV4dCA9IFwiXCIpIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldERlc3RpbmF0aW9uSGFzaChkZXN0aW5hdGlvbik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZ29Ub0Rlc3RpbmF0aW9uKGRlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChkZXN0aW5hdGlvbiB8fCBkZXN0aW5hdGlvbiA9PT0gXCJcIikge1xuICAgICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gICAgfVxuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGxpbmsudGl0bGUgPSBvdmVybGFpZFRleHQ7XG4gICAgfVxuICB9XG4gIF9iaW5kTmFtZWRBY3Rpb24obGluaywgYWN0aW9uLCBvdmVybGFpZFRleHQgPSBcIlwiKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlTmFtZWRBY3Rpb24oYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGxpbmsudGl0bGUgPSBvdmVybGFpZFRleHQ7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gICNiaW5kQXR0YWNobWVudChsaW5rLCBhdHRhY2htZW50LCBvdmVybGFpZFRleHQgPSBcIlwiLCBkZXN0ID0gbnVsbCkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGlmIChhdHRhY2htZW50LmRlc2NyaXB0aW9uKSB7XG4gICAgICBsaW5rLnRpdGxlID0gYXR0YWNobWVudC5kZXNjcmlwdGlvbjtcbiAgICB9IGVsc2UgaWYgKG92ZXJsYWlkVGV4dCkge1xuICAgICAgbGluay50aXRsZSA9IG92ZXJsYWlkVGV4dDtcbiAgICB9XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5kb3dubG9hZE1hbmFnZXI/Lm9wZW5PckRvd25sb2FkRGF0YShhdHRhY2htZW50LmNvbnRlbnQsIGF0dGFjaG1lbnQuZmlsZW5hbWUsIGRlc3QpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgI2JpbmRTZXRPQ0dTdGF0ZShsaW5rLCBhY3Rpb24sIG92ZXJsYWlkVGV4dCA9IFwiXCIpIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV4ZWN1dGVTZXRPQ0dTdGF0ZShhY3Rpb24pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgaWYgKG92ZXJsYWlkVGV4dCkge1xuICAgICAgbGluay50aXRsZSA9IG92ZXJsYWlkVGV4dDtcbiAgICB9XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgX2JpbmRKU0FjdGlvbihsaW5rLCBkYXRhKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcChbW1wiQWN0aW9uXCIsIFwib25jbGlja1wiXSwgW1wiTW91c2UgVXBcIiwgXCJvbm1vdXNldXBcIl0sIFtcIk1vdXNlIERvd25cIiwgXCJvbm1vdXNlZG93blwiXV0pO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkYXRhLmFjdGlvbnMpKSB7XG4gICAgICBjb25zdCBqc05hbWUgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgaWYgKCFqc05hbWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsaW5rW2pzTmFtZV0gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGRhdGEub3ZlcmxhaWRUZXh0KSB7XG4gICAgICBsaW5rLnRpdGxlID0gZGF0YS5vdmVybGFpZFRleHQ7XG4gICAgfVxuICAgIGlmICghbGluay5vbmNsaWNrKSB7XG4gICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgX2JpbmRSZXNldEZvcm1BY3Rpb24obGluaywgcmVzZXRGb3JtKSB7XG4gICAgY29uc3Qgb3RoZXJDbGlja0FjdGlvbiA9IGxpbmsub25jbGljaztcbiAgICBpZiAoIW90aGVyQ2xpY2tBY3Rpb24pIHtcbiAgICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgICBpZiAoIXRoaXMuX2ZpZWxkT2JqZWN0cykge1xuICAgICAgd2FybihgX2JpbmRSZXNldEZvcm1BY3Rpb24gLSBcInJlc2V0Rm9ybVwiIGFjdGlvbiBub3Qgc3VwcG9ydGVkLCBgICsgXCJlbnN1cmUgdGhhdCB0aGUgYGZpZWxkT2JqZWN0c2AgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLlwiKTtcbiAgICAgIGlmICghb3RoZXJDbGlja0FjdGlvbikge1xuICAgICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgb3RoZXJDbGlja0FjdGlvbj8uKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpZWxkczogcmVzZXRGb3JtRmllbGRzLFxuICAgICAgICByZWZzOiByZXNldEZvcm1SZWZzLFxuICAgICAgICBpbmNsdWRlXG4gICAgICB9ID0gcmVzZXRGb3JtO1xuICAgICAgY29uc3QgYWxsRmllbGRzID0gW107XG4gICAgICBpZiAocmVzZXRGb3JtRmllbGRzLmxlbmd0aCAhPT0gMCB8fCByZXNldEZvcm1SZWZzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBmaWVsZElkcyA9IG5ldyBTZXQocmVzZXRGb3JtUmVmcyk7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIHJlc2V0Rm9ybUZpZWxkcykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkT2JqZWN0c1tmaWVsZE5hbWVdIHx8IFtdO1xuICAgICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9IG9mIGZpZWxkcykge1xuICAgICAgICAgICAgZmllbGRJZHMuYWRkKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZElkcy5oYXMoZmllbGQuaWQpID09PSBpbmNsdWRlKSB7XG4gICAgICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRzIG9mIE9iamVjdC52YWx1ZXModGhpcy5fZmllbGRPYmplY3RzKSkge1xuICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKC4uLmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgY29uc3QgYWxsSWRzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGFsbEZpZWxkcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IGZpZWxkO1xuICAgICAgICBhbGxJZHMucHVzaChpZCk7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgY2FzZSBcInJhZGlvYnV0dG9uXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlID09PSBmaWVsZC5leHBvcnRWYWx1ZXM7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNvbWJvYm94XCI6XG4gICAgICAgICAgY2FzZSBcImxpc3Rib3hcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICBpZiAoIWRvbUVsZW1lbnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICghR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgd2FybihgX2JpbmRSZXNldEZvcm1BY3Rpb24gLSBlbGVtZW50IG5vdCBhbGxvd2VkOiAke2lkfWApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRvbUVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJyZXNldGZvcm1cIikpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nKSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IFwiYXBwXCIsXG4gICAgICAgICAgICBpZHM6IGFsbElkcyxcbiAgICAgICAgICAgIG5hbWU6IFwiUmVzZXRGb3JtXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbn1cbmNsYXNzIFRleHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGV4dEFubm90YXRpb25cIik7XG4gICAgY29uc3QgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIGltYWdlLnNyYyA9IHRoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoICsgXCJhbm5vdGF0aW9uLVwiICsgdGhpcy5kYXRhLm5hbWUudG9Mb3dlckNhc2UoKSArIFwiLnN2Z1wiO1xuICAgIGltYWdlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLXRleHQtYW5ub3RhdGlvbi10eXBlXCIpO1xuICAgIGltYWdlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHR5cGU6IHRoaXMuZGF0YS5uYW1lXG4gICAgfSkpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoaW1hZ2UpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgc2hvd0VsZW1lbnRBbmRIaWRlQ2FudmFzKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgaWYgKGVsZW1lbnQucHJldmlvdXNTaWJsaW5nPy5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgICBlbGVtZW50LnByZXZpb3VzU2libGluZy5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgX2dldEtleU1vZGlmaWVyKGV2ZW50KSB7XG4gICAgcmV0dXJuIHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm0uaXNNYWMgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleTtcbiAgfVxuICBfc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgYmFzZU5hbWUsIGV2ZW50TmFtZSwgdmFsdWVHZXR0ZXIpIHtcbiAgICBpZiAoYmFzZU5hbWUuaW5jbHVkZXMoXCJtb3VzZVwiKSkge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGJhc2VOYW1lLCBldmVudCA9PiB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZGF0YS5pZCxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZUdldHRlcihldmVudCksXG4gICAgICAgICAgICBzaGlmdDogZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICBtb2RpZmllcjogdGhpcy5fZ2V0S2V5TW9kaWZpZXIoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZU5hbWUsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGJhc2VOYW1lID09PSBcImJsdXJcIikge1xuICAgICAgICAgIGlmICghZWxlbWVudERhdGEuZm9jdXNlZCB8fCAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZU5hbWUgPT09IFwiZm9jdXNcIikge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWVHZXR0ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlR2V0dGVyKGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBuYW1lcywgZ2V0dGVyKSB7XG4gICAgZm9yIChjb25zdCBbYmFzZU5hbWUsIGV2ZW50TmFtZV0gb2YgbmFtZXMpIHtcbiAgICAgIGlmIChldmVudE5hbWUgPT09IFwiQWN0aW9uXCIgfHwgdGhpcy5kYXRhLmFjdGlvbnM/LltldmVudE5hbWVdKSB7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiRm9jdXNcIiB8fCBldmVudE5hbWUgPT09IFwiQmx1clwiKSB7XG4gICAgICAgICAgZWxlbWVudERhdGEgfHw9IHtcbiAgICAgICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBiYXNlTmFtZSwgZXZlbnROYW1lLCBnZXR0ZXIpO1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcIkZvY3VzXCIgJiYgIXRoaXMuZGF0YS5hY3Rpb25zPy5CbHVyKSB7XG4gICAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgXCJibHVyXCIsIFwiQmx1clwiLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09IFwiQmx1clwiICYmICF0aGlzLmRhdGEuYWN0aW9ucz8uRm9jdXMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBcImZvY3VzXCIsIFwiRm9jdXNcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KSB7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmRhdGEuYmFja2dyb3VuZENvbG9yIHx8IG51bGw7XG4gICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvciA9PT0gbnVsbCA/IFwidHJhbnNwYXJlbnRcIiA6IFV0aWwubWFrZUhleENvbG9yKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0pO1xuICB9XG4gIF9zZXRUZXh0U3R5bGUoZWxlbWVudCkge1xuICAgIGNvbnN0IFRFWFRfQUxJR05NRU5UID0gW1wibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCJdO1xuICAgIGNvbnN0IHtcbiAgICAgIGZvbnRDb2xvclxuICAgIH0gPSB0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhO1xuICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YS5mb250U2l6ZSB8fCBhbm5vdGF0aW9uX2xheWVyX0RFRkFVTFRfRk9OVF9TSVpFO1xuICAgIGNvbnN0IHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBsZXQgY29tcHV0ZWRGb250U2l6ZTtcbiAgICBjb25zdCBCT1JERVJfU0laRSA9IDI7XG4gICAgY29uc3Qgcm91bmRUb09uZURlY2ltYWwgPSB4ID0+IE1hdGgucm91bmQoMTAgKiB4KSAvIDEwO1xuICAgIGlmICh0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyh0aGlzLmRhdGEucmVjdFszXSAtIHRoaXMuZGF0YS5yZWN0WzFdIC0gQk9SREVSX1NJWkUpO1xuICAgICAgY29uc3QgbnVtYmVyT2ZMaW5lcyA9IE1hdGgucm91bmQoaGVpZ2h0IC8gKExJTkVfRkFDVE9SICogZm9udFNpemUpKSB8fCAxO1xuICAgICAgY29uc3QgbGluZUhlaWdodCA9IGhlaWdodCAvIG51bWJlck9mTGluZXM7XG4gICAgICBjb21wdXRlZEZvbnRTaXplID0gTWF0aC5taW4oZm9udFNpemUsIHJvdW5kVG9PbmVEZWNpbWFsKGxpbmVIZWlnaHQgLyBMSU5FX0ZBQ1RPUikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyh0aGlzLmRhdGEucmVjdFszXSAtIHRoaXMuZGF0YS5yZWN0WzFdIC0gQk9SREVSX1NJWkUpO1xuICAgICAgY29tcHV0ZWRGb250U2l6ZSA9IE1hdGgubWluKGZvbnRTaXplLCByb3VuZFRvT25lRGVjaW1hbChoZWlnaHQgLyBMSU5FX0ZBQ1RPUikpO1xuICAgIH1cbiAgICBzdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7Y29tcHV0ZWRGb250U2l6ZX1weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IFV0aWwubWFrZUhleENvbG9yKGZvbnRDb2xvclswXSwgZm9udENvbG9yWzFdLCBmb250Q29sb3JbMl0pO1xuICAgIGlmICh0aGlzLmRhdGEudGV4dEFsaWdubWVudCAhPT0gbnVsbCkge1xuICAgICAgc3R5bGUudGV4dEFsaWduID0gVEVYVF9BTElHTk1FTlRbdGhpcy5kYXRhLnRleHRBbGlnbm1lbnRdO1xuICAgIH1cbiAgfVxuICBfc2V0UmVxdWlyZWQoZWxlbWVudCwgaXNSZXF1aXJlZCkge1xuICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInJlcXVpcmVkXCIsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtcmVxdWlyZWRcIiwgaXNSZXF1aXJlZCk7XG4gIH1cbn1cbmNsYXNzIFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9IHBhcmFtZXRlcnMucmVuZGVyRm9ybXMgfHwgcGFyYW1ldGVycy5kYXRhLmhhc093bkNhbnZhcyB8fCAhcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2UgJiYgISFwYXJhbWV0ZXJzLmRhdGEuZmllbGRWYWx1ZTtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGVcbiAgICB9KTtcbiAgfVxuICBzZXRQcm9wZXJ0eU9uU2libGluZ3MoYmFzZSwga2V5LCB2YWx1ZSwga2V5SW5TdG9yYWdlKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKGJhc2UubmFtZSwgYmFzZS5pZCkpIHtcbiAgICAgIGlmIChlbGVtZW50LmRvbUVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5kb21FbGVtZW50W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoZWxlbWVudC5pZCwge1xuICAgICAgICBba2V5SW5TdG9yYWdlXTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgaWQgPSB0aGlzLmRhdGEuaWQ7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInRleHRXaWRnZXRBbm5vdGF0aW9uXCIpO1xuICAgIGxldCBlbGVtZW50ID0gbnVsbDtcbiAgICBpZiAodGhpcy5yZW5kZXJGb3Jtcykge1xuICAgICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuZGF0YS5maWVsZFZhbHVlXG4gICAgICB9KTtcbiAgICAgIGxldCB0ZXh0Q29udGVudCA9IHN0b3JlZERhdGEudmFsdWUgfHwgXCJcIjtcbiAgICAgIGNvbnN0IG1heExlbiA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgICAgY2hhckxpbWl0OiB0aGlzLmRhdGEubWF4TGVuXG4gICAgICB9KS5jaGFyTGltaXQ7XG4gICAgICBpZiAobWF4TGVuICYmIHRleHRDb250ZW50Lmxlbmd0aCA+IG1heExlbikge1xuICAgICAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDAsIG1heExlbik7XG4gICAgICB9XG4gICAgICBsZXQgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPSBzdG9yZWREYXRhLmZvcm1hdHRlZFZhbHVlIHx8IHRoaXMuZGF0YS50ZXh0Q29udGVudD8uam9pbihcIlxcblwiKSB8fCBudWxsO1xuICAgICAgaWYgKGZpZWxkRm9ybWF0dGVkVmFsdWVzICYmIHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgIGZpZWxkRm9ybWF0dGVkVmFsdWVzID0gZmllbGRGb3JtYXR0ZWRWYWx1ZXMucmVwbGFjZUFsbCgvXFxzKy9nLCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsZW1lbnREYXRhID0ge1xuICAgICAgICB1c2VyVmFsdWU6IHRleHRDb250ZW50LFxuICAgICAgICBmb3JtYXR0ZWRWYWx1ZTogZmllbGRGb3JtYXR0ZWRWYWx1ZXMsXG4gICAgICAgIGxhc3RDb21taXR0ZWRWYWx1ZTogbnVsbCxcbiAgICAgICAgY29tbWl0S2V5OiAxLFxuICAgICAgICBmb2N1c2VkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBmaWVsZEZvcm1hdHRlZFZhbHVlcyA/PyB0ZXh0Q29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5kb05vdFNjcm9sbCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gXCJoaWRkZW5cIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgZWxlbWVudC50eXBlID0gdGhpcy5kYXRhLnBhc3N3b3JkID8gXCJwYXNzd29yZFwiIDogXCJ0ZXh0XCI7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPz8gdGV4dENvbnRlbnQpO1xuICAgICAgICBpZiAodGhpcy5kYXRhLmRvTm90U2Nyb2xsKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5vdmVyZmxvd1ggPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgICBlbGVtZW50LmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgICBlbGVtZW50LmRpc2FibGVkID0gdGhpcy5kYXRhLnJlYWRPbmx5O1xuICAgICAgZWxlbWVudC5uYW1lID0gdGhpcy5kYXRhLmZpZWxkTmFtZTtcbiAgICAgIGVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRldGltZUZvcm1hdCxcbiAgICAgICAgZGF0ZXRpbWVUeXBlLFxuICAgICAgICB0aW1lU3RlcFxuICAgICAgfSA9IHRoaXMuZGF0YTtcbiAgICAgIGNvbnN0IGhhc0RhdGVPclRpbWUgPSAhIWRhdGV0aW1lVHlwZSAmJiB0aGlzLmVuYWJsZVNjcmlwdGluZztcbiAgICAgIGlmIChkYXRldGltZUZvcm1hdCkge1xuICAgICAgICBlbGVtZW50LnRpdGxlID0gZGF0ZXRpbWVGb3JtYXQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgICAgaWYgKG1heExlbikge1xuICAgICAgICBlbGVtZW50Lm1heExlbmd0aCA9IG1heExlbjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHlPblNpYmxpbmdzKGVsZW1lbnQsIFwidmFsdWVcIiwgZXZlbnQudGFyZ2V0LnZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSA/PyBcIlwiO1xuICAgICAgICBlbGVtZW50LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIGxldCBibHVyTGlzdGVuZXIgPSBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICB9ID0gZWxlbWVudERhdGE7XG4gICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSAhPT0gbnVsbCAmJiBmb3JtYXR0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0LnNjcm9sbExlZnQgPSAwO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgIGlmIChoYXNEYXRlT3JUaW1lKSB7XG4gICAgICAgICAgICB0YXJnZXQudHlwZSA9IGRhdGV0aW1lVHlwZTtcbiAgICAgICAgICAgIGlmICh0aW1lU3RlcCkge1xuICAgICAgICAgICAgICB0YXJnZXQuc3RlcCA9IHRpbWVTdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEudXNlclZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICAgIGlmIChoYXNEYXRlT3JUaW1lKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRldGltZVR5cGUgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IFtkYXRlLmdldEhvdXJzKCksIGRhdGUuZ2V0TWludXRlcygpLCBkYXRlLmdldFNlY29uZHMoKV07XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gcGFydHMubWFwKHYgPT4gdi50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIjpcIik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gbmV3IERhdGUodmFsdWUgLSBUSU1FWk9ORV9PRkZTRVQpLnRvSVNPU3RyaW5nKCkuc3BsaXQoZGF0ZXRpbWVUeXBlID09PSBcImRhdGVcIiA/IFwiVFwiIDogXCIuXCIsIDEpWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICAgICAgICAgIGVsZW1lbnREYXRhLmNvbW1pdEtleSA9IDE7XG4gICAgICAgICAgaWYgKCF0aGlzLmRhdGEuYWN0aW9ucz8uRm9jdXMpIHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICAgIHRoaXMuc2hvd0VsZW1lbnRBbmRIaWRlQ2FudmFzKGpzRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgICAgdmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gZXZlbnQuZGV0YWlsLnZhbHVlID8/IFwiXCI7XG4gICAgICAgICAgICAgIGlmICghaGFzRGF0ZU9yVGltZSkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBlbGVtZW50RGF0YS51c2VyVmFsdWUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZShldmVudCkge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlICE9PSBudWxsICYmIGZvcm1hdHRlZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgZXZlbnQudGFyZ2V0ICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoaGFzRGF0ZU9yVGltZSkge1xuICAgICAgICAgICAgICAgIGRhdGEudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCBkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxSYW5nZShldmVudCkge1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQuc2V0U2VsZWN0aW9uUmFuZ2UoLi4uZXZlbnQuZGV0YWlsLnNlbFJhbmdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFyTGltaXQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGNoYXJMaW1pdFxuICAgICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgaWYgKGNoYXJMaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIiwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA8PSBjaGFyTGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBjaGFyTGltaXQpO1xuICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiB0YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICBzZWxFbmQ6IHRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG4gICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMTtcbiAgICAgICAgICBsZXQgY29tbWl0S2V5ID0gLTE7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiICYmICF0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgICAgICBjb21taXRLZXkgPSAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWl0S2V5ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgIGNvbW1pdEtleSxcbiAgICAgICAgICAgICAgc2VsU3RhcnQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfYmx1ckxpc3RlbmVyID0gYmx1ckxpc3RlbmVyO1xuICAgICAgICBibHVyTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnREYXRhLmZvY3VzZWQgfHwgIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmRhdGEuYWN0aW9ucz8uQmx1cikge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSA9IHRhcmdldDtcbiAgICAgICAgICBpZiAoaGFzRGF0ZU9yVGltZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIGRhdGV0aW1lVHlwZSA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSB2YWx1ZS5zcGxpdChcIjpcIikubWFwKHYgPT4gcGFyc2VJbnQodiwgMTApKTtcbiAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSgyMDAwLCAwLCAxLCBwYXJ0c1swXSwgcGFydHNbMV0sIHBhcnRzWzJdIHx8IDApLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgdGFyZ2V0LnN0ZXAgPSBcIlwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSkudmFsdWVPZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbW1pdEtleTogZWxlbWVudERhdGEuY29tbWl0S2V5LFxuICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfYmx1ckxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuYWN0aW9ucz8uS2V5c3Ryb2tlKSB7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9ID0gdGFyZ2V0O1xuICAgICAgICAgICAgbGV0IHNlbFN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVXb3JkQmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCkubWF0Y2goL1xcdypbXlxcd10qJC8pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVdvcmRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uU3RhcnQpLm1hdGNoKC9eW15cXHddKlxcdyovKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxFbmQgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEZvcndhcmRcIjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IGRhdGEgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZWxTdGFydCxcbiAgICAgICAgICAgICAgICBzZWxFbmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgZWxlbWVudERhdGEsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChibHVyTGlzdGVuZXIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkV2lkdGggPSB0aGlzLmRhdGEucmVjdFsyXSAtIHRoaXMuZGF0YS5yZWN0WzBdO1xuICAgICAgICBjb25zdCBjb21iV2lkdGggPSBmaWVsZFdpZHRoIC8gbWF4TGVuO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb21iXCIpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxldHRlclNwYWNpbmcgPSBgY2FsYygke2NvbWJXaWR0aH1weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgLSAxY2gpYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgICBlbGVtZW50LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcIm1pZGRsZVwiO1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZS1jZWxsXCI7XG4gICAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgICBlbGVtZW50LmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3NldFRleHRTdHlsZShlbGVtZW50KTtcbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6ICEhcGFyYW1ldGVycy5kYXRhLmhhc093bkNhbnZhc1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmV4cG9ydFZhbHVlID09PSBkYXRhLmZpZWxkVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBcIk9mZlwiO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwiY2hlY2tCb3hcIik7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgZWxlbWVudC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImV4cG9ydFZhbHVlXCIsIGRhdGEuZXhwb3J0VmFsdWUpO1xuICAgIGVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoZWNrZWRcbiAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICBmb3IgKGNvbnN0IGNoZWNrYm94IG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIGlkKSkge1xuICAgICAgICBjb25zdCBjdXJDaGVja2VkID0gY2hlY2tlZCAmJiBjaGVja2JveC5leHBvcnRWYWx1ZSA9PT0gZGF0YS5leHBvcnRWYWx1ZTtcbiAgICAgICAgaWYgKGNoZWNrYm94LmRvbUVsZW1lbnQpIHtcbiAgICAgICAgICBjaGVja2JveC5kb21FbGVtZW50LmNoZWNrZWQgPSBjdXJDaGVja2VkO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoY2hlY2tib3guaWQsIHtcbiAgICAgICAgICB2YWx1ZTogY3VyQ2hlY2tlZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IGNoZWNrZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBkYXRhLmRlZmF1bHRGaWVsZFZhbHVlIHx8IFwiT2ZmXCI7XG4gICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZSA9PT0gZGF0YS5leHBvcnRWYWx1ZTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGV2ZW50LmRldGFpbC52YWx1ZSAhPT0gXCJPZmZcIjtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC5jaGVja2VkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgbnVsbCwgW1tcImNoYW5nZVwiLCBcIlZhbGlkYXRlXCJdLCBbXCJjaGFuZ2VcIiwgXCJBY3Rpb25cIl0sIFtcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfVxuICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KTtcbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhlbGVtZW50KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwicmFkaW9CdXR0b25cIik7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCBpZCA9IGRhdGEuaWQ7XG4gICAgbGV0IHZhbHVlID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IGRhdGEuZmllbGRWYWx1ZSA9PT0gZGF0YS5idXR0b25WYWx1ZVxuICAgIH0pLnZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgIT09IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKGRhdGEuZmllbGROYW1lLCBpZCkpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShyYWRpby5pZCwge1xuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgZWxlbWVudC50eXBlID0gXCJyYWRpb1wiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgIH1cbiAgICBlbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBpZCkpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShyYWRpby5pZCwge1xuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IGNoZWNrZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBkYXRhLmRlZmF1bHRGaWVsZFZhbHVlO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgZGVmYXVsdFZhbHVlID09PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgY29uc3QgcGRmQnV0dG9uVmFsdWUgPSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSBwZGZCdXR0b25WYWx1ZSA9PT0gZXZlbnQuZGV0YWlsLnZhbHVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShldmVudC50YXJnZXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VyQ2hlY2tlZCA9IGNoZWNrZWQgJiYgcmFkaW8uaWQgPT09IGlkO1xuICAgICAgICAgICAgICBpZiAocmFkaW8uZG9tRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJhZGlvLmRvbUVsZW1lbnQuY2hlY2tlZCA9IGN1ckNoZWNrZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShyYWRpby5pZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJDaGVja2VkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBudWxsLCBbW1wiY2hhbmdlXCIsIFwiVmFsaWRhdGVcIl0sIFtcImNoYW5nZVwiLCBcIkFjdGlvblwiXSwgW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIExpbmtBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpZ25vcmVCb3JkZXI6IHBhcmFtZXRlcnMuZGF0YS5oYXNBcHBlYXJhbmNlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcInB1c2hCdXR0b25cIik7XG4gICAgY29uc3QgbGlua0VsZW1lbnQgPSBjb250YWluZXIubGFzdENoaWxkO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucyAmJiBsaW5rRWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMobGlua0VsZW1lbnQpO1xuICAgICAgbGlua0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goe30sIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaG9pY2VXaWRnZXRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGlkID0gdGhpcy5kYXRhLmlkO1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICB9KTtcbiAgICBjb25zdCBzZWxlY3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoc2VsZWN0RWxlbWVudCk7XG4gICAgc2VsZWN0RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIHNlbGVjdEVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoc2VsZWN0RWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBzZWxlY3RFbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgIHNlbGVjdEVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgIGxldCBhZGRBbkVtcHR5RW50cnkgPSB0aGlzLmRhdGEuY29tYm8gJiYgdGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoID4gMDtcbiAgICBpZiAoIXRoaXMuZGF0YS5jb21ibykge1xuICAgICAgc2VsZWN0RWxlbWVudC5zaXplID0gdGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aVNlbGVjdCkge1xuICAgICAgICBzZWxlY3RFbGVtZW50Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHNlbGVjdEVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBvcHRpb24udmFsdWUgPT09IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiB0aGlzLmRhdGEub3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9uLmRpc3BsYXlWYWx1ZTtcbiAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBvcHRpb24uZXhwb3J0VmFsdWU7XG4gICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZS5pbmNsdWRlcyhvcHRpb24uZXhwb3J0VmFsdWUpKSB7XG4gICAgICAgIG9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICAgIGFkZEFuRW1wdHlFbnRyeSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgfVxuICAgIGxldCByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcbiAgICBpZiAoYWRkQW5FbXB0eUVudHJ5KSB7XG4gICAgICBjb25zdCBub25lT3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBub25lT3B0aW9uRWxlbWVudC52YWx1ZSA9IFwiIFwiO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaGlkZGVuXCIsIHRydWUpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICBzZWxlY3RFbGVtZW50LnByZXBlbmQobm9uZU9wdGlvbkVsZW1lbnQpO1xuICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9ICgpID0+IHtcbiAgICAgICAgbm9uZU9wdGlvbkVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHJlbW92ZUVtcHR5RW50cnkpO1xuICAgICAgICByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICB9XG4gICAgY29uc3QgZ2V0VmFsdWUgPSBpc0V4cG9ydCA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gaXNFeHBvcnQgPyBcInZhbHVlXCIgOiBcInRleHRDb250ZW50XCI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIG11bHRpcGxlXG4gICAgICB9ID0gc2VsZWN0RWxlbWVudDtcbiAgICAgIGlmICghbXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBudWxsIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdW25hbWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKS5tYXAob3B0aW9uID0+IG9wdGlvbltuYW1lXSk7XG4gICAgfTtcbiAgICBsZXQgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgY29uc3QgZ2V0SXRlbXMgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG9wdGlvbnMsIG9wdGlvbiA9PiAoe1xuICAgICAgICBkaXNwbGF5VmFsdWU6IG9wdGlvbi50ZXh0Q29udGVudCxcbiAgICAgICAgZXhwb3J0VmFsdWU6IG9wdGlvbi52YWx1ZVxuICAgICAgfSkpO1xuICAgIH07XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeT8uKCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBTZXQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygc2VsZWN0RWxlbWVudC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlcy5oYXMob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbXVsdGlwbGVTZWxlY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gc2VsZWN0RWxlbWVudC5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBldmVudC5kZXRhaWwucmVtb3ZlO1xuICAgICAgICAgICAgb3B0aW9uc1tpbmRleF0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgaSA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXguY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xlYXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluc2VydChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbC5pbnNlcnQ7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RDaGlsZCA9IHNlbGVjdEVsZW1lbnQuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgaWYgKHNlbGVjdENoaWxkKSB7XG4gICAgICAgICAgICAgIHNlbGVjdENoaWxkLmJlZm9yZShvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpdGVtcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpdGVtc1xuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBpdGVtO1xuICAgICAgICAgICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RFbGVtZW50Lm9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbmRpY2VzKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gbmV3IFNldChldmVudC5kZXRhaWwuaW5kaWNlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBldmVudC50YXJnZXQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBpbmRpY2VzLmhhcyhvcHRpb24uaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlZGl0YWJsZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmRpc2FibGVkID0gIWV2ZW50LmRldGFpbC5lZGl0YWJsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBleHBvcnRWYWx1ZSA9IGdldFZhbHVlKHRydWUpO1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXhwb3J0VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgY2hhbmdlLFxuICAgICAgICAgICAgY2hhbmdlRXg6IGV4cG9ydFZhbHVlLFxuICAgICAgICAgICAgd2lsbENvbW1pdDogZmFsc2UsXG4gICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICBrZXlEb3duOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKHNlbGVjdEVsZW1lbnQsIG51bGwsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdLCBbXCJpbnB1dFwiLCBcIkFjdGlvblwiXSwgW1wiaW5wdXRcIiwgXCJWYWxpZGF0ZVwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZShzZWxlY3RFbGVtZW50KTtcbiAgICB9IGVsc2Uge31cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3Ioc2VsZWN0RWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoc2VsZWN0RWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHNlbGVjdEVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBlbGVtZW50c1xuICAgIH0gPSBwYXJhbWV0ZXJzO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogQW5ub3RhdGlvbkVsZW1lbnQuX2hhc1BvcHVwRGF0YShkYXRhKVxuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB0aGlzLnBvcHVwID0gbnVsbDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyXG4gICAgfSA9IHRoaXM7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJwb3B1cEFubm90YXRpb25cIik7XG4gICAgY29udGFpbmVyLnJvbGUgPSBcImNvbW1lbnRcIjtcbiAgICBjb25zdCBwb3B1cCA9IHRoaXMucG9wdXAgPSBuZXcgUG9wdXBFbGVtZW50KHtcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICBjb2xvcjogdGhpcy5kYXRhLmNvbG9yLFxuICAgICAgdGl0bGVPYmo6IHRoaXMuZGF0YS50aXRsZU9iaixcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IHRoaXMuZGF0YS5tb2RpZmljYXRpb25EYXRlIHx8IHRoaXMuZGF0YS5jcmVhdGlvbkRhdGUsXG4gICAgICBjb250ZW50c09iajogdGhpcy5kYXRhLmNvbnRlbnRzT2JqLFxuICAgICAgcmljaFRleHQ6IHRoaXMuZGF0YS5yaWNoVGV4dCxcbiAgICAgIHJlY3Q6IHRoaXMuZGF0YS5yZWN0LFxuICAgICAgcGFyZW50UmVjdDogdGhpcy5kYXRhLnBhcmVudFJlY3QgfHwgbnVsbCxcbiAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQsXG4gICAgICBlbGVtZW50czogdGhpcy5lbGVtZW50cyxcbiAgICAgIG9wZW46IHRoaXMuZGF0YS5vcGVuLFxuICAgICAgZXZlbnRCdXM6IHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXNcbiAgICB9KTtcbiAgICBjb25zdCBlbGVtZW50SWRzID0gW107XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnQucG9wdXAgPSBwb3B1cDtcbiAgICAgIGVsZW1lbnQuY29udGFpbmVyLmFyaWFIYXNQb3B1cCA9IFwiZGlhbG9nXCI7XG4gICAgICBlbGVtZW50SWRzLnB1c2goZWxlbWVudC5kYXRhLmlkKTtcbiAgICAgIGVsZW1lbnQuYWRkSGlnaGxpZ2h0QXJlYSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xzXCIsIGVsZW1lbnRJZHMubWFwKGlkID0+IGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gKS5qb2luKFwiLFwiKSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBQb3B1cEVsZW1lbnQge1xuICAjYm91bmRLZXlEb3duID0gdGhpcy4ja2V5RG93bi5iaW5kKHRoaXMpO1xuICAjYm91bmRIaWRlID0gdGhpcy4jaGlkZS5iaW5kKHRoaXMpO1xuICAjYm91bmRTaG93ID0gdGhpcy4jc2hvdy5iaW5kKHRoaXMpO1xuICAjYm91bmRUb2dnbGUgPSB0aGlzLiN0b2dnbGUuYmluZCh0aGlzKTtcbiAgI2NvbG9yID0gbnVsbDtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICNjb250ZW50c09iaiA9IG51bGw7XG4gICNkYXRlT2JqID0gbnVsbDtcbiAgI2VsZW1lbnRzID0gbnVsbDtcbiAgI2V2ZW50QnVzID0gbnVsbDtcbiAgI3BhcmVudCA9IG51bGw7XG4gICNwYXJlbnRSZWN0ID0gbnVsbDtcbiAgI3Bpbm5lZCA9IGZhbHNlO1xuICAjcG9wdXAgPSBudWxsO1xuICAjcG9wdXBBYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAjcG9zaXRpb24gPSBudWxsO1xuICAjY29tbWVudEJ1dHRvbiA9IG51bGw7XG4gICNjb21tZW50QnV0dG9uUG9zaXRpb24gPSBudWxsO1xuICAjY29tbWVudEJ1dHRvbkNvbG9yID0gbnVsbDtcbiAgI3JlY3QgPSBudWxsO1xuICAjcmljaFRleHQgPSBudWxsO1xuICAjdGl0bGVPYmogPSBudWxsO1xuICAjdXBkYXRlcyA9IG51bGw7XG4gICN3YXNWaXNpYmxlID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250YWluZXIsXG4gICAgY29sb3IsXG4gICAgZWxlbWVudHMsXG4gICAgdGl0bGVPYmosXG4gICAgbW9kaWZpY2F0aW9uRGF0ZSxcbiAgICBjb250ZW50c09iaixcbiAgICByaWNoVGV4dCxcbiAgICBwYXJlbnQsXG4gICAgcmVjdCxcbiAgICBwYXJlbnRSZWN0LFxuICAgIG9wZW4sXG4gICAgZXZlbnRCdXMgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jdGl0bGVPYmogPSB0aXRsZU9iajtcbiAgICB0aGlzLiNjb250ZW50c09iaiA9IGNvbnRlbnRzT2JqO1xuICAgIHRoaXMuI3JpY2hUZXh0ID0gcmljaFRleHQ7XG4gICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuI2NvbG9yID0gY29sb3I7XG4gICAgdGhpcy4jcmVjdCA9IHJlY3Q7XG4gICAgdGhpcy4jcGFyZW50UmVjdCA9IHBhcmVudFJlY3Q7XG4gICAgdGhpcy4jZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB0aGlzLiNldmVudEJ1cyA9IGV2ZW50QnVzO1xuICAgIHRoaXMuI2RhdGVPYmogPSBQREZEYXRlU3RyaW5nLnRvRGF0ZU9iamVjdChtb2RpZmljYXRpb25EYXRlKTtcbiAgICB0aGlzLnRyaWdnZXIgPSBlbGVtZW50cy5mbGF0TWFwKGUgPT4gZS5nZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkpO1xuICAgIHRoaXMuI2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIHRoaXMuI3RvZ2dsZSgpO1xuICAgIH1cbiAgfVxuICAjYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuI3BvcHVwQWJvcnRDb250cm9sbGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3BvcHVwQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hbFxuICAgIH0gPSB0aGlzLiNwb3B1cEFib3J0Q29udHJvbGxlcjtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy50cmlnZ2VyKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCB0aGlzLiNib3VuZFNob3csIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy4jYm91bmRIaWRlLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy4jZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnQuY29udGFpbmVyPy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy4jcmVuZGVyQ29tbWVudEJ1dHRvbigpO1xuICB9XG4gICNzZXRDb21tZW50QnV0dG9uUG9zaXRpb24oKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuI2VsZW1lbnRzLmZpbmQoZSA9PiBlLmhhc0NvbW1lbnRCdXR0b24pO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb24gPSBlbGVtZW50Ll9ub3JtYWxpemVQb2ludChlbGVtZW50LmNvbW1lbnRCdXR0b25Qb3NpdGlvbik7XG4gICAgdGhpcy4jY29tbWVudEJ1dHRvbkNvbG9yID0gZWxlbWVudC5jb21tZW50QnV0dG9uQ29sb3I7XG4gIH1cbiAgI3JlbmRlckNvbW1lbnRCdXR0b24oKSB7XG4gICAgaWYgKHRoaXMuI2NvbW1lbnRCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb24pIHtcbiAgICAgIHRoaXMuI3NldENvbW1lbnRCdXR0b25Qb3NpdGlvbigpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2NvbW1lbnRCdXR0b25Qb3NpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNjb21tZW50QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NOYW1lID0gXCJhbm5vdGF0aW9uQ29tbWVudEJ1dHRvblwiO1xuICAgIGNvbnN0IHBhcmVudENvbnRhaW5lciA9IHRoaXMuI2VsZW1lbnRzWzBdLmNvbnRhaW5lcjtcbiAgICBidXR0b24uc3R5bGUuekluZGV4ID0gcGFyZW50Q29udGFpbmVyLnN0eWxlLnpJbmRleCArIDE7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYWxcbiAgICB9ID0gdGhpcy4jcG9wdXBBYm9ydENvbnRyb2xsZXI7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJob3ZlclwiLCB0aGlzLiNib3VuZFRvZ2dsZSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93biwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBbe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6IGVkaXRJZFxuICAgICAgICB9LFxuICAgICAgICBhbm5vdGF0aW9uRWRpdG9yVHlwZTogbW9kZVxuICAgICAgfV0gPSB0aGlzLiNlbGVtZW50cztcbiAgICAgIHRoaXMuI2V2ZW50QnVzPy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3Jtb2RlXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBlZGl0SWQsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGVkaXRDb21tZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBidXR0b247XG4gICAgc3R5bGUubGVmdCA9IGBjYWxjKCR7dGhpcy4jY29tbWVudEJ1dHRvblBvc2l0aW9uWzBdfSUpYDtcbiAgICBzdHlsZS50b3AgPSBgY2FsYygke3RoaXMuI2NvbW1lbnRCdXR0b25Qb3NpdGlvblsxXX0lIC0gdmFyKC0tY29tbWVudC1idXR0b24tZGltKSlgO1xuICAgIGlmICh0aGlzLiNjb21tZW50QnV0dG9uQ29sb3IpIHtcbiAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuI2NvbW1lbnRCdXR0b25Db2xvcjtcbiAgICB9XG4gICAgcGFyZW50Q29udGFpbmVyLmFmdGVyKGJ1dHRvbik7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLiNwb3B1cCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwb3B1cCA9IHRoaXMuI3BvcHVwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBwb3B1cC5jbGFzc05hbWUgPSBcInBvcHVwXCI7XG4gICAgaWYgKHRoaXMuI2NvbG9yKSB7XG4gICAgICBjb25zdCBiYXNlQ29sb3IgPSBwb3B1cC5zdHlsZS5vdXRsaW5lQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi50aGlzLiNjb2xvcik7XG4gICAgICBwb3B1cC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBgY29sb3ItbWl4KGluIHNyZ2IsICR7YmFzZUNvbG9yfSAzMCUsIHdoaXRlKWA7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGhlYWRlci5jbGFzc05hbWUgPSBcImhlYWRlclwiO1xuICAgIGlmICh0aGlzLiN0aXRsZU9iaj8uc3RyKSB7XG4gICAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgdGl0bGUuY2xhc3NOYW1lID0gXCJ0aXRsZVwiO1xuICAgICAgaGVhZGVyLmFwcGVuZCh0aXRsZSk7XG4gICAgICAoe1xuICAgICAgICBkaXI6IHRpdGxlLmRpcixcbiAgICAgICAgc3RyOiB0aXRsZS50ZXh0Q29udGVudFxuICAgICAgfSA9IHRoaXMuI3RpdGxlT2JqKTtcbiAgICB9XG4gICAgcG9wdXAuYXBwZW5kKGhlYWRlcik7XG4gICAgaWYgKHRoaXMuI2RhdGVPYmopIHtcbiAgICAgIGNvbnN0IG1vZGlmaWNhdGlvbkRhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGltZVwiKTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuY2xhc3NOYW1lID0gXCJwb3B1cERhdGVcIjtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtYW5ub3RhdGlvbi1kYXRlLXRpbWUtc3RyaW5nXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGRhdGVPYmo6IHRoaXMuI2RhdGVPYmoudmFsdWVPZigpXG4gICAgICB9KSk7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLmRhdGVUaW1lID0gdGhpcy4jZGF0ZU9iai50b0lTT1N0cmluZygpO1xuICAgICAgaGVhZGVyLmFwcGVuZChtb2RpZmljYXRpb25EYXRlKTtcbiAgICB9XG4gICAgY29uc3QgaHRtbCA9IHRoaXMuI2h0bWw7XG4gICAgaWYgKGh0bWwpIHtcbiAgICAgIFhmYUxheWVyLnJlbmRlcih7XG4gICAgICAgIHhmYUh0bWw6IGh0bWwsXG4gICAgICAgIGludGVudDogXCJyaWNoVGV4dFwiLFxuICAgICAgICBkaXY6IHBvcHVwXG4gICAgICB9KTtcbiAgICAgIHBvcHVwLmxhc3RDaGlsZC5jbGFzc0xpc3QuYWRkKFwicmljaFRleHRcIiwgXCJwb3B1cENvbnRlbnRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGhpcy5fZm9ybWF0Q29udGVudHModGhpcy4jY29udGVudHNPYmopO1xuICAgICAgcG9wdXAuYXBwZW5kKGNvbnRlbnRzKTtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZChwb3B1cCk7XG4gIH1cbiAgZ2V0ICNodG1sKCkge1xuICAgIGNvbnN0IHJpY2hUZXh0ID0gdGhpcy4jcmljaFRleHQ7XG4gICAgY29uc3QgY29udGVudHNPYmogPSB0aGlzLiNjb250ZW50c09iajtcbiAgICBpZiAocmljaFRleHQ/LnN0ciAmJiAoIWNvbnRlbnRzT2JqPy5zdHIgfHwgY29udGVudHNPYmouc3RyID09PSByaWNoVGV4dC5zdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jcmljaFRleHQuaHRtbCB8fCBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgI2ZvbnRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLiNodG1sPy5hdHRyaWJ1dGVzPy5zdHlsZT8uZm9udFNpemUgfHwgMDtcbiAgfVxuICBnZXQgI2ZvbnRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy4jaHRtbD8uYXR0cmlidXRlcz8uc3R5bGU/LmNvbG9yIHx8IG51bGw7XG4gIH1cbiAgI21ha2VQb3B1cENvbnRlbnQodGV4dCkge1xuICAgIGNvbnN0IHBvcHVwTGluZXMgPSBbXTtcbiAgICBjb25zdCBwb3B1cENvbnRlbnQgPSB7XG4gICAgICBzdHI6IHRleHQsXG4gICAgICBodG1sOiB7XG4gICAgICAgIG5hbWU6IFwiZGl2XCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBkaXI6IFwiYXV0b1wiXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIG5hbWU6IFwicFwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBwb3B1cExpbmVzXG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsaW5lQXR0cmlidXRlcyA9IHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiB0aGlzLiNmb250Q29sb3IsXG4gICAgICAgIGZvbnRTaXplOiB0aGlzLiNmb250U2l6ZSA/IGBjYWxjKCR7dGhpcy4jZm9udFNpemV9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWAgOiBcIlwiXG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGV4dC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgcG9wdXBMaW5lcy5wdXNoKHtcbiAgICAgICAgbmFtZTogXCJzcGFuXCIsXG4gICAgICAgIHZhbHVlOiBsaW5lLFxuICAgICAgICBhdHRyaWJ1dGVzOiBsaW5lQXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwb3B1cENvbnRlbnQ7XG4gIH1cbiAgX2Zvcm1hdENvbnRlbnRzKHtcbiAgICBzdHIsXG4gICAgZGlyXG4gIH0pIHtcbiAgICBjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgcC5jbGFzc0xpc3QuYWRkKFwicG9wdXBDb250ZW50XCIpO1xuICAgIHAuZGlyID0gZGlyO1xuICAgIGNvbnN0IGxpbmVzID0gc3RyLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaW5lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICBwLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSk7XG4gICAgICBpZiAoaSA8IGlpIC0gMSkge1xuICAgICAgICBwLmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxuICAja2V5RG93bihldmVudCkge1xuICAgIGlmIChldmVudC5hbHRLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiB8fCBldmVudC5rZXkgPT09IFwiRXNjYXBlXCIgJiYgdGhpcy4jcGlubmVkKSB7XG4gICAgICB0aGlzLiN0b2dnbGUoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlRWRpdGVkKHtcbiAgICByZWN0LFxuICAgIHBvcHVwLFxuICAgIGRlbGV0ZWRcbiAgfSkge1xuICAgIGlmIChkZWxldGVkIHx8IHBvcHVwPy5kZWxldGVkKSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuI3VwZGF0ZXMgfHw9IHtcbiAgICAgIGNvbnRlbnRzT2JqOiB0aGlzLiNjb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLiNyaWNoVGV4dFxuICAgIH07XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHBvcHVwKSB7XG4gICAgICB0aGlzLiNyaWNoVGV4dCA9IHRoaXMuI21ha2VQb3B1cENvbnRlbnQocG9wdXAudGV4dCk7XG4gICAgICB0aGlzLiNkYXRlT2JqID0gUERGRGF0ZVN0cmluZy50b0RhdGVPYmplY3QocG9wdXAuZGF0ZSk7XG4gICAgICB0aGlzLiNjb250ZW50c09iaiA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3BvcHVwPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNwb3B1cCA9IG51bGw7XG4gIH1cbiAgcmVzZXRFZGl0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLiN1cGRhdGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICh7XG4gICAgICBjb250ZW50c09iajogdGhpcy4jY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy4jcmljaFRleHRcbiAgICB9ID0gdGhpcy4jdXBkYXRlcyk7XG4gICAgdGhpcy4jdXBkYXRlcyA9IG51bGw7XG4gICAgdGhpcy4jcG9wdXA/LnJlbW92ZSgpO1xuICAgIHRoaXMuI3BvcHVwID0gbnVsbDtcbiAgICB0aGlzLiNwb3NpdGlvbiA9IG51bGw7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuI3BvcHVwQWJvcnRDb250cm9sbGVyPy5hYm9ydCgpO1xuICAgIHRoaXMuI3BvcHVwQWJvcnRDb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLiNwb3B1cD8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jcG9wdXAgPSBudWxsO1xuICAgIHRoaXMuI3dhc1Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLiNwaW5uZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy50cmlnZ2VyKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgIH1cbiAgfVxuICAjc2V0UG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgdmlld1xuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICBwYWdlWVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXMuI3BhcmVudDtcbiAgICBsZXQgdXNlUGFyZW50UmVjdCA9ICEhdGhpcy4jcGFyZW50UmVjdDtcbiAgICBsZXQgcmVjdCA9IHVzZVBhcmVudFJlY3QgPyB0aGlzLiNwYXJlbnRSZWN0IDogdGhpcy4jcmVjdDtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy4jZWxlbWVudHMpIHtcbiAgICAgIGlmICghcmVjdCB8fCBVdGlsLmludGVyc2VjdChlbGVtZW50LmRhdGEucmVjdCwgcmVjdCkgIT09IG51bGwpIHtcbiAgICAgICAgcmVjdCA9IGVsZW1lbnQuZGF0YS5yZWN0O1xuICAgICAgICB1c2VQYXJlbnRSZWN0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRSZWN0ID0gVXRpbC5ub3JtYWxpemVSZWN0KFtyZWN0WzBdLCB2aWV3WzNdIC0gcmVjdFsxXSArIHZpZXdbMV0sIHJlY3RbMl0sIHZpZXdbM10gLSByZWN0WzNdICsgdmlld1sxXV0pO1xuICAgIGNvbnN0IEhPUklaT05UQUxfU1BBQ0VfQUZURVJfQU5OT1RBVElPTiA9IDU7XG4gICAgY29uc3QgcGFyZW50V2lkdGggPSB1c2VQYXJlbnRSZWN0ID8gcmVjdFsyXSAtIHJlY3RbMF0gKyBIT1JJWk9OVEFMX1NQQUNFX0FGVEVSX0FOTk9UQVRJT04gOiAwO1xuICAgIGNvbnN0IHBvcHVwTGVmdCA9IG5vcm1hbGl6ZWRSZWN0WzBdICsgcGFyZW50V2lkdGg7XG4gICAgY29uc3QgcG9wdXBUb3AgPSBub3JtYWxpemVkUmVjdFsxXTtcbiAgICB0aGlzLiNwb3NpdGlvbiA9IFsxMDAgKiAocG9wdXBMZWZ0IC0gcGFnZVgpIC8gcGFnZVdpZHRoLCAxMDAgKiAocG9wdXBUb3AgLSBwYWdlWSkgLyBwYWdlSGVpZ2h0XTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLiNjb250YWluZXI7XG4gICAgc3R5bGUubGVmdCA9IGAke3RoaXMuI3Bvc2l0aW9uWzBdfSVgO1xuICAgIHN0eWxlLnRvcCA9IGAke3RoaXMuI3Bvc2l0aW9uWzFdfSVgO1xuICB9XG4gICN0b2dnbGUoKSB7XG4gICAgdGhpcy4jcGlubmVkID0gIXRoaXMuI3Bpbm5lZDtcbiAgICBpZiAodGhpcy4jcGlubmVkKSB7XG4gICAgICB0aGlzLiNzaG93KCk7XG4gICAgICB0aGlzLiNjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2JvdW5kVG9nZ2xlKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNoaWRlKCk7XG4gICAgICB0aGlzLiNjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2JvdW5kVG9nZ2xlKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24pO1xuICAgIH1cbiAgfVxuICAjc2hvdygpIHtcbiAgICBpZiAoIXRoaXMuI3BvcHVwKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICB0aGlzLiNzZXRQb3NpdGlvbigpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHBhcnNlSW50KHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXgpICsgMTAwMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmb2N1c2VkXCIpO1xuICAgIH1cbiAgfVxuICAjaGlkZSgpIHtcbiAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcImZvY3VzZWRcIik7XG4gICAgaWYgKHRoaXMuI3Bpbm5lZCB8fCAhdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgdGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHBhcnNlSW50KHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXgpIC0gMTAwMDtcbiAgfVxuICBmb3JjZUhpZGUoKSB7XG4gICAgdGhpcy4jd2FzVmlzaWJsZSA9IHRoaXMuaXNWaXNpYmxlO1xuICAgIGlmICghdGhpcy4jd2FzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgfVxuICBtYXliZVNob3coKSB7XG4gICAgdGhpcy4jYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNwb3B1cCkge1xuICAgICAgdGhpcy4jc2hvdygpO1xuICAgIH1cbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPT09IGZhbHNlO1xuICB9XG59XG5jbGFzcyBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0Q29udGVudDtcbiAgICB0aGlzLnRleHRQb3NpdGlvbiA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0UG9zaXRpb247XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZnJlZVRleHRBbm5vdGF0aW9uXCIpO1xuICAgIGlmICh0aGlzLnRleHRDb250ZW50KSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChcImFubm90YXRpb25UZXh0Q29udGVudFwiKTtcbiAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImNvbW1lbnRcIik7XG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy50ZXh0Q29udGVudCkge1xuICAgICAgICBjb25zdCBsaW5lU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBsaW5lU3Bhbi50ZXh0Q29udGVudCA9IGxpbmU7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kKGxpbmVTcGFuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChjb250ZW50KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRPbkRvdWJsZUNsaWNrKCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBMaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNsaW5lID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibGluZUFubm90YXRpb25cIik7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBsaW5lID0gdGhpcy4jbGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmxpbmVcIik7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ4MVwiLCBkYXRhLnJlY3RbMl0gLSBkYXRhLmxpbmVDb29yZGluYXRlc1swXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ5MVwiLCBkYXRhLnJlY3RbM10gLSBkYXRhLmxpbmVDb29yZGluYXRlc1sxXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ4MlwiLCBkYXRhLnJlY3RbMl0gLSBkYXRhLmxpbmVDb29yZGluYXRlc1syXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ5MlwiLCBkYXRhLnJlY3RbM10gLSBkYXRhLmxpbmVDb29yZGluYXRlc1szXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQobGluZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jbGluZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3NxdWFyZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInNxdWFyZUFubm90YXRpb25cIik7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IGRhdGEuYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgY29uc3Qgc3F1YXJlID0gdGhpcy4jc3F1YXJlID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwieFwiLCBib3JkZXJXaWR0aCAvIDIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ5XCIsIGJvcmRlcldpZHRoIC8gMik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoIC0gYm9yZGVyV2lkdGgpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0IC0gYm9yZGVyV2lkdGgpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyV2lkdGggfHwgMSk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChzcXVhcmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NxdWFyZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBDaXJjbGVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI2NpcmNsZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNpcmNsZUFubm90YXRpb25cIik7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IGRhdGEuYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgY29uc3QgY2lyY2xlID0gdGhpcy4jY2lyY2xlID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6ZWxsaXBzZVwiKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3hcIiwgd2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3lcIiwgaGVpZ2h0IC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJ4XCIsIHdpZHRoIC8gMiAtIGJvcmRlcldpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJ5XCIsIGhlaWdodCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyV2lkdGggfHwgMSk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChjaXJjbGUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NpcmNsZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjcG9seWxpbmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlsaW5lQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5bGluZVwiO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJlY3QsXG4gICAgICAgIHZlcnRpY2VzLFxuICAgICAgICBib3JkZXJTdHlsZSxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH0sXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghdmVydGljZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBsZXQgcG9pbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IHZlcnRpY2VzW2ldIC0gcmVjdFswXTtcbiAgICAgIGNvbnN0IHkgPSByZWN0WzNdIC0gdmVydGljZXNbaSArIDFdO1xuICAgICAgcG9pbnRzLnB1c2goYCR7eH0sJHt5fWApO1xuICAgIH1cbiAgICBwb2ludHMgPSBwb2ludHMuam9pbihcIiBcIik7XG4gICAgY29uc3QgcG9seWxpbmUgPSB0aGlzLiNwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHMpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChwb2x5bGluZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvbHlsaW5lO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlnb25Bbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlnb25cIjtcbiAgfVxufVxuY2xhc3MgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2FyZXRBbm5vdGF0aW9uXCIpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIElua0Fubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjcG9seWxpbmVzR3JvdXBFbGVtZW50ID0gbnVsbDtcbiAgI3BvbHlsaW5lcyA9IFtdO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcImlua0Fubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWxpbmVcIjtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gdGhpcy5kYXRhLml0ID09PSBcIklua0hpZ2hsaWdodFwiID8gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUIDogQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LO1xuICB9XG4gICNnZXRUcmFuc2Zvcm0ocm90YXRpb24sIHJlY3QpIHtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSg5MCkgdHJhbnNsYXRlKCR7LXJlY3RbMF19LCR7cmVjdFsxXX0pIHNjYWxlKDEsLTEpYCxcbiAgICAgICAgICB3aWR0aDogcmVjdFszXSAtIHJlY3RbMV0sXG4gICAgICAgICAgaGVpZ2h0OiByZWN0WzJdIC0gcmVjdFswXVxuICAgICAgICB9O1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlKDE4MCkgdHJhbnNsYXRlKCR7LXJlY3RbMl19LCR7cmVjdFsxXX0pIHNjYWxlKDEsLTEpYCxcbiAgICAgICAgICB3aWR0aDogcmVjdFsyXSAtIHJlY3RbMF0sXG4gICAgICAgICAgaGVpZ2h0OiByZWN0WzNdIC0gcmVjdFsxXVxuICAgICAgICB9O1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlKDI3MCkgdHJhbnNsYXRlKCR7LXJlY3RbMl19LCR7cmVjdFszXX0pIHNjYWxlKDEsLTEpYCxcbiAgICAgICAgICB3aWR0aDogcmVjdFszXSAtIHJlY3RbMV0sXG4gICAgICAgICAgaGVpZ2h0OiByZWN0WzJdIC0gcmVjdFswXVxuICAgICAgICB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHstcmVjdFswXX0sJHtyZWN0WzNdfSkgc2NhbGUoMSwtMSlgLFxuICAgICAgICAgIHdpZHRoOiByZWN0WzJdIC0gcmVjdFswXSxcbiAgICAgICAgICBoZWlnaHQ6IHJlY3RbM10gLSByZWN0WzFdXG4gICAgICAgIH07XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJlY3QsXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBpbmtMaXN0cyxcbiAgICAgICAgYm9yZGVyU3R5bGUsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy4jZ2V0VHJhbnNmb3JtKHJvdGF0aW9uLCByZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGcgPSB0aGlzLiNwb2x5bGluZXNHcm91cEVsZW1lbnQgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpnXCIpO1xuICAgIHN2Zy5hcHBlbmQoZyk7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtbGluZWNhcFwiLCBcInJvdW5kXCIpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWxpbmVqb2luXCIsIFwicm91bmRcIik7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtbWl0ZXJsaW1pdFwiLCAxMCk7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlua0xpc3RzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvbHlsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQodGhpcy5zdmdFbGVtZW50TmFtZSk7XG4gICAgICB0aGlzLiNwb2x5bGluZXMucHVzaChwb2x5bGluZSk7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgaW5rTGlzdHNbaV0uam9pbihcIixcIikpO1xuICAgICAgZy5hcHBlbmQocG9seWxpbmUpO1xuICAgIH1cbiAgICBpZiAoIXBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICB1cGRhdGVFZGl0ZWQocGFyYW1zKSB7XG4gICAgc3VwZXIudXBkYXRlRWRpdGVkKHBhcmFtcyk7XG4gICAgY29uc3Qge1xuICAgICAgdGhpY2tuZXNzLFxuICAgICAgcG9pbnRzLFxuICAgICAgcmVjdFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgZyA9IHRoaXMuI3BvbHlsaW5lc0dyb3VwRWxlbWVudDtcbiAgICBpZiAodGhpY2tuZXNzID49IDApIHtcbiAgICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIHRoaWNrbmVzcyB8fCAxKTtcbiAgICB9XG4gICAgaWYgKHBvaW50cykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy4jcG9seWxpbmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgdGhpcy4jcG9seWxpbmVzW2ldLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHNbaV0uam9pbihcIixcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVjdCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSB0aGlzLiNnZXRUcmFuc2Zvcm0odGhpcy5kYXRhLnJvdGF0aW9uLCByZWN0KTtcbiAgICAgIGNvbnN0IHJvb3QgPSBnLnBhcmVudEVsZW1lbnQ7XG4gICAgICByb290LnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgYDAgMCAke3dpZHRofSAke2hlaWdodH1gKTtcbiAgICAgIGcuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvbHlsaW5lcztcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG4gIGdldCBjb21tZW50QnV0dG9uUG9zaXRpb24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5rTGlzdHMsXG4gICAgICByZWN0XG4gICAgfSA9IHRoaXMuZGF0YTtcbiAgICBpZiAoaW5rTGlzdHM/Lmxlbmd0aCA+PSAxKSB7XG4gICAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICAgIGxldCBtYXhZID0gLUluZmluaXR5O1xuICAgICAgZm9yIChjb25zdCBpbmtMaXN0IG9mIGlua0xpc3RzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlua0xpc3QubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIGlmIChpbmtMaXN0W2kgKyAxXSA+IG1heFkpIHtcbiAgICAgICAgICAgIG1heFkgPSBpbmtMaXN0W2kgKyAxXTtcbiAgICAgICAgICAgIG1heFggPSBpbmtMaXN0W2ldO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5rTGlzdFtpICsgMV0gPT09IG1heFkpIHtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBpbmtMaXN0W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYXhYICE9PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gW21heFgsIG1heFldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVjdCkge1xuICAgICAgcmV0dXJuIFtyZWN0WzJdLCByZWN0WzNdXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmNsYXNzIEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIG92ZXJsYWlkVGV4dCxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QW5ub3RhdGlvblwiKTtcbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGNvbnN0IG1hcmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibWFya1wiKTtcbiAgICAgIG1hcmsuY2xhc3NMaXN0LmFkZChcIm92ZXJsYWlkVGV4dFwiKTtcbiAgICAgIG1hcmsudGV4dENvbnRlbnQgPSBvdmVybGFpZFRleHQ7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQobWFyayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIG92ZXJsYWlkVGV4dCxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidW5kZXJsaW5lQW5ub3RhdGlvblwiKTtcbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBjb25zdCB1bmRlcmxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidVwiKTtcbiAgICAgIHVuZGVybGluZS5jbGFzc0xpc3QuYWRkKFwib3ZlcmxhaWRUZXh0XCIpO1xuICAgICAgdW5kZXJsaW5lLnRleHRDb250ZW50ID0gb3ZlcmxhaWRUZXh0O1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHVuZGVybGluZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgb3ZlcmxhaWRUZXh0LFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghcG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVpZ2dseUFubm90YXRpb25cIik7XG4gICAgaWYgKG92ZXJsYWlkVGV4dCkge1xuICAgICAgY29uc3QgdW5kZXJsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVcIik7XG4gICAgICB1bmRlcmxpbmUuY2xhc3NMaXN0LmFkZChcIm92ZXJsYWlkVGV4dFwiKTtcbiAgICAgIHVuZGVybGluZS50ZXh0Q29udGVudCA9IG92ZXJsYWlkVGV4dDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZCh1bmRlcmxpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICBvdmVybGFpZFRleHQsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInN0cmlrZW91dEFubm90YXRpb25cIik7XG4gICAgaWYgKG92ZXJsYWlkVGV4dCkge1xuICAgICAgY29uc3Qgc3RyaWtlb3V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNcIik7XG4gICAgICBzdHJpa2VvdXQuY2xhc3NMaXN0LmFkZChcIm92ZXJsYWlkVGV4dFwiKTtcbiAgICAgIHN0cmlrZW91dC50ZXh0Q29udGVudCA9IG92ZXJsYWlkVGV4dDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdHJpa2VvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVA7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzdGFtcEFubm90YXRpb25cIik7XG4gICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImltZ1wiKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICN0cmlnZ2VyID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbGVcbiAgICB9ID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlLmZpbGVuYW1lO1xuICAgIHRoaXMuY29udGVudCA9IGZpbGUuY29udGVudDtcbiAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImZpbGVhdHRhY2htZW50YW5ub3RhdGlvblwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAuLi5maWxlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmaWxlQXR0YWNobWVudEFubm90YXRpb25cIik7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyLFxuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB0cmlnZ2VyO1xuICAgIGlmIChkYXRhLmhhc0FwcGVhcmFuY2UgfHwgZGF0YS5maWxsQWxwaGEgPT09IDApIHtcbiAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgIHRyaWdnZXIuc3JjID0gYCR7dGhpcy5pbWFnZVJlc291cmNlc1BhdGh9YW5ub3RhdGlvbi0key9wYXBlcmNsaXAvaS50ZXN0KGRhdGEubmFtZSkgPyBcInBhcGVyY2xpcFwiIDogXCJwdXNocGluXCJ9LnN2Z2A7XG4gICAgICBpZiAoZGF0YS5maWxsQWxwaGEgJiYgZGF0YS5maWxsQWxwaGEgPCAxKSB7XG4gICAgICAgIHRyaWdnZXIuc3R5bGUgPSBgZmlsdGVyOiBvcGFjaXR5KCR7TWF0aC5yb3VuZChkYXRhLmZpbGxBbHBoYSAqIDEwMCl9JSk7YDtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgdGhpcy4jZG93bmxvYWQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy4jdHJpZ2dlciA9IHRyaWdnZXI7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZ0ID0+IHtcbiAgICAgIGlmIChldnQua2V5ID09PSBcIkVudGVyXCIgJiYgKGlzTWFjID8gZXZ0Lm1ldGFLZXkgOiBldnQuY3RybEtleSkpIHtcbiAgICAgICAgdGhpcy4jZG93bmxvYWQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIuY2xhc3NMaXN0LmFkZChcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgfVxuICAgIGNvbnRhaW5lci5hcHBlbmQodHJpZ2dlcik7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiN0cmlnZ2VyO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbiAgI2Rvd25sb2FkKCkge1xuICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEodGhpcy5jb250ZW50LCB0aGlzLmZpbGVuYW1lKTtcbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkxheWVyIHtcbiAgI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gbnVsbDtcbiAgI2Fubm90YXRpb25DYW52YXNNYXAgPSBudWxsO1xuICAjZWRpdGFibGVBbm5vdGF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgI3N0cnVjdFRyZWVMYXllciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkaXYsXG4gICAgYWNjZXNzaWJpbGl0eU1hbmFnZXIsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICBhbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLFxuICAgIHBhZ2UsXG4gICAgdmlld3BvcnQsXG4gICAgc3RydWN0VHJlZUxheWVyXG4gIH0pIHtcbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IGFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAgIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMuI3N0cnVjdFRyZWVMYXllciA9IHN0cnVjdFRyZWVMYXllciB8fCBudWxsO1xuICAgIHRoaXMucGFnZSA9IHBhZ2U7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICB0aGlzLl9hbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyID0gYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcjtcbiAgfVxuICBoYXNFZGl0YWJsZUFubm90YXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnNpemUgPiAwO1xuICB9XG4gIGFzeW5jICNhcHBlbmRFbGVtZW50KGVsZW1lbnQsIGlkLCBwb3B1cEVsZW1lbnRzKSB7XG4gICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBlbGVtZW50LmZpcnN0Q2hpbGQgfHwgZWxlbWVudDtcbiAgICBjb25zdCBhbm5vdGF0aW9uSWQgPSBjb250ZW50RWxlbWVudC5pZCA9IGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gO1xuICAgIGNvbnN0IGFyaWFBdHRyaWJ1dGVzID0gYXdhaXQgdGhpcy4jc3RydWN0VHJlZUxheWVyPy5nZXRBcmlhQXR0cmlidXRlcyhhbm5vdGF0aW9uSWQpO1xuICAgIGlmIChhcmlhQXR0cmlidXRlcykge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXJpYUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29udGVudEVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocG9wdXBFbGVtZW50cykge1xuICAgICAgcG9wdXBFbGVtZW50cy5hdCgtMSkuY29udGFpbmVyLmFmdGVyKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoZWxlbWVudCk7XG4gICAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ubW92ZUVsZW1lbnRJbkRPTSh0aGlzLmRpdiwgZWxlbWVudCwgY29udGVudEVsZW1lbnQsIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVuZGVyKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25zXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIHNldExheWVyRGltZW5zaW9ucyhsYXllciwgdGhpcy52aWV3cG9ydCk7XG4gICAgY29uc3QgcG9wdXBUb0VsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGVsZW1lbnRQYXJhbXMgPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgbGF5ZXIsXG4gICAgICBsaW5rU2VydmljZTogcGFyYW1zLmxpbmtTZXJ2aWNlLFxuICAgICAgZG93bmxvYWRNYW5hZ2VyOiBwYXJhbXMuZG93bmxvYWRNYW5hZ2VyLFxuICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoOiBwYXJhbXMuaW1hZ2VSZXNvdXJjZXNQYXRoIHx8IFwiXCIsXG4gICAgICByZW5kZXJGb3JtczogcGFyYW1zLnJlbmRlckZvcm1zICE9PSBmYWxzZSxcbiAgICAgIHN2Z0ZhY3Rvcnk6IG5ldyBET01TVkdGYWN0b3J5KCksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogcGFyYW1zLmFubm90YXRpb25TdG9yYWdlIHx8IG5ldyBBbm5vdGF0aW9uU3RvcmFnZSgpLFxuICAgICAgZW5hYmxlQ29tbWVudDogcGFyYW1zLmVuYWJsZUNvbW1lbnQgPT09IHRydWUsXG4gICAgICBlbmFibGVTY3JpcHRpbmc6IHBhcmFtcy5lbmFibGVTY3JpcHRpbmcgPT09IHRydWUsXG4gICAgICBoYXNKU0FjdGlvbnM6IHBhcmFtcy5oYXNKU0FjdGlvbnMsXG4gICAgICBmaWVsZE9iamVjdHM6IHBhcmFtcy5maWVsZE9iamVjdHMsXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBlbGVtZW50czogbnVsbFxuICAgIH07XG4gICAgZm9yIChjb25zdCBkYXRhIG9mIGFubm90YXRpb25zKSB7XG4gICAgICBpZiAoZGF0YS5ub0hUTUwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1BvcHVwQW5ub3RhdGlvbiA9IGRhdGEuYW5ub3RhdGlvblR5cGUgPT09IEFubm90YXRpb25UeXBlLlBPUFVQO1xuICAgICAgaWYgKCFpc1BvcHVwQW5ub3RhdGlvbikge1xuICAgICAgICBpZiAoZGF0YS5yZWN0WzJdID09PSBkYXRhLnJlY3RbMF0gfHwgZGF0YS5yZWN0WzNdID09PSBkYXRhLnJlY3RbMV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBwb3B1cFRvRWxlbWVudHMuZ2V0KGRhdGEuaWQpO1xuICAgICAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudFBhcmFtcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgICAgfVxuICAgICAgZWxlbWVudFBhcmFtcy5kYXRhID0gZGF0YTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBBbm5vdGF0aW9uRWxlbWVudEZhY3RvcnkuY3JlYXRlKGVsZW1lbnRQYXJhbXMpO1xuICAgICAgaWYgKCFlbGVtZW50LmlzUmVuZGVyYWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNQb3B1cEFubm90YXRpb24gJiYgZGF0YS5wb3B1cFJlZikge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHBvcHVwVG9FbGVtZW50cy5nZXQoZGF0YS5wb3B1cFJlZik7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICBwb3B1cFRvRWxlbWVudHMuc2V0KGRhdGEucG9wdXBSZWYsIFtlbGVtZW50XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVyZWQgPSBlbGVtZW50LnJlbmRlcigpO1xuICAgICAgaWYgKGRhdGEuaGlkZGVuKSB7XG4gICAgICAgIHJlbmRlcmVkLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy4jYXBwZW5kRWxlbWVudChyZW5kZXJlZCwgZGF0YS5pZCwgZWxlbWVudFBhcmFtcy5lbGVtZW50cyk7XG4gICAgICBpZiAoZWxlbWVudC5faXNFZGl0YWJsZSkge1xuICAgICAgICB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnNldChlbGVtZW50LmRhdGEuaWQsIGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9hbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyPy5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpO1xuICB9XG4gIGFzeW5jIGFkZExpbmtBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucywgbGlua1NlcnZpY2UpIHtcbiAgICBjb25zdCBlbGVtZW50UGFyYW1zID0ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGxheWVyOiB0aGlzLmRpdixcbiAgICAgIGxpbmtTZXJ2aWNlLFxuICAgICAgc3ZnRmFjdG9yeTogbmV3IERPTVNWR0ZhY3RvcnkoKSxcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH07XG4gICAgZm9yIChjb25zdCBkYXRhIG9mIGFubm90YXRpb25zKSB7XG4gICAgICBkYXRhLmJvcmRlclN0eWxlIHx8PSBBbm5vdGF0aW9uTGF5ZXIuX2RlZmF1bHRCb3JkZXJTdHlsZTtcbiAgICAgIGVsZW1lbnRQYXJhbXMuZGF0YSA9IGRhdGE7XG4gICAgICBjb25zdCBlbGVtZW50ID0gQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5LmNyZWF0ZShlbGVtZW50UGFyYW1zKTtcbiAgICAgIGlmICghZWxlbWVudC5pc1JlbmRlcmFibGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJlZCA9IGVsZW1lbnQucmVuZGVyKCk7XG4gICAgICBhd2FpdCB0aGlzLiNhcHBlbmRFbGVtZW50KHJlbmRlcmVkLCBkYXRhLmlkLCBudWxsKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKGxheWVyLCB7XG4gICAgICByb3RhdGlvbjogdmlld3BvcnQucm90YXRpb25cbiAgICB9KTtcbiAgICB0aGlzLiNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCk7XG4gICAgbGF5ZXIuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgI3NldEFubm90YXRpb25DYW52YXNNYXAoKSB7XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5kaXY7XG4gICAgZm9yIChjb25zdCBbaWQsIGNhbnZhc10gb2YgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGxheWVyLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWFubm90YXRpb24taWQ9XCIke2lkfVwiXWApO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IFwiYW5ub3RhdGlvbkNvbnRlbnRcIjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlyc3RDaGlsZFxuICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICBpZiAoIWZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmQoY2FudmFzKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RDaGlsZC5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgICBmaXJzdENoaWxkLnJlcGxhY2VXaXRoKGNhbnZhcyk7XG4gICAgICB9IGVsc2UgaWYgKCFmaXJzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucyhcImFubm90YXRpb25Db250ZW50XCIpKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuYmVmb3JlKGNhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdENoaWxkLmFmdGVyKGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0YWJsZUFubm90YXRpb24gPSB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLmdldChpZCk7XG4gICAgICBpZiAoIWVkaXRhYmxlQW5ub3RhdGlvbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlZGl0YWJsZUFubm90YXRpb24uX2hhc05vQ2FudmFzKSB7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXI/LnNldE1pc3NpbmdDYW52YXMoaWQsIGVsZW1lbnQuaWQsIGNhbnZhcyk7XG4gICAgICAgIGVkaXRhYmxlQW5ub3RhdGlvbi5faGFzTm9DYW52YXMgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRhYmxlQW5ub3RhdGlvbi5jYW52YXMgPSBjYW52YXM7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXAuY2xlYXIoKTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb25zKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMudmFsdWVzKCkpO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLmdldChpZCk7XG4gIH1cbiAgc3RhdGljIGdldCBfZGVmYXVsdEJvcmRlclN0eWxlKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfZGVmYXVsdEJvcmRlclN0eWxlXCIsIE9iamVjdC5mcmVlemUoe1xuICAgICAgd2lkdGg6IDEsXG4gICAgICByYXdXaWR0aDogMSxcbiAgICAgIHN0eWxlOiBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlNPTElELFxuICAgICAgZGFzaEFycmF5OiBbM10sXG4gICAgICBob3Jpem9udGFsQ29ybmVyUmFkaXVzOiAwLFxuICAgICAgdmVydGljYWxDb3JuZXJSYWRpdXM6IDBcbiAgICB9KSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2ZyZWV0ZXh0LmpzXG5cblxuXG5cblxuY29uc3QgRU9MX1BBVFRFUk4gPSAvXFxyXFxuP3xcXG4vZztcbmNsYXNzIEZyZWVUZXh0RWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNjb2xvcjtcbiAgI2NvbnRlbnQgPSBcIlwiO1xuICAjZWRpdG9yRGl2SWQgPSBgJHt0aGlzLmlkfS1lZGl0b3JgO1xuICAjZWRpdE1vZGVBQyA9IG51bGw7XG4gICNmb250U2l6ZTtcbiAgX2NvbG9yUGlja2VyID0gbnVsbDtcbiAgc3RhdGljIF9mcmVlVGV4dERlZmF1bHRDb250ZW50ID0gXCJcIjtcbiAgc3RhdGljIF9pbnRlcm5hbFBhZGRpbmcgPSAwO1xuICBzdGF0aWMgX2RlZmF1bHRDb2xvciA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdEZvbnRTaXplID0gMTA7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCBwcm90byA9IEZyZWVUZXh0RWRpdG9yLnByb3RvdHlwZTtcbiAgICBjb25zdCBhcnJvd0NoZWNrZXIgPSBzZWxmID0+IHNlbGYuaXNFbXB0eSgpO1xuICAgIGNvbnN0IHNtYWxsID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJjdHJsK3NcIiwgXCJtYWMrbWV0YStzXCIsIFwiY3RybCtwXCIsIFwibWFjK21ldGErcFwiXSwgcHJvdG8uY29tbWl0T3JSZW1vdmUsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICB9XSwgW1tcImN0cmwrRW50ZXJcIiwgXCJtYWMrbWV0YStFbnRlclwiLCBcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIHByb3RvLmNvbW1pdE9yUmVtb3ZlXSwgW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIHNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV1dKSk7XG4gIH1cbiAgc3RhdGljIF90eXBlID0gXCJmcmVldGV4dFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJmcmVlVGV4dEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy4jY29sb3IgPSBwYXJhbXMuY29sb3IgfHwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yO1xuICAgIHRoaXMuI2ZvbnRTaXplID0gcGFyYW1zLmZvbnRTaXplIHx8IEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemU7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5hMTF5QWxlcnQoXCJwZGZqcy1lZGl0b3ItZnJlZXRleHQtYWRkZWQtYWxlcnRcIik7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIHRoaXMuX2ludGVybmFsUGFkZGluZyA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tZnJlZXRleHQtcGFkZGluZ1wiKSk7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRTpcbiAgICAgICAgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I6XG4gICAgICAgIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFOlxuICAgICAgICB0aGlzLiN1cGRhdGVGb250U2l6ZSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUjpcbiAgICAgICAgdGhpcy4jdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemVdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcl1dO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSwgdGhpcy4jZm9udFNpemVdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsIHRoaXMuI2NvbG9yXV07XG4gIH1cbiAgZ2V0IHRvb2xiYXJCdXR0b25zKCkge1xuICAgIHRoaXMuX2NvbG9yUGlja2VyIHx8PSBuZXcgQmFzaWNDb2xvclBpY2tlcih0aGlzKTtcbiAgICByZXR1cm4gW1tcImNvbG9yUGlja2VyXCIsIHRoaXMuX2NvbG9yUGlja2VyXV07XG4gIH1cbiAgZ2V0IGNvbG9yVHlwZSgpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I7XG4gIH1cbiAgZ2V0IGNvbG9yVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbG9yO1xuICB9XG4gICN1cGRhdGVGb250U2l6ZShmb250U2l6ZSkge1xuICAgIGNvbnN0IHNldEZvbnRzaXplID0gc2l6ZSA9PiB7XG4gICAgICB0aGlzLmVkaXRvckRpdi5zdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7c2l6ZX1weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgIHRoaXMudHJhbnNsYXRlKDAsIC0oc2l6ZSAtIHRoaXMuI2ZvbnRTaXplKSAqIHRoaXMucGFyZW50U2NhbGUpO1xuICAgICAgdGhpcy4jZm9udFNpemUgPSBzaXplO1xuICAgICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRGb250c2l6ZSA9IHRoaXMuI2ZvbnRTaXplO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRGb250c2l6ZS5iaW5kKHRoaXMsIGZvbnRTaXplKSxcbiAgICAgIHVuZG86IHNldEZvbnRzaXplLmJpbmQodGhpcywgc2F2ZWRGb250c2l6ZSksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI3VwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSBjb2wgPT4ge1xuICAgICAgdGhpcy4jY29sb3IgPSB0aGlzLmVkaXRvckRpdi5zdHlsZS5jb2xvciA9IGNvbDtcbiAgICAgIHRoaXMuX2NvbG9yUGlja2VyPy51cGRhdGUoY29sKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLiNjb2xvcjtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0Q29sb3IuYmluZCh0aGlzLCBjb2xvciksXG4gICAgICB1bmRvOiBzZXRDb2xvci5iaW5kKHRoaXMsIHNhdmVkQ29sb3IpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICBfdHJhbnNsYXRlRW1wdHkoeCwgeSkge1xuICAgIHRoaXMuX3VpTWFuYWdlci50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMoeCwgeSwgdHJ1ZSk7XG4gIH1cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5wYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gWy1GcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogc2NhbGUsIC0oRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyArIHRoaXMuI2ZvbnRTaXplKSAqIHNjYWxlXTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICghc3VwZXIuZW5hYmxlRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LnJlbW92ZShcImVuYWJsZWRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGl2LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiKTtcbiAgICB0aGlzLiNlZGl0TW9kZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNlZGl0TW9kZUFDKTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmVkaXRvckRpdktleWRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuZWRpdG9yRGl2Rm9jdXMuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5lZGl0b3JEaXZCbHVyLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLmVkaXRvckRpdklucHV0LmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCB0aGlzLmVkaXRvckRpdlBhc3RlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXN1cGVyLmRpc2FibGVFZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QuYWRkKFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgdGhpcy4jZWRpdG9yRGl2SWQpO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLiNlZGl0TW9kZUFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2VkaXRNb2RlQUMgPSBudWxsO1xuICAgIHRoaXMuZGl2LmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZXRleHRFZGl0aW5nXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvY3VzaW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5mb2N1c2luKGV2ZW50KTtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmVkaXRvckRpdikge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIGlmIChmb2N1cykge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2luaXRpYWxPcHRpb25zPy5pc0NlbnRlcmVkKSB7XG4gICAgICB0aGlzLmNlbnRlcigpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZWRpdG9yRGl2IHx8IHRoaXMuZWRpdG9yRGl2LmlubmVyVGV4dC50cmltKCkgPT09IFwiXCI7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWV0ZXh0RWRpdGluZ1wiKTtcbiAgICB9XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgI2V4dHJhY3RUZXh0KCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuZWRpdG9yRGl2Lm5vcm1hbGl6ZSgpO1xuICAgIGxldCBwcmV2Q2hpbGQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgaWYgKHByZXZDaGlsZD8ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIGNoaWxkLm5vZGVOYW1lID09PSBcIkJSXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBidWZmZXIucHVzaChGcmVlVGV4dEVkaXRvci4jZ2V0Tm9kZUNvbnRlbnQoY2hpbGQpKTtcbiAgICAgIHByZXZDaGlsZCA9IGNoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgI3NldEVkaXRvckRpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGxldCByZWN0O1xuICAgIGlmICh0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmVjdCA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGN1cnJlbnRMYXllcixcbiAgICAgICAgZGl2XG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHNhdmVkRGlzcGxheSA9IGRpdi5zdHlsZS5kaXNwbGF5O1xuICAgICAgY29uc3Qgc2F2ZWRWaXNpYmlsaXR5ID0gZGl2LmNsYXNzTGlzdC5jb250YWlucyhcImhpZGRlblwiKTtcbiAgICAgIGRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBcImhpZGRlblwiO1xuICAgICAgY3VycmVudExheWVyLmRpdi5hcHBlbmQodGhpcy5kaXYpO1xuICAgICAgcmVjdCA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGRpdi5yZW1vdmUoKTtcbiAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gc2F2ZWREaXNwbGF5O1xuICAgICAgZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIiwgc2F2ZWRWaXNpYmlsaXR5KTtcbiAgICB9XG4gICAgaWYgKHRoaXMucm90YXRpb24gJSAxODAgPT09IHRoaXMucGFyZW50Um90YXRpb24gJSAxODApIHtcbiAgICAgIHRoaXMud2lkdGggPSByZWN0LndpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHJlY3QuaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gcmVjdC5oZWlnaHQgLyBwYXJlbnRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdC53aWR0aCAvIHBhcmVudEhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGNvbW1pdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuY29tbWl0KCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICBjb25zdCBzYXZlZFRleHQgPSB0aGlzLiNjb250ZW50O1xuICAgIGNvbnN0IG5ld1RleHQgPSB0aGlzLiNjb250ZW50ID0gdGhpcy4jZXh0cmFjdFRleHQoKS50cmltRW5kKCk7XG4gICAgaWYgKHNhdmVkVGV4dCA9PT0gbmV3VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZXRUZXh0ID0gdGV4dCA9PiB7XG4gICAgICB0aGlzLiNjb250ZW50ID0gdGV4dDtcbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVidWlsZCh0aGlzKTtcbiAgICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHNldFRleHQobmV3VGV4dCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICBzZXRUZXh0KHNhdmVkVGV4dCk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICB9XG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzSW5FZGl0TW9kZSgpO1xuICB9XG4gIGVudGVySW5FZGl0TW9kZSgpIHtcbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgfVxuICBrZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5kaXYgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgIHRoaXMuZW50ZXJJbkVkaXRNb2RlKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBlZGl0b3JEaXZLZXlkb3duKGV2ZW50KSB7XG4gICAgRnJlZVRleHRFZGl0b3IuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICBlZGl0b3JEaXZGb2N1cyhldmVudCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcbiAgfVxuICBlZGl0b3JEaXZCbHVyKGV2ZW50KSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgfVxuICBlZGl0b3JEaXZJbnB1dChldmVudCkge1xuICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZnJlZXRleHRFZGl0aW5nXCIsIHRoaXMuaXNFbXB0eSgpKTtcbiAgfVxuICBkaXNhYmxlRWRpdGluZygpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29tbWVudFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW11bHRpbGluZVwiKTtcbiAgfVxuICBlbmFibGVFZGl0aW5nKCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0ZXh0Ym94XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbXVsdGlsaW5lXCIsIHRydWUpO1xuICB9XG4gIGdldCBjYW5DaGFuZ2VDb250ZW50KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBpZiAodGhpcy5faXNDb3B5IHx8IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxcIjtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB0aGlzLiNlZGl0b3JEaXZJZCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZnJlZS10ZXh0MlwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXR0cnNcIiwgXCJkZWZhdWx0LWNvbnRlbnRcIik7XG4gICAgdGhpcy5lbmFibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmVkaXRvckRpdjtcbiAgICBzdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7dGhpcy4jZm9udFNpemV9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgc3R5bGUuY29sb3IgPSB0aGlzLiNjb2xvcjtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5lZGl0b3JEaXYpO1xuICAgIHRoaXMub3ZlcmxheURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5hZGQoXCJvdmVybGF5XCIsIFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5vdmVybGF5RGl2KTtcbiAgICBpZiAodGhpcy5faXNDb3B5IHx8IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgICAgICBsZXQgW3R4LCB0eV0gPSB0aGlzLmdldEluaXRpYWxUcmFuc2xhdGlvbigpO1xuICAgICAgICBbdHgsIHR5XSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4odHgsIHR5KTtcbiAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgICAgICBsZXQgcG9zWCwgcG9zWTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZICsgdGhpcy5oZWlnaHQgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFt0eSwgLXR4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYIC0gdGhpcy53aWR0aCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFstdHgsIC10eV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI3MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYIC0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0KSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSArIChwb3NpdGlvblsxXSAtIHBhZ2VZIC0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbLXR5LCB0eF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEF0KHBvc1ggKiBwYXJlbnRXaWR0aCwgcG9zWSAqIHBhcmVudEhlaWdodCwgdHgsIHR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX21vdmVBZnRlclBhc3RlKGJhc2VYLCBiYXNlWSk7XG4gICAgICB9XG4gICAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBzdGF0aWMgI2dldE5vZGVDb250ZW50KG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gbm9kZS5ub2RlVmFsdWUgOiBub2RlLmlubmVyVGV4dCkucmVwbGFjZUFsbChFT0xfUEFUVEVSTiwgXCJcIik7XG4gIH1cbiAgZWRpdG9yRGl2UGFzdGUoZXZlbnQpIHtcbiAgICBjb25zdCBjbGlwYm9hcmREYXRhID0gZXZlbnQuY2xpcGJvYXJkRGF0YSB8fCB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlc1xuICAgIH0gPSBjbGlwYm9hcmREYXRhO1xuICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDEgJiYgdHlwZXNbMF0gPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgcGFzdGUgPSBGcmVlVGV4dEVkaXRvci4jZGVzZXJpYWxpemVDb250ZW50KGNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHRcIikgfHwgXCJcIikucmVwbGFjZUFsbChFT0xfUEFUVEVSTiwgXCJcXG5cIik7XG4gICAgaWYgKCFwYXN0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24ucmFuZ2VDb3VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVkaXRvckRpdi5ub3JtYWxpemUoKTtcbiAgICBzZWxlY3Rpb24uZGVsZXRlRnJvbURvY3VtZW50KCk7XG4gICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICBpZiAoIXBhc3RlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICByYW5nZS5pbnNlcnROb2RlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBhc3RlKSk7XG4gICAgICB0aGlzLmVkaXRvckRpdi5ub3JtYWxpemUoKTtcbiAgICAgIHNlbGVjdGlvbi5jb2xsYXBzZVRvU3RhcnQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRDb250YWluZXIsXG4gICAgICBzdGFydE9mZnNldFxuICAgIH0gPSByYW5nZTtcbiAgICBjb25zdCBidWZmZXJCZWZvcmUgPSBbXTtcbiAgICBjb25zdCBidWZmZXJBZnRlciA9IFtdO1xuICAgIGlmIChzdGFydENvbnRhaW5lci5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHN0YXJ0Q29udGFpbmVyLnBhcmVudEVsZW1lbnQ7XG4gICAgICBidWZmZXJBZnRlci5wdXNoKHN0YXJ0Q29udGFpbmVyLm5vZGVWYWx1ZS5zbGljZShzdGFydE9mZnNldCkucmVwbGFjZUFsbChFT0xfUEFUVEVSTiwgXCJcIikpO1xuICAgICAgaWYgKHBhcmVudCAhPT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IGJ1ZmZlckJlZm9yZTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmVkaXRvckRpdi5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKGNoaWxkID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlckFmdGVyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlci5wdXNoKEZyZWVUZXh0RWRpdG9yLiNnZXROb2RlQ29udGVudChjaGlsZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBidWZmZXJCZWZvcmUucHVzaChzdGFydENvbnRhaW5lci5ub2RlVmFsdWUuc2xpY2UoMCwgc3RhcnRPZmZzZXQpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXCIpKTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0Q29udGFpbmVyID09PSB0aGlzLmVkaXRvckRpdikge1xuICAgICAgbGV0IGJ1ZmZlciA9IGJ1ZmZlckJlZm9yZTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgICBpZiAoaSsrID09PSBzdGFydE9mZnNldCkge1xuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlckFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXNoKEZyZWVUZXh0RWRpdG9yLiNnZXROb2RlQ29udGVudChjaGlsZCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjb250ZW50ID0gYCR7YnVmZmVyQmVmb3JlLmpvaW4oXCJcXG5cIil9JHtwYXN0ZX0ke2J1ZmZlckFmdGVyLmpvaW4oXCJcXG5cIil9YDtcbiAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgY29uc3QgbmV3UmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgICBsZXQgYmVmb3JlTGVuZ3RoID0gTWF0aC5zdW1QcmVjaXNlKGJ1ZmZlckJlZm9yZS5tYXAobGluZSA9PiBsaW5lLmxlbmd0aCkpO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgZmlyc3RDaGlsZFxuICAgIH0gb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgaWYgKGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGZpcnN0Q2hpbGQubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKGJlZm9yZUxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgICAgICBuZXdSYW5nZS5zZXRTdGFydChmaXJzdENoaWxkLCBiZWZvcmVMZW5ndGgpO1xuICAgICAgICAgIG5ld1JhbmdlLnNldEVuZChmaXJzdENoaWxkLCBiZWZvcmVMZW5ndGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJlZm9yZUxlbmd0aCAtPSBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBzZWxlY3Rpb24uYWRkUmFuZ2UobmV3UmFuZ2UpO1xuICB9XG4gICNzZXRDb250ZW50KCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlcGxhY2VDaGlsZHJlbigpO1xuICAgIGlmICghdGhpcy4jY29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy4jY29udGVudC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5hcHBlbmQobGluZSA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmFwcGVuZChkaXYpO1xuICAgIH1cbiAgfVxuICAjc2VyaWFsaXplQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29udGVudC5yZXBsYWNlQWxsKFwiXFx4YTBcIiwgXCIgXCIpO1xuICB9XG4gIHN0YXRpYyAjZGVzZXJpYWxpemVDb250ZW50KGNvbnRlbnQpIHtcbiAgICByZXR1cm4gY29udGVudC5yZXBsYWNlQWxsKFwiIFwiLCBcIlxceGEwXCIpO1xuICB9XG4gIGdldCBjb250ZW50RGl2KCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRvckRpdjtcbiAgfVxuICBnZXRQREZSZWN0KCkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSBGcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogdGhpcy5wYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gdGhpcy5nZXRSZWN0KHBhZGRpbmcsIHBhZGRpbmcpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGxldCBpbml0aWFsRGF0YSA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkZWZhdWx0QXBwZWFyYW5jZURhdGE6IHtcbiAgICAgICAgICAgIGZvbnRTaXplLFxuICAgICAgICAgICAgZm9udENvbG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBvcHVwUmVmLFxuICAgICAgICAgIGNvbnRlbnRzT2JqXG4gICAgICAgIH0sXG4gICAgICAgIHRleHRDb250ZW50LFxuICAgICAgICB0ZXh0UG9zaXRpb24sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaWYgKCF0ZXh0Q29udGVudCB8fCB0ZXh0Q29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCxcbiAgICAgICAgY29sb3I6IEFycmF5LmZyb20oZm9udENvbG9yKSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIHZhbHVlOiB0ZXh0Q29udGVudC5qb2luKFwiXFxuXCIpLFxuICAgICAgICBwb3NpdGlvbjogdGV4dFBvc2l0aW9uLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZDogaWQsXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgIGNvbW1lbnQ6IGNvbnRlbnRzT2JqPy5zdHIgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci4jZm9udFNpemUgPSBkYXRhLmZvbnRTaXplO1xuICAgIGVkaXRvci4jY29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5kYXRhLmNvbG9yKTtcbiAgICBlZGl0b3IuI2NvbnRlbnQgPSBGcmVlVGV4dEVkaXRvci4jZGVzZXJpYWxpemVDb250ZW50KGRhdGEudmFsdWUpO1xuICAgIGVkaXRvci5faW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICBpZiAoZGF0YS5jb21tZW50KSB7XG4gICAgICBlZGl0b3Iuc2V0Q29tbWVudERhdGEoZGF0YS5jb21tZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmdldFBERlJlY3QoKTtcbiAgICBjb25zdCBjb2xvciA9IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuaXNBdHRhY2hlZFRvRE9NID8gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVkaXRvckRpdikuY29sb3IgOiB0aGlzLiNjb2xvcik7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCxcbiAgICAgIGNvbG9yLFxuICAgICAgZm9udFNpemU6IHRoaXMuI2ZvbnRTaXplLFxuICAgICAgdmFsdWU6IHRoaXMuI3NlcmlhbGl6ZUNvbnRlbnQoKSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tZW50KHNlcmlhbGl6ZWQpO1xuICAgIGlmIChpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHNlcmlhbGl6ZWQuaXNDb3B5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICF0aGlzLiNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGZvbnRTaXplLFxuICAgICAgY29sb3IsXG4gICAgICBwYWdlSW5kZXhcbiAgICB9ID0gdGhpcy5faW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIHRoaXMuaGFzRWRpdGVkQ29tbWVudCB8fCB0aGlzLl9oYXNCZWVuTW92ZWQgfHwgc2VyaWFsaXplZC52YWx1ZSAhPT0gdmFsdWUgfHwgc2VyaWFsaXplZC5mb250U2l6ZSAhPT0gZm9udFNpemUgfHwgc2VyaWFsaXplZC5jb2xvci5zb21lKChjLCBpKSA9PiBjICE9PSBjb2xvcltpXSkgfHwgc2VyaWFsaXplZC5wYWdlSW5kZXggIT09IHBhZ2VJbmRleDtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgY29uc3QgY29udGVudCA9IHN1cGVyLnJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pO1xuICAgIGlmICghY29udGVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGNvbnRlbnQ7XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gdGhpcy4jY29sb3I7XG4gICAgY29udGVudC5yZXBsYWNlQ2hpbGRyZW4oKTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy4jY29udGVudC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5hcHBlbmQobGluZSA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIGNvbnRlbnQuYXBwZW5kKGRpdik7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpXG4gICAgfTtcbiAgICBwYXJhbXMucG9wdXAgPSB0aGlzLmhhc0VkaXRlZENvbW1lbnQgPyB0aGlzLmNvbW1lbnQgOiB7XG4gICAgICB0ZXh0OiB0aGlzLiNjb250ZW50XG4gICAgfTtcbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZChwYXJhbXMpO1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIHJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIHN1cGVyLnJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbik7XG4gICAgYW5ub3RhdGlvbi5yZXNldEVkaXRlZCgpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL291dGxpbmUuanNcblxuY2xhc3MgT3V0bGluZSB7XG4gIHN0YXRpYyBQUkVDSVNJT04gPSAxZS00O1xuICB0b1NWR1BhdGgoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYHRvU1ZHUGF0aGAgbXVzdCBiZSBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IGdldHRlciBgYm94YCBtdXN0IGJlIGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICBzZXJpYWxpemUoX2Jib3gsIF9yb3RhdGlvbikge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBzZXJpYWxpemVgIG11c3QgYmUgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIHN0YXRpYyBfcmVzY2FsZShzcmMsIHR4LCB0eSwgc3gsIHN5LCBkZXN0KSB7XG4gICAgZGVzdCB8fD0gbmV3IEZsb2F0MzJBcnJheShzcmMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgZGVzdFtpXSA9IHR4ICsgc3JjW2ldICogc3g7XG4gICAgICBkZXN0W2kgKyAxXSA9IHR5ICsgc3JjW2kgKyAxXSAqIHN5O1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICBzdGF0aWMgX3Jlc2NhbGVBbmRTd2FwKHNyYywgdHgsIHR5LCBzeCwgc3ksIGRlc3QpIHtcbiAgICBkZXN0IHx8PSBuZXcgRmxvYXQzMkFycmF5KHNyYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBkZXN0W2ldID0gdHggKyBzcmNbaSArIDFdICogc3g7XG4gICAgICBkZXN0W2kgKyAxXSA9IHR5ICsgc3JjW2ldICogc3k7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHN0YXRpYyBfdHJhbnNsYXRlKHNyYywgdHgsIHR5LCBkZXN0KSB7XG4gICAgZGVzdCB8fD0gbmV3IEZsb2F0MzJBcnJheShzcmMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgZGVzdFtpXSA9IHR4ICsgc3JjW2ldO1xuICAgICAgZGVzdFtpICsgMV0gPSB0eSArIHNyY1tpICsgMV07XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHN0YXRpYyBzdmdSb3VuZCh4KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoeCAqIDEwMDAwKTtcbiAgfVxuICBzdGF0aWMgX25vcm1hbGl6ZVBvaW50KHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSAvIHBhcmVudFdpZHRoLCB4IC8gcGFyZW50SGVpZ2h0XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWzEgLSB4IC8gcGFyZW50V2lkdGgsIDEgLSB5IC8gcGFyZW50SGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3kgLyBwYXJlbnRXaWR0aCwgMSAtIHggLyBwYXJlbnRIZWlnaHRdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4IC8gcGFyZW50V2lkdGgsIHkgLyBwYXJlbnRIZWlnaHRdO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX25vcm1hbGl6ZVBhZ2VQb2ludCh4LCB5LCByb3RhdGlvbikge1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHJldHVybiBbKHgxICsgNSAqIHgyKSAvIDYsICh5MSArIDUgKiB5MikgLyA2LCAoNSAqIHgyICsgeDMpIC8gNiwgKDUgKiB5MiArIHkzKSAvIDYsICh4MiArIHgzKSAvIDIsICh5MiArIHkzKSAvIDJdO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL2ZyZWVkcmF3LmpzXG5cblxuY2xhc3MgRnJlZURyYXdPdXRsaW5lciB7XG4gICNib3g7XG4gICNib3R0b20gPSBbXTtcbiAgI2lubmVyTWFyZ2luO1xuICAjaXNMVFI7XG4gICN0b3AgPSBbXTtcbiAgI2xhc3QgPSBuZXcgRmxvYXQzMkFycmF5KDE4KTtcbiAgI2xhc3RYO1xuICAjbGFzdFk7XG4gICNtaW47XG4gICNtaW5fZGlzdDtcbiAgI3NjYWxlRmFjdG9yO1xuICAjdGhpY2tuZXNzO1xuICAjcG9pbnRzID0gW107XG4gIHN0YXRpYyAjTUlOX0RJU1QgPSA4O1xuICBzdGF0aWMgI01JTl9ESUZGID0gMjtcbiAgc3RhdGljICNNSU4gPSBGcmVlRHJhd091dGxpbmVyLiNNSU5fRElTVCArIEZyZWVEcmF3T3V0bGluZXIuI01JTl9ESUZGO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgeCxcbiAgICB5XG4gIH0sIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luID0gMCkge1xuICAgIHRoaXMuI2JveCA9IGJveDtcbiAgICB0aGlzLiN0aGlja25lc3MgPSB0aGlja25lc3MgKiBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNpc0xUUiA9IGlzTFRSO1xuICAgIHRoaXMuI2xhc3Quc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgsIHldLCA2KTtcbiAgICB0aGlzLiNpbm5lck1hcmdpbiA9IGlubmVyTWFyZ2luO1xuICAgIHRoaXMuI21pbl9kaXN0ID0gRnJlZURyYXdPdXRsaW5lci4jTUlOX0RJU1QgKiBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNtaW4gPSBGcmVlRHJhd091dGxpbmVyLiNNSU4gKiBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNzY2FsZUZhY3RvciA9IHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI3BvaW50cy5wdXNoKHgsIHkpO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGlzTmFOKHRoaXMuI2xhc3RbOF0pO1xuICB9XG4gICNnZXRMYXN0Q29vcmRzKCkge1xuICAgIGNvbnN0IGxhc3RUb3AgPSB0aGlzLiNsYXN0LnN1YmFycmF5KDQsIDYpO1xuICAgIGNvbnN0IGxhc3RCb3R0b20gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE2LCAxOCk7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIHJldHVybiBbKHRoaXMuI2xhc3RYICsgKGxhc3RUb3BbMF0gLSBsYXN0Qm90dG9tWzBdKSAvIDIgLSB4KSAvIHdpZHRoLCAodGhpcy4jbGFzdFkgKyAobGFzdFRvcFsxXSAtIGxhc3RCb3R0b21bMV0pIC8gMiAtIHkpIC8gaGVpZ2h0LCAodGhpcy4jbGFzdFggKyAobGFzdEJvdHRvbVswXSAtIGxhc3RUb3BbMF0pIC8gMiAtIHgpIC8gd2lkdGgsICh0aGlzLiNsYXN0WSArIChsYXN0Qm90dG9tWzFdIC0gbGFzdFRvcFsxXSkgLyAyIC0geSkgLyBoZWlnaHRdO1xuICB9XG4gIGFkZCh7XG4gICAgeCxcbiAgICB5XG4gIH0pIHtcbiAgICB0aGlzLiNsYXN0WCA9IHg7XG4gICAgdGhpcy4jbGFzdFkgPSB5O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGxldCBbeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSg4LCAxMik7XG4gICAgY29uc3QgZGlmZlggPSB4IC0geDI7XG4gICAgY29uc3QgZGlmZlkgPSB5IC0geTI7XG4gICAgY29uc3QgZCA9IE1hdGguaHlwb3QoZGlmZlgsIGRpZmZZKTtcbiAgICBpZiAoZCA8IHRoaXMuI21pbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBkaWZmRCA9IGQgLSB0aGlzLiNtaW5fZGlzdDtcbiAgICBjb25zdCBLID0gZGlmZkQgLyBkO1xuICAgIGNvbnN0IHNoaWZ0WCA9IEsgKiBkaWZmWDtcbiAgICBjb25zdCBzaGlmdFkgPSBLICogZGlmZlk7XG4gICAgbGV0IHgwID0geDE7XG4gICAgbGV0IHkwID0geTE7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICAgIHgyICs9IHNoaWZ0WDtcbiAgICB5MiArPSBzaGlmdFk7XG4gICAgdGhpcy4jcG9pbnRzPy5wdXNoKHgsIHkpO1xuICAgIGNvbnN0IG5YID0gLXNoaWZ0WSAvIGRpZmZEO1xuICAgIGNvbnN0IG5ZID0gc2hpZnRYIC8gZGlmZkQ7XG4gICAgY29uc3QgdGhYID0gblggKiB0aGlzLiN0aGlja25lc3M7XG4gICAgY29uc3QgdGhZID0gblkgKiB0aGlzLiN0aGlja25lc3M7XG4gICAgdGhpcy4jbGFzdC5zZXQodGhpcy4jbGFzdC5zdWJhcnJheSgyLCA4KSwgMCk7XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gyICsgdGhYLCB5MiArIHRoWV0sIDQpO1xuICAgIHRoaXMuI2xhc3Quc2V0KHRoaXMuI2xhc3Quc3ViYXJyYXkoMTQsIDE4KSwgMTIpO1xuICAgIHRoaXMuI2xhc3Quc2V0KFt4MiAtIHRoWCwgeTIgLSB0aFldLCAxNik7XG4gICAgaWYgKGlzTmFOKHRoaXMuI2xhc3RbNl0pKSB7XG4gICAgICBpZiAodGhpcy4jdG9wLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLiNsYXN0LnNldChbeDEgKyB0aFgsIHkxICsgdGhZXSwgMik7XG4gICAgICAgIHRoaXMuI3RvcC5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgKHgxICsgdGhYIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICh5MSArIHRoWSAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MSAtIHRoWCwgeTEgLSB0aFldLCAxNCk7XG4gICAgICAgIHRoaXMuI2JvdHRvbS5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgKHgxIC0gdGhYIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICh5MSAtIHRoWSAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNsYXN0LnNldChbeDAsIHkwLCB4MSwgeTEsIHgyLCB5Ml0sIDYpO1xuICAgICAgcmV0dXJuICF0aGlzLmlzRW1wdHkoKTtcbiAgICB9XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTJdLCA2KTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGguYWJzKE1hdGguYXRhbjIoeTAgLSB5MSwgeDAgLSB4MSkgLSBNYXRoLmF0YW4yKHNoaWZ0WSwgc2hpZnRYKSk7XG4gICAgaWYgKGFuZ2xlIDwgTWF0aC5QSSAvIDIpIHtcbiAgICAgIFt4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDIsIDYpO1xuICAgICAgdGhpcy4jdG9wLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoKHgxICsgeDIpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkxICsgeTIpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICBbeDEsIHkxLCB4MCwgeTBdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxNCwgMTgpO1xuICAgICAgdGhpcy4jYm90dG9tLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoKHgwICsgeDEpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkwICsgeTEpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgwLCA2KTtcbiAgICB0aGlzLiN0b3AucHVzaCgoKHgwICsgNSAqIHgxKSAvIDYgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MCArIDUgKiB5MSkgLyA2IC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCAoKDUgKiB4MSArIHgyKSAvIDYgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCg1ICogeTEgKyB5MikgLyA2IC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCAoKHgxICsgeDIpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkxICsgeTIpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgW3gyLCB5MiwgeDEsIHkxLCB4MCwgeTBdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxMiwgMTgpO1xuICAgIHRoaXMuI2JvdHRvbS5wdXNoKCgoeDAgKyA1ICogeDEpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkwICsgNSAqIHkxKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoNSAqIHgxICsgeDIpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKDUgKiB5MSArIHkyKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoeDEgKyB4MikgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTEgKyB5MikgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgY29uc3QgdG9wID0gdGhpcy4jdG9wO1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBpZiAoaXNOYU4odGhpcy4jbGFzdFs2XSkgJiYgIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jdG9TVkdQYXRoVHdvUG9pbnRzKCk7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGJ1ZmZlci5wdXNoKGBNJHt0b3BbNF19ICR7dG9wWzVdfWApO1xuICAgIGZvciAobGV0IGkgPSA2OyBpIDwgdG9wLmxlbmd0aDsgaSArPSA2KSB7XG4gICAgICBpZiAoaXNOYU4odG9wW2ldKSkge1xuICAgICAgICBidWZmZXIucHVzaChgTCR7dG9wW2kgKyA0XX0gJHt0b3BbaSArIDVdfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEMke3RvcFtpXX0gJHt0b3BbaSArIDFdfSAke3RvcFtpICsgMl19ICR7dG9wW2kgKyAzXX0gJHt0b3BbaSArIDRdfSAke3RvcFtpICsgNV19YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3RvU1ZHUGF0aEVuZChidWZmZXIpO1xuICAgIGZvciAobGV0IGkgPSBib3R0b20ubGVuZ3RoIC0gNjsgaSA+PSA2OyBpIC09IDYpIHtcbiAgICAgIGlmIChpc05hTihib3R0b21baV0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHtib3R0b21baSArIDRdfSAke2JvdHRvbVtpICsgNV19YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIucHVzaChgQyR7Ym90dG9tW2ldfSAke2JvdHRvbVtpICsgMV19ICR7Ym90dG9tW2kgKyAyXX0gJHtib3R0b21baSArIDNdfSAke2JvdHRvbVtpICsgNF19ICR7Ym90dG9tW2kgKyA1XX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdG9TVkdQYXRoU3RhcnQoYnVmZmVyKTtcbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gICN0b1NWR1BhdGhUd29Qb2ludHMoKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgcmV0dXJuIGBNJHsodGhpcy4jbGFzdFsyXSAtIHgpIC8gd2lkdGh9ICR7KHRoaXMuI2xhc3RbM10gLSB5KSAvIGhlaWdodH0gTCR7KHRoaXMuI2xhc3RbNF0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzVdIC0geSkgLyBoZWlnaHR9IEwke2xhc3RUb3BYfSAke2xhc3RUb3BZfSBMJHtsYXN0Qm90dG9tWH0gJHtsYXN0Qm90dG9tWX0gTCR7KHRoaXMuI2xhc3RbMTZdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFsxN10gLSB5KSAvIGhlaWdodH0gTCR7KHRoaXMuI2xhc3RbMTRdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFsxNV0gLSB5KSAvIGhlaWdodH0gWmA7XG4gIH1cbiAgI3RvU1ZHUGF0aFN0YXJ0KGJ1ZmZlcikge1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBidWZmZXIucHVzaChgTCR7Ym90dG9tWzRdfSAke2JvdHRvbVs1XX0gWmApO1xuICB9XG4gICN0b1NWR1BhdGhFbmQoYnVmZmVyKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IGxhc3RUb3AgPSB0aGlzLiNsYXN0LnN1YmFycmF5KDQsIDYpO1xuICAgIGNvbnN0IGxhc3RCb3R0b20gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE2LCAxOCk7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICBidWZmZXIucHVzaChgTCR7KGxhc3RUb3BbMF0gLSB4KSAvIHdpZHRofSAkeyhsYXN0VG9wWzFdIC0geSkgLyBoZWlnaHR9IEwke2xhc3RUb3BYfSAke2xhc3RUb3BZfSBMJHtsYXN0Qm90dG9tWH0gJHtsYXN0Qm90dG9tWX0gTCR7KGxhc3RCb3R0b21bMF0gLSB4KSAvIHdpZHRofSAkeyhsYXN0Qm90dG9tWzFdIC0geSkgLyBoZWlnaHR9YCk7XG4gIH1cbiAgbmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpO1xuICB9XG4gIGdldE91dGxpbmVzKCkge1xuICAgIGNvbnN0IHRvcCA9IHRoaXMuI3RvcDtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLiNib3R0b207XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuI2xhc3Q7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSgodGhpcy4jcG9pbnRzPy5sZW5ndGggPz8gMCkgKyAyKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoIC0gMjsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIHBvaW50c1tpXSA9ICh0aGlzLiNwb2ludHNbaV0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aDtcbiAgICAgIHBvaW50c1tpICsgMV0gPSAodGhpcy4jcG9pbnRzW2kgKyAxXSAtIGxheWVyWSkgLyBsYXllckhlaWdodDtcbiAgICB9XG4gICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSA9ICh0aGlzLiNsYXN0WCAtIGxheWVyWCkgLyBsYXllcldpZHRoO1xuICAgIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gPSAodGhpcy4jbGFzdFkgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQ7XG4gICAgaWYgKGlzTmFOKGxhc3RbNl0pICYmICF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI2dldE91dGxpbmVUd29Qb2ludHMocG9pbnRzKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy4jdG9wLmxlbmd0aCArIDI0ICsgdGhpcy4jYm90dG9tLmxlbmd0aCk7XG4gICAgbGV0IE4gPSB0b3AubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSArPSAyKSB7XG4gICAgICBpZiAoaXNOYU4odG9wW2ldKSkge1xuICAgICAgICBvdXRsaW5lW2ldID0gb3V0bGluZVtpICsgMV0gPSBOYU47XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgb3V0bGluZVtpXSA9IHRvcFtpXTtcbiAgICAgIG91dGxpbmVbaSArIDFdID0gdG9wW2kgKyAxXTtcbiAgICB9XG4gICAgTiA9IHRoaXMuI2dldE91dGxpbmVFbmQob3V0bGluZSwgTik7XG4gICAgZm9yIChsZXQgaSA9IGJvdHRvbS5sZW5ndGggLSA2OyBpID49IDY7IGkgLT0gNikge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA2OyBqICs9IDIpIHtcbiAgICAgICAgaWYgKGlzTmFOKGJvdHRvbVtpICsgal0pKSB7XG4gICAgICAgICAgb3V0bGluZVtOXSA9IG91dGxpbmVbTiArIDFdID0gTmFOO1xuICAgICAgICAgIE4gKz0gMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvdXRsaW5lW05dID0gYm90dG9tW2kgKyBqXTtcbiAgICAgICAgb3V0bGluZVtOICsgMV0gPSBib3R0b21baSArIGogKyAxXTtcbiAgICAgICAgTiArPSAyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNnZXRPdXRsaW5lU3RhcnQob3V0bGluZSwgTik7XG4gICAgcmV0dXJuIHRoaXMubmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgdGhpcy4jYm94LCB0aGlzLiNzY2FsZUZhY3RvciwgdGhpcy4jaW5uZXJNYXJnaW4sIHRoaXMuI2lzTFRSKTtcbiAgfVxuICAjZ2V0T3V0bGluZVR3b1BvaW50cyhwb2ludHMpIHtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy4jbGFzdDtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBbbGFzdFRvcFgsIGxhc3RUb3BZLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVldID0gdGhpcy4jZ2V0TGFzdENvb3JkcygpO1xuICAgIGNvbnN0IG91dGxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KDM2KTtcbiAgICBvdXRsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFsyXSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFszXSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFs0XSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFs1XSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0VG9wWCwgbGFzdFRvcFksIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzE2XSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFsxN10gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsIE5hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RbMTRdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzE1XSAtIGxheWVyWSkgLyBsYXllckhlaWdodF0sIDApO1xuICAgIHJldHVybiB0aGlzLm5ld0ZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIHRoaXMuI2JveCwgdGhpcy4jc2NhbGVGYWN0b3IsIHRoaXMuI2lubmVyTWFyZ2luLCB0aGlzLiNpc0xUUik7XG4gIH1cbiAgI2dldE91dGxpbmVTdGFydChvdXRsaW5lLCBwb3MpIHtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLiNib3R0b207XG4gICAgb3V0bGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgYm90dG9tWzRdLCBib3R0b21bNV1dLCBwb3MpO1xuICAgIHJldHVybiBwb3MgKz0gNjtcbiAgfVxuICAjZ2V0T3V0bGluZUVuZChvdXRsaW5lLCBwb3MpIHtcbiAgICBjb25zdCBsYXN0VG9wID0gdGhpcy4jbGFzdC5zdWJhcnJheSg0LCA2KTtcbiAgICBjb25zdCBsYXN0Qm90dG9tID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxNiwgMTgpO1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgb3V0bGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RUb3BbMF0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RUb3BbMV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdFRvcFgsIGxhc3RUb3BZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWSwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdEJvdHRvbVswXSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdEJvdHRvbVsxXSAtIGxheWVyWSkgLyBsYXllckhlaWdodF0sIHBvcyk7XG4gICAgcmV0dXJuIHBvcyArPSAyNDtcbiAgfVxufVxuY2xhc3MgRnJlZURyYXdPdXRsaW5lIGV4dGVuZHMgT3V0bGluZSB7XG4gICNib3g7XG4gICNiYm94ID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgI2lubmVyTWFyZ2luO1xuICAjaXNMVFI7XG4gICNwb2ludHM7XG4gICNzY2FsZUZhY3RvcjtcbiAgI291dGxpbmU7XG4gIGNvbnN0cnVjdG9yKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNvdXRsaW5lID0gb3V0bGluZTtcbiAgICB0aGlzLiNwb2ludHMgPSBwb2ludHM7XG4gICAgdGhpcy4jYm94ID0gYm94O1xuICAgIHRoaXMuI3NjYWxlRmFjdG9yID0gc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jaW5uZXJNYXJnaW4gPSBpbm5lck1hcmdpbjtcbiAgICB0aGlzLiNpc0xUUiA9IGlzTFRSO1xuICAgIHRoaXMubGFzdFBvaW50ID0gW05hTiwgTmFOXTtcbiAgICB0aGlzLiNjb21wdXRlTWluTWF4KGlzTFRSKTtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG91dGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgb3V0bGluZVtpXSA9IChvdXRsaW5lW2ldIC0geCkgLyB3aWR0aDtcbiAgICAgIG91dGxpbmVbaSArIDFdID0gKG91dGxpbmVbaSArIDFdIC0geSkgLyBoZWlnaHQ7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBwb2ludHNbaV0gPSAocG9pbnRzW2ldIC0geCkgLyB3aWR0aDtcbiAgICAgIHBvaW50c1tpICsgMV0gPSAocG9pbnRzW2kgKyAxXSAtIHkpIC8gaGVpZ2h0O1xuICAgIH1cbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW2BNJHt0aGlzLiNvdXRsaW5lWzRdfSAke3RoaXMuI291dGxpbmVbNV19YF07XG4gICAgZm9yIChsZXQgaSA9IDYsIGlpID0gdGhpcy4jb3V0bGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICBpZiAoaXNOYU4odGhpcy4jb3V0bGluZVtpXSkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEwke3RoaXMuI291dGxpbmVbaSArIDRdfSAke3RoaXMuI291dGxpbmVbaSArIDVdfWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5wdXNoKGBDJHt0aGlzLiNvdXRsaW5lW2ldfSAke3RoaXMuI291dGxpbmVbaSArIDFdfSAke3RoaXMuI291dGxpbmVbaSArIDJdfSAke3RoaXMuI291dGxpbmVbaSArIDNdfSAke3RoaXMuI291dGxpbmVbaSArIDRdfSAke3RoaXMuI291dGxpbmVbaSArIDVdfWApO1xuICAgIH1cbiAgICBidWZmZXIucHVzaChcIlpcIik7XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgfVxuICBzZXJpYWxpemUoW2JsWCwgYmxZLCB0clgsIHRyWV0sIHJvdGF0aW9uKSB7XG4gICAgY29uc3Qgd2lkdGggPSB0clggLSBibFg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdHJZIC0gYmxZO1xuICAgIGxldCBvdXRsaW5lO1xuICAgIGxldCBwb2ludHM7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBvdXRsaW5lID0gT3V0bGluZS5fcmVzY2FsZSh0aGlzLiNvdXRsaW5lLCBibFgsIHRyWSwgd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSBPdXRsaW5lLl9yZXNjYWxlKHRoaXMuI3BvaW50cywgYmxYLCB0clksIHdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICBvdXRsaW5lID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXAodGhpcy4jb3V0bGluZSwgYmxYLCBibFksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcCh0aGlzLiNwb2ludHMsIGJsWCwgYmxZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgb3V0bGluZSA9IE91dGxpbmUuX3Jlc2NhbGUodGhpcy4jb3V0bGluZSwgdHJYLCBibFksIC13aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcG9pbnRzID0gT3V0bGluZS5fcmVzY2FsZSh0aGlzLiNwb2ludHMsIHRyWCwgYmxZLCAtd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIG91dGxpbmUgPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcCh0aGlzLiNvdXRsaW5lLCB0clgsIHRyWSwgLXdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgcG9pbnRzID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXAodGhpcy4jcG9pbnRzLCB0clgsIHRyWSwgLXdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvdXRsaW5lOiBBcnJheS5mcm9tKG91dGxpbmUpLFxuICAgICAgcG9pbnRzOiBbQXJyYXkuZnJvbShwb2ludHMpXVxuICAgIH07XG4gIH1cbiAgI2NvbXB1dGVNaW5NYXgoaXNMVFIpIHtcbiAgICBjb25zdCBvdXRsaW5lID0gdGhpcy4jb3V0bGluZTtcbiAgICBsZXQgbGFzdFggPSBvdXRsaW5lWzRdO1xuICAgIGxldCBsYXN0WSA9IG91dGxpbmVbNV07XG4gICAgY29uc3QgbWluTWF4ID0gW2xhc3RYLCBsYXN0WSwgbGFzdFgsIGxhc3RZXTtcbiAgICBsZXQgbGFzdFBvaW50WCA9IGxhc3RYO1xuICAgIGxldCBsYXN0UG9pbnRZID0gbGFzdFk7XG4gICAgY29uc3QgbHRyQ2FsbGJhY2sgPSBpc0xUUiA/IE1hdGgubWF4IDogTWF0aC5taW47XG4gICAgZm9yIChsZXQgaSA9IDYsIGlpID0gb3V0bGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICBjb25zdCB4ID0gb3V0bGluZVtpICsgNF0sXG4gICAgICAgIHkgPSBvdXRsaW5lW2kgKyA1XTtcbiAgICAgIGlmIChpc05hTihvdXRsaW5lW2ldKSkge1xuICAgICAgICBVdGlsLnBvaW50Qm91bmRpbmdCb3goeCwgeSwgbWluTWF4KTtcbiAgICAgICAgaWYgKGxhc3RQb2ludFkgPCB5KSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IHg7XG4gICAgICAgICAgbGFzdFBvaW50WSA9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFBvaW50WSA9PT0geSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBsdHJDYWxsYmFjayhsYXN0UG9pbnRYLCB4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYmJveCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgICAgVXRpbC5iZXppZXJCb3VuZGluZ0JveChsYXN0WCwgbGFzdFksIC4uLm91dGxpbmUuc2xpY2UoaSwgaSArIDYpLCBiYm94KTtcbiAgICAgICAgVXRpbC5yZWN0Qm91bmRpbmdCb3goLi4uYmJveCwgbWluTWF4KTtcbiAgICAgICAgaWYgKGxhc3RQb2ludFkgPCBiYm94WzNdKSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IGJib3hbMl07XG4gICAgICAgICAgbGFzdFBvaW50WSA9IGJib3hbM107XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFBvaW50WSA9PT0gYmJveFszXSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBsdHJDYWxsYmFjayhsYXN0UG9pbnRYLCBiYm94WzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFggPSB4O1xuICAgICAgbGFzdFkgPSB5O1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBiYm94WzBdID0gbWluTWF4WzBdIC0gdGhpcy4jaW5uZXJNYXJnaW47XG4gICAgYmJveFsxXSA9IG1pbk1heFsxXSAtIHRoaXMuI2lubmVyTWFyZ2luO1xuICAgIGJib3hbMl0gPSBtaW5NYXhbMl0gLSBtaW5NYXhbMF0gKyAyICogdGhpcy4jaW5uZXJNYXJnaW47XG4gICAgYmJveFszXSA9IG1pbk1heFszXSAtIG1pbk1heFsxXSArIDIgKiB0aGlzLiNpbm5lck1hcmdpbjtcbiAgICB0aGlzLmxhc3RQb2ludCA9IFtsYXN0UG9pbnRYLCBsYXN0UG9pbnRZXTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHJldHVybiB0aGlzLiNiYm94O1xuICB9XG4gIG5ld091dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbiA9IDApIHtcbiAgICByZXR1cm4gbmV3IEZyZWVEcmF3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luKTtcbiAgfVxuICBnZXROZXdPdXRsaW5lKHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IHN4ID0gd2lkdGggKiBsYXllcldpZHRoO1xuICAgIGNvbnN0IHN5ID0gaGVpZ2h0ICogbGF5ZXJIZWlnaHQ7XG4gICAgY29uc3QgdHggPSB4ICogbGF5ZXJXaWR0aCArIGxheWVyWDtcbiAgICBjb25zdCB0eSA9IHkgKiBsYXllckhlaWdodCArIGxheWVyWTtcbiAgICBjb25zdCBvdXRsaW5lciA9IHRoaXMubmV3T3V0bGluZXIoe1xuICAgICAgeDogdGhpcy4jcG9pbnRzWzBdICogc3ggKyB0eCxcbiAgICAgIHk6IHRoaXMuI3BvaW50c1sxXSAqIHN5ICsgdHlcbiAgICB9LCB0aGlzLiNib3gsIHRoaXMuI3NjYWxlRmFjdG9yLCB0aGlja25lc3MsIHRoaXMuI2lzTFRSLCBpbm5lck1hcmdpbiA/PyB0aGlzLiNpbm5lck1hcmdpbik7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0aGlzLiNwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIG91dGxpbmVyLmFkZCh7XG4gICAgICAgIHg6IHRoaXMuI3BvaW50c1tpXSAqIHN4ICsgdHgsXG4gICAgICAgIHk6IHRoaXMuI3BvaW50c1tpICsgMV0gKiBzeSArIHR5XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dGxpbmVyLmdldE91dGxpbmVzKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvaGlnaGxpZ2h0LmpzXG5cblxuXG5jbGFzcyBIaWdobGlnaHRPdXRsaW5lciB7XG4gICNib3g7XG4gICNsYXN0UG9pbnQ7XG4gICN2ZXJ0aWNhbEVkZ2VzID0gW107XG4gICNpbnRlcnZhbHMgPSBbXTtcbiAgY29uc3RydWN0b3IoYm94ZXMsIGJvcmRlcldpZHRoID0gMCwgaW5uZXJNYXJnaW4gPSAwLCBpc0xUUiA9IHRydWUpIHtcbiAgICBjb25zdCBtaW5NYXggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgY29uc3QgTlVNQkVSX09GX0RJR0lUUyA9IDQ7XG4gICAgY29uc3QgRVBTSUxPTiA9IDEwICoqIC1OVU1CRVJfT0ZfRElHSVRTO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gb2YgYm94ZXMpIHtcbiAgICAgIGNvbnN0IHgxID0gTWF0aC5mbG9vcigoeCAtIGJvcmRlcldpZHRoKSAvIEVQU0lMT04pICogRVBTSUxPTjtcbiAgICAgIGNvbnN0IHgyID0gTWF0aC5jZWlsKCh4ICsgd2lkdGggKyBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCB5MSA9IE1hdGguZmxvb3IoKHkgLSBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCB5MiA9IE1hdGguY2VpbCgoeSArIGhlaWdodCArIGJvcmRlcldpZHRoKSAvIEVQU0lMT04pICogRVBTSUxPTjtcbiAgICAgIGNvbnN0IGxlZnQgPSBbeDEsIHkxLCB5MiwgdHJ1ZV07XG4gICAgICBjb25zdCByaWdodCA9IFt4MiwgeTEsIHkyLCBmYWxzZV07XG4gICAgICB0aGlzLiN2ZXJ0aWNhbEVkZ2VzLnB1c2gobGVmdCwgcmlnaHQpO1xuICAgICAgVXRpbC5yZWN0Qm91bmRpbmdCb3goeDEsIHkxLCB4MiwgeTIsIG1pbk1heCk7XG4gICAgfVxuICAgIGNvbnN0IGJib3hXaWR0aCA9IG1pbk1heFsyXSAtIG1pbk1heFswXSArIDIgKiBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBiYm94SGVpZ2h0ID0gbWluTWF4WzNdIC0gbWluTWF4WzFdICsgMiAqIGlubmVyTWFyZ2luO1xuICAgIGNvbnN0IHNoaWZ0ZWRNaW5YID0gbWluTWF4WzBdIC0gaW5uZXJNYXJnaW47XG4gICAgY29uc3Qgc2hpZnRlZE1pblkgPSBtaW5NYXhbMV0gLSBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBsYXN0RWRnZSA9IHRoaXMuI3ZlcnRpY2FsRWRnZXMuYXQoaXNMVFIgPyAtMSA6IC0yKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBbbGFzdEVkZ2VbMF0sIGxhc3RFZGdlWzJdXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy4jdmVydGljYWxFZGdlcykge1xuICAgICAgY29uc3QgW3gsIHkxLCB5Ml0gPSBlZGdlO1xuICAgICAgZWRnZVswXSA9ICh4IC0gc2hpZnRlZE1pblgpIC8gYmJveFdpZHRoO1xuICAgICAgZWRnZVsxXSA9ICh5MSAtIHNoaWZ0ZWRNaW5ZKSAvIGJib3hIZWlnaHQ7XG4gICAgICBlZGdlWzJdID0gKHkyIC0gc2hpZnRlZE1pblkpIC8gYmJveEhlaWdodDtcbiAgICB9XG4gICAgdGhpcy4jYm94ID0gbmV3IEZsb2F0MzJBcnJheShbc2hpZnRlZE1pblgsIHNoaWZ0ZWRNaW5ZLCBiYm94V2lkdGgsIGJib3hIZWlnaHRdKTtcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBsYXN0UG9pbnQ7XG4gIH1cbiAgZ2V0T3V0bGluZXMoKSB7XG4gICAgdGhpcy4jdmVydGljYWxFZGdlcy5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXSB8fCBhWzJdIC0gYlsyXSk7XG4gICAgY29uc3Qgb3V0bGluZVZlcnRpY2FsRWRnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy4jdmVydGljYWxFZGdlcykge1xuICAgICAgaWYgKGVkZ2VbM10pIHtcbiAgICAgICAgb3V0bGluZVZlcnRpY2FsRWRnZXMucHVzaCguLi50aGlzLiNicmVha0VkZ2UoZWRnZSkpO1xuICAgICAgICB0aGlzLiNpbnNlcnQoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNyZW1vdmUoZWRnZSk7XG4gICAgICAgIG91dGxpbmVWZXJ0aWNhbEVkZ2VzLnB1c2goLi4udGhpcy4jYnJlYWtFZGdlKGVkZ2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2dldE91dGxpbmVzKG91dGxpbmVWZXJ0aWNhbEVkZ2VzKTtcbiAgfVxuICAjZ2V0T3V0bGluZXMob3V0bGluZVZlcnRpY2FsRWRnZXMpIHtcbiAgICBjb25zdCBlZGdlcyA9IFtdO1xuICAgIGNvbnN0IGFsbEVkZ2VzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBvdXRsaW5lVmVydGljYWxFZGdlcykge1xuICAgICAgY29uc3QgW3gsIHkxLCB5Ml0gPSBlZGdlO1xuICAgICAgZWRnZXMucHVzaChbeCwgeTEsIGVkZ2VdLCBbeCwgeTIsIGVkZ2VdKTtcbiAgICB9XG4gICAgZWRnZXMuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0gfHwgYVswXSAtIGJbMF0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVkZ2VzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGVkZ2UxID0gZWRnZXNbaV1bMl07XG4gICAgICBjb25zdCBlZGdlMiA9IGVkZ2VzW2kgKyAxXVsyXTtcbiAgICAgIGVkZ2UxLnB1c2goZWRnZTIpO1xuICAgICAgZWRnZTIucHVzaChlZGdlMSk7XG4gICAgICBhbGxFZGdlcy5hZGQoZWRnZTEpO1xuICAgICAgYWxsRWRnZXMuYWRkKGVkZ2UyKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICBsZXQgb3V0bGluZTtcbiAgICB3aGlsZSAoYWxsRWRnZXMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IGVkZ2UgPSBhbGxFZGdlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICBsZXQgW3gsIHkxLCB5MiwgZWRnZTEsIGVkZ2UyXSA9IGVkZ2U7XG4gICAgICBhbGxFZGdlcy5kZWxldGUoZWRnZSk7XG4gICAgICBsZXQgbGFzdFBvaW50WCA9IHg7XG4gICAgICBsZXQgbGFzdFBvaW50WSA9IHkxO1xuICAgICAgb3V0bGluZSA9IFt4LCB5Ml07XG4gICAgICBvdXRsaW5lcy5wdXNoKG91dGxpbmUpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGlmIChhbGxFZGdlcy5oYXMoZWRnZTEpKSB7XG4gICAgICAgICAgZSA9IGVkZ2UxO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbEVkZ2VzLmhhcyhlZGdlMikpIHtcbiAgICAgICAgICBlID0gZWRnZTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYWxsRWRnZXMuZGVsZXRlKGUpO1xuICAgICAgICBbeCwgeTEsIHkyLCBlZGdlMSwgZWRnZTJdID0gZTtcbiAgICAgICAgaWYgKGxhc3RQb2ludFggIT09IHgpIHtcbiAgICAgICAgICBvdXRsaW5lLnB1c2gobGFzdFBvaW50WCwgbGFzdFBvaW50WSwgeCwgbGFzdFBvaW50WSA9PT0geTEgPyB5MSA6IHkyKTtcbiAgICAgICAgICBsYXN0UG9pbnRYID0geDtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UG9pbnRZID0gbGFzdFBvaW50WSA9PT0geTEgPyB5MiA6IHkxO1xuICAgICAgfVxuICAgICAgb3V0bGluZS5wdXNoKGxhc3RQb2ludFgsIGxhc3RQb2ludFkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEhpZ2hsaWdodE91dGxpbmUob3V0bGluZXMsIHRoaXMuI2JveCwgdGhpcy4jbGFzdFBvaW50KTtcbiAgfVxuICAjYmluYXJ5U2VhcmNoKHkpIHtcbiAgICBjb25zdCBhcnJheSA9IHRoaXMuI2ludGVydmFscztcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0ICsgZW5kID4+IDE7XG4gICAgICBjb25zdCB5MSA9IGFycmF5W21pZGRsZV1bMF07XG4gICAgICBpZiAoeTEgPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICAgIH1cbiAgICAgIGlmICh5MSA8IHkpIHtcbiAgICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gbWlkZGxlIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZCArIDE7XG4gIH1cbiAgI2luc2VydChbLCB5MSwgeTJdKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTEpO1xuICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaW5kZXgsIDAsIFt5MSwgeTJdKTtcbiAgfVxuICAjcmVtb3ZlKFssIHkxLCB5Ml0pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuI2JpbmFyeVNlYXJjaCh5MSk7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgdGhpcy4jaW50ZXJ2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSB0aGlzLiNpbnRlcnZhbHNbaV07XG4gICAgICBpZiAoc3RhcnQgIT09IHkxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSB5MSAmJiBlbmQgPT09IHkyKSB7XG4gICAgICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRoaXMuI2ludGVydmFsc1tpXTtcbiAgICAgIGlmIChzdGFydCAhPT0geTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPT09IHkxICYmIGVuZCA9PT0geTIpIHtcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWxzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjYnJlYWtFZGdlKGVkZ2UpIHtcbiAgICBjb25zdCBbeCwgeTEsIHkyXSA9IGVkZ2U7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtbeCwgeTEsIHkyXV07XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdGhpcy4jaW50ZXJ2YWxzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gcmVzdWx0cy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIGNvbnN0IFssIHkzLCB5NF0gPSByZXN1bHRzW2pdO1xuICAgICAgICBpZiAoZW5kIDw9IHkzIHx8IHk0IDw9IHN0YXJ0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkzID49IHN0YXJ0KSB7XG4gICAgICAgICAgaWYgKHk0ID4gZW5kKSB7XG4gICAgICAgICAgICByZXN1bHRzW2pdWzFdID0gZW5kO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoamogPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICBqai0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzW2pdWzJdID0gc3RhcnQ7XG4gICAgICAgIGlmICh5NCA+IGVuZCkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChbeCwgZW5kLCB5NF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59XG5jbGFzcyBIaWdobGlnaHRPdXRsaW5lIGV4dGVuZHMgT3V0bGluZSB7XG4gICNib3g7XG4gICNvdXRsaW5lcztcbiAgY29uc3RydWN0b3Iob3V0bGluZXMsIGJveCwgbGFzdFBvaW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNvdXRsaW5lcyA9IG91dGxpbmVzO1xuICAgIHRoaXMuI2JveCA9IGJveDtcbiAgICB0aGlzLmxhc3RQb2ludCA9IGxhc3RQb2ludDtcbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgZm9yIChjb25zdCBwb2x5Z29uIG9mIHRoaXMuI291dGxpbmVzKSB7XG4gICAgICBsZXQgW3ByZXZYLCBwcmV2WV0gPSBwb2x5Z29uO1xuICAgICAgYnVmZmVyLnB1c2goYE0ke3ByZXZYfSAke3ByZXZZfWApO1xuICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHggPSBwb2x5Z29uW2ldO1xuICAgICAgICBjb25zdCB5ID0gcG9seWdvbltpICsgMV07XG4gICAgICAgIGlmICh4ID09PSBwcmV2WCkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGBWJHt5fWApO1xuICAgICAgICAgIHByZXZZID0geTtcbiAgICAgICAgfSBlbHNlIGlmICh5ID09PSBwcmV2WSkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGBIJHt4fWApO1xuICAgICAgICAgIHByZXZYID0geDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShbYmxYLCBibFksIHRyWCwgdHJZXSwgX3JvdGF0aW9uKSB7XG4gICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICBjb25zdCB3aWR0aCA9IHRyWCAtIGJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSB0clkgLSBibFk7XG4gICAgZm9yIChjb25zdCBvdXRsaW5lIG9mIHRoaXMuI291dGxpbmVzKSB7XG4gICAgICBjb25zdCBwb2ludHMgPSBuZXcgQXJyYXkob3V0bGluZS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRsaW5lLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHBvaW50c1tpXSA9IGJsWCArIG91dGxpbmVbaV0gKiB3aWR0aDtcbiAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWSAtIG91dGxpbmVbaSArIDFdICogaGVpZ2h0O1xuICAgICAgfVxuICAgICAgb3V0bGluZXMucHVzaChwb2ludHMpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0bGluZXM7XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYm94O1xuICB9XG4gIGdldCBjbGFzc05hbWVzRm9yT3V0bGluaW5nKCkge1xuICAgIHJldHVybiBbXCJoaWdobGlnaHRPdXRsaW5lXCJdO1xuICB9XG59XG5jbGFzcyBGcmVlSGlnaGxpZ2h0T3V0bGluZXIgZXh0ZW5kcyBGcmVlRHJhd091dGxpbmVyIHtcbiAgbmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlSGlnaGxpZ2h0T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUik7XG4gIH1cbn1cbmNsYXNzIEZyZWVIaWdobGlnaHRPdXRsaW5lIGV4dGVuZHMgRnJlZURyYXdPdXRsaW5lIHtcbiAgbmV3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luID0gMCkge1xuICAgIHJldHVybiBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2hpZ2hsaWdodC5qc1xuXG5cblxuXG5cblxuXG5jbGFzcyBIaWdobGlnaHRFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2FuY2hvck5vZGUgPSBudWxsO1xuICAjYW5jaG9yT2Zmc2V0ID0gMDtcbiAgI2JveGVzO1xuICAjY2xpcFBhdGhJZCA9IG51bGw7XG4gICNjb2xvclBpY2tlciA9IG51bGw7XG4gICNmb2N1c091dGxpbmVzID0gbnVsbDtcbiAgI2ZvY3VzTm9kZSA9IG51bGw7XG4gICNmb2N1c09mZnNldCA9IDA7XG4gICNoaWdobGlnaHREaXYgPSBudWxsO1xuICAjaGlnaGxpZ2h0T3V0bGluZXMgPSBudWxsO1xuICAjaWQgPSBudWxsO1xuICAjaXNGcmVlSGlnaGxpZ2h0ID0gZmFsc2U7XG4gICNsYXN0UG9pbnQgPSBudWxsO1xuICAjb3BhY2l0eTtcbiAgI291dGxpbmVJZCA9IG51bGw7XG4gICN0ZXh0ID0gXCJcIjtcbiAgI3RoaWNrbmVzcztcbiAgI21ldGhvZE9mQ3JlYXRpb24gPSBcIlwiO1xuICBzdGF0aWMgX2RlZmF1bHRDb2xvciA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdE9wYWNpdHkgPSAxO1xuICBzdGF0aWMgX2RlZmF1bHRUaGlja25lc3MgPSAxMjtcbiAgc3RhdGljIF90eXBlID0gXCJoaWdobGlnaHRcIjtcbiAgc3RhdGljIF9lZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUO1xuICBzdGF0aWMgX2ZyZWVIaWdobGlnaHRJZCA9IC0xO1xuICBzdGF0aWMgX2ZyZWVIaWdobGlnaHQgPSBudWxsO1xuICBzdGF0aWMgX2ZyZWVIaWdobGlnaHRDbGlwSWQgPSBcIlwiO1xuICBzdGF0aWMgZ2V0IF9rZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcHJvdG8gPSBIaWdobGlnaHRFZGl0b3IucHJvdG90eXBlO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBwcm90by5fbW92ZUNhcmV0LCB7XG4gICAgICBhcmdzOiBbMF1cbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8uX21vdmVDYXJldCwge1xuICAgICAgYXJnczogWzFdXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFsyXVxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcHJvdG8uX21vdmVDYXJldCwge1xuICAgICAgYXJnczogWzNdXG4gICAgfV1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJoaWdobGlnaHRFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuY29sb3IgPSBwYXJhbXMuY29sb3IgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3I7XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gcGFyYW1zLnRoaWNrbmVzcyB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRUaGlja25lc3M7XG4gICAgdGhpcy4jb3BhY2l0eSA9IHBhcmFtcy5vcGFjaXR5IHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdE9wYWNpdHk7XG4gICAgdGhpcy4jYm94ZXMgPSBwYXJhbXMuYm94ZXMgfHwgbnVsbDtcbiAgICB0aGlzLiNtZXRob2RPZkNyZWF0aW9uID0gcGFyYW1zLm1ldGhvZE9mQ3JlYXRpb24gfHwgXCJcIjtcbiAgICB0aGlzLiN0ZXh0ID0gcGFyYW1zLnRleHQgfHwgXCJcIjtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGVmYXVsdEwxMG5JZCA9IFwicGRmanMtZWRpdG9yLWhpZ2hsaWdodC1lZGl0b3JcIjtcbiAgICBpZiAocGFyYW1zLmhpZ2hsaWdodElkID4gLTEpIHtcbiAgICAgIHRoaXMuI2lzRnJlZUhpZ2hsaWdodCA9IHRydWU7XG4gICAgICB0aGlzLiNjcmVhdGVGcmVlT3V0bGluZXMocGFyYW1zKTtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNib3hlcykge1xuICAgICAgdGhpcy4jYW5jaG9yTm9kZSA9IHBhcmFtcy5hbmNob3JOb2RlO1xuICAgICAgdGhpcy4jYW5jaG9yT2Zmc2V0ID0gcGFyYW1zLmFuY2hvck9mZnNldDtcbiAgICAgIHRoaXMuI2ZvY3VzTm9kZSA9IHBhcmFtcy5mb2N1c05vZGU7XG4gICAgICB0aGlzLiNmb2N1c09mZnNldCA9IHBhcmFtcy5mb2N1c09mZnNldDtcbiAgICAgIHRoaXMuI2NyZWF0ZU91dGxpbmVzKCk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgICAgdGhpcy5yb3RhdGUodGhpcy5yb3RhdGlvbik7XG4gICAgfVxuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYTExeUFsZXJ0KFwicGRmanMtZWRpdG9yLWhpZ2hsaWdodC1hZGRlZC1hbGVydFwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUluaXRpYWxEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246IFwiYWRkZWRcIixcbiAgICAgIHR5cGU6IHRoaXMuI2lzRnJlZUhpZ2hsaWdodCA/IFwiZnJlZV9oaWdobGlnaHRcIiA6IFwiaGlnaGxpZ2h0XCIsXG4gICAgICBjb2xvcjogdGhpcy5fdWlNYW5hZ2VyLmdldE5vbkhDTUNvbG9yTmFtZSh0aGlzLmNvbG9yKSxcbiAgICAgIHRoaWNrbmVzczogdGhpcy4jdGhpY2tuZXNzLFxuICAgICAgbWV0aG9kT2ZDcmVhdGlvbjogdGhpcy4jbWV0aG9kT2ZDcmVhdGlvblxuICAgIH07XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJoaWdobGlnaHRcIixcbiAgICAgIGNvbG9yOiB0aGlzLl91aU1hbmFnZXIuZ2V0Tm9uSENNQ29sb3JOYW1lKHRoaXMuY29sb3IpXG4gICAgfTtcbiAgfVxuICBnZXQgY29tbWVudENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yO1xuICB9XG4gIHN0YXRpYyBjb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyT2ZDb2xvcnM6IGRhdGEuZ2V0KFwiY29sb3JcIikuc2l6ZVxuICAgIH07XG4gIH1cbiAgI2NyZWF0ZU91dGxpbmVzKCkge1xuICAgIGNvbnN0IG91dGxpbmVyID0gbmV3IEhpZ2hsaWdodE91dGxpbmVyKHRoaXMuI2JveGVzLCAwLjAwMSk7XG4gICAgdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMgPSBvdXRsaW5lci5nZXRPdXRsaW5lcygpO1xuICAgIFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdID0gdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuYm94O1xuICAgIGNvbnN0IG91dGxpbmVyRm9yT3V0bGluZSA9IG5ldyBIaWdobGlnaHRPdXRsaW5lcih0aGlzLiNib3hlcywgMC4wMDI1LCAwLjAwMSwgdGhpcy5fdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIik7XG4gICAgdGhpcy4jZm9jdXNPdXRsaW5lcyA9IG91dGxpbmVyRm9yT3V0bGluZS5nZXRPdXRsaW5lcygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RQb2ludFxuICAgIH0gPSB0aGlzLiNmb2N1c091dGxpbmVzO1xuICAgIHRoaXMuI2xhc3RQb2ludCA9IFsobGFzdFBvaW50WzBdIC0gdGhpcy54KSAvIHRoaXMud2lkdGgsIChsYXN0UG9pbnRbMV0gLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHRdO1xuICB9XG4gICNjcmVhdGVGcmVlT3V0bGluZXMoe1xuICAgIGhpZ2hsaWdodE91dGxpbmVzLFxuICAgIGhpZ2hsaWdodElkLFxuICAgIGNsaXBQYXRoSWRcbiAgfSkge1xuICAgIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzID0gaGlnaGxpZ2h0T3V0bGluZXM7XG4gICAgY29uc3QgZXh0cmFUaGlja25lc3MgPSAxLjU7XG4gICAgdGhpcy4jZm9jdXNPdXRsaW5lcyA9IGhpZ2hsaWdodE91dGxpbmVzLmdldE5ld091dGxpbmUodGhpcy4jdGhpY2tuZXNzIC8gMiArIGV4dHJhVGhpY2tuZXNzLCAwLjAwMjUpO1xuICAgIGlmIChoaWdobGlnaHRJZCA+PSAwKSB7XG4gICAgICB0aGlzLiNpZCA9IGhpZ2hsaWdodElkO1xuICAgICAgdGhpcy4jY2xpcFBhdGhJZCA9IGNsaXBQYXRoSWQ7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIuZmluYWxpemVEcmF3KGhpZ2hsaWdodElkLCB7XG4gICAgICAgIGJib3g6IGhpZ2hsaWdodE91dGxpbmVzLmJveCxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IGhpZ2hsaWdodE91dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy4jb3V0bGluZUlkID0gdGhpcy5wYXJlbnQuZHJhd0xheWVyLmRyYXdPdXRsaW5lKHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlnaGxpZ2h0T3V0bGluZTogdHJ1ZSxcbiAgICAgICAgICBmcmVlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGJib3g6IHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy4jZm9jdXNPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBjb25zdCBhbmdsZSA9IHRoaXMucGFyZW50LnZpZXdwb3J0LnJvdGF0aW9uO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jaWQsIHtcbiAgICAgICAgYmJveDogSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveCwgKGFuZ2xlIC0gdGhpcy5yb3RhdGlvbiArIDM2MCkgJSAzNjApLFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogaGlnaGxpZ2h0T3V0bGluZXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgICAgYmJveDogSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LCBhbmdsZSksXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiB0aGlzLiNmb2N1c091dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSBoaWdobGlnaHRPdXRsaW5lcy5ib3g7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgICAgIHRoaXMueCA9IHk7XG4gICAgICAgICAgdGhpcy55ID0gMSAtIHg7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcGFnZUhlaWdodCAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB0aGlzLnggPSAxIC0geDtcbiAgICAgICAgdGhpcy55ID0gMSAtIHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgICB0aGlzLnggPSAxIC0geTtcbiAgICAgICAgICB0aGlzLnkgPSB4O1xuICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiBwYWdlV2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RQb2ludFxuICAgIH0gPSB0aGlzLiNmb2N1c091dGxpbmVzO1xuICAgIHRoaXMuI2xhc3RQb2ludCA9IFsobGFzdFBvaW50WzBdIC0geCkgLyB3aWR0aCwgKGxhc3RQb2ludFsxXSAtIHkpIC8gaGVpZ2h0XTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fD0gdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycz8udmFsdWVzKCkubmV4dCgpLnZhbHVlIHx8IFwiI2ZmZjA2NlwiO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUjpcbiAgICAgICAgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1M6XG4gICAgICAgIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzcyA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdHJhbnNsYXRlSW5QYWdlKHgsIHkpIHt9XG4gIGdldCB0b29sYmFyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xhc3RQb2ludDtcbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SOlxuICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTOlxuICAgICAgICB0aGlzLiN1cGRhdGVUaGlja25lc3ModmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUiwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3JdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1RISUNLTkVTUywgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzXV07XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1IsIHRoaXMuY29sb3IgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3JdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1RISUNLTkVTUywgdGhpcy4jdGhpY2tuZXNzIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzc10sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfRlJFRSwgdGhpcy4jaXNGcmVlSGlnaGxpZ2h0XV07XG4gIH1cbiAgI3VwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgY29uc3Qgc2V0Q29sb3JBbmRPcGFjaXR5ID0gKGNvbCwgb3BhKSA9PiB7XG4gICAgICB0aGlzLmNvbG9yID0gY29sO1xuICAgICAgdGhpcy4jb3BhY2l0eSA9IG9wYTtcbiAgICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNpZCwge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgZmlsbDogY29sLFxuICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IG9wYVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuI2NvbG9yUGlja2VyPy51cGRhdGVDb2xvcihjb2wpO1xuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgY29uc3Qgc2F2ZWRPcGFjaXR5ID0gdGhpcy4jb3BhY2l0eTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0Q29sb3JBbmRPcGFjaXR5LmJpbmQodGhpcywgY29sb3IsIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdE9wYWNpdHkpLFxuICAgICAgdW5kbzogc2V0Q29sb3JBbmRPcGFjaXR5LmJpbmQodGhpcywgc2F2ZWRDb2xvciwgc2F2ZWRPcGFjaXR5KSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUixcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiY29sb3JfY2hhbmdlZFwiLFxuICAgICAgY29sb3I6IHRoaXMuX3VpTWFuYWdlci5nZXROb25IQ01Db2xvck5hbWUoY29sb3IpXG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgI3VwZGF0ZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBjb25zdCBzYXZlZFRoaWNrbmVzcyA9IHRoaXMuI3RoaWNrbmVzcztcbiAgICBjb25zdCBzZXRUaGlja25lc3MgPSB0aCA9PiB7XG4gICAgICB0aGlzLiN0aGlja25lc3MgPSB0aDtcbiAgICAgIHRoaXMuI2NoYW5nZVRoaWNrbmVzcyh0aCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0VGhpY2tuZXNzLmJpbmQodGhpcywgdGhpY2tuZXNzKSxcbiAgICAgIHVuZG86IHNldFRoaWNrbmVzcy5iaW5kKHRoaXMsIHNhdmVkVGhpY2tuZXNzKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1MsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcInRoaWNrbmVzc19jaGFuZ2VkXCIsXG4gICAgICB0aGlja25lc3NcbiAgICB9LCB0cnVlKTtcbiAgfVxuICBnZXQgdG9vbGJhckJ1dHRvbnMoKSB7XG4gICAgaWYgKHRoaXMuX3VpTWFuYWdlci5oaWdobGlnaHRDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGNvbG9yUGlja2VyID0gdGhpcy4jY29sb3JQaWNrZXIgPSBuZXcgQ29sb3JQaWNrZXIoe1xuICAgICAgICBlZGl0b3I6IHRoaXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtbXCJjb2xvclBpY2tlclwiLCBjb2xvclBpY2tlcl1dO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIudG9vbGJhckJ1dHRvbnM7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICBzdXBlci5lbmFibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIGZhbHNlKTtcbiAgfVxuICBmaXhBbmRTZXRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gc3VwZXIuZml4QW5kU2V0UG9zaXRpb24odGhpcy4jZ2V0Um90YXRpb24oKSk7XG4gIH1cbiAgZ2V0QmFzZVRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgZ2V0UmVjdCh0eCwgdHkpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0UmVjdCh0eCwgdHksIHRoaXMuI2dldFJvdGF0aW9uKCkpO1xuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGRVbmRvYWJsZUVkaXRvcih0aGlzKTtcbiAgICB9XG4gICAgaWYgKGZvY3VzKSB7XG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgIH1cbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcImRlbGV0ZWRcIlxuICAgIH0pO1xuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgbGV0IG11c3RCZVNlbGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmICFwYXJlbnQpIHtcbiAgICAgIHRoaXMuI2NsZWFuRHJhd0xheWVyKCk7XG4gICAgfSBlbHNlIGlmIChwYXJlbnQpIHtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKHBhcmVudCk7XG4gICAgICBtdXN0QmVTZWxlY3RlZCA9ICF0aGlzLnBhcmVudCAmJiB0aGlzLmRpdj8uY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgfVxuICAgIHN1cGVyLnNldFBhcmVudChwYXJlbnQpO1xuICAgIHRoaXMuc2hvdyh0aGlzLl9pc1Zpc2libGUpO1xuICAgIGlmIChtdXN0QmVTZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZWxlY3QoKTtcbiAgICB9XG4gIH1cbiAgI2NoYW5nZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBpZiAoIXRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjcmVhdGVGcmVlT3V0bGluZXMoe1xuICAgICAgaGlnaGxpZ2h0T3V0bGluZXM6IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmdldE5ld091dGxpbmUodGhpY2tuZXNzIC8gMilcbiAgICB9KTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0RGltcyh0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgfVxuICAjY2xlYW5EcmF3TGF5ZXIoKSB7XG4gICAgaWYgKHRoaXMuI2lkID09PSBudWxsIHx8ICF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuI2lkKTtcbiAgICB0aGlzLiNpZCA9IG51bGw7XG4gICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnJlbW92ZSh0aGlzLiNvdXRsaW5lSWQpO1xuICAgIHRoaXMuI291dGxpbmVJZCA9IG51bGw7XG4gIH1cbiAgI2FkZFRvRHJhd0xheWVyKHBhcmVudCA9IHRoaXMucGFyZW50KSB7XG4gICAgaWYgKHRoaXMuI2lkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICh7XG4gICAgICBpZDogdGhpcy4jaWQsXG4gICAgICBjbGlwUGF0aElkOiB0aGlzLiNjbGlwUGF0aElkXG4gICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh7XG4gICAgICBiYm94OiB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3gsXG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDEgMVwiLFxuICAgICAgICBmaWxsOiB0aGlzLmNvbG9yLFxuICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiB0aGlzLiNvcGFjaXR5XG4gICAgICB9LFxuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGhpZ2hsaWdodDogdHJ1ZSxcbiAgICAgICAgZnJlZTogdGhpcy4jaXNGcmVlSGlnaGxpZ2h0XG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH0sIGZhbHNlLCB0cnVlKSk7XG4gICAgdGhpcy4jb3V0bGluZUlkID0gcGFyZW50LmRyYXdMYXllci5kcmF3T3V0bGluZSh7XG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgaGlnaGxpZ2h0T3V0bGluZTogdHJ1ZSxcbiAgICAgICAgZnJlZTogdGhpcy4jaXNGcmVlSGlnaGxpZ2h0XG4gICAgICB9LFxuICAgICAgYmJveDogdGhpcy4jZm9jdXNPdXRsaW5lcy5ib3gsXG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMuI2ZvY3VzT3V0bGluZXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9LCB0aGlzLiNpc0ZyZWVIaWdobGlnaHQpO1xuICAgIGlmICh0aGlzLiNoaWdobGlnaHREaXYpIHtcbiAgICAgIHRoaXMuI2hpZ2hsaWdodERpdi5zdHlsZS5jbGlwUGF0aCA9IHRoaXMuI2NsaXBQYXRoSWQ7XG4gICAgfVxuICB9XG4gIHN0YXRpYyAjcm90YXRlQmJveChbeCwgeSwgd2lkdGgsIGhlaWdodF0sIGFuZ2xlKSB7XG4gICAgc3dpdGNoIChhbmdsZSkge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSAtIGhlaWdodCwgeCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCAtIHdpZHRoLCAxIC0geSAtIGhlaWdodCwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geCAtIHdpZHRoLCBoZWlnaHQsIHdpZHRoXTtcbiAgICB9XG4gICAgcmV0dXJuIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgfVxuICByb3RhdGUoYW5nbGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBkcmF3TGF5ZXJcbiAgICB9ID0gdGhpcy5wYXJlbnQ7XG4gICAgbGV0IGJveDtcbiAgICBpZiAodGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICBhbmdsZSA9IChhbmdsZSAtIHRoaXMucm90YXRpb24gKyAzNjApICUgMzYwO1xuICAgICAgYm94ID0gSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveCwgYW5nbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3ggPSBIaWdobGlnaHRFZGl0b3IuI3JvdGF0ZUJib3goW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF0sIGFuZ2xlKTtcbiAgICB9XG4gICAgZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jaWQsIHtcbiAgICAgIGJib3g6IGJveCxcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgXCJkYXRhLW1haW4tcm90YXRpb25cIjogYW5nbGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgIGJib3g6IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNmb2N1c091dGxpbmVzLmJveCwgYW5nbGUpLFxuICAgICAgcm9vdDoge1xuICAgICAgICBcImRhdGEtbWFpbi1yb3RhdGlvblwiOiBhbmdsZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgY29uc3QgZGl2ID0gc3VwZXIucmVuZGVyKCk7XG4gICAgaWYgKHRoaXMuI3RleHQpIHtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMuI3RleHQpO1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJtYXJrXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZChcImZyZWVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2tleWRvd24uYmluZCh0aGlzKSwge1xuICAgICAgICBzaWduYWw6IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgaGlnaGxpZ2h0RGl2ID0gdGhpcy4jaGlnaGxpZ2h0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuYXBwZW5kKGhpZ2hsaWdodERpdik7XG4gICAgaGlnaGxpZ2h0RGl2LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICBoaWdobGlnaHREaXYuY2xhc3NOYW1lID0gXCJpbnRlcm5hbFwiO1xuICAgIGhpZ2hsaWdodERpdi5zdHlsZS5jbGlwUGF0aCA9IHRoaXMuI2NsaXBQYXRoSWQ7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0RGltcyh0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICBiaW5kRXZlbnRzKHRoaXMsIHRoaXMuI2hpZ2hsaWdodERpdiwgW1wicG9pbnRlcm92ZXJcIiwgXCJwb2ludGVybGVhdmVcIl0pO1xuICAgIHRoaXMuZW5hYmxlRWRpdGluZygpO1xuICAgIHJldHVybiBkaXY7XG4gIH1cbiAgcG9pbnRlcm92ZXIoKSB7XG4gICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaG92ZXJlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcG9pbnRlcmxlYXZlKCkge1xuICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKSB7XG4gICAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhvdmVyZWQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAja2V5ZG93bihldmVudCkge1xuICAgIEhpZ2hsaWdodEVkaXRvci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gIF9tb3ZlQ2FyZXQoZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5wYXJlbnQudW5zZWxlY3QodGhpcyk7XG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdGhpcy4jc2V0Q2FyZXQodHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgY2FzZSAzOlxuICAgICAgICB0aGlzLiNzZXRDYXJldChmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAjc2V0Q2FyZXQoc3RhcnQpIHtcbiAgICBpZiAoIXRoaXMuI2FuY2hvck5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgc2VsZWN0aW9uLnNldFBvc2l0aW9uKHRoaXMuI2FuY2hvck5vZGUsIHRoaXMuI2FuY2hvck9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi5zZXRQb3NpdGlvbih0aGlzLiNmb2N1c05vZGUsIHRoaXMuI2ZvY3VzT2Zmc2V0KTtcbiAgICB9XG4gIH1cbiAgc2VsZWN0KCkge1xuICAgIHN1cGVyLnNlbGVjdCgpO1xuICAgIGlmICghdGhpcy4jb3V0bGluZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBob3ZlcmVkOiBmYWxzZSxcbiAgICAgICAgc2VsZWN0ZWQ6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1bnNlbGVjdCgpIHtcbiAgICBzdXBlci51bnNlbGVjdCgpO1xuICAgIGlmICghdGhpcy4jb3V0bGluZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBzZWxlY3RlZDogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgdGhpcy4jc2V0Q2FyZXQoZmFsc2UpO1xuICAgIH1cbiAgfVxuICBnZXQgX211c3RGaXhQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMuI2lzRnJlZUhpZ2hsaWdodDtcbiAgfVxuICBzaG93KHZpc2libGUgPSB0aGlzLl9pc1Zpc2libGUpIHtcbiAgICBzdXBlci5zaG93KHZpc2libGUpO1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jaWQsIHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlkZGVuOiAhdmlzaWJsZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgICBoaWRkZW46ICF2aXNpYmxlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAjZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzRnJlZUhpZ2hsaWdodCA/IHRoaXMucm90YXRpb24gOiAwO1xuICB9XG4gICNzZXJpYWxpemVCb3hlcygpIHtcbiAgICBpZiAodGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgY29uc3QgYm94ZXMgPSB0aGlzLiNib3hlcztcbiAgICBjb25zdCBxdWFkUG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShib3hlcy5sZW5ndGggKiA4KTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSBvZiBib3hlcykge1xuICAgICAgY29uc3Qgc3ggPSB4ICogcGFnZVdpZHRoICsgcGFnZVg7XG4gICAgICBjb25zdCBzeSA9ICgxIC0geSkgKiBwYWdlSGVpZ2h0ICsgcGFnZVk7XG4gICAgICBxdWFkUG9pbnRzW2ldID0gcXVhZFBvaW50c1tpICsgNF0gPSBzeDtcbiAgICAgIHF1YWRQb2ludHNbaSArIDFdID0gcXVhZFBvaW50c1tpICsgM10gPSBzeTtcbiAgICAgIHF1YWRQb2ludHNbaSArIDJdID0gcXVhZFBvaW50c1tpICsgNl0gPSBzeCArIHdpZHRoICogcGFnZVdpZHRoO1xuICAgICAgcXVhZFBvaW50c1tpICsgNV0gPSBxdWFkUG9pbnRzW2kgKyA3XSA9IHN5IC0gaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICAgIGkgKz0gODtcbiAgICB9XG4gICAgcmV0dXJuIHF1YWRQb2ludHM7XG4gIH1cbiAgI3NlcmlhbGl6ZU91dGxpbmVzKHJlY3QpIHtcbiAgICByZXR1cm4gdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuc2VyaWFsaXplKHJlY3QsIHRoaXMuI2dldFJvdGF0aW9uKCkpO1xuICB9XG4gIHN0YXRpYyBzdGFydEhpZ2hsaWdodGluZyhwYXJlbnQsIGlzTFRSLCB7XG4gICAgdGFyZ2V0OiB0ZXh0TGF5ZXIsXG4gICAgeCxcbiAgICB5XG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICB4OiBsYXllclgsXG4gICAgICB5OiBsYXllclksXG4gICAgICB3aWR0aDogcGFyZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhcmVudEhlaWdodFxuICAgIH0gPSB0ZXh0TGF5ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gcGFyZW50LmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9IGUgPT4ge1xuICAgICAgYWMuYWJvcnQoKTtcbiAgICAgIHRoaXMuI2VuZEhpZ2hsaWdodChwYXJlbnQsIGUpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBzdG9wRXZlbnQsIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGV4dExheWVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLiNoaWdobGlnaHRNb3ZlLmJpbmQodGhpcywgcGFyZW50KSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodCA9IG5ldyBGcmVlSGlnaGxpZ2h0T3V0bGluZXIoe1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9LCBbbGF5ZXJYLCBsYXllclksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdLCBwYXJlbnQuc2NhbGUsIHRoaXMuX2RlZmF1bHRUaGlja25lc3MgLyAyLCBpc0xUUiwgMC4wMDEpO1xuICAgICh7XG4gICAgICBpZDogdGhpcy5fZnJlZUhpZ2hsaWdodElkLFxuICAgICAgY2xpcFBhdGhJZDogdGhpcy5fZnJlZUhpZ2hsaWdodENsaXBJZFxuICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcoe1xuICAgICAgYmJveDogWzAsIDAsIDEsIDFdLFxuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiBcIjAgMCAxIDFcIixcbiAgICAgICAgZmlsbDogdGhpcy5fZGVmYXVsdENvbG9yLFxuICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiB0aGlzLl9kZWZhdWx0T3BhY2l0eVxuICAgICAgfSxcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBoaWdobGlnaHQ6IHRydWUsXG4gICAgICAgIGZyZWU6IHRydWVcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMuX2ZyZWVIaWdobGlnaHQudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9LCB0cnVlLCB0cnVlKSk7XG4gIH1cbiAgc3RhdGljICNoaWdobGlnaHRNb3ZlKHBhcmVudCwgZXZlbnQpIHtcbiAgICBpZiAodGhpcy5fZnJlZUhpZ2hsaWdodC5hZGQoZXZlbnQpKSB7XG4gICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZnJlZUhpZ2hsaWdodElkLCB7XG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0LnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgI2VuZEhpZ2hsaWdodChwYXJlbnQsIGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mcmVlSGlnaGxpZ2h0LmlzRW1wdHkoKSkge1xuICAgICAgcGFyZW50LmNyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgZmFsc2UsIHtcbiAgICAgICAgaGlnaGxpZ2h0SWQ6IHRoaXMuX2ZyZWVIaWdobGlnaHRJZCxcbiAgICAgICAgaGlnaGxpZ2h0T3V0bGluZXM6IHRoaXMuX2ZyZWVIaWdobGlnaHQuZ2V0T3V0bGluZXMoKSxcbiAgICAgICAgY2xpcFBhdGhJZDogdGhpcy5fZnJlZUhpZ2hsaWdodENsaXBJZCxcbiAgICAgICAgbWV0aG9kT2ZDcmVhdGlvbjogXCJtYWluX3Rvb2xiYXJcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuX2ZyZWVIaWdobGlnaHRJZCk7XG4gICAgfVxuICAgIHRoaXMuX2ZyZWVIaWdobGlnaHRJZCA9IC0xO1xuICAgIHRoaXMuX2ZyZWVIaWdobGlnaHQgPSBudWxsO1xuICAgIHRoaXMuX2ZyZWVIaWdobGlnaHRDbGlwSWQgPSBcIlwiO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGxldCBpbml0aWFsRGF0YSA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcXVhZFBvaW50cyxcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgY29udGVudHNPYmpcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGNvbG9yKSxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgcXVhZFBvaW50cyxcbiAgICAgICAgYm94ZXM6IG51bGwsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBpZCxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgY29tbWVudDogY29udGVudHNPYmo/LnN0ciB8fCBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIElua0Fubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpbmtMaXN0cyxcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIGJvcmRlclN0eWxlOiB7XG4gICAgICAgICAgICByYXdXaWR0aDogdGhpY2tuZXNzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgICBjb250ZW50c09ialxuICAgICAgICB9LFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCxcbiAgICAgICAgY29sb3I6IEFycmF5LmZyb20oY29sb3IpLFxuICAgICAgICB0aGlja25lc3MsXG4gICAgICAgIGlua0xpc3RzLFxuICAgICAgICBib3hlczogbnVsbCxcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGFubm90YXRpb25FbGVtZW50SWQ6IGlkLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIHBvcHVwUmVmLFxuICAgICAgICBjb21tZW50OiBjb250ZW50c09iaj8uc3RyIHx8IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbG9yLFxuICAgICAgcXVhZFBvaW50cyxcbiAgICAgIGlua0xpc3RzLFxuICAgICAgb3BhY2l0eVxuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuY29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5jb2xvcik7XG4gICAgZWRpdG9yLiNvcGFjaXR5ID0gb3BhY2l0eSB8fCAxO1xuICAgIGlmIChpbmtMaXN0cykge1xuICAgICAgZWRpdG9yLiN0aGlja25lc3MgPSBkYXRhLnRoaWNrbmVzcztcbiAgICB9XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIGlmIChkYXRhLmNvbW1lbnQpIHtcbiAgICAgIGVkaXRvci5zZXRDb21tZW50RGF0YShkYXRhLmNvbW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IGVkaXRvci5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IGVkaXRvci5wYWdlVHJhbnNsYXRpb247XG4gICAgaWYgKHF1YWRQb2ludHMpIHtcbiAgICAgIGNvbnN0IGJveGVzID0gZWRpdG9yLiNib3hlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWFkUG9pbnRzLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgIGJveGVzLnB1c2goe1xuICAgICAgICAgIHg6IChxdWFkUG9pbnRzW2ldIC0gcGFnZVgpIC8gcGFnZVdpZHRoLFxuICAgICAgICAgIHk6IDEgLSAocXVhZFBvaW50c1tpICsgMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiAocXVhZFBvaW50c1tpICsgMl0gLSBxdWFkUG9pbnRzW2ldKSAvIHBhZ2VXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IChxdWFkUG9pbnRzW2kgKyAxXSAtIHF1YWRQb2ludHNbaSArIDVdKSAvIHBhZ2VIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlZGl0b3IuI2NyZWF0ZU91dGxpbmVzKCk7XG4gICAgICBlZGl0b3IuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgICBlZGl0b3Iucm90YXRlKGVkaXRvci5yb3RhdGlvbik7XG4gICAgfSBlbHNlIGlmIChpbmtMaXN0cykge1xuICAgICAgZWRpdG9yLiNpc0ZyZWVIaWdobGlnaHQgPSB0cnVlO1xuICAgICAgY29uc3QgcG9pbnRzID0gaW5rTGlzdHNbMF07XG4gICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogcG9pbnRzWzBdIC0gcGFnZVgsXG4gICAgICAgIHk6IHBhZ2VIZWlnaHQgLSAocG9pbnRzWzFdIC0gcGFnZVkpXG4gICAgICB9O1xuICAgICAgY29uc3Qgb3V0bGluZXIgPSBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmVyKHBvaW50LCBbMCwgMCwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSwgMSwgZWRpdG9yLiN0aGlja25lc3MgLyAyLCB0cnVlLCAwLjAwMSk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICBwb2ludC54ID0gcG9pbnRzW2ldIC0gcGFnZVg7XG4gICAgICAgIHBvaW50LnkgPSBwYWdlSGVpZ2h0IC0gKHBvaW50c1tpICsgMV0gLSBwYWdlWSk7XG4gICAgICAgIG91dGxpbmVyLmFkZChwb2ludCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkLFxuICAgICAgICBjbGlwUGF0aElkXG4gICAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHtcbiAgICAgICAgYmJveDogWzAsIDAsIDEsIDFdLFxuICAgICAgICByb290OiB7XG4gICAgICAgICAgdmlld0JveDogXCIwIDAgMSAxXCIsXG4gICAgICAgICAgZmlsbDogZWRpdG9yLmNvbG9yLFxuICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IGVkaXRvci5fZGVmYXVsdE9wYWNpdHlcbiAgICAgICAgfSxcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlnaGxpZ2h0OiB0cnVlLFxuICAgICAgICAgIGZyZWU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IG91dGxpbmVyLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0sIHRydWUsIHRydWUpO1xuICAgICAgZWRpdG9yLiNjcmVhdGVGcmVlT3V0bGluZXMoe1xuICAgICAgICBoaWdobGlnaHRPdXRsaW5lczogb3V0bGluZXIuZ2V0T3V0bGluZXMoKSxcbiAgICAgICAgaGlnaGxpZ2h0SWQ6IGlkLFxuICAgICAgICBjbGlwUGF0aElkXG4gICAgICB9KTtcbiAgICAgIGVkaXRvci4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICAgIGVkaXRvci5yb3RhdGUoZWRpdG9yLnBhcmVudFJvdGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkgfHwgaXNGb3JDb3B5aW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICAgIH1cbiAgICBjb25zdCByZWN0ID0gdGhpcy5nZXRQREZSZWN0KCk7XG4gICAgY29uc3QgY29sb3IgPSBBbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydCh0aGlzLl91aU1hbmFnZXIuZ2V0Tm9uSENNQ29sb3IodGhpcy5jb2xvcikpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULFxuICAgICAgY29sb3IsXG4gICAgICBvcGFjaXR5OiB0aGlzLiNvcGFjaXR5LFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLiN0aGlja25lc3MsXG4gICAgICBxdWFkUG9pbnRzOiB0aGlzLiNzZXJpYWxpemVCb3hlcygpLFxuICAgICAgb3V0bGluZXM6IHRoaXMuI3NlcmlhbGl6ZU91dGxpbmVzKHJlY3QpLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvbjogdGhpcy4jZ2V0Um90YXRpb24oKSxcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1lbnQoc2VyaWFsaXplZCk7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3JcbiAgICB9ID0gdGhpcy5faW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIHRoaXMuaGFzRWRpdGVkQ29tbWVudCB8fCBzZXJpYWxpemVkLmNvbG9yLnNvbWUoKGMsIGkpID0+IGMgIT09IGNvbG9yW2ldKTtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgYW5ub3RhdGlvbi5oaWRlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgcmVjdDogdGhpcy5nZXRQREZSZWN0KClcbiAgICB9O1xuICAgIGlmICh0aGlzLmhhc0VkaXRlZENvbW1lbnQpIHtcbiAgICAgIHBhcmFtcy5wb3B1cCA9IHRoaXMuY29tbWVudDtcbiAgICB9XG4gICAgYW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQocGFyYW1zKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGF0aWMgY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3LmpzXG5cblxuXG5jbGFzcyBEcmF3aW5nT3B0aW9ucyB7XG4gICNzdmdQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdXBkYXRlUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVTVkdQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgdXBkYXRlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKSkge1xuICAgICAgaWYgKCFuYW1lLnN0YXJ0c1dpdGgoXCJfXCIpKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1cGRhdGVTVkdQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuI3N2Z1Byb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuICB0b1NWR1Byb3BlcnRpZXMoKSB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI3N2Z1Byb3BlcnRpZXM7XG4gICAgdGhpcy4jc3ZnUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3RcbiAgICB9O1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuI3N2Z1Byb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIHVwZGF0ZUFsbChvcHRpb25zID0gdGhpcykge1xuICAgIHRoaXMudXBkYXRlUHJvcGVydGllcyhvcHRpb25zKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxufVxuY2xhc3MgRHJhd2luZ0VkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjZHJhd091dGxpbmVzID0gbnVsbDtcbiAgI211c3RCZUNvbW1pdHRlZDtcbiAgX2NvbG9yUGlja2VyID0gbnVsbDtcbiAgX2RyYXdJZCA9IG51bGw7XG4gIHN0YXRpYyBfY3VycmVudERyYXdJZCA9IC0xO1xuICBzdGF0aWMgX2N1cnJlbnRQYXJlbnQgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnREcmF3ID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50RHJhd2luZ0FDID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50RHJhd2luZ09wdGlvbnMgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnRQb2ludGVySWQgPSBOYU47XG4gIHN0YXRpYyAjY3VycmVudFBvaW50ZXJUeXBlID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50UG9pbnRlcklkcyA9IG51bGw7XG4gIHN0YXRpYyAjY3VycmVudE1vdmVUaW1lc3RhbXAgPSBOYU47XG4gIHN0YXRpYyBfSU5ORVJfTUFSR0lOID0gMztcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKTtcbiAgICB0aGlzLiNtdXN0QmVDb21taXR0ZWQgPSBwYXJhbXMubXVzdEJlQ29tbWl0dGVkIHx8IGZhbHNlO1xuICAgIHRoaXMuX2FkZE91dGxpbmVzKHBhcmFtcyk7XG4gIH1cbiAgX2FkZE91dGxpbmVzKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMuZHJhd091dGxpbmVzKSB7XG4gICAgICB0aGlzLiNjcmVhdGVEcmF3T3V0bGluZXMocGFyYW1zKTtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgfVxuICB9XG4gICNjcmVhdGVEcmF3T3V0bGluZXMoe1xuICAgIGRyYXdPdXRsaW5lcyxcbiAgICBkcmF3SWQsXG4gICAgZHJhd2luZ09wdGlvbnNcbiAgfSkge1xuICAgIHRoaXMuI2RyYXdPdXRsaW5lcyA9IGRyYXdPdXRsaW5lcztcbiAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucyB8fD0gZHJhd2luZ09wdGlvbnM7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5hMTF5QWxlcnQoYHBkZmpzLWVkaXRvci0ke3RoaXMuZWRpdG9yVHlwZX0tYWRkZWQtYWxlcnRgKTtcbiAgICB9XG4gICAgaWYgKGRyYXdJZCA+PSAwKSB7XG4gICAgICB0aGlzLl9kcmF3SWQgPSBkcmF3SWQ7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIuZmluYWxpemVEcmF3KGRyYXdJZCwgZHJhd091dGxpbmVzLmRlZmF1bHRQcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZHJhd0lkID0gdGhpcy4jY3JlYXRlRHJhd2luZyhkcmF3T3V0bGluZXMsIHRoaXMucGFyZW50KTtcbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlQmJveChkcmF3T3V0bGluZXMuYm94KTtcbiAgfVxuICAjY3JlYXRlRHJhd2luZyhkcmF3T3V0bGluZXMsIHBhcmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkXG4gICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyhEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy5fZHJhd2luZ09wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCksIGRyYXdPdXRsaW5lcy5kZWZhdWx0U1ZHUHJvcGVydGllcyksIGZhbHNlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIHN0YXRpYyBfbWVyZ2VTVkdQcm9wZXJ0aWVzKHAxLCBwMikge1xuICAgIGNvbnN0IHAxS2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMocDEpKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwMikpIHtcbiAgICAgIGlmIChwMUtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwMVtrZXldLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwMVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwMTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKF9vcHRpb25zKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlc01hcCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRHJhd2VyKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgY29uc3QgcHJvcGVydHlOYW1lID0gdGhpcy50eXBlc01hcC5nZXQodHlwZSk7XG4gICAgaWYgKHByb3BlcnR5TmFtZSkge1xuICAgICAgdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLnVwZGF0ZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY3VycmVudFBhcmVudCkge1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcudXBkYXRlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLl9jdXJyZW50UGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHRoaXMuY29uc3RydWN0b3IudHlwZXNNYXAuZ2V0KHR5cGUpO1xuICAgIGlmIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVByb3BlcnR5KHR5cGUsIHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IFtdO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnM7XG4gICAgZm9yIChjb25zdCBbdHlwZSwgbmFtZV0gb2YgdGhpcy50eXBlc01hcCkge1xuICAgICAgcHJvcGVydGllcy5wdXNoKFt0eXBlLCBvcHRpb25zW25hbWVdXSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IFtdO1xuICAgIGNvbnN0IHtcbiAgICAgIF9kcmF3aW5nT3B0aW9uc1xuICAgIH0gPSB0aGlzO1xuICAgIGZvciAoY29uc3QgW3R5cGUsIG5hbWVdIG9mIHRoaXMuY29uc3RydWN0b3IudHlwZXNNYXApIHtcbiAgICAgIHByb3BlcnRpZXMucHVzaChbdHlwZSwgX2RyYXdpbmdPcHRpb25zW25hbWVdXSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICB9XG4gIF91cGRhdGVQcm9wZXJ0eSh0eXBlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kcmF3aW5nT3B0aW9ucztcbiAgICBjb25zdCBzYXZlZFZhbHVlID0gb3B0aW9uc1tuYW1lXTtcbiAgICBjb25zdCBzZXR0ZXIgPSB2YWwgPT4ge1xuICAgICAgb3B0aW9ucy51cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgICAgY29uc3QgYmJveCA9IHRoaXMuI2RyYXdPdXRsaW5lcy51cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgICAgaWYgKGJib3gpIHtcbiAgICAgICAgdGhpcy4jdXBkYXRlQmJveChiYm94KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIG9wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCkpO1xuICAgICAgaWYgKHR5cGUgPT09IHRoaXMuY29sb3JUeXBlKSB7XG4gICAgICAgIHRoaXMuX2NvbG9yUGlja2VyPy51cGRhdGUodmFsKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXR0ZXIuYmluZCh0aGlzLCB2YWx1ZSksXG4gICAgICB1bmRvOiBzZXR0ZXIuYmluZCh0aGlzLCBzYXZlZFZhbHVlKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGUsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICBfb25SZXNpemluZygpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy4jZHJhd091dGxpbmVzLmdldFBhdGhSZXNpemluZ1NWR1Byb3BlcnRpZXModGhpcy4jY29udmVydFRvRHJhd1NwYWNlKCkpLCB7XG4gICAgICBiYm94OiB0aGlzLiNyb3RhdGVCb3goKVxuICAgIH0pKTtcbiAgfVxuICBfb25SZXNpemVkKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIERyYXdpbmdFZGl0b3IuX21lcmdlU1ZHUHJvcGVydGllcyh0aGlzLiNkcmF3T3V0bGluZXMuZ2V0UGF0aFJlc2l6ZWRTVkdQcm9wZXJ0aWVzKHRoaXMuI2NvbnZlcnRUb0RyYXdTcGFjZSgpKSwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KSk7XG4gIH1cbiAgX29uVHJhbnNsYXRpbmcoX3gsIF95KSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KTtcbiAgfVxuICBfb25UcmFuc2xhdGVkKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIERyYXdpbmdFZGl0b3IuX21lcmdlU1ZHUHJvcGVydGllcyh0aGlzLiNkcmF3T3V0bGluZXMuZ2V0UGF0aFRyYW5zbGF0ZWRTVkdQcm9wZXJ0aWVzKHRoaXMuI2NvbnZlcnRUb0RyYXdTcGFjZSgpLCB0aGlzLnBhcmVudERpbWVuc2lvbnMpLCB7XG4gICAgICBiYm94OiB0aGlzLiNyb3RhdGVCb3goKVxuICAgIH0pKTtcbiAgfVxuICBfb25TdGFydERyYWdnaW5nKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBtb3Zpbmc6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfb25TdG9wRHJhZ2dpbmcoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwge1xuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIG1vdmluZzogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb21taXQoKSB7XG4gICAgc3VwZXIuY29tbWl0KCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLmRpc2FibGVFZGl0aW5nKCk7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICBzdXBlci5lbmFibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIGZhbHNlKTtcbiAgfVxuICBnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZFVuZG9hYmxlRWRpdG9yKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgaWYgKHRoaXMuI211c3RCZUNvbW1pdHRlZCkge1xuICAgICAgdGhpcy4jbXVzdEJlQ29tbWl0dGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgICBpZiAoZm9jdXMgJiYgdGhpcy5pc09uU2NyZWVuKSB7XG4gICAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgdGhpcy4jdXBkYXRlQmJveCh0aGlzLiNkcmF3T3V0bGluZXMuYm94KTtcbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBsZXQgbXVzdEJlU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgIXBhcmVudCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlbW92ZVNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIH0gZWxzZSBpZiAocGFyZW50KSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYWRkU2hvdWxkUmVzY2FsZSh0aGlzKTtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKHBhcmVudCk7XG4gICAgICBtdXN0QmVTZWxlY3RlZCA9ICF0aGlzLnBhcmVudCAmJiB0aGlzLmRpdj8uY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgfVxuICAgIHN1cGVyLnNldFBhcmVudChwYXJlbnQpO1xuICAgIGlmIChtdXN0QmVTZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZWxlY3QoKTtcbiAgICB9XG4gIH1cbiAgI2NsZWFuRHJhd0xheWVyKCkge1xuICAgIGlmICh0aGlzLl9kcmF3SWQgPT09IG51bGwgfHwgIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy5fZHJhd0lkKTtcbiAgICB0aGlzLl9kcmF3SWQgPSBudWxsO1xuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zLnJlc2V0KCk7XG4gIH1cbiAgI2FkZFRvRHJhd0xheWVyKHBhcmVudCA9IHRoaXMucGFyZW50KSB7XG4gICAgaWYgKHRoaXMuX2RyYXdJZCAhPT0gbnVsbCAmJiB0aGlzLnBhcmVudCA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9kcmF3SWQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQYXJlbnQodGhpcy5fZHJhd0lkLCBwYXJlbnQuZHJhd0xheWVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZHJhd2luZ09wdGlvbnMudXBkYXRlQWxsKCk7XG4gICAgdGhpcy5fZHJhd0lkID0gdGhpcy4jY3JlYXRlRHJhd2luZyh0aGlzLiNkcmF3T3V0bGluZXMsIHBhcmVudCk7XG4gIH1cbiAgI2NvbnZlcnRUb1BhcmVudFNwYWNlKFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudERpbWVuc2lvbnM6IFtwVywgcEhdLFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gdGhpcztcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4LCB3aWR0aCAqIChwSCAvIHBXKSwgaGVpZ2h0ICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWzEgLSB4LCAxIC0geSwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeCwgd2lkdGggKiAocEggLyBwVyksIGhlaWdodCAqIChwVyAvIHBIKV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgIH1cbiAgfVxuICAjY29udmVydFRvRHJhd1NwYWNlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcFcsIHBIXSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeCwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHgsIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgI3VwZGF0ZUJib3goYmJveCkge1xuICAgIFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdID0gdGhpcy4jY29udmVydFRvUGFyZW50U3BhY2UoYmJveCk7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgfVxuICAgIHRoaXMuX29uUmVzaXplZCgpO1xuICB9XG4gICNyb3RhdGVCb3goKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcGFyZW50Um90YXRpb24sXG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcFcsIHBIXVxuICAgIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAoKHJvdGF0aW9uICogNCArIHBhcmVudFJvdGF0aW9uKSAvIDkwKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBbMSAtIHkgLSBoZWlnaHQsIHgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gWzEgLSB4IC0gd2lkdGgsIDEgLSB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geCAtIHdpZHRoLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIFt4LCB5IC0gd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCldO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gWzEgLSB5LCB4LCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcmV0dXJuIFsxIC0geCAtIGhlaWdodCAqIChwSCAvIHBXKSwgMSAtIHksIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCldO1xuICAgICAgY2FzZSA3OlxuICAgICAgICByZXR1cm4gW3kgLSB3aWR0aCAqIChwVyAvIHBIKSwgMSAtIHggLSBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgY2FzZSA4OlxuICAgICAgICByZXR1cm4gW3ggLSB3aWR0aCwgeSAtIGhlaWdodCwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDk6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHggLSB3aWR0aCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDEwOlxuICAgICAgICByZXR1cm4gWzEgLSB4LCAxIC0geSwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDExOlxuICAgICAgICByZXR1cm4gW3kgLSBoZWlnaHQsIDEgLSB4LCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTI6XG4gICAgICAgIHJldHVybiBbeCAtIGhlaWdodCAqIChwSCAvIHBXKSwgeSwgaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDEzOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC0gd2lkdGggKiAocFcgLyBwSCksIHggLSBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgY2FzZSAxNDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHkgLSB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDE1OlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4LCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeSwgd2lkdGgsIGhlaWdodF07XG4gICAgfVxuICB9XG4gIHJvdGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwgRHJhd2luZ0VkaXRvci5fbWVyZ2VTVkdQcm9wZXJ0aWVzKHtcbiAgICAgIGJib3g6IHRoaXMuI3JvdGF0ZUJveCgpXG4gICAgfSwgdGhpcy4jZHJhd091dGxpbmVzLnVwZGF0ZVJvdGF0aW9uKCh0aGlzLnBhcmVudFJvdGF0aW9uIC0gdGhpcy5yb3RhdGlvbiArIDM2MCkgJSAzNjApKSk7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlQmJveCh0aGlzLiNkcmF3T3V0bGluZXMudXBkYXRlUGFyZW50RGltZW5zaW9ucyh0aGlzLnBhcmVudERpbWVuc2lvbnMsIHRoaXMucGFyZW50LnNjYWxlKSk7XG4gIH1cbiAgc3RhdGljIG9uU2NhbGVDaGFuZ2luZ1doZW5EcmF3aW5nKCkge31cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLl9pc0NvcHkpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwiZHJhd1wiKTtcbiAgICBjb25zdCBkcmF3RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuYXBwZW5kKGRyYXdEaXYpO1xuICAgIGRyYXdEaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIGRyYXdEaXYuY2xhc3NOYW1lID0gXCJpbnRlcm5hbFwiO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdGluZygpO1xuICAgIGlmICh0aGlzLl9pc0NvcHkpIHtcbiAgICAgIHRoaXMuX21vdmVBZnRlclBhc3RlKGJhc2VYLCBiYXNlWSk7XG4gICAgfVxuICAgIHJldHVybiBkaXY7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZURyYXdlckluc3RhbmNlKF94LCBfeSwgX3BhcmVudFdpZHRoLCBfcGFyZW50SGVpZ2h0LCBfcm90YXRpb24pIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBzdGF0aWMgc3RhcnREcmF3aW5nKHBhcmVudCwgdWlNYW5hZ2VyLCBfaXNMVFIsIGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAgb2Zmc2V0WDogeCxcbiAgICAgIG9mZnNldFk6IHksXG4gICAgICBwb2ludGVySWQsXG4gICAgICBwb2ludGVyVHlwZVxuICAgIH0gPSBldmVudDtcbiAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJUeXBlICYmIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSAhPT0gcG9pbnRlclR5cGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH1cbiAgICB9ID0gcGFyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBhYyA9IERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gcGFyZW50LmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkIHx8PSBwb2ludGVySWQ7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJUeXBlID8/PSBwb2ludGVyVHlwZTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBlID0+IHtcbiAgICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xuICAgICAgICB0aGlzLl9lbmREcmF3KGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZHM/LmRlbGV0ZShlLnBvaW50ZXJJZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIGUgPT4ge1xuICAgICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWQgPT09IGUucG9pbnRlcklkKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQuZW5kRHJhd2luZ1Nlc3Npb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWRzPy5kZWxldGUoZS5wb2ludGVySWQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZSA9PiB7XG4gICAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJUeXBlICE9PSBlLnBvaW50ZXJUeXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkcyB8fD0gbmV3IFNldCgpKS5hZGQoZS5wb2ludGVySWQpO1xuICAgICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmlzQ2FuY2VsbGFibGUoKSkge1xuICAgICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5yZW1vdmVMYXN0RWxlbWVudCgpO1xuICAgICAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFBhcmVudC5lbmREcmF3aW5nU2Vzc2lvbih0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9lbmREcmF3KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuX2RyYXdNb3ZlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGUgPT4ge1xuICAgICAgaWYgKGUudGltZVN0YW1wID09PSBEcmF3aW5nRWRpdG9yLiNjdXJyZW50TW92ZVRpbWVzdGFtcCkge1xuICAgICAgICBzdG9wRXZlbnQoZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcGFyZW50LnRvZ2dsZURyYXdpbmcoKTtcbiAgICB1aU1hbmFnZXIuX2VkaXRvclVuZG9CYXI/LmhpZGUoKTtcbiAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcpIHtcbiAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9jdXJyZW50RHJhd0lkLCBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5zdGFydE5ldyh4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1aU1hbmFnZXIudXBkYXRlVUlGb3JEZWZhdWx0UHJvcGVydGllcyh0aGlzKTtcbiAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdyA9IHRoaXMuY3JlYXRlRHJhd2VySW5zdGFuY2UoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24pO1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nT3B0aW9ucyA9IHRoaXMuZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKCk7XG4gICAgdGhpcy5fY3VycmVudFBhcmVudCA9IHBhcmVudDtcbiAgICAoe1xuICAgICAgaWQ6IHRoaXMuX2N1cnJlbnREcmF3SWRcbiAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHRoaXMuX21lcmdlU1ZHUHJvcGVydGllcyhEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ09wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCksIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmRlZmF1bHRTVkdQcm9wZXJ0aWVzKSwgdHJ1ZSwgZmFsc2UpKTtcbiAgfVxuICBzdGF0aWMgX2RyYXdNb3ZlKGV2ZW50KSB7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudE1vdmVUaW1lc3RhbXAgPSAtMTtcbiAgICBpZiAoIURyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgcG9pbnRlcklkXG4gICAgfSA9IGV2ZW50O1xuICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkICE9PSBwb2ludGVySWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWRzPy5zaXplID49IDEpIHtcbiAgICAgIHRoaXMuX2VuZERyYXcoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50UGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmFkZChvZmZzZXRYLCBvZmZzZXRZKSk7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudE1vdmVUaW1lc3RhbXAgPSBldmVudC50aW1lU3RhbXA7XG4gICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgfVxuICBzdGF0aWMgX2NsZWFudXAoYWxsKSB7XG4gICAgaWYgKGFsbCkge1xuICAgICAgdGhpcy5fY3VycmVudERyYXdJZCA9IC0xO1xuICAgICAgdGhpcy5fY3VycmVudFBhcmVudCA9IG51bGw7XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdyA9IG51bGw7XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ09wdGlvbnMgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJUeXBlID0gbnVsbDtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRNb3ZlVGltZXN0YW1wID0gTmFOO1xuICAgIH1cbiAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdBQykge1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdBQy5hYm9ydCgpO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdBQyA9IG51bGw7XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkID0gTmFOO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZHMgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX2VuZERyYXcoZXZlbnQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9jdXJyZW50UGFyZW50O1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhcmVudC50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xuICAgIGlmIChldmVudD8udGFyZ2V0ID09PSBwYXJlbnQuZGl2KSB7XG4gICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuZW5kKGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MpIHtcbiAgICAgIGNvbnN0IGRyYXcgPSBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdztcbiAgICAgIGNvbnN0IGRyYXdJZCA9IHRoaXMuX2N1cnJlbnREcmF3SWQ7XG4gICAgICBjb25zdCBsYXN0RWxlbWVudCA9IGRyYXcuZ2V0TGFzdEVsZW1lbnQoKTtcbiAgICAgIHBhcmVudC5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyhkcmF3SWQsIGRyYXcuc2V0TGFzdEVsZW1lbnQobGFzdEVsZW1lbnQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyhkcmF3SWQsIGRyYXcucmVtb3ZlTGFzdEVsZW1lbnQoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG11c3RFeGVjOiBmYWxzZSxcbiAgICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRFJBV19TVEVQXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmREcmF3aW5nKGZhbHNlKTtcbiAgfVxuICBzdGF0aWMgZW5kRHJhd2luZyhpc0Fib3J0ZWQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9jdXJyZW50UGFyZW50O1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGFyZW50LnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgcGFyZW50LmNsZWFuVW5kb1N0YWNrKEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkRSQVdfU1RFUCk7XG4gICAgaWYgKCFEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5pc0VtcHR5KCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdLFxuICAgICAgICBzY2FsZVxuICAgICAgfSA9IHBhcmVudDtcbiAgICAgIGNvbnN0IGVkaXRvciA9IHBhcmVudC5jcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAwXG4gICAgICB9LCBmYWxzZSwge1xuICAgICAgICBkcmF3SWQ6IHRoaXMuX2N1cnJlbnREcmF3SWQsXG4gICAgICAgIGRyYXdPdXRsaW5lczogRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuZ2V0T3V0bGluZXMocGFnZVdpZHRoICogc2NhbGUsIHBhZ2VIZWlnaHQgKiBzY2FsZSwgc2NhbGUsIHRoaXMuX0lOTkVSX01BUkdJTiksXG4gICAgICAgIGRyYXdpbmdPcHRpb25zOiBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ09wdGlvbnMsXG4gICAgICAgIG11c3RCZUNvbW1pdHRlZDogIWlzQWJvcnRlZFxuICAgICAgfSk7XG4gICAgICB0aGlzLl9jbGVhbnVwKHRydWUpO1xuICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICB9XG4gICAgcGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy5fY3VycmVudERyYXdJZCk7XG4gICAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjcmVhdGVEcmF3aW5nT3B0aW9ucyhfZGF0YSkge31cbiAgc3RhdGljIGRlc2VyaWFsaXplRHJhdyhfcGFnZVgsIF9wYWdlWSwgX3BhZ2VXaWR0aCwgX3BhZ2VIZWlnaHQsIF9pbm5lcldpZHRoLCBfZGF0YSkge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICBwYWdlWCxcbiAgICAgICAgcGFnZVlcbiAgICAgIH1cbiAgICB9ID0gcGFyZW50LnZpZXdwb3J0O1xuICAgIGNvbnN0IGRyYXdPdXRsaW5lcyA9IHRoaXMuZGVzZXJpYWxpemVEcmF3KHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCB0aGlzLl9JTk5FUl9NQVJHSU4sIGRhdGEpO1xuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuY3JlYXRlRHJhd2luZ09wdGlvbnMoZGF0YSk7XG4gICAgZWRpdG9yLiNjcmVhdGVEcmF3T3V0bGluZXMoe1xuICAgICAgZHJhd091dGxpbmVzXG4gICAgfSk7XG4gICAgZWRpdG9yLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIGVkaXRvci5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgICBlZGl0b3Iucm90YXRlKCk7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemVEcmF3KGlzRm9yQ29weWluZykge1xuICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIHJldHVybiB0aGlzLiNkcmF3T3V0bGluZXMuc2VyaWFsaXplKFtwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodF0sIGlzRm9yQ29weWluZyk7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpXG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RhdGljIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhd2Vycy9pbmtkcmF3LmpzXG5cblxuY2xhc3MgSW5rRHJhd091dGxpbmVyIHtcbiAgI2xhc3QgPSBuZXcgRmxvYXQ2NEFycmF5KDYpO1xuICAjbGluZTtcbiAgI2xpbmVzO1xuICAjcm90YXRpb247XG4gICN0aGlja25lc3M7XG4gICNwb2ludHM7XG4gICNsYXN0U1ZHUGF0aCA9IFwiXCI7XG4gICNsYXN0SW5kZXggPSAwO1xuICAjb3V0bGluZXMgPSBuZXcgSW5rRHJhd091dGxpbmUoKTtcbiAgI3BhcmVudFdpZHRoO1xuICAjcGFyZW50SGVpZ2h0O1xuICBjb25zdHJ1Y3Rvcih4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbiwgdGhpY2tuZXNzKSB7XG4gICAgdGhpcy4jcGFyZW50V2lkdGggPSBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLiNwYXJlbnRIZWlnaHQgPSBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy4jcm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLiN0aGlja25lc3MgPSB0aGlja25lc3M7XG4gICAgW3gsIHldID0gdGhpcy4jbm9ybWFsaXplUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgbGluZSA9IHRoaXMuI2xpbmUgPSBbTmFOLCBOYU4sIE5hTiwgTmFOLCB4LCB5XTtcbiAgICB0aGlzLiNwb2ludHMgPSBbeCwgeV07XG4gICAgdGhpcy4jbGluZXMgPSBbe1xuICAgICAgbGluZSxcbiAgICAgIHBvaW50czogdGhpcy4jcG9pbnRzXG4gICAgfV07XG4gICAgdGhpcy4jbGFzdC5zZXQobGluZSwgMCk7XG4gIH1cbiAgdXBkYXRlUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJzdHJva2Utd2lkdGhcIikge1xuICAgICAgdGhpcy4jdGhpY2tuZXNzID0gdmFsdWU7XG4gICAgfVxuICB9XG4gICNub3JtYWxpemVQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIE91dGxpbmUuX25vcm1hbGl6ZVBvaW50KHgsIHksIHRoaXMuI3BhcmVudFdpZHRoLCB0aGlzLiNwYXJlbnRIZWlnaHQsIHRoaXMuI3JvdGF0aW9uKTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhdGhpcy4jbGluZXMgfHwgdGhpcy4jbGluZXMubGVuZ3RoID09PSAwO1xuICB9XG4gIGlzQ2FuY2VsbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvaW50cy5sZW5ndGggPD0gMTA7XG4gIH1cbiAgYWRkKHgsIHkpIHtcbiAgICBbeCwgeV0gPSB0aGlzLiNub3JtYWxpemVQb2ludCh4LCB5KTtcbiAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgyLCA2KTtcbiAgICBjb25zdCBkaWZmWCA9IHggLSB4MjtcbiAgICBjb25zdCBkaWZmWSA9IHkgLSB5MjtcbiAgICBjb25zdCBkID0gTWF0aC5oeXBvdCh0aGlzLiNwYXJlbnRXaWR0aCAqIGRpZmZYLCB0aGlzLiNwYXJlbnRIZWlnaHQgKiBkaWZmWSk7XG4gICAgaWYgKGQgPD0gMikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3BvaW50cy5wdXNoKHgsIHkpO1xuICAgIGlmIChpc05hTih4MSkpIHtcbiAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MiwgeTIsIHgsIHldLCAyKTtcbiAgICAgIHRoaXMuI2xpbmUucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sIHgsIHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKHRoaXMuI2xhc3RbMF0pKSB7XG4gICAgICB0aGlzLiNsaW5lLnNwbGljZSg2LCA2KTtcbiAgICB9XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gxLCB5MSwgeDIsIHkyLCB4LCB5XSwgMCk7XG4gICAgdGhpcy4jbGluZS5wdXNoKC4uLk91dGxpbmUuY3JlYXRlQmV6aWVyUG9pbnRzKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZW5kKHgsIHkpIHtcbiAgICBjb25zdCBjaGFuZ2UgPSB0aGlzLmFkZCh4LCB5KTtcbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcG9pbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RhcnROZXcoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24pIHtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHBhcmVudFdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIFt4LCB5XSA9IHRoaXMuI25vcm1hbGl6ZVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IGxpbmUgPSB0aGlzLiNsaW5lID0gW05hTiwgTmFOLCBOYU4sIE5hTiwgeCwgeV07XG4gICAgdGhpcy4jcG9pbnRzID0gW3gsIHldO1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsaW5lcy5hdCgtMSk7XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubGluZSA9IG5ldyBGbG9hdDMyQXJyYXkobGFzdC5saW5lKTtcbiAgICAgIGxhc3QucG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LnBvaW50cyk7XG4gICAgfVxuICAgIHRoaXMuI2xpbmVzLnB1c2goe1xuICAgICAgbGluZSxcbiAgICAgIHBvaW50czogdGhpcy4jcG9pbnRzXG4gICAgfSk7XG4gICAgdGhpcy4jbGFzdC5zZXQobGluZSwgMCk7XG4gICAgdGhpcy4jbGFzdEluZGV4ID0gMDtcbiAgICB0aGlzLnRvU1ZHUGF0aCgpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldExhc3RFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNsaW5lcy5hdCgtMSk7XG4gIH1cbiAgc2V0TGFzdEVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy4jbGluZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLiNvdXRsaW5lcy5zZXRMYXN0RWxlbWVudChlbGVtZW50KTtcbiAgICB9XG4gICAgdGhpcy4jbGluZXMucHVzaChlbGVtZW50KTtcbiAgICB0aGlzLiNsaW5lID0gZWxlbWVudC5saW5lO1xuICAgIHRoaXMuI3BvaW50cyA9IGVsZW1lbnQucG9pbnRzO1xuICAgIHRoaXMuI2xhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmVtb3ZlTGFzdEVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLiNsaW5lcykge1xuICAgICAgcmV0dXJuIHRoaXMuI291dGxpbmVzLnJlbW92ZUxhc3RFbGVtZW50KCk7XG4gICAgfVxuICAgIHRoaXMuI2xpbmVzLnBvcCgpO1xuICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLiNsaW5lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSA9IHRoaXMuI2xpbmVzW2ldO1xuICAgICAgdGhpcy4jbGluZSA9IGxpbmU7XG4gICAgICB0aGlzLiNwb2ludHMgPSBwb2ludHM7XG4gICAgICB0aGlzLiNsYXN0SW5kZXggPSAwO1xuICAgICAgdGhpcy50b1NWR1BhdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy4jbGFzdFNWR1BhdGhcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBjb25zdCBmaXJzdFggPSBPdXRsaW5lLnN2Z1JvdW5kKHRoaXMuI2xpbmVbNF0pO1xuICAgIGNvbnN0IGZpcnN0WSA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVs1XSk7XG4gICAgaWYgKHRoaXMuI3BvaW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gYCR7dGhpcy4jbGFzdFNWR1BhdGh9IE0gJHtmaXJzdFh9ICR7Zmlyc3RZfSBaYDtcbiAgICAgIHJldHVybiB0aGlzLiNsYXN0U1ZHUGF0aDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3BvaW50cy5sZW5ndGggPD0gNikge1xuICAgICAgY29uc3QgaSA9IHRoaXMuI2xhc3RTVkdQYXRoLmxhc3RJbmRleE9mKFwiTVwiKTtcbiAgICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gYCR7dGhpcy4jbGFzdFNWR1BhdGguc2xpY2UoMCwgaSl9IE0gJHtmaXJzdFh9ICR7Zmlyc3RZfWA7XG4gICAgICB0aGlzLiNsYXN0SW5kZXggPSA2O1xuICAgIH1cbiAgICBpZiAodGhpcy4jcG9pbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgY29uc3Qgc2Vjb25kWCA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVsxMF0pO1xuICAgICAgY29uc3Qgc2Vjb25kWSA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVsxMV0pO1xuICAgICAgdGhpcy4jbGFzdFNWR1BhdGggPSBgJHt0aGlzLiNsYXN0U1ZHUGF0aH0gTCAke3NlY29uZFh9ICR7c2Vjb25kWX1gO1xuICAgICAgdGhpcy4jbGFzdEluZGV4ID0gMTI7XG4gICAgICByZXR1cm4gdGhpcy4jbGFzdFNWR1BhdGg7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGlmICh0aGlzLiNsYXN0SW5kZXggPT09IDApIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGBNICR7Zmlyc3RYfSAke2ZpcnN0WX1gKTtcbiAgICAgIHRoaXMuI2xhc3RJbmRleCA9IDY7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSB0aGlzLiNsYXN0SW5kZXgsIGlpID0gdGhpcy4jbGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICBjb25zdCBbYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5XSA9IHRoaXMuI2xpbmUuc2xpY2UoaSwgaSArIDYpLm1hcChPdXRsaW5lLnN2Z1JvdW5kKTtcbiAgICAgIGJ1ZmZlci5wdXNoKGBDJHtjMXh9ICR7YzF5fSAke2MyeH0gJHtjMnl9ICR7eH0gJHt5fWApO1xuICAgIH1cbiAgICB0aGlzLiNsYXN0U1ZHUGF0aCArPSBidWZmZXIuam9pbihcIiBcIik7XG4gICAgdGhpcy4jbGFzdEluZGV4ID0gdGhpcy4jbGluZS5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuI2xhc3RTVkdQYXRoO1xuICB9XG4gIGdldE91dGxpbmVzKHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHNjYWxlLCBpbm5lck1hcmdpbikge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsaW5lcy5hdCgtMSk7XG4gICAgbGFzdC5saW5lID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LmxpbmUpO1xuICAgIGxhc3QucG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LnBvaW50cyk7XG4gICAgdGhpcy4jb3V0bGluZXMuYnVpbGQodGhpcy4jbGluZXMsIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHNjYWxlLCB0aGlzLiNyb3RhdGlvbiwgdGhpcy4jdGhpY2tuZXNzLCBpbm5lck1hcmdpbik7XG4gICAgdGhpcy4jbGFzdCA9IG51bGw7XG4gICAgdGhpcy4jbGluZSA9IG51bGw7XG4gICAgdGhpcy4jbGluZXMgPSBudWxsO1xuICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy4jb3V0bGluZXM7XG4gIH1cbiAgZ2V0IGRlZmF1bHRTVkdQcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDEwMDAwIDEwMDAwXCJcbiAgICAgIH0sXG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgZHJhdzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGJib3g6IFswLCAwLCAxLCAxXVxuICAgIH07XG4gIH1cbn1cbmNsYXNzIElua0RyYXdPdXRsaW5lIGV4dGVuZHMgT3V0bGluZSB7XG4gICNiYm94O1xuICAjY3VycmVudFJvdGF0aW9uID0gMDtcbiAgI2lubmVyTWFyZ2luO1xuICAjbGluZXM7XG4gICNwYXJlbnRXaWR0aDtcbiAgI3BhcmVudEhlaWdodDtcbiAgI3BhcmVudFNjYWxlO1xuICAjcm90YXRpb247XG4gICN0aGlja25lc3M7XG4gIGJ1aWxkKGxpbmVzLCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCBwYXJlbnRTY2FsZSwgcm90YXRpb24sIHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pIHtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHBhcmVudFdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICB0aGlzLiNwYXJlbnRTY2FsZSA9IHBhcmVudFNjYWxlO1xuICAgIHRoaXMuI3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gdGhpY2tuZXNzO1xuICAgIHRoaXMuI2lubmVyTWFyZ2luID0gaW5uZXJNYXJnaW4gPz8gMDtcbiAgICB0aGlzLiNsaW5lcyA9IGxpbmVzO1xuICAgIHRoaXMuI2NvbXB1dGVCYm94KCk7XG4gIH1cbiAgZ2V0IHRoaWNrbmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy4jdGhpY2tuZXNzO1xuICB9XG4gIHNldExhc3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB0aGlzLiNsaW5lcy5wdXNoKGVsZW1lbnQpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJlbW92ZUxhc3RFbGVtZW50KCkge1xuICAgIHRoaXMuI2xpbmVzLnBvcCgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGxpbmVcbiAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICBidWZmZXIucHVzaChgTSR7T3V0bGluZS5zdmdSb3VuZChsaW5lWzRdKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbNV0pfWApO1xuICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5sZW5ndGggPT09IDEyICYmIGlzTmFOKGxpbmVbNl0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbMTBdKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbMTFdKX1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gNiwgaWkgPSBsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgICAgY29uc3QgW2MxeCwgYzF5LCBjMngsIGMyeSwgeCwgeV0gPSBsaW5lLnN1YmFycmF5KGksIGkgKyA2KS5tYXAoT3V0bGluZS5zdmdSb3VuZCk7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBDJHtjMXh9ICR7YzF5fSAke2MyeH0gJHtjMnl9ICR7eH0gJHt5fWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcIik7XG4gIH1cbiAgc2VyaWFsaXplKFtwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodF0sIGlzRm9yQ29weWluZykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRMaW5lcyA9IFtdO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRQb2ludHMgPSBbXTtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNnZXRCQm94V2l0aE5vTWFyZ2luKCk7XG4gICAgbGV0IHR4LCB0eSwgc3gsIHN5LCB4MSwgeTEsIHgyLCB5MiwgcmVzY2FsZUZuO1xuICAgIHN3aXRjaCAodGhpcy4jcm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZTtcbiAgICAgICAgdHggPSBwYWdlWDtcbiAgICAgICAgdHkgPSBwYWdlWSArIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN4ID0gcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IC1wYWdlSGVpZ2h0O1xuICAgICAgICB4MSA9IHBhZ2VYICsgeCAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArICgxIC0geSAtIGhlaWdodCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKHggKyB3aWR0aCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkyID0gcGFnZVkgKyAoMSAtIHkpICogcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSBwYWdlWDtcbiAgICAgICAgdHkgPSBwYWdlWTtcbiAgICAgICAgc3ggPSBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gcGFnZUhlaWdodDtcbiAgICAgICAgeDEgPSBwYWdlWCArIHkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkxID0gcGFnZVkgKyB4ICogcGFnZUhlaWdodDtcbiAgICAgICAgeDIgPSBwYWdlWCArICh5ICsgaGVpZ2h0KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICh4ICsgd2lkdGgpICogcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZTtcbiAgICAgICAgdHggPSBwYWdlWCArIHBhZ2VXaWR0aDtcbiAgICAgICAgdHkgPSBwYWdlWTtcbiAgICAgICAgc3ggPSAtcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgxID0gcGFnZVggKyAoMSAtIHggLSB3aWR0aCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkxID0gcGFnZVkgKyB5ICogcGFnZUhlaWdodDtcbiAgICAgICAgeDIgPSBwYWdlWCArICgxIC0geCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkyID0gcGFnZVkgKyAoeSArIGhlaWdodCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSBwYWdlWCArIHBhZ2VXaWR0aDtcbiAgICAgICAgdHkgPSBwYWdlWSArIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN4ID0gLXBhZ2VXaWR0aDtcbiAgICAgICAgc3kgPSAtcGFnZUhlaWdodDtcbiAgICAgICAgeDEgPSBwYWdlWCArICgxIC0geSAtIGhlaWdodCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkxID0gcGFnZVkgKyAoMSAtIHggLSB3aWR0aCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKDEgLSB5KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICgxIC0geCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBsaW5lLFxuICAgICAgcG9pbnRzXG4gICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgc2VyaWFsaXplZExpbmVzLnB1c2gocmVzY2FsZUZuKGxpbmUsIHR4LCB0eSwgc3gsIHN5LCBpc0ZvckNvcHlpbmcgPyBuZXcgQXJyYXkobGluZS5sZW5ndGgpIDogbnVsbCkpO1xuICAgICAgc2VyaWFsaXplZFBvaW50cy5wdXNoKHJlc2NhbGVGbihwb2ludHMsIHR4LCB0eSwgc3gsIHN5LCBpc0ZvckNvcHlpbmcgPyBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCkgOiBudWxsKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsaW5lczogc2VyaWFsaXplZExpbmVzLFxuICAgICAgcG9pbnRzOiBzZXJpYWxpemVkUG9pbnRzLFxuICAgICAgcmVjdDogW3gxLCB5MSwgeDIsIHkyXVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBpbm5lck1hcmdpbiwge1xuICAgIHBhdGhzOiB7XG4gICAgICBsaW5lcyxcbiAgICAgIHBvaW50c1xuICAgIH0sXG4gICAgcm90YXRpb24sXG4gICAgdGhpY2tuZXNzXG4gIH0pIHtcbiAgICBjb25zdCBuZXdMaW5lcyA9IFtdO1xuICAgIGxldCB0eCwgdHksIHN4LCBzeSwgcmVzY2FsZUZuO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZTtcbiAgICAgICAgdHggPSAtcGFnZVggLyBwYWdlV2lkdGg7XG4gICAgICAgIHR5ID0gcGFnZVkgLyBwYWdlSGVpZ2h0ICsgMTtcbiAgICAgICAgc3ggPSAxIC8gcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IC0xIC8gcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSAtcGFnZVkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICB0eSA9IC1wYWdlWCAvIHBhZ2VXaWR0aDtcbiAgICAgICAgc3ggPSAxIC8gcGFnZUhlaWdodDtcbiAgICAgICAgc3kgPSAxIC8gcGFnZVdpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IHBhZ2VYIC8gcGFnZVdpZHRoICsgMTtcbiAgICAgICAgdHkgPSAtcGFnZVkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBzeCA9IC0xIC8gcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IDEgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSBwYWdlWSAvIHBhZ2VIZWlnaHQgKyAxO1xuICAgICAgICB0eSA9IHBhZ2VYIC8gcGFnZVdpZHRoICsgMTtcbiAgICAgICAgc3ggPSAtMSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN5ID0gLTEgLyBwYWdlV2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIWxpbmVzKSB7XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gcG9pbnQubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICAgICAgbGluZXMucHVzaChuZXcgRmxvYXQzMkFycmF5KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHBvaW50WzBdLCBwb2ludFsxXV0pKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID09PSA0KSB7XG4gICAgICAgICAgbGluZXMucHVzaChuZXcgRmxvYXQzMkFycmF5KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHBvaW50WzBdLCBwb2ludFsxXSwgTmFOLCBOYU4sIE5hTiwgTmFOLCBwb2ludFsyXSwgcG9pbnRbM11dKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyAqIChsZW4gLSAyKSk7XG4gICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIGxldCBbeDEsIHkxLCB4MiwgeTJdID0gcG9pbnQuc3ViYXJyYXkoMCwgNCk7XG4gICAgICAgIGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgxLCB5MV0sIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gNDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50W2ldO1xuICAgICAgICAgIGNvbnN0IHkgPSBwb2ludFtpICsgMV07XG4gICAgICAgICAgbGluZS5zZXQoT3V0bGluZS5jcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgsIHkpLCAoaSAtIDIpICogMyk7XG4gICAgICAgICAgW3gxLCB5MSwgeDIsIHkyXSA9IFt4MiwgeTIsIHgsIHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpbmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIG5ld0xpbmVzLnB1c2goe1xuICAgICAgICBsaW5lOiByZXNjYWxlRm4obGluZXNbaV0ubWFwKHggPT4geCA/PyBOYU4pLCB0eCwgdHksIHN4LCBzeSksXG4gICAgICAgIHBvaW50czogcmVzY2FsZUZuKHBvaW50c1tpXS5tYXAoeCA9PiB4ID8/IE5hTiksIHR4LCB0eSwgc3gsIHN5KVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmVzID0gbmV3IHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yKCk7XG4gICAgb3V0bGluZXMuYnVpbGQobmV3TGluZXMsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgMSwgcm90YXRpb24sIHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pO1xuICAgIHJldHVybiBvdXRsaW5lcztcbiAgfVxuICAjZ2V0TWFyZ2luQ29tcG9uZW50cyh0aGlja25lc3MgPSB0aGlzLiN0aGlja25lc3MpIHtcbiAgICBjb25zdCBtYXJnaW4gPSB0aGlzLiNpbm5lck1hcmdpbiArIHRoaWNrbmVzcyAvIDIgKiB0aGlzLiNwYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gdGhpcy4jcm90YXRpb24gJSAxODAgPT09IDAgPyBbbWFyZ2luIC8gdGhpcy4jcGFyZW50V2lkdGgsIG1hcmdpbiAvIHRoaXMuI3BhcmVudEhlaWdodF0gOiBbbWFyZ2luIC8gdGhpcy4jcGFyZW50SGVpZ2h0LCBtYXJnaW4gLyB0aGlzLiNwYXJlbnRXaWR0aF07XG4gIH1cbiAgI2dldEJCb3hXaXRoTm9NYXJnaW4oKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKDApO1xuICAgIHJldHVybiBbeCArIG1hcmdpblgsIHkgKyBtYXJnaW5ZLCB3aWR0aCAtIDIgKiBtYXJnaW5YLCBoZWlnaHQgLSAyICogbWFyZ2luWV07XG4gIH1cbiAgI2NvbXB1dGVCYm94KCkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94ID0gbmV3IEZsb2F0MzJBcnJheShbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV0pO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgbGluZVxuICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA8PSAxMikge1xuICAgICAgICBmb3IgKGxldCBpID0gNCwgaWkgPSBsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgICAgICBVdGlsLnBvaW50Qm91bmRpbmdCb3gobGluZVtpXSwgbGluZVtpICsgMV0sIGJib3gpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGxhc3RYID0gbGluZVs0XSxcbiAgICAgICAgbGFzdFkgPSBsaW5lWzVdO1xuICAgICAgZm9yIChsZXQgaSA9IDYsIGlpID0gbGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICAgIGNvbnN0IFtjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHldID0gbGluZS5zdWJhcnJheShpLCBpICsgNik7XG4gICAgICAgIFV0aWwuYmV6aWVyQm91bmRpbmdCb3gobGFzdFgsIGxhc3RZLCBjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHksIGJib3gpO1xuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgW21hcmdpblgsIG1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGJib3hbMF0gPSBNYXRoQ2xhbXAoYmJveFswXSAtIG1hcmdpblgsIDAsIDEpO1xuICAgIGJib3hbMV0gPSBNYXRoQ2xhbXAoYmJveFsxXSAtIG1hcmdpblksIDAsIDEpO1xuICAgIGJib3hbMl0gPSBNYXRoQ2xhbXAoYmJveFsyXSArIG1hcmdpblgsIDAsIDEpO1xuICAgIGJib3hbM10gPSBNYXRoQ2xhbXAoYmJveFszXSArIG1hcmdpblksIDAsIDEpO1xuICAgIGJib3hbMl0gLT0gYmJveFswXTtcbiAgICBiYm94WzNdIC09IGJib3hbMV07XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYmJveDtcbiAgfVxuICB1cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lID09PSBcInN0cm9rZS13aWR0aFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy4jdXBkYXRlVGhpY2tuZXNzKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgI3VwZGF0ZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBjb25zdCBbb2xkTWFyZ2luWCwgb2xkTWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gdGhpY2tuZXNzO1xuICAgIGNvbnN0IFtuZXdNYXJnaW5YLCBuZXdNYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBbZGlmZk1hcmdpblgsIGRpZmZNYXJnaW5ZXSA9IFtuZXdNYXJnaW5YIC0gb2xkTWFyZ2luWCwgbmV3TWFyZ2luWSAtIG9sZE1hcmdpblldO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGJib3hbMF0gLT0gZGlmZk1hcmdpblg7XG4gICAgYmJveFsxXSAtPSBkaWZmTWFyZ2luWTtcbiAgICBiYm94WzJdICs9IDIgKiBkaWZmTWFyZ2luWDtcbiAgICBiYm94WzNdICs9IDIgKiBkaWZmTWFyZ2luWTtcbiAgICByZXR1cm4gYmJveDtcbiAgfVxuICB1cGRhdGVQYXJlbnREaW1lbnNpb25zKFt3aWR0aCwgaGVpZ2h0XSwgc2NhbGUpIHtcbiAgICBjb25zdCBbb2xkTWFyZ2luWCwgb2xkTWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgdGhpcy4jcGFyZW50V2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLiNwYXJlbnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy4jcGFyZW50U2NhbGUgPSBzY2FsZTtcbiAgICBjb25zdCBbbmV3TWFyZ2luWCwgbmV3TWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgY29uc3QgZGlmZk1hcmdpblggPSBuZXdNYXJnaW5YIC0gb2xkTWFyZ2luWDtcbiAgICBjb25zdCBkaWZmTWFyZ2luWSA9IG5ld01hcmdpblkgLSBvbGRNYXJnaW5ZO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGJib3hbMF0gLT0gZGlmZk1hcmdpblg7XG4gICAgYmJveFsxXSAtPSBkaWZmTWFyZ2luWTtcbiAgICBiYm94WzJdICs9IDIgKiBkaWZmTWFyZ2luWDtcbiAgICBiYm94WzNdICs9IDIgKiBkaWZmTWFyZ2luWTtcbiAgICByZXR1cm4gYmJveDtcbiAgfVxuICB1cGRhdGVSb3RhdGlvbihyb3RhdGlvbikge1xuICAgIHRoaXMuI2N1cnJlbnRSb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5yb3RhdGlvblRyYW5zZm9ybVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0IHZpZXdCb3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Jib3gubWFwKE91dGxpbmUuc3ZnUm91bmQpLmpvaW4oXCIgXCIpO1xuICB9XG4gIGdldCBkZWZhdWx0UHJvcGVydGllcygpIHtcbiAgICBjb25zdCBbeCwgeV0gPSB0aGlzLiNiYm94O1xuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQoeCl9ICR7T3V0bGluZS5zdmdSb3VuZCh5KX1gXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXQgcm90YXRpb25UcmFuc2Zvcm0oKSB7XG4gICAgY29uc3QgWywsIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBsZXQgYSA9IDAsXG4gICAgICBiID0gMCxcbiAgICAgIGMgPSAwLFxuICAgICAgZCA9IDAsXG4gICAgICBlID0gMCxcbiAgICAgIGYgPSAwO1xuICAgIHN3aXRjaCAodGhpcy4jY3VycmVudFJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICBiID0gaGVpZ2h0IC8gd2lkdGg7XG4gICAgICAgIGMgPSAtd2lkdGggLyBoZWlnaHQ7XG4gICAgICAgIGUgPSB3aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgYSA9IC0xO1xuICAgICAgICBkID0gLTE7XG4gICAgICAgIGUgPSB3aWR0aDtcbiAgICAgICAgZiA9IGhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgYiA9IC1oZWlnaHQgLyB3aWR0aDtcbiAgICAgICAgYyA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgICBmID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gYG1hdHJpeCgke2F9ICR7Yn0gJHtjfSAke2R9ICR7T3V0bGluZS5zdmdSb3VuZChlKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKGYpfSlgO1xuICB9XG4gIGdldFBhdGhSZXNpemluZ1NWR1Byb3BlcnRpZXMoW25ld1gsIG5ld1ksIG5ld1dpZHRoLCBuZXdIZWlnaHRdKSB7XG4gICAgY29uc3QgW21hcmdpblgsIG1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2Jib3g7XG4gICAgaWYgKE1hdGguYWJzKHdpZHRoIC0gbWFyZ2luWCkgPD0gT3V0bGluZS5QUkVDSVNJT04gfHwgTWF0aC5hYnMoaGVpZ2h0IC0gbWFyZ2luWSkgPD0gT3V0bGluZS5QUkVDSVNJT04pIHtcbiAgICAgIGNvbnN0IHR4ID0gbmV3WCArIG5ld1dpZHRoIC8gMiAtICh4ICsgd2lkdGggLyAyKTtcbiAgICAgIGNvbnN0IHR5ID0gbmV3WSArIG5ld0hlaWdodCAvIDIgLSAoeSArIGhlaWdodCAvIDIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1gpfSAke091dGxpbmUuc3ZnUm91bmQobmV3WSl9YCxcbiAgICAgICAgICB0cmFuc2Zvcm06IGAke3RoaXMucm90YXRpb25UcmFuc2Zvcm19IHRyYW5zbGF0ZSgke3R4fSAke3R5fSlgXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHMxeCA9IChuZXdXaWR0aCAtIDIgKiBtYXJnaW5YKSAvICh3aWR0aCAtIDIgKiBtYXJnaW5YKTtcbiAgICBjb25zdCBzMXkgPSAobmV3SGVpZ2h0IC0gMiAqIG1hcmdpblkpIC8gKGhlaWdodCAtIDIgKiBtYXJnaW5ZKTtcbiAgICBjb25zdCBzMnggPSB3aWR0aCAvIG5ld1dpZHRoO1xuICAgIGNvbnN0IHMyeSA9IGhlaWdodCAvIG5ld0hlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZCh4KX0gJHtPdXRsaW5lLnN2Z1JvdW5kKHkpfWAsXG4gICAgICAgIHRyYW5zZm9ybTogYCR7dGhpcy5yb3RhdGlvblRyYW5zZm9ybX0gc2NhbGUoJHtzMnh9ICR7czJ5fSkgYCArIGB0cmFuc2xhdGUoJHtPdXRsaW5lLnN2Z1JvdW5kKG1hcmdpblgpfSAke091dGxpbmUuc3ZnUm91bmQobWFyZ2luWSl9KSBzY2FsZSgke3MxeH0gJHtzMXl9KSBgICsgYHRyYW5zbGF0ZSgke091dGxpbmUuc3ZnUm91bmQoLW1hcmdpblgpfSAke091dGxpbmUuc3ZnUm91bmQoLW1hcmdpblkpfSlgXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXRQYXRoUmVzaXplZFNWR1Byb3BlcnRpZXMoW25ld1gsIG5ld1ksIG5ld1dpZHRoLCBuZXdIZWlnaHRdKSB7XG4gICAgY29uc3QgW21hcmdpblgsIG1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IGJib3g7XG4gICAgYmJveFswXSA9IG5ld1g7XG4gICAgYmJveFsxXSA9IG5ld1k7XG4gICAgYmJveFsyXSA9IG5ld1dpZHRoO1xuICAgIGJib3hbM10gPSBuZXdIZWlnaHQ7XG4gICAgaWYgKE1hdGguYWJzKHdpZHRoIC0gbWFyZ2luWCkgPD0gT3V0bGluZS5QUkVDSVNJT04gfHwgTWF0aC5hYnMoaGVpZ2h0IC0gbWFyZ2luWSkgPD0gT3V0bGluZS5QUkVDSVNJT04pIHtcbiAgICAgIGNvbnN0IHR4ID0gbmV3WCArIG5ld1dpZHRoIC8gMiAtICh4ICsgd2lkdGggLyAyKTtcbiAgICAgIGNvbnN0IHR5ID0gbmV3WSArIG5ld0hlaWdodCAvIDIgLSAoeSArIGhlaWdodCAvIDIpO1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgICBPdXRsaW5lLl90cmFuc2xhdGUobGluZSwgdHgsIHR5LCBsaW5lKTtcbiAgICAgICAgT3V0bGluZS5fdHJhbnNsYXRlKHBvaW50cywgdHgsIHR5LCBwb2ludHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgICB9LFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQobmV3WCl9ICR7T3V0bGluZS5zdmdSb3VuZChuZXdZKX1gLFxuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5yb3RhdGlvblRyYW5zZm9ybSB8fCBudWxsLFxuICAgICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgczF4ID0gKG5ld1dpZHRoIC0gMiAqIG1hcmdpblgpIC8gKHdpZHRoIC0gMiAqIG1hcmdpblgpO1xuICAgIGNvbnN0IHMxeSA9IChuZXdIZWlnaHQgLSAyICogbWFyZ2luWSkgLyAoaGVpZ2h0IC0gMiAqIG1hcmdpblkpO1xuICAgIGNvbnN0IHR4ID0gLXMxeCAqICh4ICsgbWFyZ2luWCkgKyBuZXdYICsgbWFyZ2luWDtcbiAgICBjb25zdCB0eSA9IC1zMXkgKiAoeSArIG1hcmdpblkpICsgbmV3WSArIG1hcmdpblk7XG4gICAgaWYgKHMxeCAhPT0gMSB8fCBzMXkgIT09IDEgfHwgdHggIT09IDAgfHwgdHkgIT09IDApIHtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgICAgT3V0bGluZS5fcmVzY2FsZShsaW5lLCB0eCwgdHksIHMxeCwgczF5LCBsaW5lKTtcbiAgICAgICAgT3V0bGluZS5fcmVzY2FsZShwb2ludHMsIHR4LCB0eSwgczF4LCBzMXksIHBvaW50cyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQobmV3WCl9ICR7T3V0bGluZS5zdmdSb3VuZChuZXdZKX1gLFxuICAgICAgICB0cmFuc2Zvcm06IHRoaXMucm90YXRpb25UcmFuc2Zvcm0gfHwgbnVsbCxcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0UGF0aFRyYW5zbGF0ZWRTVkdQcm9wZXJ0aWVzKFtuZXdYLCBuZXdZXSwgcGFyZW50RGltZW5zaW9ucykge1xuICAgIGNvbnN0IFtuZXdQYXJlbnRXaWR0aCwgbmV3UGFyZW50SGVpZ2h0XSA9IHBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgY29uc3QgdHggPSBuZXdYIC0gYmJveFswXTtcbiAgICBjb25zdCB0eSA9IG5ld1kgLSBiYm94WzFdO1xuICAgIGlmICh0aGlzLiNwYXJlbnRXaWR0aCA9PT0gbmV3UGFyZW50V2lkdGggJiYgdGhpcy4jcGFyZW50SGVpZ2h0ID09PSBuZXdQYXJlbnRIZWlnaHQpIHtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgICAgT3V0bGluZS5fdHJhbnNsYXRlKGxpbmUsIHR4LCB0eSwgbGluZSk7XG4gICAgICAgIE91dGxpbmUuX3RyYW5zbGF0ZShwb2ludHMsIHR4LCB0eSwgcG9pbnRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3ggPSB0aGlzLiNwYXJlbnRXaWR0aCAvIG5ld1BhcmVudFdpZHRoO1xuICAgICAgY29uc3Qgc3kgPSB0aGlzLiNwYXJlbnRIZWlnaHQgLyBuZXdQYXJlbnRIZWlnaHQ7XG4gICAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IG5ld1BhcmVudFdpZHRoO1xuICAgICAgdGhpcy4jcGFyZW50SGVpZ2h0ID0gbmV3UGFyZW50SGVpZ2h0O1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgICBPdXRsaW5lLl9yZXNjYWxlKGxpbmUsIHR4LCB0eSwgc3gsIHN5LCBsaW5lKTtcbiAgICAgICAgT3V0bGluZS5fcmVzY2FsZShwb2ludHMsIHR4LCB0eSwgc3gsIHN5LCBwb2ludHMpO1xuICAgICAgfVxuICAgICAgYmJveFsyXSAqPSBzeDtcbiAgICAgIGJib3hbM10gKj0gc3k7XG4gICAgfVxuICAgIGJib3hbMF0gPSBuZXdYO1xuICAgIGJib3hbMV0gPSBuZXdZO1xuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKSxcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQobmV3WCl9ICR7T3V0bGluZS5zdmdSb3VuZChuZXdZKX1gXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXQgZGVmYXVsdFNWR1Byb3BlcnRpZXMoKSB7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICB9LFxuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGRyYXc6IHRydWVcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKCksXG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKGJib3hbMF0pfSAke091dGxpbmUuc3ZnUm91bmQoYmJveFsxXSl9YCxcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnJvdGF0aW9uVHJhbnNmb3JtIHx8IG51bGxcbiAgICAgIH0sXG4gICAgICBiYm94XG4gICAgfTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvaW5rLmpzXG5cblxuXG5cblxuXG5jbGFzcyBJbmtEcmF3aW5nT3B0aW9ucyBleHRlbmRzIERyYXdpbmdPcHRpb25zIHtcbiAgY29uc3RydWN0b3Iodmlld2VyUGFyYW1ldGVycykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fdmlld1BhcmFtZXRlcnMgPSB2aWV3ZXJQYXJhbWV0ZXJzO1xuICAgIHN1cGVyLnVwZGF0ZVByb3BlcnRpZXMoe1xuICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICBzdHJva2U6IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3IsXG4gICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IDEsXG4gICAgICBcInN0cm9rZS13aWR0aFwiOiAxLFxuICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiBcInJvdW5kXCIsXG4gICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIsXG4gICAgICBcInN0cm9rZS1taXRlcmxpbWl0XCI6IDEwXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlU1ZHUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJzdHJva2Utd2lkdGhcIikge1xuICAgICAgdmFsdWUgPz89IHRoaXNbXCJzdHJva2Utd2lkdGhcIl07XG4gICAgICB2YWx1ZSAqPSB0aGlzLl92aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gICAgfVxuICAgIHN1cGVyLnVwZGF0ZVNWR1Byb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBJbmtEcmF3aW5nT3B0aW9ucyh0aGlzLl92aWV3UGFyYW1ldGVycyk7XG4gICAgY2xvbmUudXBkYXRlQWxsKHRoaXMpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuY2xhc3MgSW5rRWRpdG9yIGV4dGVuZHMgRHJhd2luZ0VkaXRvciB7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaW5rXCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLklOSztcbiAgc3RhdGljIF9kZWZhdWx0RHJhd2luZ09wdGlvbnMgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImlua0VkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgdGhpcy5kZWZhdWx0TDEwbklkID0gXCJwZGZqcy1lZGl0b3ItaW5rLWVkaXRvclwiO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucyA9IG5ldyBJbmtEcmF3aW5nT3B0aW9ucyh1aU1hbmFnZXIudmlld1BhcmFtZXRlcnMpO1xuICB9XG4gIHN0YXRpYyBnZXREZWZhdWx0RHJhd2luZ09wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IGNsb25lID0gdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLmNsb25lKCk7XG4gICAgY2xvbmUudXBkYXRlUHJvcGVydGllcyhvcHRpb25zKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgc3RhdGljIGdldCBzdXBwb3J0TXVsdGlwbGVEcmF3aW5ncygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGVzTWFwKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJ0eXBlc01hcFwiLCBuZXcgTWFwKFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUywgXCJzdHJva2Utd2lkdGhcIl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1IsIFwic3Ryb2tlXCJdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksIFwic3Ryb2tlLW9wYWNpdHlcIl1dKSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZURyYXdlckluc3RhbmNlKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBJbmtEcmF3T3V0bGluZXIoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24sIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9uc1tcInN0cm9rZS13aWR0aFwiXSk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplRHJhdyhwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgaW5uZXJNYXJnaW4sIGRhdGEpIHtcbiAgICByZXR1cm4gSW5rRHJhd091dGxpbmUuZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgSW5rQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlua0xpc3RzLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICBib3JkZXJTdHlsZToge1xuICAgICAgICAgICAgcmF3V2lkdGg6IHRoaWNrbmVzc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgY29udGVudHNPYmpcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkssXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGNvbG9yKSxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBwYXRoczoge1xuICAgICAgICAgIHBvaW50czogaW5rTGlzdHNcbiAgICAgICAgfSxcbiAgICAgICAgYm94ZXM6IG51bGwsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBpZCxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgY29tbWVudDogY29udGVudHNPYmo/LnN0ciB8fCBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIGlmIChkYXRhLmNvbW1lbnQpIHtcbiAgICAgIGVkaXRvci5zZXRDb21tZW50RGF0YShkYXRhLmNvbW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICB0aGlzLl9jb2xvclBpY2tlciB8fD0gbmV3IEJhc2ljQ29sb3JQaWNrZXIodGhpcyk7XG4gICAgcmV0dXJuIFtbXCJjb2xvclBpY2tlclwiLCB0aGlzLl9jb2xvclBpY2tlcl1dO1xuICB9XG4gIGdldCBjb2xvclR5cGUoKSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUjtcbiAgfVxuICBnZXQgY29sb3JWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJhd2luZ09wdGlvbnMuc3Ryb2tlO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLm9uU2NhbGVDaGFuZ2luZygpO1xuICAgIGNvbnN0IHtcbiAgICAgIF9kcmF3SWQsXG4gICAgICBfZHJhd2luZ09wdGlvbnMsXG4gICAgICBwYXJlbnRcbiAgICB9ID0gdGhpcztcbiAgICBfZHJhd2luZ09wdGlvbnMudXBkYXRlU1ZHUHJvcGVydHkoXCJzdHJva2Utd2lkdGhcIik7XG4gICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKF9kcmF3SWQsIF9kcmF3aW5nT3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSk7XG4gIH1cbiAgc3RhdGljIG9uU2NhbGVDaGFuZ2luZ1doZW5EcmF3aW5nKCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2N1cnJlbnRQYXJlbnQ7XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIub25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmcoKTtcbiAgICB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMudXBkYXRlU1ZHUHJvcGVydHkoXCJzdHJva2Utd2lkdGhcIik7XG4gICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSk7XG4gIH1cbiAgY3JlYXRlRHJhd2luZ09wdGlvbnMoe1xuICAgIGNvbG9yLFxuICAgIHRoaWNrbmVzcyxcbiAgICBvcGFjaXR5XG4gIH0pIHtcbiAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucyA9IElua0VkaXRvci5nZXREZWZhdWx0RHJhd2luZ09wdGlvbnMoe1xuICAgICAgc3Ryb2tlOiBVdGlsLm1ha2VIZXhDb2xvciguLi5jb2xvciksXG4gICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlja25lc3MsXG4gICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IG9wYWNpdHlcbiAgICB9KTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxpbmVzLFxuICAgICAgcG9pbnRzLFxuICAgICAgcmVjdFxuICAgIH0gPSB0aGlzLnNlcmlhbGl6ZURyYXcoaXNGb3JDb3B5aW5nKTtcbiAgICBjb25zdCB7XG4gICAgICBfZHJhd2luZ09wdGlvbnM6IHtcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IG9wYWNpdHksXG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaWNrbmVzc1xuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LLFxuICAgICAgY29sb3I6IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHN0cm9rZSksXG4gICAgICBvcGFjaXR5LFxuICAgICAgdGhpY2tuZXNzLFxuICAgICAgcGF0aHM6IHtcbiAgICAgICAgbGluZXMsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tZW50KHNlcmlhbGl6ZWQpO1xuICAgIGlmIChpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHNlcmlhbGl6ZWQuaXNDb3B5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICF0aGlzLiNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2xvcixcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIG9wYWNpdHksXG4gICAgICBwYWdlSW5kZXhcbiAgICB9ID0gdGhpcy5faW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIHRoaXMuaGFzRWRpdGVkQ29tbWVudCB8fCB0aGlzLl9oYXNCZWVuTW92ZWQgfHwgdGhpcy5faGFzQmVlblJlc2l6ZWQgfHwgc2VyaWFsaXplZC5jb2xvci5zb21lKChjLCBpKSA9PiBjICE9PSBjb2xvcltpXSkgfHwgc2VyaWFsaXplZC50aGlja25lc3MgIT09IHRoaWNrbmVzcyB8fCBzZXJpYWxpemVkLm9wYWNpdHkgIT09IG9wYWNpdHkgfHwgc2VyaWFsaXplZC5wYWdlSW5kZXggIT09IHBhZ2VJbmRleDtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgYW5ub3RhdGlvbi5oaWRlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcG9pbnRzLFxuICAgICAgcmVjdFxuICAgIH0gPSB0aGlzLnNlcmlhbGl6ZURyYXcoZmFsc2UpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIHJlY3QsXG4gICAgICB0aGlja25lc3M6IHRoaXMuX2RyYXdpbmdPcHRpb25zW1wic3Ryb2tlLXdpZHRoXCJdLFxuICAgICAgcG9pbnRzXG4gICAgfTtcbiAgICBpZiAodGhpcy5oYXNFZGl0ZWRDb21tZW50KSB7XG4gICAgICBwYXJhbXMucG9wdXAgPSB0aGlzLmNvbW1lbnQ7XG4gICAgfVxuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHBhcmFtcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvY29udG91ci5qc1xuXG5jbGFzcyBDb250b3VyRHJhd091dGxpbmUgZXh0ZW5kcyBJbmtEcmF3T3V0bGluZSB7XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBsZXQgcGF0aCA9IHN1cGVyLnRvU1ZHUGF0aCgpO1xuICAgIGlmICghcGF0aC5lbmRzV2l0aChcIlpcIikpIHtcbiAgICAgIHBhdGggKz0gXCJaXCI7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL3NpZ25hdHVyZWRyYXcuanNcblxuXG5cblxuY29uc3QgQkFTRV9IRUFERVJfTEVOR1RIID0gODtcbmNvbnN0IFBPSU5UU19QUk9QRVJUSUVTX05VTUJFUiA9IDM7XG5jbGFzcyBTaWduYXR1cmVFeHRyYWN0b3Ige1xuICBzdGF0aWMgI1BBUkFNRVRFUlMgPSB7XG4gICAgbWF4RGltOiA1MTIsXG4gICAgc2lnbWFTRmFjdG9yOiAwLjAyLFxuICAgIHNpZ21hUjogMjUsXG4gICAga2VybmVsU2l6ZTogMTZcbiAgfTtcbiAgc3RhdGljICNuZWlnaGJvckluZGV4VG9JZChpMCwgajAsIGksIGopIHtcbiAgICBpIC09IGkwO1xuICAgIGogLT0gajA7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHJldHVybiBqID4gMCA/IDAgOiA0O1xuICAgIH1cbiAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGogKyA2O1xuICAgIH1cbiAgICByZXR1cm4gMiAtIGo7XG4gIH1cbiAgc3RhdGljICNuZWlnaGJvcklkVG9JbmRleCA9IG5ldyBJbnQzMkFycmF5KFswLCAxLCAtMSwgMSwgLTEsIDAsIC0xLCAtMSwgMCwgLTEsIDEsIC0xLCAxLCAwLCAxLCAxXSk7XG4gIHN0YXRpYyAjY2xvY2t3aXNlTm9uWmVybyhidWYsIHdpZHRoLCBpMCwgajAsIGksIGosIG9mZnNldCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy4jbmVpZ2hib3JJbmRleFRvSWQoaTAsIGowLCBpLCBqKTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgY29uc3Qga2sgPSAoLWsgKyBpZCAtIG9mZnNldCArIDE2KSAlIDg7XG4gICAgICBjb25zdCBzaGlmdEkgPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2tdO1xuICAgICAgY29uc3Qgc2hpZnRKID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrICsgMV07XG4gICAgICBpZiAoYnVmWyhpMCArIHNoaWZ0SSkgKiB3aWR0aCArIChqMCArIHNoaWZ0SildICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBraztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHN0YXRpYyAjY291bnRlckNsb2Nrd2lzZU5vblplcm8oYnVmLCB3aWR0aCwgaTAsIGowLCBpLCBqLCBvZmZzZXQpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuI25laWdoYm9ySW5kZXhUb0lkKGkwLCBqMCwgaSwgaik7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGNvbnN0IGtrID0gKGsgKyBpZCArIG9mZnNldCArIDE2KSAlIDg7XG4gICAgICBjb25zdCBzaGlmdEkgPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2tdO1xuICAgICAgY29uc3Qgc2hpZnRKID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrICsgMV07XG4gICAgICBpZiAoYnVmWyhpMCArIHNoaWZ0SSkgKiB3aWR0aCArIChqMCArIHNoaWZ0SildICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBraztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHN0YXRpYyAjZmluZENvbnRvdXJzKGJ1Ziwgd2lkdGgsIGhlaWdodCwgdGhyZXNob2xkKSB7XG4gICAgY29uc3QgTiA9IGJ1Zi5sZW5ndGg7XG4gICAgY29uc3QgdHlwZXMgPSBuZXcgSW50MzJBcnJheShOKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdHlwZXNbaV0gPSBidWZbaV0gPD0gdGhyZXNob2xkID8gMSA6IDA7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVpZ2h0IC0gMTsgaSsrKSB7XG4gICAgICB0eXBlc1tpICogd2lkdGhdID0gdHlwZXNbaSAqIHdpZHRoICsgd2lkdGggLSAxXSA9IDA7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgdHlwZXNbaV0gPSB0eXBlc1t3aWR0aCAqIGhlaWdodCAtIDEgLSBpXSA9IDA7XG4gICAgfVxuICAgIGxldCBuYmQgPSAxO1xuICAgIGxldCBsbmJkO1xuICAgIGNvbnN0IGNvbnRvdXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBoZWlnaHQgLSAxOyBpKyspIHtcbiAgICAgIGxuYmQgPSAxO1xuICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCB3aWR0aCAtIDE7IGorKykge1xuICAgICAgICBjb25zdCBpaiA9IGkgKiB3aWR0aCArIGo7XG4gICAgICAgIGNvbnN0IHBpeCA9IHR5cGVzW2lqXTtcbiAgICAgICAgaWYgKHBpeCA9PT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpMiA9IGk7XG4gICAgICAgIGxldCBqMiA9IGo7XG4gICAgICAgIGlmIChwaXggPT09IDEgJiYgdHlwZXNbaWogLSAxXSA9PT0gMCkge1xuICAgICAgICAgIG5iZCArPSAxO1xuICAgICAgICAgIGoyIC09IDE7XG4gICAgICAgIH0gZWxzZSBpZiAocGl4ID49IDEgJiYgdHlwZXNbaWogKyAxXSA9PT0gMCkge1xuICAgICAgICAgIG5iZCArPSAxO1xuICAgICAgICAgIGoyICs9IDE7XG4gICAgICAgICAgaWYgKHBpeCA+IDEpIHtcbiAgICAgICAgICAgIGxuYmQgPSBwaXg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwaXggIT09IDEpIHtcbiAgICAgICAgICAgIGxuYmQgPSBNYXRoLmFicyhwaXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludHMgPSBbaiwgaV07XG4gICAgICAgIGNvbnN0IGlzSG9sZSA9IGoyID09PSBqICsgMTtcbiAgICAgICAgY29uc3QgY29udG91ciA9IHtcbiAgICAgICAgICBpc0hvbGUsXG4gICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgIGlkOiBuYmQsXG4gICAgICAgICAgcGFyZW50OiAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnRvdXJzLnB1c2goY29udG91cik7XG4gICAgICAgIGxldCBjb250b3VyMDtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvbnRvdXJzKSB7XG4gICAgICAgICAgaWYgKGMuaWQgPT09IGxuYmQpIHtcbiAgICAgICAgICAgIGNvbnRvdXIwID0gYztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRvdXIwKSB7XG4gICAgICAgICAgY29udG91ci5wYXJlbnQgPSBpc0hvbGUgPyBsbmJkIDogMDtcbiAgICAgICAgfSBlbHNlIGlmIChjb250b3VyMC5pc0hvbGUpIHtcbiAgICAgICAgICBjb250b3VyLnBhcmVudCA9IGlzSG9sZSA/IGNvbnRvdXIwLnBhcmVudCA6IGxuYmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udG91ci5wYXJlbnQgPSBpc0hvbGUgPyBsbmJkIDogY29udG91cjAucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLiNjbG9ja3dpc2VOb25aZXJvKHR5cGVzLCB3aWR0aCwgaSwgaiwgaTIsIGoyLCAwKTtcbiAgICAgICAgaWYgKGsgPT09IC0xKSB7XG4gICAgICAgICAgdHlwZXNbaWpdID0gLW5iZDtcbiAgICAgICAgICBpZiAodHlwZXNbaWpdICE9PSAxKSB7XG4gICAgICAgICAgICBsbmJkID0gTWF0aC5hYnModHlwZXNbaWpdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNoaWZ0SSA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBrXTtcbiAgICAgICAgbGV0IHNoaWZ0SiA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBrICsgMV07XG4gICAgICAgIGNvbnN0IGkxID0gaSArIHNoaWZ0STtcbiAgICAgICAgY29uc3QgajEgPSBqICsgc2hpZnRKO1xuICAgICAgICBpMiA9IGkxO1xuICAgICAgICBqMiA9IGoxO1xuICAgICAgICBsZXQgaTMgPSBpO1xuICAgICAgICBsZXQgajMgPSBqO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IGtrID0gdGhpcy4jY291bnRlckNsb2Nrd2lzZU5vblplcm8odHlwZXMsIHdpZHRoLCBpMywgajMsIGkyLCBqMiwgMSk7XG4gICAgICAgICAgc2hpZnRJID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrXTtcbiAgICAgICAgICBzaGlmdEogPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2sgKyAxXTtcbiAgICAgICAgICBjb25zdCBpNCA9IGkzICsgc2hpZnRJO1xuICAgICAgICAgIGNvbnN0IGo0ID0gajMgKyBzaGlmdEo7XG4gICAgICAgICAgcG9pbnRzLnB1c2goajQsIGk0KTtcbiAgICAgICAgICBjb25zdCBpajMgPSBpMyAqIHdpZHRoICsgajM7XG4gICAgICAgICAgaWYgKHR5cGVzW2lqMyArIDFdID09PSAwKSB7XG4gICAgICAgICAgICB0eXBlc1tpajNdID0gLW5iZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVzW2lqM10gPT09IDEpIHtcbiAgICAgICAgICAgIHR5cGVzW2lqM10gPSBuYmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpNCA9PT0gaSAmJiBqNCA9PT0gaiAmJiBpMyA9PT0gaTEgJiYgajMgPT09IGoxKSB7XG4gICAgICAgICAgICBpZiAodHlwZXNbaWpdICE9PSAxKSB7XG4gICAgICAgICAgICAgIGxuYmQgPSBNYXRoLmFicyh0eXBlc1tpal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkyID0gaTM7XG4gICAgICAgICAgICBqMiA9IGozO1xuICAgICAgICAgICAgaTMgPSBpNDtcbiAgICAgICAgICAgIGozID0gajQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250b3VycztcbiAgfVxuICBzdGF0aWMgI2RvdWdsYXNQZXVja2VySGVscGVyKHBvaW50cywgc3RhcnQsIGVuZCwgb3V0cHV0KSB7XG4gICAgaWYgKGVuZCAtIHN0YXJ0IDw9IDQpIHtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZCAtIDI7IGkgKz0gMikge1xuICAgICAgICBvdXRwdXQucHVzaChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBheCA9IHBvaW50c1tzdGFydF07XG4gICAgY29uc3QgYXkgPSBwb2ludHNbc3RhcnQgKyAxXTtcbiAgICBjb25zdCBhYnggPSBwb2ludHNbZW5kIC0gNF0gLSBheDtcbiAgICBjb25zdCBhYnkgPSBwb2ludHNbZW5kIC0gM10gLSBheTtcbiAgICBjb25zdCBkaXN0ID0gTWF0aC5oeXBvdChhYngsIGFieSk7XG4gICAgY29uc3QgbmFieCA9IGFieCAvIGRpc3Q7XG4gICAgY29uc3QgbmFieSA9IGFieSAvIGRpc3Q7XG4gICAgY29uc3QgYWEgPSBuYWJ4ICogYXkgLSBuYWJ5ICogYXg7XG4gICAgY29uc3QgbSA9IGFieSAvIGFieDtcbiAgICBjb25zdCBpbnZTID0gMSAvIGRpc3Q7XG4gICAgY29uc3QgcGhpID0gTWF0aC5hdGFuKG0pO1xuICAgIGNvbnN0IGNvc1BoaSA9IE1hdGguY29zKHBoaSk7XG4gICAgY29uc3Qgc2luUGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICBjb25zdCB0bWF4ID0gaW52UyAqIChNYXRoLmFicyhjb3NQaGkpICsgTWF0aC5hYnMoc2luUGhpKSk7XG4gICAgY29uc3QgcG9seSA9IGludlMgKiAoMSAtIHRtYXggKyB0bWF4ICoqIDIpO1xuICAgIGNvbnN0IHBhcnRpYWxQaGkgPSBNYXRoLm1heChNYXRoLmF0YW4oTWF0aC5hYnMoc2luUGhpICsgY29zUGhpKSAqIHBvbHkpLCBNYXRoLmF0YW4oTWF0aC5hYnMoc2luUGhpIC0gY29zUGhpKSAqIHBvbHkpKTtcbiAgICBsZXQgZG1heCA9IDA7XG4gICAgbGV0IGluZGV4ID0gc3RhcnQ7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0ICsgMjsgaSA8IGVuZCAtIDI7IGkgKz0gMikge1xuICAgICAgY29uc3QgZCA9IE1hdGguYWJzKGFhIC0gbmFieCAqIHBvaW50c1tpICsgMV0gKyBuYWJ5ICogcG9pbnRzW2ldKTtcbiAgICAgIGlmIChkID4gZG1heCkge1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIGRtYXggPSBkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZG1heCA+IChkaXN0ICogcGFydGlhbFBoaSkgKiogMikge1xuICAgICAgdGhpcy4jZG91Z2xhc1BldWNrZXJIZWxwZXIocG9pbnRzLCBzdGFydCwgaW5kZXggKyAyLCBvdXRwdXQpO1xuICAgICAgdGhpcy4jZG91Z2xhc1BldWNrZXJIZWxwZXIocG9pbnRzLCBpbmRleCwgZW5kLCBvdXRwdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaChheCwgYXkpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgI2RvdWdsYXNQZXVja2VyKHBvaW50cykge1xuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgdGhpcy4jZG91Z2xhc1BldWNrZXJIZWxwZXIocG9pbnRzLCAwLCBsZW4sIG91dHB1dCk7XG4gICAgb3V0cHV0LnB1c2gocG9pbnRzW2xlbiAtIDJdLCBwb2ludHNbbGVuIC0gMV0pO1xuICAgIHJldHVybiBvdXRwdXQubGVuZ3RoIDw9IDQgPyBudWxsIDogb3V0cHV0O1xuICB9XG4gIHN0YXRpYyAjYmlsYXRlcmFsRmlsdGVyKGJ1Ziwgd2lkdGgsIGhlaWdodCwgc2lnbWFTLCBzaWdtYVIsIGtlcm5lbFNpemUpIHtcbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgRmxvYXQzMkFycmF5KGtlcm5lbFNpemUgKiogMik7XG4gICAgY29uc3Qgc2lnbWFTMiA9IC0yICogc2lnbWFTICoqIDI7XG4gICAgY29uc3QgaGFsZlNpemUgPSBrZXJuZWxTaXplID4+IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSAoaSAtIGhhbGZTaXplKSAqKiAyO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXJuZWxTaXplOyBqKyspIHtcbiAgICAgICAga2VybmVsW2kgKiBrZXJuZWxTaXplICsgal0gPSBNYXRoLmV4cCgoeCArIChqIC0gaGFsZlNpemUpICoqIDIpIC8gc2lnbWFTMik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSgyNTYpO1xuICAgIGNvbnN0IHNpZ21hUjIgPSAtMiAqIHNpZ21hUiAqKiAyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIHJhbmdlVmFsdWVzW2ldID0gTWF0aC5leHAoaSAqKiAyIC8gc2lnbWFSMik7XG4gICAgfVxuICAgIGNvbnN0IE4gPSBidWYubGVuZ3RoO1xuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KE4pO1xuICAgIGNvbnN0IGhpc3RvZ3JhbSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgICBjb25zdCBpaiA9IGkgKiB3aWR0aCArIGo7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGJ1Zltpal07XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgbm9ybSA9IDA7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwga2VybmVsU2l6ZTsgaysrKSB7XG4gICAgICAgICAgY29uc3QgeSA9IGkgKyBrIC0gaGFsZlNpemU7XG4gICAgICAgICAgaWYgKHkgPCAwIHx8IHkgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCBrZXJuZWxTaXplOyBsKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBqICsgbCAtIGhhbGZTaXplO1xuICAgICAgICAgICAgaWYgKHggPCAwIHx8IHggPj0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZWlnaGJvdXIgPSBidWZbeSAqIHdpZHRoICsgeF07XG4gICAgICAgICAgICBjb25zdCB3ID0ga2VybmVsW2sgKiBrZXJuZWxTaXplICsgbF0gKiByYW5nZVZhbHVlc1tNYXRoLmFicyhuZWlnaGJvdXIgLSBjZW50ZXIpXTtcbiAgICAgICAgICAgIHN1bSArPSBuZWlnaGJvdXIgKiB3O1xuICAgICAgICAgICAgbm9ybSArPSB3O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaXggPSBvdXRbaWpdID0gTWF0aC5yb3VuZChzdW0gLyBub3JtKTtcbiAgICAgICAgaGlzdG9ncmFtW3BpeF0rKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtvdXQsIGhpc3RvZ3JhbV07XG4gIH1cbiAgc3RhdGljICNnZXRIaXN0b2dyYW0oYnVmKSB7XG4gICAgY29uc3QgaGlzdG9ncmFtID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgZm9yIChjb25zdCBnIG9mIGJ1Zikge1xuICAgICAgaGlzdG9ncmFtW2ddKys7XG4gICAgfVxuICAgIHJldHVybiBoaXN0b2dyYW07XG4gIH1cbiAgc3RhdGljICN0b1VpbnQ4KGJ1Zikge1xuICAgIGNvbnN0IE4gPSBidWYubGVuZ3RoO1xuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OENsYW1wZWRBcnJheShOID4+IDIpO1xuICAgIGxldCBtYXggPSAtSW5maW5pdHk7XG4gICAgbGV0IG1pbiA9IEluZmluaXR5O1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG91dC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBwaXggPSBvdXRbaV0gPSBidWZbaSA8PCAyXTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcGl4KTtcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcGl4KTtcbiAgICB9XG4gICAgY29uc3QgcmF0aW8gPSAyNTUgLyAobWF4IC0gbWluKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBvdXQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgb3V0W2ldID0gKG91dFtpXSAtIG1pbikgKiByYXRpbztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBzdGF0aWMgI2d1ZXNzVGhyZXNob2xkKGhpc3RvZ3JhbSkge1xuICAgIGxldCBpO1xuICAgIGxldCBNID0gLUluZmluaXR5O1xuICAgIGxldCBMID0gLUluZmluaXR5O1xuICAgIGNvbnN0IG1pbiA9IGhpc3RvZ3JhbS5maW5kSW5kZXgodiA9PiB2ICE9PSAwKTtcbiAgICBsZXQgcG9zID0gbWluO1xuICAgIGxldCBzcG9zID0gbWluO1xuICAgIGZvciAoaSA9IG1pbjsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBjb25zdCB2ID0gaGlzdG9ncmFtW2ldO1xuICAgICAgaWYgKHYgPiBNKSB7XG4gICAgICAgIGlmIChpIC0gcG9zID4gTCkge1xuICAgICAgICAgIEwgPSBpIC0gcG9zO1xuICAgICAgICAgIHNwb3MgPSBpIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBNID0gdjtcbiAgICAgICAgcG9zID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gc3BvcyAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoaGlzdG9ncmFtW2ldID4gaGlzdG9ncmFtW2kgKyAxXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgc3RhdGljICNnZXRHcmF5UGl4ZWxzKGJpdG1hcCkge1xuICAgIGNvbnN0IG9yaWdpbmFsQml0bWFwID0gYml0bWFwO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGJpdG1hcDtcbiAgICBjb25zdCB7XG4gICAgICBtYXhEaW1cbiAgICB9ID0gdGhpcy4jUEFSQU1FVEVSUztcbiAgICBsZXQgbmV3V2lkdGggPSB3aWR0aDtcbiAgICBsZXQgbmV3SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGlmICh3aWR0aCA+IG1heERpbSB8fCBoZWlnaHQgPiBtYXhEaW0pIHtcbiAgICAgIGxldCBwcmV2V2lkdGggPSB3aWR0aDtcbiAgICAgIGxldCBwcmV2SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgbGV0IHN0ZXBzID0gTWF0aC5sb2cyKE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpIC8gbWF4RGltKTtcbiAgICAgIGNvbnN0IGlzdGVwcyA9IE1hdGguZmxvb3Ioc3RlcHMpO1xuICAgICAgc3RlcHMgPSBzdGVwcyA9PT0gaXN0ZXBzID8gaXN0ZXBzIC0gMSA6IGlzdGVwcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RlcHM7IGkrKykge1xuICAgICAgICBuZXdXaWR0aCA9IE1hdGguY2VpbChwcmV2V2lkdGggLyAyKTtcbiAgICAgICAgbmV3SGVpZ2h0ID0gTWF0aC5jZWlsKHByZXZIZWlnaHQgLyAyKTtcbiAgICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICAgIHByZXZXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICBwcmV2SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICBpZiAoYml0bWFwICE9PSBvcmlnaW5hbEJpdG1hcCkge1xuICAgICAgICAgIGJpdG1hcC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJpdG1hcCA9IG9mZnNjcmVlbi50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4obWF4RGltIC8gbmV3V2lkdGgsIG1heERpbSAvIG5ld0hlaWdodCk7XG4gICAgICBuZXdXaWR0aCA9IE1hdGgucm91bmQobmV3V2lkdGggKiByYXRpbyk7XG4gICAgICBuZXdIZWlnaHQgPSBNYXRoLnJvdW5kKG5ld0hlaWdodCAqIHJhdGlvKTtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgIGN0eC5maWx0ZXIgPSBcImdyYXlzY2FsZSgxKVwiO1xuICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgIGNvbnN0IGdyYXlJbWFnZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCkuZGF0YTtcbiAgICBjb25zdCB1aW50OEJ1ZiA9IHRoaXMuI3RvVWludDgoZ3JheUltYWdlKTtcbiAgICByZXR1cm4gW3VpbnQ4QnVmLCBuZXdXaWR0aCwgbmV3SGVpZ2h0XTtcbiAgfVxuICBzdGF0aWMgZXh0cmFjdENvbnRvdXJzRnJvbVRleHQodGV4dCwge1xuICAgIGZvbnRGYW1pbHksXG4gICAgZm9udFN0eWxlLFxuICAgIGZvbnRXZWlnaHRcbiAgfSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCByb3RhdGlvbiwgaW5uZXJNYXJnaW4pIHtcbiAgICBsZXQgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKTtcbiAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCBmb250U2l6ZSA9IDIwMDtcbiAgICBjb25zdCBmb250ID0gY3R4LmZvbnQgPSBgJHtmb250U3R5bGV9ICR7Zm9udFdlaWdodH0gJHtmb250U2l6ZX1weCAke2ZvbnRGYW1pbHl9YDtcbiAgICBjb25zdCB7XG4gICAgICBhY3R1YWxCb3VuZGluZ0JveExlZnQsXG4gICAgICBhY3R1YWxCb3VuZGluZ0JveFJpZ2h0LFxuICAgICAgYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICBhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICBmb250Qm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICBmb250Qm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgd2lkdGhcbiAgICB9ID0gY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgIGNvbnN0IFNDQUxFID0gMS41O1xuICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gTWF0aC5jZWlsKE1hdGgubWF4KE1hdGguYWJzKGFjdHVhbEJvdW5kaW5nQm94TGVmdCkgKyBNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveFJpZ2h0KSB8fCAwLCB3aWR0aCkgKiBTQ0FMRSk7XG4gICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubWF4KE1hdGguYWJzKGFjdHVhbEJvdW5kaW5nQm94QXNjZW50KSArIE1hdGguYWJzKGFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCkgfHwgZm9udFNpemUsIE1hdGguYWJzKGZvbnRCb3VuZGluZ0JveEFzY2VudCkgKyBNYXRoLmFicyhmb250Qm91bmRpbmdCb3hEZXNjZW50KSB8fCBmb250U2l6ZSkgKiBTQ0FMRSk7XG4gICAgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgfSk7XG4gICAgY3R4LmZvbnQgPSBmb250O1xuICAgIGN0eC5maWx0ZXIgPSBcImdyYXlzY2FsZSgxKVwiO1xuICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgY3R4LmZpbGxUZXh0KHRleHQsIGNhbnZhc1dpZHRoICogKFNDQUxFIC0gMSkgLyAyLCBjYW52YXNIZWlnaHQgKiAoMyAtIFNDQUxFKSAvIDIpO1xuICAgIGNvbnN0IHVpbnQ4QnVmID0gdGhpcy4jdG9VaW50OChjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpLmRhdGEpO1xuICAgIGNvbnN0IGhpc3RvZ3JhbSA9IHRoaXMuI2dldEhpc3RvZ3JhbSh1aW50OEJ1Zik7XG4gICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy4jZ3Vlc3NUaHJlc2hvbGQoaGlzdG9ncmFtKTtcbiAgICBjb25zdCBjb250b3VyTGlzdCA9IHRoaXMuI2ZpbmRDb250b3Vycyh1aW50OEJ1ZiwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCwgdGhyZXNob2xkKTtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgICBsaW5lczoge1xuICAgICAgICBjdXJ2ZXM6IGNvbnRvdXJMaXN0LFxuICAgICAgICB3aWR0aDogY2FudmFzV2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzSGVpZ2h0XG4gICAgICB9LFxuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgaW5uZXJNYXJnaW4sXG4gICAgICBtdXN0U21vb3RoOiB0cnVlLFxuICAgICAgYXJlQ29udG91cnM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgcHJvY2VzcyhiaXRtYXAsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgcm90YXRpb24sIGlubmVyTWFyZ2luKSB7XG4gICAgY29uc3QgW3VpbnQ4QnVmLCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2dldEdyYXlQaXhlbHMoYml0bWFwKTtcbiAgICBjb25zdCBbYnVmZmVyLCBoaXN0b2dyYW1dID0gdGhpcy4jYmlsYXRlcmFsRmlsdGVyKHVpbnQ4QnVmLCB3aWR0aCwgaGVpZ2h0LCBNYXRoLmh5cG90KHdpZHRoLCBoZWlnaHQpICogdGhpcy4jUEFSQU1FVEVSUy5zaWdtYVNGYWN0b3IsIHRoaXMuI1BBUkFNRVRFUlMuc2lnbWFSLCB0aGlzLiNQQVJBTUVURVJTLmtlcm5lbFNpemUpO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuI2d1ZXNzVGhyZXNob2xkKGhpc3RvZ3JhbSk7XG4gICAgY29uc3QgY29udG91ckxpc3QgPSB0aGlzLiNmaW5kQ29udG91cnMoYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCB0aHJlc2hvbGQpO1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NEcmF3bkxpbmVzKHtcbiAgICAgIGxpbmVzOiB7XG4gICAgICAgIGN1cnZlczogY29udG91ckxpc3QsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0sXG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0LFxuICAgICAgcm90YXRpb24sXG4gICAgICBpbm5lck1hcmdpbixcbiAgICAgIG11c3RTbW9vdGg6IHRydWUsXG4gICAgICBhcmVDb250b3VyczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBwcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgbGluZXMsXG4gICAgcGFnZVdpZHRoLFxuICAgIHBhZ2VIZWlnaHQsXG4gICAgcm90YXRpb24sXG4gICAgaW5uZXJNYXJnaW4sXG4gICAgbXVzdFNtb290aCxcbiAgICBhcmVDb250b3Vyc1xuICB9KSB7XG4gICAgaWYgKHJvdGF0aW9uICUgMTgwICE9PSAwKSB7XG4gICAgICBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IFtwYWdlSGVpZ2h0LCBwYWdlV2lkdGhdO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjdXJ2ZXMsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBsaW5lcztcbiAgICBjb25zdCB0aGlja25lc3MgPSBsaW5lcy50aGlja25lc3MgPz8gMDtcbiAgICBjb25zdCBsaW5lc0FuZFBvaW50cyA9IFtdO1xuICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4ocGFnZVdpZHRoIC8gd2lkdGgsIHBhZ2VIZWlnaHQgLyBoZWlnaHQpO1xuICAgIGNvbnN0IHhTY2FsZSA9IHJhdGlvIC8gcGFnZVdpZHRoO1xuICAgIGNvbnN0IHlTY2FsZSA9IHJhdGlvIC8gcGFnZUhlaWdodDtcbiAgICBjb25zdCBuZXdDdXJ2ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHBvaW50c1xuICAgIH0gb2YgY3VydmVzKSB7XG4gICAgICBjb25zdCByZWR1Y2VkUG9pbnRzID0gbXVzdFNtb290aCA/IHRoaXMuI2RvdWdsYXNQZXVja2VyKHBvaW50cykgOiBwb2ludHM7XG4gICAgICBpZiAoIXJlZHVjZWRQb2ludHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBuZXdDdXJ2ZXMucHVzaChyZWR1Y2VkUG9pbnRzKTtcbiAgICAgIGNvbnN0IGxlbiA9IHJlZHVjZWRQb2ludHMubGVuZ3RoO1xuICAgICAgY29uc3QgbmV3UG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICAgICAgY29uc3QgbGluZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyAqIChsZW4gPT09IDIgPyAyIDogbGVuIC0gMikpO1xuICAgICAgbGluZXNBbmRQb2ludHMucHVzaCh7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50czogbmV3UG9pbnRzXG4gICAgICB9KTtcbiAgICAgIGlmIChsZW4gPT09IDIpIHtcbiAgICAgICAgbmV3UG9pbnRzWzBdID0gcmVkdWNlZFBvaW50c1swXSAqIHhTY2FsZTtcbiAgICAgICAgbmV3UG9pbnRzWzFdID0gcmVkdWNlZFBvaW50c1sxXSAqIHlTY2FsZTtcbiAgICAgICAgbGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgbmV3UG9pbnRzWzBdLCBuZXdQb2ludHNbMV1dLCAwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgW3gxLCB5MSwgeDIsIHkyXSA9IHJlZHVjZWRQb2ludHM7XG4gICAgICB4MSAqPSB4U2NhbGU7XG4gICAgICB5MSAqPSB5U2NhbGU7XG4gICAgICB4MiAqPSB4U2NhbGU7XG4gICAgICB5MiAqPSB5U2NhbGU7XG4gICAgICBuZXdQb2ludHMuc2V0KFt4MSwgeTEsIHgyLCB5Ml0sIDApO1xuICAgICAgbGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgeDEsIHkxXSwgMCk7XG4gICAgICBmb3IgKGxldCBpID0gNDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHggPSBuZXdQb2ludHNbaV0gPSByZWR1Y2VkUG9pbnRzW2ldICogeFNjYWxlO1xuICAgICAgICBjb25zdCB5ID0gbmV3UG9pbnRzW2kgKyAxXSA9IHJlZHVjZWRQb2ludHNbaSArIDFdICogeVNjYWxlO1xuICAgICAgICBsaW5lLnNldChPdXRsaW5lLmNyZWF0ZUJlemllclBvaW50cyh4MSwgeTEsIHgyLCB5MiwgeCwgeSksIChpIC0gMikgKiAzKTtcbiAgICAgICAgW3gxLCB5MSwgeDIsIHkyXSA9IFt4MiwgeTIsIHgsIHldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGluZXNBbmRQb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZSA9IGFyZUNvbnRvdXJzID8gbmV3IENvbnRvdXJEcmF3T3V0bGluZSgpIDogbmV3IElua0RyYXdPdXRsaW5lKCk7XG4gICAgb3V0bGluZS5idWlsZChsaW5lc0FuZFBvaW50cywgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCAxLCByb3RhdGlvbiwgYXJlQ29udG91cnMgPyAwIDogdGhpY2tuZXNzLCBpbm5lck1hcmdpbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dGxpbmUsXG4gICAgICBuZXdDdXJ2ZXMsXG4gICAgICBhcmVDb250b3VycyxcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY29tcHJlc3NTaWduYXR1cmUoe1xuICAgIG91dGxpbmVzLFxuICAgIGFyZUNvbnRvdXJzLFxuICAgIHRoaWNrbmVzcyxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSkge1xuICAgIGxldCBtaW5EaWZmID0gSW5maW5pdHk7XG4gICAgbGV0IG1heERpZmYgPSAtSW5maW5pdHk7XG4gICAgbGV0IG91dGxpbmVzTGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50cyBvZiBvdXRsaW5lcykge1xuICAgICAgb3V0bGluZXNMZW5ndGggKz0gcG9pbnRzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAyLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gcG9pbnRzW2ldIC0gcG9pbnRzW2kgLSAyXTtcbiAgICAgICAgbWluRGlmZiA9IE1hdGgubWluKG1pbkRpZmYsIGR4KTtcbiAgICAgICAgbWF4RGlmZiA9IE1hdGgubWF4KG1heERpZmYsIGR4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJ1ZmZlclR5cGU7XG4gICAgaWYgKG1pbkRpZmYgPj0gLTEyOCAmJiBtYXhEaWZmIDw9IDEyNykge1xuICAgICAgYnVmZmVyVHlwZSA9IEludDhBcnJheTtcbiAgICB9IGVsc2UgaWYgKG1pbkRpZmYgPj0gLTMyNzY4ICYmIG1heERpZmYgPD0gMzI3NjcpIHtcbiAgICAgIGJ1ZmZlclR5cGUgPSBJbnQxNkFycmF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXJUeXBlID0gSW50MzJBcnJheTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gb3V0bGluZXMubGVuZ3RoO1xuICAgIGNvbnN0IGhlYWRlckxlbmd0aCA9IEJBU0VfSEVBREVSX0xFTkdUSCArIFBPSU5UU19QUk9QRVJUSUVTX05VTUJFUiAqIGxlbjtcbiAgICBjb25zdCBoZWFkZXIgPSBuZXcgVWludDMyQXJyYXkoaGVhZGVyTGVuZ3RoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gaGVhZGVyTGVuZ3RoICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQgKyAob3V0bGluZXNMZW5ndGggLSAyICogbGVuKSAqIGJ1ZmZlclR5cGUuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IDA7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IHdpZHRoO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSBoZWlnaHQ7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IGFyZUNvbnRvdXJzID8gMCA6IDE7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IodGhpY2tuZXNzID8/IDApKTtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gbGVuO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSBidWZmZXJUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIGZvciAoY29uc3QgcG9pbnRzIG9mIG91dGxpbmVzKSB7XG4gICAgICBoZWFkZXJbb2Zmc2V0KytdID0gcG9pbnRzLmxlbmd0aCAtIDI7XG4gICAgICBoZWFkZXJbb2Zmc2V0KytdID0gcG9pbnRzWzBdO1xuICAgICAgaGVhZGVyW29mZnNldCsrXSA9IHBvaW50c1sxXTtcbiAgICB9XG4gICAgY29uc3QgY3MgPSBuZXcgQ29tcHJlc3Npb25TdHJlYW0oXCJkZWZsYXRlLXJhd1wiKTtcbiAgICBjb25zdCB3cml0ZXIgPSBjcy53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgd3JpdGVyLndyaXRlKGhlYWRlcik7XG4gICAgY29uc3QgQnVmZmVyQ3RvciA9IGJ1ZmZlclR5cGUucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuICAgIGZvciAoY29uc3QgcG9pbnRzIG9mIG91dGxpbmVzKSB7XG4gICAgICBjb25zdCBkaWZmcyA9IG5ldyBCdWZmZXJDdG9yKHBvaW50cy5sZW5ndGggLSAyKTtcbiAgICAgIGZvciAobGV0IGkgPSAyLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGRpZmZzW2kgLSAyXSA9IHBvaW50c1tpXSAtIHBvaW50c1tpIC0gMl07XG4gICAgICB9XG4gICAgICB3cml0ZXIud3JpdGUoZGlmZnMpO1xuICAgIH1cbiAgICB3cml0ZXIuY2xvc2UoKTtcbiAgICBjb25zdCBidWYgPSBhd2FpdCBuZXcgUmVzcG9uc2UoY3MucmVhZGFibGUpLmFycmF5QnVmZmVyKCk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIHJldHVybiB0b0Jhc2U2NFV0aWwoYnl0ZXMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZWNvbXByZXNzU2lnbmF0dXJlKHNpZ25hdHVyZURhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBmcm9tQmFzZTY0VXRpbChzaWduYXR1cmVEYXRhKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVhZGFibGUsXG4gICAgICAgIHdyaXRhYmxlXG4gICAgICB9ID0gbmV3IERlY29tcHJlc3Npb25TdHJlYW0oXCJkZWZsYXRlLXJhd1wiKTtcbiAgICAgIGNvbnN0IHdyaXRlciA9IHdyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgd3JpdGVyLndyaXRlKGJ5dGVzKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgICBhd2FpdCB3cml0ZXIuY2xvc2UoKTtcbiAgICAgIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgIGxldCBkYXRhID0gbnVsbDtcbiAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZWFkYWJsZSkge1xuICAgICAgICBkYXRhIHx8PSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoY2h1bmsuYnVmZmVyLCAwLCA0KVswXSk7XG4gICAgICAgIGRhdGEuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgfVxuICAgICAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQzMkFycmF5KGRhdGEuYnVmZmVyLCAwLCBkYXRhLmxlbmd0aCA+PiAyKTtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBoZWFkZXJbMV07XG4gICAgICBpZiAodmVyc2lvbiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmVyc2lvbjogJHt2ZXJzaW9ufWApO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lkdGggPSBoZWFkZXJbMl07XG4gICAgICBjb25zdCBoZWlnaHQgPSBoZWFkZXJbM107XG4gICAgICBjb25zdCBhcmVDb250b3VycyA9IGhlYWRlcls0XSA9PT0gMDtcbiAgICAgIGNvbnN0IHRoaWNrbmVzcyA9IGhlYWRlcls1XTtcbiAgICAgIGNvbnN0IG51bWJlck9mRHJhd2luZ3MgPSBoZWFkZXJbNl07XG4gICAgICBjb25zdCBidWZmZXJUeXBlID0gaGVhZGVyWzddO1xuICAgICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICAgIGNvbnN0IGRpZmZzT2Zmc2V0ID0gKEJBU0VfSEVBREVSX0xFTkdUSCArIFBPSU5UU19QUk9QRVJUSUVTX05VTUJFUiAqIG51bWJlck9mRHJhd2luZ3MpICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICBsZXQgZGlmZnM7XG4gICAgICBzd2l0Y2ggKGJ1ZmZlclR5cGUpIHtcbiAgICAgICAgY2FzZSBJbnQ4QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ6XG4gICAgICAgICAgZGlmZnMgPSBuZXcgSW50OEFycmF5KGRhdGEuYnVmZmVyLCBkaWZmc09mZnNldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSW50MTZBcnJheS5CWVRFU19QRVJfRUxFTUVOVDpcbiAgICAgICAgICBkaWZmcyA9IG5ldyBJbnQxNkFycmF5KGRhdGEuYnVmZmVyLCBkaWZmc09mZnNldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDpcbiAgICAgICAgICBkaWZmcyA9IG5ldyBJbnQzMkFycmF5KGRhdGEuYnVmZmVyLCBkaWZmc09mZnNldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkRyYXdpbmdzOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGVuID0gaGVhZGVyW1BPSU5UU19QUk9QRVJUSUVTX05VTUJFUiAqIGkgKyBCQVNFX0hFQURFUl9MRU5HVEhdO1xuICAgICAgICBjb25zdCBwb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KGxlbiArIDIpO1xuICAgICAgICBvdXRsaW5lcy5wdXNoKHBvaW50cyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgUE9JTlRTX1BST1BFUlRJRVNfTlVNQkVSIC0gMTsgaisrKSB7XG4gICAgICAgICAgcG9pbnRzW2pdID0gaGVhZGVyW1BPSU5UU19QUk9QRVJUSUVTX05VTUJFUiAqIGkgKyBCQVNFX0hFQURFUl9MRU5HVEggKyBqICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIHBvaW50c1tqICsgMl0gPSBwb2ludHNbal0gKyBkaWZmc1tvZmZzZXQrK107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFyZUNvbnRvdXJzLFxuICAgICAgICB0aGlja25lc3MsXG4gICAgICAgIG91dGxpbmVzLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oYGRlY29tcHJlc3NTaWduYXR1cmU6ICR7ZX1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3Ivc2lnbmF0dXJlLmpzXG5cblxuXG5cblxuXG5cbmNsYXNzIFNpZ25hdHVyZU9wdGlvbnMgZXh0ZW5kcyBEcmF3aW5nT3B0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgc3VwZXIudXBkYXRlUHJvcGVydGllcyh7XG4gICAgICBmaWxsOiBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogMFxuICAgIH0pO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IFNpZ25hdHVyZU9wdGlvbnMoKTtcbiAgICBjbG9uZS51cGRhdGVBbGwodGhpcyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG5jbGFzcyBEcmF3blNpZ25hdHVyZU9wdGlvbnMgZXh0ZW5kcyBJbmtEcmF3aW5nT3B0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKHZpZXdlclBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcih2aWV3ZXJQYXJhbWV0ZXJzKTtcbiAgICBzdXBlci51cGRhdGVQcm9wZXJ0aWVzKHtcbiAgICAgIHN0cm9rZTogQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcixcbiAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDFcbiAgICB9KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBEcmF3blNpZ25hdHVyZU9wdGlvbnModGhpcy5fdmlld1BhcmFtZXRlcnMpO1xuICAgIGNsb25lLnVwZGF0ZUFsbCh0aGlzKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbmNsYXNzIFNpZ25hdHVyZUVkaXRvciBleHRlbmRzIERyYXdpbmdFZGl0b3Ige1xuICAjaXNFeHRyYWN0ZWQgPSBmYWxzZTtcbiAgI2Rlc2NyaXB0aW9uID0gbnVsbDtcbiAgI3NpZ25hdHVyZURhdGEgPSBudWxsO1xuICAjc2lnbmF0dXJlVVVJRCA9IG51bGw7XG4gIHN0YXRpYyBfdHlwZSA9IFwic2lnbmF0dXJlXCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLlNJR05BVFVSRTtcbiAgc3RhdGljIF9kZWZhdWx0RHJhd2luZ09wdGlvbnMgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBtdXN0QmVDb21taXR0ZWQ6IHRydWUsXG4gICAgICBuYW1lOiBcInNpZ25hdHVyZUVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgdGhpcy4jc2lnbmF0dXJlRGF0YSA9IHBhcmFtcy5zaWduYXR1cmVEYXRhIHx8IG51bGw7XG4gICAgdGhpcy4jZGVzY3JpcHRpb24gPSBudWxsO1xuICAgIHRoaXMuZGVmYXVsdEwxMG5JZCA9IFwicGRmanMtZWRpdG9yLXNpZ25hdHVyZS1lZGl0b3IxXCI7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gICAgdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zID0gbmV3IFNpZ25hdHVyZU9wdGlvbnMoKTtcbiAgICB0aGlzLl9kZWZhdWx0RHJhd25TaWduYXR1cmVPcHRpb25zID0gbmV3IERyYXduU2lnbmF0dXJlT3B0aW9ucyh1aU1hbmFnZXIudmlld1BhcmFtZXRlcnMpO1xuICB9XG4gIHN0YXRpYyBnZXREZWZhdWx0RHJhd2luZ09wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IGNsb25lID0gdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLmNsb25lKCk7XG4gICAgY2xvbmUudXBkYXRlUHJvcGVydGllcyhvcHRpb25zKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgc3RhdGljIGdldCBzdXBwb3J0TXVsdGlwbGVEcmF3aW5ncygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlc01hcCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwidHlwZXNNYXBcIiwgbmV3IE1hcCgpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRHJhd2VyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXQgdGVsZW1ldHJ5RmluYWxEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNpZ25hdHVyZVwiLFxuICAgICAgaGFzRGVzY3JpcHRpb246ICEhdGhpcy4jZGVzY3JpcHRpb25cbiAgICB9O1xuICB9XG4gIHN0YXRpYyBjb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhKGRhdGEpIHtcbiAgICBjb25zdCBoYXNEZXNjcmlwdGlvblN0YXRzID0gZGF0YS5nZXQoXCJoYXNEZXNjcmlwdGlvblwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzQWx0VGV4dDogaGFzRGVzY3JpcHRpb25TdGF0cy5nZXQodHJ1ZSkgPz8gMCxcbiAgICAgIGhhc05vQWx0VGV4dDogaGFzRGVzY3JpcHRpb25TdGF0cy5nZXQoZmFsc2UpID8/IDBcbiAgICB9O1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2RyYXdJZCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgY29uc3Qge1xuICAgICAgX2lzQ29weVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChfaXNDb3B5KSB7XG4gICAgICB0aGlzLl9pc0NvcHkgPSBmYWxzZTtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIGlmICh0aGlzLl9kcmF3SWQgPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLiNzaWduYXR1cmVEYXRhKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICBtdXN0U21vb3RoLFxuICAgICAgICAgIGFyZUNvbnRvdXJzLFxuICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgIHV1aWQsXG4gICAgICAgICAgaGVpZ2h0SW5QYWdlXG4gICAgICAgIH0gPSB0aGlzLiNzaWduYXR1cmVEYXRhO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmF3RGltczoge1xuICAgICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgICAgcGFnZUhlaWdodFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcm90YXRpb25cbiAgICAgICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgICAgICBjb25zdCBvdXRsaW5lID0gU2lnbmF0dXJlRXh0cmFjdG9yLnByb2Nlc3NEcmF3bkxpbmVzKHtcbiAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpbm5lck1hcmdpbjogU2lnbmF0dXJlRWRpdG9yLl9JTk5FUl9NQVJHSU4sXG4gICAgICAgICAgbXVzdFNtb290aCxcbiAgICAgICAgICBhcmVDb250b3Vyc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRTaWduYXR1cmUob3V0bGluZSwgaGVpZ2h0SW5QYWdlLCBkZXNjcmlwdGlvbiwgdXVpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiXCJcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmRpdi5oaWRkZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLl91aU1hbmFnZXIuZ2V0U2lnbmF0dXJlKHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLiNkZXNjcmlwdGlvbiB8fCBcIlwiXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChfaXNDb3B5KSB7XG4gICAgICB0aGlzLl9pc0NvcHkgPSB0cnVlO1xuICAgICAgdGhpcy5fbW92ZUFmdGVyUGFzdGUoYmFzZVgsIGJhc2VZKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIHNldFV1aWQodXVpZCkge1xuICAgIHRoaXMuI3NpZ25hdHVyZVVVSUQgPSB1dWlkO1xuICAgIHRoaXMuYWRkRWRpdFRvb2xiYXIoKTtcbiAgfVxuICBnZXRVdWlkKCkge1xuICAgIHJldHVybiB0aGlzLiNzaWduYXR1cmVVVUlEO1xuICB9XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jZGVzY3JpcHRpb247XG4gIH1cbiAgc2V0IGRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgdGhpcy4jZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICBpZiAoIXRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGRlc2NyaXB0aW9uXG4gICAgfSkpO1xuICAgIHN1cGVyLmFkZEVkaXRUb29sYmFyKCkudGhlbih0b29sYmFyID0+IHtcbiAgICAgIHRvb2xiYXI/LnVwZGF0ZUVkaXRTaWduYXR1cmVCdXR0b24oZGVzY3JpcHRpb24pO1xuICAgIH0pO1xuICB9XG4gIGdldFNpZ25hdHVyZVByZXZpZXcoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmV3Q3VydmVzLFxuICAgICAgYXJlQ29udG91cnMsXG4gICAgICB0aGlja25lc3MsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLiNzaWduYXR1cmVEYXRhO1xuICAgIGNvbnN0IG1heERpbSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IG91dGxpbmVEYXRhID0gU2lnbmF0dXJlRXh0cmFjdG9yLnByb2Nlc3NEcmF3bkxpbmVzKHtcbiAgICAgIGxpbmVzOiB7XG4gICAgICAgIGN1cnZlczogbmV3Q3VydmVzLm1hcChwb2ludHMgPT4gKHtcbiAgICAgICAgICBwb2ludHNcbiAgICAgICAgfSkpLFxuICAgICAgICB0aGlja25lc3MsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0sXG4gICAgICBwYWdlV2lkdGg6IG1heERpbSxcbiAgICAgIHBhZ2VIZWlnaHQ6IG1heERpbSxcbiAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgaW5uZXJNYXJnaW46IDAsXG4gICAgICBtdXN0U21vb3RoOiBmYWxzZSxcbiAgICAgIGFyZUNvbnRvdXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFyZUNvbnRvdXJzLFxuICAgICAgb3V0bGluZTogb3V0bGluZURhdGEub3V0bGluZVxuICAgIH07XG4gIH1cbiAgZ2V0IHRvb2xiYXJCdXR0b25zKCkge1xuICAgIGlmICh0aGlzLl91aU1hbmFnZXIuc2lnbmF0dXJlTWFuYWdlcikge1xuICAgICAgcmV0dXJuIFtbXCJlZGl0U2lnbmF0dXJlXCIsIHRoaXMuX3VpTWFuYWdlci5zaWduYXR1cmVNYW5hZ2VyXV07XG4gICAgfVxuICAgIHJldHVybiBzdXBlci50b29sYmFyQnV0dG9ucztcbiAgfVxuICBhZGRTaWduYXR1cmUoZGF0YSwgaGVpZ2h0SW5QYWdlLCBkZXNjcmlwdGlvbiwgdXVpZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IHNhdmVkWCxcbiAgICAgIHk6IHNhdmVkWVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIG91dGxpbmVcbiAgICB9ID0gdGhpcy4jc2lnbmF0dXJlRGF0YSA9IGRhdGE7XG4gICAgdGhpcy4jaXNFeHRyYWN0ZWQgPSBvdXRsaW5lIGluc3RhbmNlb2YgQ29udG91ckRyYXdPdXRsaW5lO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICBsZXQgZHJhd2luZ09wdGlvbnM7XG4gICAgaWYgKHRoaXMuI2lzRXh0cmFjdGVkKSB7XG4gICAgICBkcmF3aW5nT3B0aW9ucyA9IFNpZ25hdHVyZUVkaXRvci5nZXREZWZhdWx0RHJhd2luZ09wdGlvbnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhd2luZ09wdGlvbnMgPSBTaWduYXR1cmVFZGl0b3IuX2RlZmF1bHREcmF3blNpZ25hdHVyZU9wdGlvbnMuY2xvbmUoKTtcbiAgICAgIGRyYXdpbmdPcHRpb25zLnVwZGF0ZVByb3BlcnRpZXMoe1xuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBvdXRsaW5lLnRoaWNrbmVzc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2FkZE91dGxpbmVzKHtcbiAgICAgIGRyYXdPdXRsaW5lczogb3V0bGluZSxcbiAgICAgIGRyYXdpbmdPcHRpb25zXG4gICAgfSk7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IFssIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBsZXQgbmV3SGVpZ2h0ID0gaGVpZ2h0SW5QYWdlIC8gcGFnZUhlaWdodDtcbiAgICBuZXdIZWlnaHQgPSBuZXdIZWlnaHQgPj0gMSA/IDAuNSA6IG5ld0hlaWdodDtcbiAgICB0aGlzLndpZHRoICo9IG5ld0hlaWdodCAvIHRoaXMuaGVpZ2h0O1xuICAgIGlmICh0aGlzLndpZHRoID49IDEpIHtcbiAgICAgIG5ld0hlaWdodCAqPSAwLjkgLyB0aGlzLndpZHRoO1xuICAgICAgdGhpcy53aWR0aCA9IDAuOTtcbiAgICB9XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgdGhpcy5zZXREaW1zKHBhcmVudFdpZHRoICogdGhpcy53aWR0aCwgcGFyZW50SGVpZ2h0ICogdGhpcy5oZWlnaHQpO1xuICAgIHRoaXMueCA9IHNhdmVkWDtcbiAgICB0aGlzLnkgPSBzYXZlZFk7XG4gICAgdGhpcy5jZW50ZXIoKTtcbiAgICB0aGlzLl9vblJlc2l6ZWQoKTtcbiAgICB0aGlzLm9uU2NhbGVDaGFuZ2luZygpO1xuICAgIHRoaXMucm90YXRlKCk7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gICAgdGhpcy5zZXRVdWlkKHV1aWQpO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwicGRmanMuc2lnbmF0dXJlLmluc2VydGVkXCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGhhc0JlZW5TYXZlZDogISF1dWlkLFxuICAgICAgICBoYXNEZXNjcmlwdGlvbjogISFkZXNjcmlwdGlvblxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGdldEZyb21JbWFnZShiaXRtYXApIHtcbiAgICBjb25zdCB7XG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodFxuICAgICAgfSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgIHJldHVybiBTaWduYXR1cmVFeHRyYWN0b3IucHJvY2VzcyhiaXRtYXAsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgcm90YXRpb24sIFNpZ25hdHVyZUVkaXRvci5fSU5ORVJfTUFSR0lOKTtcbiAgfVxuICBnZXRGcm9tVGV4dCh0ZXh0LCBmb250SW5mbykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0XG4gICAgICB9LFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgcmV0dXJuIFNpZ25hdHVyZUV4dHJhY3Rvci5leHRyYWN0Q29udG91cnNGcm9tVGV4dCh0ZXh0LCBmb250SW5mbywgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCByb3RhdGlvbiwgU2lnbmF0dXJlRWRpdG9yLl9JTk5FUl9NQVJHSU4pO1xuICB9XG4gIGdldERyYXduU2lnbmF0dXJlKGN1cnZlcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0XG4gICAgICB9LFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgcmV0dXJuIFNpZ25hdHVyZUV4dHJhY3Rvci5wcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgICBsaW5lczogY3VydmVzLFxuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgaW5uZXJNYXJnaW46IFNpZ25hdHVyZUVkaXRvci5fSU5ORVJfTUFSR0lOLFxuICAgICAgbXVzdFNtb290aDogZmFsc2UsXG4gICAgICBhcmVDb250b3VyczogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVEcmF3aW5nT3B0aW9ucyh7XG4gICAgYXJlQ29udG91cnMsXG4gICAgdGhpY2tuZXNzXG4gIH0pIHtcbiAgICBpZiAoYXJlQ29udG91cnMpIHtcbiAgICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zID0gU2lnbmF0dXJlRWRpdG9yLmdldERlZmF1bHREcmF3aW5nT3B0aW9ucygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucyA9IFNpZ25hdHVyZUVkaXRvci5fZGVmYXVsdERyYXduU2lnbmF0dXJlT3B0aW9ucy5jbG9uZSgpO1xuICAgICAgdGhpcy5fZHJhd2luZ09wdGlvbnMudXBkYXRlUHJvcGVydGllcyh7XG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaWNrbmVzc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxpbmVzLFxuICAgICAgcG9pbnRzLFxuICAgICAgcmVjdFxuICAgIH0gPSB0aGlzLnNlcmlhbGl6ZURyYXcoaXNGb3JDb3B5aW5nKTtcbiAgICBjb25zdCB7XG4gICAgICBfZHJhd2luZ09wdGlvbnM6IHtcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogdGhpY2tuZXNzXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TSUdOQVRVUkUsXG4gICAgICBpc1NpZ25hdHVyZTogdHJ1ZSxcbiAgICAgIGFyZUNvbnRvdXJzOiB0aGlzLiNpc0V4dHJhY3RlZCxcbiAgICAgIGNvbG9yOiBbMCwgMCwgMF0sXG4gICAgICB0aGlja25lc3M6IHRoaXMuI2lzRXh0cmFjdGVkID8gMCA6IHRoaWNrbmVzcyxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tZW50KHNlcmlhbGl6ZWQpO1xuICAgIGlmIChpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHNlcmlhbGl6ZWQucGF0aHMgPSB7XG4gICAgICAgIGxpbmVzLFxuICAgICAgICBwb2ludHNcbiAgICAgIH07XG4gICAgICBzZXJpYWxpemVkLnV1aWQgPSB0aGlzLiNzaWduYXR1cmVVVUlEO1xuICAgICAgc2VyaWFsaXplZC5pc0NvcHkgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkLmxpbmVzID0gbGluZXM7XG4gICAgfVxuICAgIGlmICh0aGlzLiNkZXNjcmlwdGlvbikge1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHtcbiAgICAgICAgdHlwZTogXCJGaWd1cmVcIixcbiAgICAgICAgYWx0OiB0aGlzLiNkZXNjcmlwdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplRHJhdyhwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgaW5uZXJNYXJnaW4sIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5hcmVDb250b3Vycykge1xuICAgICAgcmV0dXJuIENvbnRvdXJEcmF3T3V0bGluZS5kZXNlcmlhbGl6ZShwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgaW5uZXJNYXJnaW4sIGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gSW5rRHJhd091dGxpbmUuZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLiNpc0V4dHJhY3RlZCA9IGRhdGEuYXJlQ29udG91cnM7XG4gICAgZWRpdG9yLmRlc2NyaXB0aW9uID0gZGF0YS5hY2Nlc3NpYmlsaXR5RGF0YT8uYWx0IHx8IFwiXCI7XG4gICAgZWRpdG9yLiNzaWduYXR1cmVVVUlEID0gZGF0YS51dWlkO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL3N0YW1wLmpzXG5cblxuXG5cbmNsYXNzIFN0YW1wRWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNiaXRtYXAgPSBudWxsO1xuICAjYml0bWFwSWQgPSBudWxsO1xuICAjYml0bWFwUHJvbWlzZSA9IG51bGw7XG4gICNiaXRtYXBVcmwgPSBudWxsO1xuICAjYml0bWFwRmlsZSA9IG51bGw7XG4gICNiaXRtYXBGaWxlTmFtZSA9IFwiXCI7XG4gICNjYW52YXMgPSBudWxsO1xuICAjbWlzc2luZ0NhbnZhcyA9IGZhbHNlO1xuICAjcmVzaXplVGltZW91dElkID0gbnVsbDtcbiAgI2lzU3ZnID0gZmFsc2U7XG4gICNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9IGZhbHNlO1xuICBzdGF0aWMgX3R5cGUgPSBcInN0YW1wXCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcInN0YW1wRWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLiNiaXRtYXBVcmwgPSBwYXJhbXMuYml0bWFwVXJsO1xuICAgIHRoaXMuI2JpdG1hcEZpbGUgPSBwYXJhbXMuYml0bWFwRmlsZTtcbiAgICB0aGlzLmRlZmF1bHRMMTBuSWQgPSBcInBkZmpzLWVkaXRvci1zdGFtcC1lZGl0b3JcIjtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgfVxuICBzdGF0aWMgaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKG1pbWUpIHtcbiAgICByZXR1cm4gU3VwcG9ydGVkSW1hZ2VNaW1lVHlwZXMuaW5jbHVkZXMobWltZSk7XG4gIH1cbiAgc3RhdGljIHBhc3RlKGl0ZW0sIHBhcmVudCkge1xuICAgIHBhcmVudC5wYXN0ZUVkaXRvcih7XG4gICAgICBtb2RlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUFxuICAgIH0sIHtcbiAgICAgIGJpdG1hcEZpbGU6IGl0ZW0uZ2V0QXNGaWxlKClcbiAgICB9KTtcbiAgfVxuICBhbHRUZXh0RmluaXNoKCkge1xuICAgIGlmICh0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIHRoaXMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICBzdXBlci5hbHRUZXh0RmluaXNoKCk7XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdGFtcFwiLFxuICAgICAgaGFzQWx0VGV4dDogISF0aGlzLmFsdFRleHREYXRhPy5hbHRUZXh0XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShkYXRhKSB7XG4gICAgY29uc3QgaGFzQWx0VGV4dFN0YXRzID0gZGF0YS5nZXQoXCJoYXNBbHRUZXh0XCIpO1xuICAgIHJldHVybiB7XG4gICAgICBoYXNBbHRUZXh0OiBoYXNBbHRUZXh0U3RhdHMuZ2V0KHRydWUpID8/IDAsXG4gICAgICBoYXNOb0FsdFRleHQ6IGhhc0FsdFRleHRTdGF0cy5nZXQoZmFsc2UpID8/IDBcbiAgICB9O1xuICB9XG4gICNnZXRCaXRtYXBGZXRjaGVkKGRhdGEsIGZyb21JZCA9IGZhbHNlKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNiaXRtYXAgPSBkYXRhLmJpdG1hcDtcbiAgICBpZiAoIWZyb21JZCkge1xuICAgICAgdGhpcy4jYml0bWFwSWQgPSBkYXRhLmlkO1xuICAgICAgdGhpcy4jaXNTdmcgPSBkYXRhLmlzU3ZnO1xuICAgIH1cbiAgICBpZiAoZGF0YS5maWxlKSB7XG4gICAgICB0aGlzLiNiaXRtYXBGaWxlTmFtZSA9IGRhdGEuZmlsZS5uYW1lO1xuICAgIH1cbiAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgfVxuICAjZ2V0Qml0bWFwRG9uZSgpIHtcbiAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyhmYWxzZSk7XG4gICAgaWYgKCF0aGlzLiNjYW52YXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlICYmIHRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0RmxvdyAmJiB0aGlzLiNiaXRtYXApIHtcbiAgICAgIHRoaXMuYWRkRWRpdFRvb2xiYXIoKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fZWRpdFRvb2xiYXIuaGlkZSgpO1xuICAgICAgICB0aGlzLl91aU1hbmFnZXIuZWRpdEFsdFRleHQodGhpcywgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSAmJiB0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cgJiYgdGhpcy4jYml0bWFwKSB7XG4gICAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICBhY3Rpb246IFwicGRmanMuaW1hZ2UuaW1hZ2VfYWRkZWRcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGFsdF90ZXh0X21vZGFsOiBmYWxzZSxcbiAgICAgICAgICBhbHRfdGV4dF90eXBlOiBcImVtcHR5XCJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm1sR3Vlc3NBbHRUZXh0KCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgYXN5bmMgbWxHdWVzc0FsdFRleHQoaW1hZ2VEYXRhID0gbnVsbCwgdXBkYXRlQWx0VGV4dERhdGEgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuaGFzQWx0VGV4dERhdGEoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1sTWFuYWdlclxuICAgIH0gPSB0aGlzLl91aU1hbmFnZXI7XG4gICAgaWYgKCFtbE1hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE1MLlwiKTtcbiAgICB9XG4gICAgaWYgKCEoYXdhaXQgbWxNYW5hZ2VyLmlzRW5hYmxlZEZvcihcImFsdFRleHRcIikpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNTCBpc24ndCBlbmFibGVkIGZvciBhbHQgdGV4dC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWFnZURhdGEgfHwgdGhpcy5jb3B5Q2FudmFzKG51bGwsIG51bGwsIHRydWUpLmltYWdlRGF0YTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1sTWFuYWdlci5ndWVzcyh7XG4gICAgICBuYW1lOiBcImFsdFRleHRcIixcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgY2hhbm5lbHM6IGRhdGEubGVuZ3RoIC8gKHdpZHRoICogaGVpZ2h0KVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlc3BvbnNlIGZyb20gdGhlIEFJIHNlcnZpY2UuXCIpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGZyb20gdGhlIEFJIHNlcnZpY2UuXCIpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuY2FuY2VsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vdXRwdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbGlkIHJlc3BvbnNlIGZyb20gdGhlIEFJIHNlcnZpY2UuXCIpO1xuICAgIH1cbiAgICBjb25zdCBhbHRUZXh0ID0gcmVzcG9uc2Uub3V0cHV0O1xuICAgIGF3YWl0IHRoaXMuc2V0R3Vlc3NlZEFsdFRleHQoYWx0VGV4dCk7XG4gICAgaWYgKHVwZGF0ZUFsdFRleHREYXRhICYmICF0aGlzLmhhc0FsdFRleHREYXRhKCkpIHtcbiAgICAgIHRoaXMuYWx0VGV4dERhdGEgPSB7XG4gICAgICAgIGFsdDogYWx0VGV4dCxcbiAgICAgICAgZGVjb3JhdGl2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhbHRUZXh0O1xuICB9XG4gICNnZXRCaXRtYXAoKSB7XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUlkKHRoaXMuI2JpdG1hcElkKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCB0cnVlKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwVXJsKSB7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLiNiaXRtYXBVcmw7XG4gICAgICB0aGlzLiNiaXRtYXBVcmwgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tVXJsKHVybCkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcEZpbGUpIHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLiNiaXRtYXBGaWxlO1xuICAgICAgdGhpcy4jYml0bWFwRmlsZSA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGZpbGUpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnR5cGUgPSBcImZpbGVcIjtcbiAgICBpbnB1dC5hY2NlcHQgPSBTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlcy5qb2luKFwiLFwiKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKCFpbnB1dC5maWxlcyB8fCBpbnB1dC5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGlucHV0LmZpbGVzWzBdKTtcbiAgICAgICAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmltYWdlX3NlbGVjdGVkXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGFsdF90ZXh0X21vZGFsOiB0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5jZWxcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgIGlucHV0LmNsaWNrKCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy4jYml0bWFwID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZGVsZXRlSWQodGhpcy4jYml0bWFwSWQpO1xuICAgICAgdGhpcy4jY2FudmFzPy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI2NhbnZhcyA9IG51bGw7XG4gICAgICBpZiAodGhpcy4jcmVzaXplVGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNyZXNpemVUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgICB0aGlzLiNnZXRCaXRtYXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwSWQgJiYgdGhpcy4jY2FudmFzID09PSBudWxsKSB7XG4gICAgICB0aGlzLiNnZXRCaXRtYXAoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoZm9jdXMpIHtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgaWYgKGZvY3VzKSB7XG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhKHRoaXMuI2JpdG1hcFByb21pc2UgfHwgdGhpcy4jYml0bWFwIHx8IHRoaXMuI2JpdG1hcFVybCB8fCB0aGlzLiNiaXRtYXBGaWxlIHx8IHRoaXMuI2JpdG1hcElkIHx8IHRoaXMuI21pc3NpbmdDYW52YXMpO1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICByZXR1cm4gW1tcImFsdFRleHRcIiwgdGhpcy5jcmVhdGVBbHRUZXh0KCldXTtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLl9pc0NvcHkpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZGl2LmhpZGRlbiA9IHRydWU7XG4gICAgdGhpcy5jcmVhdGVBbHRUZXh0KCk7XG4gICAgaWYgKCF0aGlzLiNtaXNzaW5nQ2FudmFzKSB7XG4gICAgICBpZiAodGhpcy4jYml0bWFwKSB7XG4gICAgICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc0NvcHkpIHtcbiAgICAgIHRoaXMuX21vdmVBZnRlclBhc3RlKGJhc2VYLCBiYXNlWSk7XG4gICAgfVxuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBzZXRDYW52YXMoYW5ub3RhdGlvbkVsZW1lbnRJZCwgY2FudmFzKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQ6IGJpdG1hcElkLFxuICAgICAgYml0bWFwXG4gICAgfSA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUNhbnZhcyhhbm5vdGF0aW9uRWxlbWVudElkLCBjYW52YXMpO1xuICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICBpZiAoYml0bWFwSWQgJiYgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5pc1ZhbGlkSWQoYml0bWFwSWQpKSB7XG4gICAgICB0aGlzLiNiaXRtYXBJZCA9IGJpdG1hcElkO1xuICAgICAgaWYgKGJpdG1hcCkge1xuICAgICAgICB0aGlzLiNiaXRtYXAgPSBiaXRtYXA7XG4gICAgICB9XG4gICAgICB0aGlzLiNtaXNzaW5nQ2FudmFzID0gZmFsc2U7XG4gICAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICB9XG4gIH1cbiAgX29uUmVzaXplZCgpIHtcbiAgICB0aGlzLm9uU2NhbGVDaGFuZ2luZygpO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNyZXNpemVUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNyZXNpemVUaW1lb3V0SWQpO1xuICAgIH1cbiAgICBjb25zdCBUSU1FX1RPX1dBSVQgPSAyMDA7XG4gICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgdGhpcy4jZHJhd0JpdG1hcCgpO1xuICAgIH0sIFRJTUVfVE9fV0FJVCk7XG4gIH1cbiAgI2NyZWF0ZUNhbnZhcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXZcbiAgICB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBNQVhfUkFUSU8gPSAwLjc1O1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICB3aWR0aCA9IHRoaXMud2lkdGggKiBwYWdlV2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+IE1BWF9SQVRJTyAqIHBhZ2VXaWR0aCB8fCBoZWlnaHQgPiBNQVhfUkFUSU8gKiBwYWdlSGVpZ2h0KSB7XG4gICAgICBjb25zdCBmYWN0b3IgPSBNYXRoLm1pbihNQVhfUkFUSU8gKiBwYWdlV2lkdGggLyB3aWR0aCwgTUFYX1JBVElPICogcGFnZUhlaWdodCAvIGhlaWdodCk7XG4gICAgICB3aWR0aCAqPSBmYWN0b3I7XG4gICAgICBoZWlnaHQgKj0gZmFjdG9yO1xuICAgIH1cbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXREaW1zKHdpZHRoICogcGFyZW50V2lkdGggLyBwYWdlV2lkdGgsIGhlaWdodCAqIHBhcmVudEhlaWdodCAvIHBhZ2VIZWlnaHQpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKGZhbHNlKTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLiNjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiaW1nXCIpO1xuICAgIHRoaXMuYWRkQ29udGFpbmVyKGNhbnZhcyk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIC8gcGFnZVdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICBpZiAodGhpcy5faW5pdGlhbE9wdGlvbnM/LmlzQ2VudGVyZWQpIHtcbiAgICAgIHRoaXMuY2VudGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSBudWxsO1xuICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgfHwgIXRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0RmxvdyB8fCB0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy4jZHJhd0JpdG1hcCgpO1xuICAgIGlmICghdGhpcy4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2spIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZFVuZG9hYmxlRWRpdG9yKHRoaXMpO1xuICAgICAgdGhpcy4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcImluc2VydGVkX2ltYWdlXCJcbiAgICB9KTtcbiAgICBpZiAodGhpcy4jYml0bWFwRmlsZU5hbWUpIHtcbiAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpcHRpb25cIiwgdGhpcy4jYml0bWFwRmlsZU5hbWUpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmExMXlBbGVydChcInBkZmpzLWVkaXRvci1zdGFtcC1hZGRlZC1hbGVydFwiKTtcbiAgICB9XG4gIH1cbiAgY29weUNhbnZhcyhtYXhEYXRhRGltZW5zaW9uLCBtYXhQcmV2aWV3RGltZW5zaW9uLCBjcmVhdGVJbWFnZURhdGEgPSBmYWxzZSkge1xuICAgIGlmICghbWF4RGF0YURpbWVuc2lvbikge1xuICAgICAgbWF4RGF0YURpbWVuc2lvbiA9IDIyNDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0OiBiaXRtYXBIZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGNvbnN0IG91dHB1dFNjYWxlID0gbmV3IE91dHB1dFNjYWxlKCk7XG4gICAgbGV0IGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICBsZXQgd2lkdGggPSBiaXRtYXBXaWR0aCxcbiAgICAgIGhlaWdodCA9IGJpdG1hcEhlaWdodDtcbiAgICBsZXQgY2FudmFzID0gbnVsbDtcbiAgICBpZiAobWF4UHJldmlld0RpbWVuc2lvbikge1xuICAgICAgaWYgKGJpdG1hcFdpZHRoID4gbWF4UHJldmlld0RpbWVuc2lvbiB8fCBiaXRtYXBIZWlnaHQgPiBtYXhQcmV2aWV3RGltZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4obWF4UHJldmlld0RpbWVuc2lvbiAvIGJpdG1hcFdpZHRoLCBtYXhQcmV2aWV3RGltZW5zaW9uIC8gYml0bWFwSGVpZ2h0KTtcbiAgICAgICAgd2lkdGggPSBNYXRoLmZsb29yKGJpdG1hcFdpZHRoICogcmF0aW8pO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGJpdG1hcEhlaWdodCAqIHJhdGlvKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICBjb25zdCBzY2FsZWRXaWR0aCA9IGNhbnZhcy53aWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIG91dHB1dFNjYWxlLnN4KTtcbiAgICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogb3V0cHV0U2NhbGUuc3kpO1xuICAgICAgaWYgKCF0aGlzLiNpc1N2Zykge1xuICAgICAgICBiaXRtYXAgPSB0aGlzLiNzY2FsZUJpdG1hcChzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZmlsdGVyID0gdGhpcy5fdWlNYW5hZ2VyLmhjbUZpbHRlcjtcbiAgICAgIGxldCB3aGl0ZSA9IFwid2hpdGVcIixcbiAgICAgICAgYmxhY2sgPSBcIiNjZmNmZDhcIjtcbiAgICAgIGlmICh0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyICE9PSBcIm5vbmVcIikge1xuICAgICAgICBibGFjayA9IFwiYmxhY2tcIjtcbiAgICAgIH0gZWxzZSBpZiAod2luZG93Lm1hdGNoTWVkaWE/LihcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikubWF0Y2hlcykge1xuICAgICAgICB3aGl0ZSA9IFwiIzhmOGY5ZFwiO1xuICAgICAgICBibGFjayA9IFwiIzQyNDE0ZFwiO1xuICAgICAgfVxuICAgICAgY29uc3QgYm94RGltID0gMTU7XG4gICAgICBjb25zdCBib3hEaW1XaWR0aCA9IGJveERpbSAqIG91dHB1dFNjYWxlLnN4O1xuICAgICAgY29uc3QgYm94RGltSGVpZ2h0ID0gYm94RGltICogb3V0cHV0U2NhbGUuc3k7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhib3hEaW1XaWR0aCAqIDIsIGJveERpbUhlaWdodCAqIDIpO1xuICAgICAgY29uc3QgcGF0dGVybkN0eCA9IHBhdHRlcm4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgcGF0dGVybkN0eC5maWxsU3R5bGUgPSB3aGl0ZTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFJlY3QoMCwgMCwgYm94RGltV2lkdGggKiAyLCBib3hEaW1IZWlnaHQgKiAyKTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gYmxhY2s7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxSZWN0KDAsIDAsIGJveERpbVdpZHRoLCBib3hEaW1IZWlnaHQpO1xuICAgICAgcGF0dGVybkN0eC5maWxsUmVjdChib3hEaW1XaWR0aCwgYm94RGltSGVpZ2h0LCBib3hEaW1XaWR0aCwgYm94RGltSGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjdHguY3JlYXRlUGF0dGVybihwYXR0ZXJuLCBcInJlcGVhdFwiKTtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgIH1cbiAgICBsZXQgaW1hZ2VEYXRhID0gbnVsbDtcbiAgICBpZiAoY3JlYXRlSW1hZ2VEYXRhKSB7XG4gICAgICBsZXQgZGF0YVdpZHRoLCBkYXRhSGVpZ2h0O1xuICAgICAgaWYgKG91dHB1dFNjYWxlLnN5bW1ldHJpYyAmJiBiaXRtYXAud2lkdGggPCBtYXhEYXRhRGltZW5zaW9uICYmIGJpdG1hcC5oZWlnaHQgPCBtYXhEYXRhRGltZW5zaW9uKSB7XG4gICAgICAgIGRhdGFXaWR0aCA9IGJpdG1hcC53aWR0aDtcbiAgICAgICAgZGF0YUhlaWdodCA9IGJpdG1hcC5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaXRtYXAgPSB0aGlzLiNiaXRtYXA7XG4gICAgICAgIGlmIChiaXRtYXBXaWR0aCA+IG1heERhdGFEaW1lbnNpb24gfHwgYml0bWFwSGVpZ2h0ID4gbWF4RGF0YURpbWVuc2lvbikge1xuICAgICAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4obWF4RGF0YURpbWVuc2lvbiAvIGJpdG1hcFdpZHRoLCBtYXhEYXRhRGltZW5zaW9uIC8gYml0bWFwSGVpZ2h0KTtcbiAgICAgICAgICBkYXRhV2lkdGggPSBNYXRoLmZsb29yKGJpdG1hcFdpZHRoICogcmF0aW8pO1xuICAgICAgICAgIGRhdGFIZWlnaHQgPSBNYXRoLmZsb29yKGJpdG1hcEhlaWdodCAqIHJhdGlvKTtcbiAgICAgICAgICBpZiAoIXRoaXMuI2lzU3ZnKSB7XG4gICAgICAgICAgICBiaXRtYXAgPSB0aGlzLiNzY2FsZUJpdG1hcChkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgY29uc3Qgb2Zmc2NyZWVuQ3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBvZmZzY3JlZW5DdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCBkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgaW1hZ2VEYXRhID0ge1xuICAgICAgICB3aWR0aDogZGF0YVdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGRhdGFIZWlnaHQsXG4gICAgICAgIGRhdGE6IG9mZnNjcmVlbkN0eC5nZXRJbWFnZURhdGEoMCwgMCwgZGF0YVdpZHRoLCBkYXRhSGVpZ2h0KS5kYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBpbWFnZURhdGFcbiAgICB9O1xuICB9XG4gICNzY2FsZUJpdG1hcCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0OiBiaXRtYXBIZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGxldCBuZXdXaWR0aCA9IGJpdG1hcFdpZHRoO1xuICAgIGxldCBuZXdIZWlnaHQgPSBiaXRtYXBIZWlnaHQ7XG4gICAgbGV0IGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICB3aGlsZSAobmV3V2lkdGggPiAyICogd2lkdGggfHwgbmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgY29uc3QgcHJldldpZHRoID0gbmV3V2lkdGg7XG4gICAgICBjb25zdCBwcmV2SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgaWYgKG5ld1dpZHRoID4gMiAqIHdpZHRoKSB7XG4gICAgICAgIG5ld1dpZHRoID0gbmV3V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld1dpZHRoIC8gMikgLSAxIDogTWF0aC5jZWlsKG5ld1dpZHRoIC8gMik7XG4gICAgICB9XG4gICAgICBpZiAobmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgICBuZXdIZWlnaHQgPSBuZXdIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld0hlaWdodCAvIDIpIC0gMSA6IE1hdGguY2VpbChuZXdIZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBiaXRtYXAgPSBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBiaXRtYXA7XG4gIH1cbiAgI2RyYXdCaXRtYXAoKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgb3V0cHV0U2NhbGUgPSBuZXcgT3V0cHV0U2NhbGUoKTtcbiAgICBjb25zdCBzY2FsZWRXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIHBhcmVudFdpZHRoICogb3V0cHV0U2NhbGUuc3gpO1xuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBwYXJlbnRIZWlnaHQgKiBvdXRwdXRTY2FsZS5zeSk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy4jY2FudmFzO1xuICAgIGlmICghY2FudmFzIHx8IGNhbnZhcy53aWR0aCA9PT0gc2NhbGVkV2lkdGggJiYgY2FudmFzLmhlaWdodCA9PT0gc2NhbGVkSGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbnZhcy53aWR0aCA9IHNjYWxlZFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzY2FsZWRIZWlnaHQ7XG4gICAgY29uc3QgYml0bWFwID0gdGhpcy4jaXNTdmcgPyB0aGlzLiNiaXRtYXAgOiB0aGlzLiNzY2FsZUJpdG1hcChzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eC5maWx0ZXIgPSB0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyO1xuICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICB9XG4gICNzZXJpYWxpemVCaXRtYXAodG9VcmwpIHtcbiAgICBpZiAodG9VcmwpIHtcbiAgICAgIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldFN2Z1VybCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgKHtcbiAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICB9ID0gdGhpcy4jYml0bWFwKTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuI2JpdG1hcCwgMCwgMCk7XG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogcGFnZVdpZHRoICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0ICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLiNiaXRtYXAsIDAsIDAsIHRoaXMuI2JpdG1hcC53aWR0aCwgdGhpcy4jYml0bWFwLmhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHRoaXMuI2JpdG1hcCk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBsZXQgbWlzc2luZ0NhbnZhcyA9IGZhbHNlO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgU3RhbXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBzdHJ1Y3RQYXJlbnQsXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgY29udGVudHNPYmpcbiAgICAgICAgfSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYW52YXNcbiAgICAgIH0gPSBkYXRhO1xuICAgICAgbGV0IGJpdG1hcElkLCBiaXRtYXA7XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhLmNhbnZhcztcbiAgICAgICAgKHtcbiAgICAgICAgICBpZDogYml0bWFwSWQsXG4gICAgICAgICAgYml0bWFwXG4gICAgICAgIH0gPSB1aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21DYW52YXMoY29udGFpbmVyLmlkLCBjYW52YXMpKTtcbiAgICAgICAgY2FudmFzLnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWlzc2luZ0NhbnZhcyA9IHRydWU7XG4gICAgICAgIGRhdGEuX2hhc05vQ2FudmFzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFsdFRleHQgPSAoYXdhaXQgcGFyZW50Ll9zdHJ1Y3RUcmVlLmdldEFyaWFBdHRyaWJ1dGVzKGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gKSk/LmdldChcImFyaWEtbGFiZWxcIikgfHwgXCJcIjtcbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QLFxuICAgICAgICBiaXRtYXBJZCxcbiAgICAgICAgYml0bWFwLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZDogaWQsXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgYWNjZXNzaWJpbGl0eURhdGE6IHtcbiAgICAgICAgICBkZWNvcmF0aXZlOiBmYWxzZSxcbiAgICAgICAgICBhbHRUZXh0XG4gICAgICAgIH0sXG4gICAgICAgIGlzU3ZnOiBmYWxzZSxcbiAgICAgICAgc3RydWN0UGFyZW50LFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgY29tbWVudDogY29udGVudHNPYmo/LnN0ciB8fCBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgY29uc3Qge1xuICAgICAgcmVjdCxcbiAgICAgIGJpdG1hcCxcbiAgICAgIGJpdG1hcFVybCxcbiAgICAgIGJpdG1hcElkLFxuICAgICAgaXNTdmcsXG4gICAgICBhY2Nlc3NpYmlsaXR5RGF0YVxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChtaXNzaW5nQ2FudmFzKSB7XG4gICAgICB1aU1hbmFnZXIuYWRkTWlzc2luZ0NhbnZhcyhkYXRhLmlkLCBlZGl0b3IpO1xuICAgICAgZWRpdG9yLiNtaXNzaW5nQ2FudmFzID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGJpdG1hcElkICYmIHVpTWFuYWdlci5pbWFnZU1hbmFnZXIuaXNWYWxpZElkKGJpdG1hcElkKSkge1xuICAgICAgZWRpdG9yLiNiaXRtYXBJZCA9IGJpdG1hcElkO1xuICAgICAgaWYgKGJpdG1hcCkge1xuICAgICAgICBlZGl0b3IuI2JpdG1hcCA9IGJpdG1hcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLiNiaXRtYXBVcmwgPSBiaXRtYXBVcmw7XG4gICAgfVxuICAgIGVkaXRvci4jaXNTdmcgPSBpc1N2ZztcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgZWRpdG9yLndpZHRoID0gKHJlY3RbMl0gLSByZWN0WzBdKSAvIHBhcmVudFdpZHRoO1xuICAgIGVkaXRvci5oZWlnaHQgPSAocmVjdFszXSAtIHJlY3RbMV0pIC8gcGFyZW50SGVpZ2h0O1xuICAgIGlmIChhY2Nlc3NpYmlsaXR5RGF0YSkge1xuICAgICAgZWRpdG9yLmFsdFRleHREYXRhID0gYWNjZXNzaWJpbGl0eURhdGE7XG4gICAgfVxuICAgIGVkaXRvci5faW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICBpZiAoZGF0YS5jb21tZW50KSB7XG4gICAgICBlZGl0b3Iuc2V0Q29tbWVudERhdGEoZGF0YS5jb21tZW50KTtcbiAgICB9XG4gICAgZWRpdG9yLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9ICEhaW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QLFxuICAgICAgYml0bWFwSWQ6IHRoaXMuI2JpdG1hcElkLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpLFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBpc1N2ZzogdGhpcy4jaXNTdmcsXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tZW50KHNlcmlhbGl6ZWQpO1xuICAgIGlmIChpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHNlcmlhbGl6ZWQuYml0bWFwVXJsID0gdGhpcy4jc2VyaWFsaXplQml0bWFwKHRydWUpO1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHRoaXMuc2VyaWFsaXplQWx0VGV4dCh0cnVlKTtcbiAgICAgIHNlcmlhbGl6ZWQuaXNDb3B5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkZWNvcmF0aXZlLFxuICAgICAgYWx0VGV4dFxuICAgIH0gPSB0aGlzLnNlcmlhbGl6ZUFsdFRleHQoZmFsc2UpO1xuICAgIGlmICghZGVjb3JhdGl2ZSAmJiBhbHRUZXh0KSB7XG4gICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhID0ge1xuICAgICAgICB0eXBlOiBcIkZpZ3VyZVwiLFxuICAgICAgICBhbHQ6IGFsdFRleHRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLiNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKTtcbiAgICAgIGlmIChjaGFuZ2VzLmlzU2FtZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFuZ2VzLmlzU2FtZUFsdFRleHQpIHtcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhLnN0cnVjdFBhcmVudCA9IHRoaXMuX2luaXRpYWxEYXRhLnN0cnVjdFBhcmVudCA/PyAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VyaWFsaXplZC5pZCA9IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGNvbnRleHQuc3RhbXBzIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuI2lzU3ZnID8gKHNlcmlhbGl6ZWQucmVjdFsyXSAtIHNlcmlhbGl6ZWQucmVjdFswXSkgKiAoc2VyaWFsaXplZC5yZWN0WzNdIC0gc2VyaWFsaXplZC5yZWN0WzFdKSA6IG51bGw7XG4gICAgaWYgKCFjb250ZXh0LnN0YW1wcy5oYXModGhpcy4jYml0bWFwSWQpKSB7XG4gICAgICBjb250ZXh0LnN0YW1wcy5zZXQodGhpcy4jYml0bWFwSWQsIHtcbiAgICAgICAgYXJlYSxcbiAgICAgICAgc2VyaWFsaXplZFxuICAgICAgfSk7XG4gICAgICBzZXJpYWxpemVkLmJpdG1hcCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcChmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgY29uc3QgcHJldkRhdGEgPSBjb250ZXh0LnN0YW1wcy5nZXQodGhpcy4jYml0bWFwSWQpO1xuICAgICAgaWYgKGFyZWEgPiBwcmV2RGF0YS5hcmVhKSB7XG4gICAgICAgIHByZXZEYXRhLmFyZWEgPSBhcmVhO1xuICAgICAgICBwcmV2RGF0YS5zZXJpYWxpemVkLmJpdG1hcC5jbG9zZSgpO1xuICAgICAgICBwcmV2RGF0YS5zZXJpYWxpemVkLmJpdG1hcCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZUluZGV4LFxuICAgICAgYWNjZXNzaWJpbGl0eURhdGE6IHtcbiAgICAgICAgYWx0VGV4dFxuICAgICAgfVxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICBjb25zdCBpc1NhbWVQYWdlSW5kZXggPSBzZXJpYWxpemVkLnBhZ2VJbmRleCA9PT0gcGFnZUluZGV4O1xuICAgIGNvbnN0IGlzU2FtZUFsdFRleHQgPSAoc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YT8uYWx0IHx8IFwiXCIpID09PSBhbHRUZXh0O1xuICAgIHJldHVybiB7XG4gICAgICBpc1NhbWU6ICF0aGlzLmhhc0VkaXRlZENvbW1lbnQgJiYgIXRoaXMuX2hhc0JlZW5Nb3ZlZCAmJiAhdGhpcy5faGFzQmVlblJlc2l6ZWQgJiYgaXNTYW1lUGFnZUluZGV4ICYmIGlzU2FtZUFsdFRleHQsXG4gICAgICBpc1NhbWVBbHRUZXh0XG4gICAgfTtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgYW5ub3RhdGlvbi5oaWRlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgcmVjdDogdGhpcy5nZXRQREZSZWN0KClcbiAgICB9O1xuICAgIGlmICh0aGlzLmhhc0VkaXRlZENvbW1lbnQpIHtcbiAgICAgIHBhcmFtcy5wb3B1cCA9IHRoaXMuY29tbWVudDtcbiAgICB9XG4gICAgYW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQocGFyYW1zKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvYW5ub3RhdGlvbl9lZGl0b3JfbGF5ZXIuanNcblxuXG5cblxuXG5cblxuXG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIge1xuICAjYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICNhbGxvd0NsaWNrID0gZmFsc2U7XG4gICNhbm5vdGF0aW9uTGF5ZXIgPSBudWxsO1xuICAjY2xpY2tBQyA9IG51bGw7XG4gICNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IG51bGw7XG4gICNlZGl0b3JzID0gbmV3IE1hcCgpO1xuICAjaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgI2lzRGlzYWJsaW5nID0gZmFsc2U7XG4gICNpc0VuYWJsaW5nID0gZmFsc2U7XG4gICNkcmF3aW5nQUMgPSBudWxsO1xuICAjZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuICAjdGV4dExheWVyID0gbnVsbDtcbiAgI3RleHRTZWxlY3Rpb25BQyA9IG51bGw7XG4gICN0ZXh0TGF5ZXJEYmxDbGlja0FDID0gbnVsbDtcbiAgI2xhc3RQb2ludGVyRG93blRpbWVzdGFtcCA9IC0xO1xuICAjdWlNYW5hZ2VyO1xuICBzdGF0aWMgX2luaXRpYWxpemVkID0gZmFsc2U7XG4gIHN0YXRpYyAjZWRpdG9yVHlwZXMgPSBuZXcgTWFwKFtGcmVlVGV4dEVkaXRvciwgSW5rRWRpdG9yLCBTdGFtcEVkaXRvciwgSGlnaGxpZ2h0RWRpdG9yLCBTaWduYXR1cmVFZGl0b3JdLm1hcCh0eXBlID0+IFt0eXBlLl9lZGl0b3JUeXBlLCB0eXBlXSkpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdWlNYW5hZ2VyLFxuICAgIHBhZ2VJbmRleCxcbiAgICBkaXYsXG4gICAgc3RydWN0VHJlZUxheWVyLFxuICAgIGFjY2Vzc2liaWxpdHlNYW5hZ2VyLFxuICAgIGFubm90YXRpb25MYXllcixcbiAgICBkcmF3TGF5ZXIsXG4gICAgdGV4dExheWVyLFxuICAgIHZpZXdwb3J0LFxuICAgIGwxMG5cbiAgfSkge1xuICAgIGNvbnN0IGVkaXRvclR5cGVzID0gWy4uLkFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMudmFsdWVzKCldO1xuICAgIGlmICghQW5ub3RhdGlvbkVkaXRvckxheWVyLl9pbml0aWFsaXplZCkge1xuICAgICAgQW5ub3RhdGlvbkVkaXRvckxheWVyLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgZWRpdG9yVHlwZS5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHVpTWFuYWdlci5yZWdpc3RlckVkaXRvclR5cGVzKGVkaXRvclR5cGVzKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIgPSB1aU1hbmFnZXI7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgICB0aGlzLiNhbm5vdGF0aW9uTGF5ZXIgPSBhbm5vdGF0aW9uTGF5ZXI7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMuI3RleHRMYXllciA9IHRleHRMYXllcjtcbiAgICB0aGlzLmRyYXdMYXllciA9IGRyYXdMYXllcjtcbiAgICB0aGlzLl9zdHJ1Y3RUcmVlID0gc3RydWN0VHJlZUxheWVyO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRMYXllcih0aGlzKTtcbiAgfVxuICBnZXQgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdG9ycy5zaXplID09PSAwO1xuICB9XG4gIGdldCBpc0ludmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VtcHR5ICYmIHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gIH1cbiAgdXBkYXRlVG9vbGJhcihvcHRpb25zKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZVRvb2xiYXIob3B0aW9ucyk7XG4gIH1cbiAgdXBkYXRlTW9kZShtb2RlID0gdGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSkge1xuICAgIHRoaXMuI2NsZWFudXAoKTtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTpcbiAgICAgICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgICAgICB0aGlzLnRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUNsaWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LOlxuICAgICAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgICAgdGhpcy5lbmFibGVDbGljaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUOlxuICAgICAgICB0aGlzLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQ2xpY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgICAgdGhpcy5lbmFibGVDbGljaygpO1xuICAgIH1cbiAgICB0aGlzLnRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNsYXNzTGlzdFxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy52YWx1ZXMoKSkge1xuICAgICAgY2xhc3NMaXN0LnRvZ2dsZShgJHtlZGl0b3JUeXBlLl90eXBlfUVkaXRpbmdgLCBtb2RlID09PSBlZGl0b3JUeXBlLl9lZGl0b3JUeXBlKTtcbiAgICB9XG4gICAgdGhpcy5kaXYuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgaGFzVGV4dExheWVyKHRleHRMYXllcikge1xuICAgIHJldHVybiB0ZXh0TGF5ZXIgPT09IHRoaXMuI3RleHRMYXllcj8uZGl2O1xuICB9XG4gIHNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZyk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZENvbW1hbmRzKHBhcmFtcyk7XG4gIH1cbiAgY2xlYW5VbmRvU3RhY2sodHlwZSkge1xuICAgIHRoaXMuI3VpTWFuYWdlci5jbGVhblVuZG9TdGFjayh0eXBlKTtcbiAgfVxuICB0b2dnbGVEcmF3aW5nKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkcmF3aW5nXCIsICFlbmFibGVkKTtcbiAgfVxuICB0b2dnbGVQb2ludGVyRXZlbnRzKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCAhZW5hYmxlZCk7XG4gIH1cbiAgdG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyhlbmFibGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLiNhbm5vdGF0aW9uTGF5ZXI/LmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgIWVuYWJsZWQpO1xuICB9XG4gIGFzeW5jIGVuYWJsZSgpIHtcbiAgICB0aGlzLiNpc0VuYWJsaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi50YWJJbmRleCA9IDA7XG4gICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgIHRoaXMuI3RleHRMYXllckRibENsaWNrQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jdGV4dExheWVyRGJsQ2xpY2tBQyA9IG51bGw7XG4gICAgY29uc3QgYW5ub3RhdGlvbkVsZW1lbnRJZHMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgZWRpdG9yLmVuYWJsZUVkaXRpbmcoKTtcbiAgICAgIGVkaXRvci5zaG93KHRydWUpO1xuICAgICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgICAgIGFubm90YXRpb25FbGVtZW50SWRzLmFkZChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy4jYW5ub3RhdGlvbkxheWVyKSB7XG4gICAgICB0aGlzLiNpc0VuYWJsaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRhYmxlcyA9IHRoaXMuI2Fubm90YXRpb25MYXllci5nZXRFZGl0YWJsZUFubm90YXRpb25zKCk7XG4gICAgZm9yIChjb25zdCBlZGl0YWJsZSBvZiBlZGl0YWJsZXMpIHtcbiAgICAgIGVkaXRhYmxlLmhpZGUoKTtcbiAgICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdGFibGUuZGF0YS5pZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYW5ub3RhdGlvbkVsZW1lbnRJZHMuaGFzKGVkaXRhYmxlLmRhdGEuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRpdG9yID0gYXdhaXQgdGhpcy5kZXNlcmlhbGl6ZShlZGl0YWJsZSk7XG4gICAgICBpZiAoIWVkaXRvcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgICBlZGl0b3IuZW5hYmxlRWRpdGluZygpO1xuICAgIH1cbiAgICB0aGlzLiNpc0VuYWJsaW5nID0gZmFsc2U7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLiNpc0Rpc2FibGluZyA9IHRydWU7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAtMTtcbiAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgIGlmICh0aGlzLiN0ZXh0TGF5ZXIgJiYgIXRoaXMuI3RleHRMYXllckRibENsaWNrQUMpIHtcbiAgICAgIHRoaXMuI3RleHRMYXllckRibENsaWNrQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jdGV4dExheWVyRGJsQ2xpY2tBQyk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBlID0+IHtcbiAgICAgICAgY29uc3QgREJMX0NMSUNLX1RIUkVTSE9MRCA9IDUwMDtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSxcbiAgICAgICAgICB0aW1lU3RhbXBcbiAgICAgICAgfSA9IGU7XG4gICAgICAgIGNvbnN0IGxhc3RQb2ludGVyRG93blRpbWVzdGFtcCA9IHRoaXMuI2xhc3RQb2ludGVyRG93blRpbWVzdGFtcDtcbiAgICAgICAgaWYgKHRpbWVTdGFtcCAtIGxhc3RQb2ludGVyRG93blRpbWVzdGFtcCA+IERCTF9DTElDS19USFJFU0hPTEQpIHtcbiAgICAgICAgICB0aGlzLiNsYXN0UG9pbnRlckRvd25UaW1lc3RhbXAgPSB0aW1lU3RhbXA7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2xhc3RQb2ludGVyRG93blRpbWVzdGFtcCA9IC0xO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2xhc3NMaXN0XG4gICAgICAgIH0gPSB0aGlzLmRpdjtcbiAgICAgICAgY2xhc3NMaXN0LnRvZ2dsZShcImdldEVsZW1lbnRzXCIsIHRydWUpO1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50KGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgICBjbGFzc0xpc3QudG9nZ2xlKFwiZ2V0RWxlbWVudHNcIiwgZmFsc2UpO1xuICAgICAgICBpZiAoIXRoaXMuZGl2LmNvbnRhaW5zKGVsZW1lbnRzWzBdKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7QW5ub3RhdGlvbkVkaXRvclByZWZpeH1bMC05XSskYCk7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgIGlmIChyZWdleC50ZXN0KGVsZW1lbnQuaWQpKSB7XG4gICAgICAgICAgICBpZCA9IGVsZW1lbnQuaWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNlZGl0b3JzLmdldChpZCk7XG4gICAgICAgIGlmIChlZGl0b3I/LmFubm90YXRpb25FbGVtZW50SWQgPT09IG51bGwpIHtcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBlZGl0b3IuZGJsY2xpY2soKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkQW5ub3RhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcmVzZXRBbm5vdGF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBlZGl0b3IuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICAgIGlmICghZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLnNlcmlhbGl6ZSgpICE9PSBudWxsKSB7XG4gICAgICAgIGNoYW5nZWRBbm5vdGF0aW9ucy5zZXQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQsIGVkaXRvcik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRBbm5vdGF0aW9ucy5zZXQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQsIGVkaXRvcik7XG4gICAgICB9XG4gICAgICB0aGlzLmdldEVkaXRhYmxlQW5ub3RhdGlvbihlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk/LnNob3coKTtcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2Fubm90YXRpb25MYXllcikge1xuICAgICAgY29uc3QgZWRpdGFibGVzID0gdGhpcy4jYW5ub3RhdGlvbkxheWVyLmdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdGFibGUgb2YgZWRpdGFibGVzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZWRpdGFibGUuZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChpZCkpIHtcbiAgICAgICAgICBlZGl0YWJsZS51cGRhdGVFZGl0ZWQoe1xuICAgICAgICAgICAgZGVsZXRlZDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlZGl0b3IgPSByZXNldEFubm90YXRpb25zLmdldChpZCk7XG4gICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICBlZGl0b3IucmVzZXRBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZSk7XG4gICAgICAgICAgZWRpdG9yLnNob3coZmFsc2UpO1xuICAgICAgICAgIGVkaXRhYmxlLnNob3coKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IgPSBjaGFuZ2VkQW5ub3RhdGlvbnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgICAgICAgaWYgKGVkaXRvci5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZSkpIHtcbiAgICAgICAgICAgIGVkaXRvci5zaG93KGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWRpdGFibGUuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2xhc3NMaXN0XG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLnZhbHVlcygpKSB7XG4gICAgICBjbGFzc0xpc3QucmVtb3ZlKGAke2VkaXRvclR5cGUuX3R5cGV9RWRpdGluZ2ApO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgdGhpcy50b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgIHRoaXMuI2lzRGlzYWJsaW5nID0gZmFsc2U7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Fubm90YXRpb25MYXllcj8uZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB8fCBudWxsO1xuICB9XG4gIHNldEFjdGl2ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBjb25zdCBjdXJyZW50QWN0aXZlID0gdGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpO1xuICAgIGlmIChjdXJyZW50QWN0aXZlID09PSBlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEFjdGl2ZUVkaXRvcihlZGl0b3IpO1xuICB9XG4gIGVuYWJsZVRleHRTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAtMTtcbiAgICBpZiAodGhpcy4jdGV4dExheWVyPy5kaXYgJiYgIXRoaXMuI3RleHRTZWxlY3Rpb25BQykge1xuICAgICAgdGhpcy4jdGV4dFNlbGVjdGlvbkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI3RleHRTZWxlY3Rpb25BQyk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiN0ZXh0TGF5ZXJQb2ludGVyRG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRpbmdcIik7XG4gICAgfVxuICB9XG4gIGRpc2FibGVUZXh0U2VsZWN0aW9uKCkge1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gMDtcbiAgICBpZiAodGhpcy4jdGV4dExheWVyPy5kaXYgJiYgdGhpcy4jdGV4dFNlbGVjdGlvbkFDKSB7XG4gICAgICB0aGlzLiN0ZXh0U2VsZWN0aW9uQUMuYWJvcnQoKTtcbiAgICAgIHRoaXMuI3RleHRTZWxlY3Rpb25BQyA9IG51bGw7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWdobGlnaHRpbmdcIik7XG4gICAgfVxuICB9XG4gICN0ZXh0TGF5ZXJQb2ludGVyRG93bihldmVudCkge1xuICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdEFsbCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDtcbiAgICBpZiAodGFyZ2V0ID09PSB0aGlzLiN0ZXh0TGF5ZXIuZGl2IHx8ICh0YXJnZXQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSA9PT0gXCJpbWdcIiB8fCB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZW5kT2ZDb250ZW50XCIpKSAmJiB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNNYWNcbiAgICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3VpTWFuYWdlci5zaG93QWxsRWRpdG9ycyhcImhpZ2hsaWdodFwiLCB0cnVlLCB0cnVlKTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWVcIik7XG4gICAgICB0aGlzLnRvZ2dsZURyYXdpbmcoKTtcbiAgICAgIEhpZ2hsaWdodEVkaXRvci5zdGFydEhpZ2hsaWdodGluZyh0aGlzLCB0aGlzLiN1aU1hbmFnZXIuZGlyZWN0aW9uID09PSBcImx0clwiLCB7XG4gICAgICAgIHRhcmdldDogdGhpcy4jdGV4dExheWVyLmRpdixcbiAgICAgICAgeDogZXZlbnQueCxcbiAgICAgICAgeTogZXZlbnQueVxuICAgICAgfSk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJmcmVlXCIpO1xuICAgICAgICB0aGlzLnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgIH0pO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMuI2NsaWNrQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY2xpY2tBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jY2xpY2tBQyk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMucG9pbnRlcmRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgcG9pbnRlcnVwID0gdGhpcy5wb2ludGVydXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJ1cCwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgcG9pbnRlcnVwLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICBkaXNhYmxlQ2xpY2soKSB7XG4gICAgdGhpcy4jY2xpY2tBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNjbGlja0FDID0gbnVsbDtcbiAgfVxuICBhdHRhY2goZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9ycy5zZXQoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25FbGVtZW50SWRcbiAgICB9ID0gZWRpdG9yO1xuICAgIGlmIChhbm5vdGF0aW9uRWxlbWVudElkICYmIHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uRWxlbWVudElkKSkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBkZXRhY2goZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9ycy5kZWxldGUoZWRpdG9yLmlkKTtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ucmVtb3ZlUG9pbnRlckluVGV4dExheWVyKGVkaXRvci5jb250ZW50RGl2KTtcbiAgICBpZiAoIXRoaXMuI2lzRGlzYWJsaW5nICYmIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgfVxuICB9XG4gIHJlbW92ZShlZGl0b3IpIHtcbiAgICB0aGlzLmRldGFjaChlZGl0b3IpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVFZGl0b3IoZWRpdG9yKTtcbiAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgfVxuICBjaGFuZ2VQYXJlbnQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgJiYgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgICAgQW5ub3RhdGlvbkVkaXRvci5kZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmF0dGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5wYXJlbnQ/LmRldGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5zZXRQYXJlbnQodGhpcyk7XG4gICAgaWYgKGVkaXRvci5kaXYgJiYgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChlZGl0b3IuZGl2KTtcbiAgICB9XG4gIH1cbiAgYWRkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSB0aGlzICYmIGVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgdGhpcy5hdHRhY2goZWRpdG9yKTtcbiAgICBpZiAoIWVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIGNvbnN0IGRpdiA9IGVkaXRvci5yZW5kZXIoKTtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChkaXYpO1xuICAgICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IHRydWU7XG4gICAgfVxuICAgIGVkaXRvci5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIGVkaXRvci5vbmNlQWRkZWQoIXRoaXMuI2lzRW5hYmxpbmcpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gICAgZWRpdG9yLl9yZXBvcnRUZWxlbWV0cnkoZWRpdG9yLnRlbGVtZXRyeUluaXRpYWxEYXRhKTtcbiAgfVxuICBtb3ZlRWRpdG9ySW5ET00oZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkgJiYgIXRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkKSB7XG4gICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICBpZiAoIWVkaXRvci5kaXYuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBlZGl0b3IuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsICgpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgc2lnbmFsOiB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICBlZGl0b3IuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5tb3ZlRWxlbWVudEluRE9NKHRoaXMuZGl2LCBlZGl0b3IuZGl2LCBlZGl0b3IuY29udGVudERpdiwgdHJ1ZSk7XG4gIH1cbiAgYWRkT3JSZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IubmVlZHNUb0JlUmVidWlsdCgpKSB7XG4gICAgICBlZGl0b3IucGFyZW50IHx8PSB0aGlzO1xuICAgICAgZWRpdG9yLnJlYnVpbGQoKTtcbiAgICAgIGVkaXRvci5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGFkZFVuZG9hYmxlRWRpdG9yKGVkaXRvcikge1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IGVkaXRvci5fdWlNYW5hZ2VyLnJlYnVpbGQoZWRpdG9yKTtcbiAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZ2V0TmV4dElkKCkge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIuZ2V0SWQoKTtcbiAgfVxuICBnZXQgI2N1cnJlbnRFZGl0b3JUeXBlKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLmdldCh0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpKTtcbiAgfVxuICBjb21iaW5lZFNpZ25hbChhYykge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwoYWMpO1xuICB9XG4gICNjcmVhdGVOZXdFZGl0b3IocGFyYW1zKSB7XG4gICAgY29uc3QgZWRpdG9yVHlwZSA9IHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlO1xuICAgIHJldHVybiBlZGl0b3JUeXBlID8gbmV3IGVkaXRvclR5cGUucHJvdG90eXBlLmNvbnN0cnVjdG9yKHBhcmFtcykgOiBudWxsO1xuICB9XG4gIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZT8uY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKTtcbiAgfVxuICBhc3luYyBwYXN0ZUVkaXRvcihvcHRpb25zLCBwYXJhbXMpIHtcbiAgICB0aGlzLnVwZGF0ZVRvb2xiYXIob3B0aW9ucyk7XG4gICAgYXdhaXQgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZU1vZGUob3B0aW9ucy5tb2RlKTtcbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WVxuICAgIH0gPSB0aGlzLiNnZXRDZW50ZXJQb2ludCgpO1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBvZmZzZXRYLFxuICAgICAgeTogb2Zmc2V0WSxcbiAgICAgIHVpTWFuYWdlcjogdGhpcy4jdWlNYW5hZ2VyLFxuICAgICAgaXNDZW50ZXJlZDogdHJ1ZSxcbiAgICAgIC4uLnBhcmFtc1xuICAgIH0pO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEpIHtcbiAgICByZXR1cm4gKGF3YWl0IEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMuZ2V0KGRhdGEuYW5ub3RhdGlvblR5cGUgPz8gZGF0YS5hbm5vdGF0aW9uRWRpdG9yVHlwZSk/LmRlc2VyaWFsaXplKGRhdGEsIHRoaXMsIHRoaXMuI3VpTWFuYWdlcikpIHx8IG51bGw7XG4gIH1cbiAgY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBpc0NlbnRlcmVkLCBkYXRhID0ge30pIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jY3JlYXRlTmV3RWRpdG9yKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGlkLFxuICAgICAgeDogZXZlbnQub2Zmc2V0WCxcbiAgICAgIHk6IGV2ZW50Lm9mZnNldFksXG4gICAgICB1aU1hbmFnZXI6IHRoaXMuI3VpTWFuYWdlcixcbiAgICAgIGlzQ2VudGVyZWQsXG4gICAgICAuLi5kYXRhXG4gICAgfSk7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICAjZ2V0Q2VudGVyUG9pbnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB0bFggPSBNYXRoLm1heCgwLCB4KTtcbiAgICBjb25zdCB0bFkgPSBNYXRoLm1heCgwLCB5KTtcbiAgICBjb25zdCBiclggPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJXaWR0aCwgeCArIHdpZHRoKTtcbiAgICBjb25zdCBiclkgPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGNvbnN0IGNlbnRlclggPSAodGxYICsgYnJYKSAvIDIgLSB4O1xuICAgIGNvbnN0IGNlbnRlclkgPSAodGxZICsgYnJZKSAvIDIgLSB5O1xuICAgIGNvbnN0IFtvZmZzZXRYLCBvZmZzZXRZXSA9IHRoaXMudmlld3BvcnQucm90YXRpb24gJSAxODAgPT09IDAgPyBbY2VudGVyWCwgY2VudGVyWV0gOiBbY2VudGVyWSwgY2VudGVyWF07XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZXG4gICAgfTtcbiAgfVxuICBhZGROZXdFZGl0b3IoZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5jcmVhdGVBbmRBZGROZXdFZGl0b3IodGhpcy4jZ2V0Q2VudGVyUG9pbnQoKSwgdHJ1ZSwgZGF0YSk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldFNlbGVjdGVkKGVkaXRvcik7XG4gIH1cbiAgdG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnRvZ2dsZVNlbGVjdGVkKGVkaXRvcik7XG4gIH1cbiAgdW5zZWxlY3QoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVuc2VsZWN0KGVkaXRvcik7XG4gIH1cbiAgcG9pbnRlcnVwKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNoYWRQb2ludGVyRG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAgIGlmICh0aGlzLiNjdXJyZW50RWRpdG9yVHlwZT8uaXNEcmF3ZXIgJiYgdGhpcy4jY3VycmVudEVkaXRvclR5cGUuc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNhbGxvd0NsaWNrKSB7XG4gICAgICB0aGlzLiNhbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudE1vZGUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpO1xuICAgIGlmIChjdXJyZW50TW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAgfHwgY3VycmVudE1vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlNJR05BVFVSRSkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnVuc2VsZWN0QWxsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBmYWxzZSk7XG4gIH1cbiAgcG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUKSB7XG4gICAgICB0aGlzLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2hhZFBvaW50ZXJEb3duKSB7XG4gICAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IHRydWU7XG4gICAgaWYgKHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlPy5pc0RyYXdlcikge1xuICAgICAgdGhpcy5zdGFydERyYXdpbmdTZXNzaW9uKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpO1xuICAgIHRoaXMuI2FsbG93Q2xpY2sgPSAhZWRpdG9yIHx8IGVkaXRvci5pc0VtcHR5KCk7XG4gIH1cbiAgc3RhcnREcmF3aW5nU2Vzc2lvbihldmVudCkge1xuICAgIHRoaXMuZGl2LmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICB9KTtcbiAgICBpZiAodGhpcy4jZHJhd2luZ0FDKSB7XG4gICAgICB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5zdGFydERyYXdpbmcodGhpcywgdGhpcy4jdWlNYW5hZ2VyLCBmYWxzZSwgZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0Q3VycmVudERyYXdpbmdTZXNzaW9uKHRoaXMpO1xuICAgIHRoaXMuI2RyYXdpbmdBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jZHJhd2luZ0FDKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoe1xuICAgICAgcmVsYXRlZFRhcmdldFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ICYmICF0aGlzLmRpdi5jb250YWlucyhyZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICB0aGlzLiNmb2N1c2VkRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5zdGFydERyYXdpbmcodGhpcywgdGhpcy4jdWlNYW5hZ2VyLCBmYWxzZSwgZXZlbnQpO1xuICB9XG4gIHBhdXNlKG9uKSB7XG4gICAgaWYgKG9uKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICAgIH0gPSBkb2N1bWVudDtcbiAgICAgIGlmICh0aGlzLmRpdi5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICB0aGlzLiNmb2N1c2VkRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNmb2N1c2VkRWxlbWVudCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50Py5mb2N1cygpO1xuICAgICAgICB0aGlzLiNmb2N1c2VkRWxlbWVudCA9IG51bGw7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cbiAgZW5kRHJhd2luZ1Nlc3Npb24oaXNBYm9ydGVkID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuI2RyYXdpbmdBQykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRDdXJyZW50RHJhd2luZ1Nlc3Npb24obnVsbCk7XG4gICAgdGhpcy4jZHJhd2luZ0FDLmFib3J0KCk7XG4gICAgdGhpcy4jZHJhd2luZ0FDID0gbnVsbDtcbiAgICB0aGlzLiNmb2N1c2VkRWxlbWVudCA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLmVuZERyYXdpbmcoaXNBYm9ydGVkKTtcbiAgfVxuICBmaW5kTmV3UGFyZW50KGVkaXRvciwgeCwgeSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jdWlNYW5hZ2VyLmZpbmRQYXJlbnQoeCwgeSk7XG4gICAgaWYgKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB0aGlzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxheWVyLmNoYW5nZVBhcmVudChlZGl0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLiNkcmF3aW5nQUMpIHtcbiAgICAgIHRoaXMuZW5kRHJhd2luZ1Nlc3Npb24oKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy4jZHJhd2luZ0FDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLm9uU2NhbGVDaGFuZ2luZ1doZW5EcmF3aW5nKHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk/LnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCk7XG4gICAgICB0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5yZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIoZWRpdG9yLmNvbnRlbnREaXYpO1xuICAgICAgZWRpdG9yLnNldFBhcmVudChudWxsKTtcbiAgICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLiNlZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUxheWVyKHRoaXMpO1xuICB9XG4gICNjbGVhbnVwKCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVuZGVyKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHNldExheWVyRGltZW5zaW9ucyh0aGlzLmRpdiwgdmlld3BvcnQpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3VpTWFuYWdlci5nZXRFZGl0b3JzKHRoaXMucGFnZUluZGV4KSkge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTW9kZSgpO1xuICB9XG4gIHVwZGF0ZSh7XG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIHRoaXMuI3VpTWFuYWdlci5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMuI2NsZWFudXAoKTtcbiAgICBjb25zdCBvbGRSb3RhdGlvbiA9IHRoaXMudmlld3BvcnQucm90YXRpb247XG4gICAgY29uc3Qgcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuZGl2LCB7XG4gICAgICByb3RhdGlvblxuICAgIH0pO1xuICAgIGlmIChvbGRSb3RhdGlvbiAhPT0gcm90YXRpb24pIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgZWRpdG9yLnJvdGF0ZShyb3RhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBwYWdlRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMudmlld3BvcnQucmF3RGltcztcbiAgICByZXR1cm4gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gIH1cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2RyYXdfbGF5ZXIuanNcblxuXG5jbGFzcyBEcmF3TGF5ZXIge1xuICAjcGFyZW50ID0gbnVsbDtcbiAgI21hcHBpbmcgPSBuZXcgTWFwKCk7XG4gICN0b1VwZGF0ZSA9IG5ldyBNYXAoKTtcbiAgc3RhdGljICNpZCA9IDA7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYWdlSW5kZXhcbiAgfSkge1xuICAgIHRoaXMucGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBpZiAoIXRoaXMuI3BhcmVudCkge1xuICAgICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcGFyZW50ICE9PSBwYXJlbnQpIHtcbiAgICAgIGlmICh0aGlzLiNtYXBwaW5nLnNpemUgPiAwKSB7XG4gICAgICAgIGZvciAoY29uc3Qgcm9vdCBvZiB0aGlzLiNtYXBwaW5nLnZhbHVlcygpKSB7XG4gICAgICAgICAgcm9vdC5yZW1vdmUoKTtcbiAgICAgICAgICBwYXJlbnQuYXBwZW5kKHJvb3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgX3N2Z0ZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9zdmdGYWN0b3J5XCIsIG5ldyBET01TVkdGYWN0b3J5KCkpO1xuICB9XG4gIHN0YXRpYyAjc2V0Qm94KGVsZW1lbnQsIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGVsZW1lbnQ7XG4gICAgc3R5bGUudG9wID0gYCR7MTAwICogeX0lYDtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7MTAwICogeH0lYDtcbiAgICBzdHlsZS53aWR0aCA9IGAkezEwMCAqIHdpZHRofSVgO1xuICAgIHN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodH0lYDtcbiAgfVxuICAjY3JlYXRlU1ZHKCkge1xuICAgIGNvbnN0IHN2ZyA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGUoMSwgMSwgdHJ1ZSk7XG4gICAgdGhpcy4jcGFyZW50LmFwcGVuZChzdmcpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCB0cnVlKTtcbiAgICByZXR1cm4gc3ZnO1xuICB9XG4gICNjcmVhdGVDbGlwUGF0aChkZWZzLCBwYXRoSWQpIHtcbiAgICBjb25zdCBjbGlwUGF0aCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIik7XG4gICAgZGVmcy5hcHBlbmQoY2xpcFBhdGgpO1xuICAgIGNvbnN0IGNsaXBQYXRoSWQgPSBgY2xpcF8ke3BhdGhJZH1gO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIGNsaXBQYXRoSWQpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImNsaXBQYXRoVW5pdHNcIiwgXCJvYmplY3RCb3VuZGluZ0JveFwiKTtcbiAgICBjb25zdCBjbGlwUGF0aFVzZSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgIGNsaXBQYXRoLmFwcGVuZChjbGlwUGF0aFVzZSk7XG4gICAgY2xpcFBhdGhVc2Uuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgIGNsaXBQYXRoVXNlLmNsYXNzTGlzdC5hZGQoXCJjbGlwXCIpO1xuICAgIHJldHVybiBjbGlwUGF0aElkO1xuICB9XG4gICN1cGRhdGVQcm9wZXJ0aWVzKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKSkge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhdyhwcm9wZXJ0aWVzLCBpc1BhdGhVcGRhdGFibGUgPSBmYWxzZSwgaGFzQ2xpcCA9IGZhbHNlKSB7XG4gICAgY29uc3QgaWQgPSBEcmF3TGF5ZXIuI2lkKys7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI2NyZWF0ZVNWRygpO1xuICAgIGNvbnN0IGRlZnMgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgcm9vdC5hcHBlbmQoZGVmcyk7XG4gICAgY29uc3QgcGF0aCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicGF0aFwiKTtcbiAgICBkZWZzLmFwcGVuZChwYXRoKTtcbiAgICBjb25zdCBwYXRoSWQgPSBgcGF0aF9wJHt0aGlzLnBhZ2VJbmRleH1fJHtpZH1gO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgcGF0aElkKTtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcInZlY3Rvci1lZmZlY3RcIiwgXCJub24tc2NhbGluZy1zdHJva2VcIik7XG4gICAgaWYgKGlzUGF0aFVwZGF0YWJsZSkge1xuICAgICAgdGhpcy4jdG9VcGRhdGUuc2V0KGlkLCBwYXRoKTtcbiAgICB9XG4gICAgY29uc3QgY2xpcFBhdGhJZCA9IGhhc0NsaXAgPyB0aGlzLiNjcmVhdGVDbGlwUGF0aChkZWZzLCBwYXRoSWQpIDogbnVsbDtcbiAgICBjb25zdCB1c2UgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICByb290LmFwcGVuZCh1c2UpO1xuICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKHJvb3QsIHByb3BlcnRpZXMpO1xuICAgIHRoaXMuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICBjbGlwUGF0aElkOiBgdXJsKCMke2NsaXBQYXRoSWR9KWBcbiAgICB9O1xuICB9XG4gIGRyYXdPdXRsaW5lKHByb3BlcnRpZXMsIG11c3RSZW1vdmVTZWxmSW50ZXJzZWN0aW9ucykge1xuICAgIGNvbnN0IGlkID0gRHJhd0xheWVyLiNpZCsrO1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLiNjcmVhdGVTVkcoKTtcbiAgICBjb25zdCBkZWZzID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIpO1xuICAgIHJvb3QuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IHBhdGggPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInBhdGhcIik7XG4gICAgZGVmcy5hcHBlbmQocGF0aCk7XG4gICAgY29uc3QgcGF0aElkID0gYHBhdGhfcCR7dGhpcy5wYWdlSW5kZXh9XyR7aWR9YDtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIHBhdGhJZCk7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJ2ZWN0b3ItZWZmZWN0XCIsIFwibm9uLXNjYWxpbmctc3Ryb2tlXCIpO1xuICAgIGxldCBtYXNrSWQ7XG4gICAgaWYgKG11c3RSZW1vdmVTZWxmSW50ZXJzZWN0aW9ucykge1xuICAgICAgY29uc3QgbWFzayA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwibWFza1wiKTtcbiAgICAgIGRlZnMuYXBwZW5kKG1hc2spO1xuICAgICAgbWFza0lkID0gYG1hc2tfcCR7dGhpcy5wYWdlSW5kZXh9XyR7aWR9YDtcbiAgICAgIG1hc2suc2V0QXR0cmlidXRlKFwiaWRcIiwgbWFza0lkKTtcbiAgICAgIG1hc2suc2V0QXR0cmlidXRlKFwibWFza1VuaXRzXCIsIFwib2JqZWN0Qm91bmRpbmdCb3hcIik7XG4gICAgICBjb25zdCByZWN0ID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIpO1xuICAgICAgbWFzay5hcHBlbmQocmVjdCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMVwiKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMVwiKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcIndoaXRlXCIpO1xuICAgICAgY29uc3QgdXNlID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIik7XG4gICAgICBtYXNrLmFwcGVuZCh1c2UpO1xuICAgICAgdXNlLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke3BhdGhJZH1gKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJub25lXCIpO1xuICAgICAgdXNlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJibGFja1wiKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJmaWxsLXJ1bGVcIiwgXCJub256ZXJvXCIpO1xuICAgICAgdXNlLmNsYXNzTGlzdC5hZGQoXCJtYXNrXCIpO1xuICAgIH1cbiAgICBjb25zdCB1c2UxID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIik7XG4gICAgcm9vdC5hcHBlbmQodXNlMSk7XG4gICAgdXNlMS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgaWYgKG1hc2tJZCkge1xuICAgICAgdXNlMS5zZXRBdHRyaWJ1dGUoXCJtYXNrXCIsIGB1cmwoIyR7bWFza0lkfSlgKTtcbiAgICB9XG4gICAgY29uc3QgdXNlMiA9IHVzZTEuY2xvbmVOb2RlKCk7XG4gICAgcm9vdC5hcHBlbmQodXNlMik7XG4gICAgdXNlMS5jbGFzc0xpc3QuYWRkKFwibWFpbk91dGxpbmVcIik7XG4gICAgdXNlMi5jbGFzc0xpc3QuYWRkKFwic2Vjb25kYXJ5T3V0bGluZVwiKTtcbiAgICB0aGlzLnVwZGF0ZVByb3BlcnRpZXMocm9vdCwgcHJvcGVydGllcyk7XG4gICAgdGhpcy4jbWFwcGluZy5zZXQoaWQsIHJvb3QpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBmaW5hbGl6ZURyYXcoaWQsIHByb3BlcnRpZXMpIHtcbiAgICB0aGlzLiN0b1VwZGF0ZS5kZWxldGUoaWQpO1xuICAgIHRoaXMudXBkYXRlUHJvcGVydGllcyhpZCwgcHJvcGVydGllcyk7XG4gIH1cbiAgdXBkYXRlUHJvcGVydGllcyhlbGVtZW50T3JJZCwgcHJvcGVydGllcykge1xuICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICByb290LFxuICAgICAgYmJveCxcbiAgICAgIHJvb3RDbGFzcyxcbiAgICAgIHBhdGhcbiAgICB9ID0gcHJvcGVydGllcztcbiAgICBjb25zdCBlbGVtZW50ID0gdHlwZW9mIGVsZW1lbnRPcklkID09PSBcIm51bWJlclwiID8gdGhpcy4jbWFwcGluZy5nZXQoZWxlbWVudE9ySWQpIDogZWxlbWVudE9ySWQ7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyb290KSB7XG4gICAgICB0aGlzLiN1cGRhdGVQcm9wZXJ0aWVzKGVsZW1lbnQsIHJvb3QpO1xuICAgIH1cbiAgICBpZiAoYmJveCkge1xuICAgICAgRHJhd0xheWVyLiNzZXRCb3goZWxlbWVudCwgYmJveCk7XG4gICAgfVxuICAgIGlmIChyb290Q2xhc3MpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xhc3NMaXN0XG4gICAgICB9ID0gZWxlbWVudDtcbiAgICAgIGZvciAoY29uc3QgW2NsYXNzTmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJvb3RDbGFzcykpIHtcbiAgICAgICAgY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGNvbnN0IGRlZnMgPSBlbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICBjb25zdCBwYXRoRWxlbWVudCA9IGRlZnMuZmlyc3RDaGlsZDtcbiAgICAgIHRoaXMuI3VwZGF0ZVByb3BlcnRpZXMocGF0aEVsZW1lbnQsIHBhdGgpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJlbnQoaWQsIGxheWVyKSB7XG4gICAgaWYgKGxheWVyID09PSB0aGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvb3QgPSB0aGlzLiNtYXBwaW5nLmdldChpZCk7XG4gICAgaWYgKCFyb290KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxheWVyLiNwYXJlbnQuYXBwZW5kKHJvb3QpO1xuICAgIHRoaXMuI21hcHBpbmcuZGVsZXRlKGlkKTtcbiAgICBsYXllci4jbWFwcGluZy5zZXQoaWQsIHJvb3QpO1xuICB9XG4gIHJlbW92ZShpZCkge1xuICAgIHRoaXMuI3RvVXBkYXRlLmRlbGV0ZShpZCk7XG4gICAgaWYgKHRoaXMuI3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNtYXBwaW5nLmdldChpZCkucmVtb3ZlKCk7XG4gICAgdGhpcy4jbWFwcGluZy5kZWxldGUoaWQpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jcGFyZW50ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHJvb3Qgb2YgdGhpcy4jbWFwcGluZy52YWx1ZXMoKSkge1xuICAgICAgcm9vdC5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy4jbWFwcGluZy5jbGVhcigpO1xuICAgIHRoaXMuI3RvVXBkYXRlLmNsZWFyKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL3BkZi5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG57XG4gIGdsb2JhbFRoaXMuX3BkZmpzVGVzdGluZ1V0aWxzID0ge1xuICAgIEhpZ2hsaWdodE91dGxpbmVyOiBIaWdobGlnaHRPdXRsaW5lclxuICB9O1xufVxuZ2xvYmFsVGhpcy5wZGZqc0xpYiA9IHtcbiAgQWJvcnRFeGNlcHRpb246IEFib3J0RXhjZXB0aW9uLFxuICBBbm5vdGF0aW9uRWRpdG9yTGF5ZXI6IEFubm90YXRpb25FZGl0b3JMYXllcixcbiAgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLFxuICBBbm5vdGF0aW9uRWRpdG9yVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUsXG4gIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXI6IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIsXG4gIEFubm90YXRpb25MYXllcjogQW5ub3RhdGlvbkxheWVyLFxuICBBbm5vdGF0aW9uTW9kZTogQW5ub3RhdGlvbk1vZGUsXG4gIEFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uVHlwZSxcbiAgYnVpbGQ6IGJ1aWxkLFxuICBDb2xvclBpY2tlcjogQ29sb3JQaWNrZXIsXG4gIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmw6IGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwsXG4gIERPTVNWR0ZhY3Rvcnk6IERPTVNWR0ZhY3RvcnksXG4gIERyYXdMYXllcjogRHJhd0xheWVyLFxuICBGZWF0dXJlVGVzdDogdXRpbF9GZWF0dXJlVGVzdCxcbiAgZmV0Y2hEYXRhOiBmZXRjaERhdGEsXG4gIGdldERvY3VtZW50OiBnZXREb2N1bWVudCxcbiAgZ2V0RmlsZW5hbWVGcm9tVXJsOiBnZXRGaWxlbmFtZUZyb21VcmwsXG4gIGdldFBkZkZpbGVuYW1lRnJvbVVybDogZ2V0UGRmRmlsZW5hbWVGcm9tVXJsLFxuICBnZXRSR0I6IGdldFJHQixcbiAgZ2V0VXVpZDogZ2V0VXVpZCxcbiAgZ2V0WGZhUGFnZVZpZXdwb3J0OiBnZXRYZmFQYWdlVmlld3BvcnQsXG4gIEdsb2JhbFdvcmtlck9wdGlvbnM6IEdsb2JhbFdvcmtlck9wdGlvbnMsXG4gIEltYWdlS2luZDogdXRpbF9JbWFnZUtpbmQsXG4gIEludmFsaWRQREZFeGNlcHRpb246IEludmFsaWRQREZFeGNlcHRpb24sXG4gIGlzRGF0YVNjaGVtZTogaXNEYXRhU2NoZW1lLFxuICBpc1BkZkZpbGU6IGlzUGRmRmlsZSxcbiAgaXNWYWxpZEV4cGxpY2l0RGVzdDogaXNWYWxpZEV4cGxpY2l0RGVzdCxcbiAgTWF0aENsYW1wOiBNYXRoQ2xhbXAsXG4gIG5vQ29udGV4dE1lbnU6IG5vQ29udGV4dE1lbnUsXG4gIG5vcm1hbGl6ZVVuaWNvZGU6IG5vcm1hbGl6ZVVuaWNvZGUsXG4gIE9QUzogT1BTLFxuICBPdXRwdXRTY2FsZTogT3V0cHV0U2NhbGUsXG4gIFBhc3N3b3JkUmVzcG9uc2VzOiBQYXNzd29yZFJlc3BvbnNlcyxcbiAgUERGRGF0YVJhbmdlVHJhbnNwb3J0OiBQREZEYXRhUmFuZ2VUcmFuc3BvcnQsXG4gIFBERkRhdGVTdHJpbmc6IFBERkRhdGVTdHJpbmcsXG4gIFBERldvcmtlcjogUERGV29ya2VyLFxuICBQZXJtaXNzaW9uRmxhZzogUGVybWlzc2lvbkZsYWcsXG4gIFBpeGVsc1BlckluY2g6IFBpeGVsc1BlckluY2gsXG4gIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjogUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uLFxuICBSZXNwb25zZUV4Y2VwdGlvbjogUmVzcG9uc2VFeGNlcHRpb24sXG4gIHNldExheWVyRGltZW5zaW9uczogc2V0TGF5ZXJEaW1lbnNpb25zLFxuICBzaGFkb3c6IHNoYWRvdyxcbiAgU2lnbmF0dXJlRXh0cmFjdG9yOiBTaWduYXR1cmVFeHRyYWN0b3IsXG4gIHN0b3BFdmVudDogc3RvcEV2ZW50LFxuICBTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlczogU3VwcG9ydGVkSW1hZ2VNaW1lVHlwZXMsXG4gIFRleHRMYXllcjogVGV4dExheWVyLFxuICBUb3VjaE1hbmFnZXI6IFRvdWNoTWFuYWdlcixcbiAgdXBkYXRlVXJsSGFzaDogdXBkYXRlVXJsSGFzaCxcbiAgVXRpbDogVXRpbCxcbiAgVmVyYm9zaXR5TGV2ZWw6IFZlcmJvc2l0eUxldmVsLFxuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICBYZmFMYXllcjogWGZhTGF5ZXJcbn07XG5cbmV4cG9ydCB7IEFib3J0RXhjZXB0aW9uLCBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIsIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLCBBbm5vdGF0aW9uRWRpdG9yVHlwZSwgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciwgQW5ub3RhdGlvbkxheWVyLCBBbm5vdGF0aW9uTW9kZSwgQW5ub3RhdGlvblR5cGUsIENvbG9yUGlja2VyLCBET01TVkdGYWN0b3J5LCBEcmF3TGF5ZXIsIHV0aWxfRmVhdHVyZVRlc3QgYXMgRmVhdHVyZVRlc3QsIEdsb2JhbFdvcmtlck9wdGlvbnMsIHV0aWxfSW1hZ2VLaW5kIGFzIEltYWdlS2luZCwgSW52YWxpZFBERkV4Y2VwdGlvbiwgTWF0aENsYW1wLCBPUFMsIE91dHB1dFNjYWxlLCBQREZEYXRhUmFuZ2VUcmFuc3BvcnQsIFBERkRhdGVTdHJpbmcsIFBERldvcmtlciwgUGFzc3dvcmRSZXNwb25zZXMsIFBlcm1pc3Npb25GbGFnLCBQaXhlbHNQZXJJbmNoLCBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24sIFJlc3BvbnNlRXhjZXB0aW9uLCBTaWduYXR1cmVFeHRyYWN0b3IsIFN1cHBvcnRlZEltYWdlTWltZVR5cGVzLCBUZXh0TGF5ZXIsIFRvdWNoTWFuYWdlciwgVXRpbCwgVmVyYm9zaXR5TGV2ZWwsIFhmYUxheWVyLCBidWlsZCwgY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCwgZmV0Y2hEYXRhLCBnZXREb2N1bWVudCwgZ2V0RmlsZW5hbWVGcm9tVXJsLCBnZXRQZGZGaWxlbmFtZUZyb21VcmwsIGdldFJHQiwgZ2V0VXVpZCwgZ2V0WGZhUGFnZVZpZXdwb3J0LCBpc0RhdGFTY2hlbWUsIGlzUGRmRmlsZSwgaXNWYWxpZEV4cGxpY2l0RGVzdCwgbm9Db250ZXh0TWVudSwgbm9ybWFsaXplVW5pY29kZSwgc2V0TGF5ZXJEaW1lbnNpb25zLCBzaGFkb3csIHN0b3BFdmVudCwgdXBkYXRlVXJsSGFzaCwgdmVyc2lvbiB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZGYubWpzLm1hcCJdLCJuYW1lcyI6WyJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiZCIsImV4cG9ydHMiLCJkZWZpbml0aW9uIiwia2V5IiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsIm9iaiIsInByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiaXNOb2RlSlMiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJudyIsImVsZWN0cm9uIiwidHlwZSIsIkZPTlRfSURFTlRJVFlfTUFUUklYIiwiTElORV9GQUNUT1IiLCJMSU5FX0RFU0NFTlRfRkFDVE9SIiwiQkFTRUxJTkVfRkFDVE9SIiwiUmVuZGVyaW5nSW50ZW50RmxhZyIsIkFOWSIsIkRJU1BMQVkiLCJQUklOVCIsIlNBVkUiLCJBTk5PVEFUSU9OU19GT1JNUyIsIkFOTk9UQVRJT05TX1NUT1JBR0UiLCJBTk5PVEFUSU9OU19ESVNBQkxFIiwiSVNfRURJVElORyIsIk9QTElTVCIsIkFubm90YXRpb25Nb2RlIiwiRElTQUJMRSIsIkVOQUJMRSIsIkVOQUJMRV9GT1JNUyIsIkVOQUJMRV9TVE9SQUdFIiwiQW5ub3RhdGlvbkVkaXRvclByZWZpeCIsIkFubm90YXRpb25FZGl0b3JUeXBlIiwiTk9ORSIsIkZSRUVURVhUIiwiSElHSExJR0hUIiwiU1RBTVAiLCJJTksiLCJQT1BVUCIsIlNJR05BVFVSRSIsIkNPTU1FTlQiLCJBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSIsIlJFU0laRSIsIkNSRUFURSIsIkZSRUVURVhUX1NJWkUiLCJGUkVFVEVYVF9DT0xPUiIsIkZSRUVURVhUX09QQUNJVFkiLCJJTktfQ09MT1IiLCJJTktfVEhJQ0tORVNTIiwiSU5LX09QQUNJVFkiLCJISUdITElHSFRfQ09MT1IiLCJISUdITElHSFRfVEhJQ0tORVNTIiwiSElHSExJR0hUX0ZSRUUiLCJISUdITElHSFRfU0hPV19BTEwiLCJEUkFXX1NURVAiLCJQZXJtaXNzaW9uRmxhZyIsIk1PRElGWV9DT05URU5UUyIsIkNPUFkiLCJNT0RJRllfQU5OT1RBVElPTlMiLCJGSUxMX0lOVEVSQUNUSVZFX0ZPUk1TIiwiQ09QWV9GT1JfQUNDRVNTSUJJTElUWSIsIkFTU0VNQkxFIiwiUFJJTlRfSElHSF9RVUFMSVRZIiwiVGV4dFJlbmRlcmluZ01vZGUiLCJGSUxMIiwiU1RST0tFIiwiRklMTF9TVFJPS0UiLCJJTlZJU0lCTEUiLCJGSUxMX0FERF9UT19QQVRIIiwiU1RST0tFX0FERF9UT19QQVRIIiwiRklMTF9TVFJPS0VfQUREX1RPX1BBVEgiLCJBRERfVE9fUEFUSCIsIkZJTExfU1RST0tFX01BU0siLCJBRERfVE9fUEFUSF9GTEFHIiwidXRpbF9JbWFnZUtpbmQiLCJHUkFZU0NBTEVfMUJQUCIsIlJHQl8yNEJQUCIsIlJHQkFfMzJCUFAiLCJBbm5vdGF0aW9uVHlwZSIsIlRFWFQiLCJMSU5LIiwiTElORSIsIlNRVUFSRSIsIkNJUkNMRSIsIlBPTFlHT04iLCJQT0xZTElORSIsIlVOREVSTElORSIsIlNRVUlHR0xZIiwiU1RSSUtFT1VUIiwiQ0FSRVQiLCJGSUxFQVRUQUNITUVOVCIsIlNPVU5EIiwiTU9WSUUiLCJXSURHRVQiLCJTQ1JFRU4iLCJQUklOVEVSTUFSSyIsIlRSQVBORVQiLCJXQVRFUk1BUksiLCJUSFJFRUQiLCJSRURBQ1QiLCJBbm5vdGF0aW9uUmVwbHlUeXBlIiwiR1JPVVAiLCJSRVBMWSIsIkFubm90YXRpb25GbGFnIiwiSElEREVOIiwiTk9aT09NIiwiTk9ST1RBVEUiLCJOT1ZJRVciLCJSRUFET05MWSIsIkxPQ0tFRCIsIlRPR0dMRU5PVklFVyIsIkxPQ0tFRENPTlRFTlRTIiwiQW5ub3RhdGlvbkZpZWxkRmxhZyIsIlJFUVVJUkVEIiwiTk9FWFBPUlQiLCJNVUxUSUxJTkUiLCJQQVNTV09SRCIsIk5PVE9HR0xFVE9PRkYiLCJSQURJTyIsIlBVU0hCVVRUT04iLCJDT01CTyIsIkVESVQiLCJTT1JUIiwiRklMRVNFTEVDVCIsIk1VTFRJU0VMRUNUIiwiRE9OT1RTUEVMTENIRUNLIiwiRE9OT1RTQ1JPTEwiLCJDT01CIiwiUklDSFRFWFQiLCJSQURJT1NJTlVOSVNPTiIsIkNPTU1JVE9OU0VMQ0hBTkdFIiwiQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSIsIlNPTElEIiwiREFTSEVEIiwiQkVWRUxFRCIsIklOU0VUIiwiQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSIsIkUiLCJYIiwiRCIsIlUiLCJGbyIsIkJsIiwiUE8iLCJQQyIsIlBWIiwiUEkiLCJLIiwiRiIsIlYiLCJDIiwiRG9jdW1lbnRBY3Rpb25FdmVudFR5cGUiLCJXQyIsIldTIiwiRFMiLCJXUCIsIkRQIiwiUGFnZUFjdGlvbkV2ZW50VHlwZSIsIk8iLCJWZXJib3NpdHlMZXZlbCIsIkVSUk9SUyIsIldBUk5JTkdTIiwiSU5GT1MiLCJPUFMiLCJkZXBlbmRlbmN5Iiwic2V0TGluZVdpZHRoIiwic2V0TGluZUNhcCIsInNldExpbmVKb2luIiwic2V0TWl0ZXJMaW1pdCIsInNldERhc2giLCJzZXRSZW5kZXJpbmdJbnRlbnQiLCJzZXRGbGF0bmVzcyIsInNldEdTdGF0ZSIsInNhdmUiLCJyZXN0b3JlIiwidHJhbnNmb3JtIiwibW92ZVRvIiwibGluZVRvIiwiY3VydmVUbyIsImN1cnZlVG8yIiwiY3VydmVUbzMiLCJjbG9zZVBhdGgiLCJyZWN0YW5nbGUiLCJzdHJva2UiLCJjbG9zZVN0cm9rZSIsImZpbGwiLCJlb0ZpbGwiLCJmaWxsU3Ryb2tlIiwiZW9GaWxsU3Ryb2tlIiwiY2xvc2VGaWxsU3Ryb2tlIiwiY2xvc2VFT0ZpbGxTdHJva2UiLCJlbmRQYXRoIiwiY2xpcCIsImVvQ2xpcCIsImJlZ2luVGV4dCIsImVuZFRleHQiLCJzZXRDaGFyU3BhY2luZyIsInNldFdvcmRTcGFjaW5nIiwic2V0SFNjYWxlIiwic2V0TGVhZGluZyIsInNldEZvbnQiLCJzZXRUZXh0UmVuZGVyaW5nTW9kZSIsInNldFRleHRSaXNlIiwibW92ZVRleHQiLCJzZXRMZWFkaW5nTW92ZVRleHQiLCJzZXRUZXh0TWF0cml4IiwibmV4dExpbmUiLCJzaG93VGV4dCIsInNob3dTcGFjZWRUZXh0IiwibmV4dExpbmVTaG93VGV4dCIsIm5leHRMaW5lU2V0U3BhY2luZ1Nob3dUZXh0Iiwic2V0Q2hhcldpZHRoIiwic2V0Q2hhcldpZHRoQW5kQm91bmRzIiwic2V0U3Ryb2tlQ29sb3JTcGFjZSIsInNldEZpbGxDb2xvclNwYWNlIiwic2V0U3Ryb2tlQ29sb3IiLCJzZXRTdHJva2VDb2xvck4iLCJzZXRGaWxsQ29sb3IiLCJzZXRGaWxsQ29sb3JOIiwic2V0U3Ryb2tlR3JheSIsInNldEZpbGxHcmF5Iiwic2V0U3Ryb2tlUkdCQ29sb3IiLCJzZXRGaWxsUkdCQ29sb3IiLCJzZXRTdHJva2VDTVlLQ29sb3IiLCJzZXRGaWxsQ01ZS0NvbG9yIiwic2hhZGluZ0ZpbGwiLCJiZWdpbklubGluZUltYWdlIiwiYmVnaW5JbWFnZURhdGEiLCJlbmRJbmxpbmVJbWFnZSIsInBhaW50WE9iamVjdCIsIm1hcmtQb2ludCIsIm1hcmtQb2ludFByb3BzIiwiYmVnaW5NYXJrZWRDb250ZW50IiwiYmVnaW5NYXJrZWRDb250ZW50UHJvcHMiLCJlbmRNYXJrZWRDb250ZW50IiwiYmVnaW5Db21wYXQiLCJlbmRDb21wYXQiLCJwYWludEZvcm1YT2JqZWN0QmVnaW4iLCJwYWludEZvcm1YT2JqZWN0RW5kIiwiYmVnaW5Hcm91cCIsImVuZEdyb3VwIiwiYmVnaW5Bbm5vdGF0aW9uIiwiZW5kQW5ub3RhdGlvbiIsInBhaW50SW1hZ2VNYXNrWE9iamVjdCIsInBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwIiwicGFpbnRJbWFnZVhPYmplY3QiLCJwYWludElubGluZUltYWdlWE9iamVjdCIsInBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAiLCJwYWludEltYWdlWE9iamVjdFJlcGVhdCIsInBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdCIsInBhaW50U29saWRDb2xvckltYWdlTWFzayIsImNvbnN0cnVjdFBhdGgiLCJzZXRTdHJva2VUcmFuc3BhcmVudCIsInNldEZpbGxUcmFuc3BhcmVudCIsInJhd0ZpbGxQYXRoIiwiRHJhd09QUyIsIlBhc3N3b3JkUmVzcG9uc2VzIiwiTkVFRF9QQVNTV09SRCIsIklOQ09SUkVDVF9QQVNTV09SRCIsInZlcmJvc2l0eSIsInNldFZlcmJvc2l0eUxldmVsIiwibGV2ZWwiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJnZXRWZXJib3NpdHlMZXZlbCIsImluZm8iLCJtc2ciLCJjb25zb2xlIiwibG9nIiwid2FybiIsInVucmVhY2hhYmxlIiwiRXJyb3IiLCJhc3NlcnQiLCJjb25kIiwiX2lzVmFsaWRQcm90b2NvbCIsInVybCIsInByb3RvY29sIiwiY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCIsImJhc2VVcmwiLCJvcHRpb25zIiwiYWRkRGVmYXVsdFByb3RvY29sIiwic3RhcnRzV2l0aCIsImRvdHMiLCJtYXRjaCIsImxlbmd0aCIsInRyeUNvbnZlcnRFbmNvZGluZyIsInN0cmluZ1RvVVRGOFN0cmluZyIsImFic29sdXRlVXJsIiwiVVJMIiwicGFyc2UiLCJ1cGRhdGVVcmxIYXNoIiwiaGFzaCIsImFsbG93UmVsIiwicmVzIiwiaHJlZiIsInNwbGl0Iiwic2hhZG93IiwidmFsdWUiLCJub25TZXJpYWxpemFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIkJhc2VFeGNlcHRpb24iLCJCYXNlRXhjZXB0aW9uQ2xvc3VyZSIsIm1lc3NhZ2UiLCJuYW1lIiwiY29uc3RydWN0b3IiLCJQYXNzd29yZEV4Y2VwdGlvbiIsImNvZGUiLCJVbmtub3duRXJyb3JFeGNlcHRpb24iLCJkZXRhaWxzIiwiSW52YWxpZFBERkV4Y2VwdGlvbiIsIlJlc3BvbnNlRXhjZXB0aW9uIiwic3RhdHVzIiwibWlzc2luZyIsIkZvcm1hdEVycm9yIiwiQWJvcnRFeGNlcHRpb24iLCJieXRlc1RvU3RyaW5nIiwiYnl0ZXMiLCJ1bmRlZmluZWQiLCJNQVhfQVJHVU1FTlRfQ09VTlQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsInN0ckJ1ZiIsImkiLCJjaHVua0VuZCIsIk1hdGgiLCJtaW4iLCJjaHVuayIsInN1YmFycmF5IiwicHVzaCIsImpvaW4iLCJzdHJpbmdUb0J5dGVzIiwic3RyIiwiVWludDhBcnJheSIsImNoYXJDb2RlQXQiLCJzdHJpbmczMiIsIm9iamVjdFNpemUiLCJrZXlzIiwiaXNMaXR0bGVFbmRpYW4iLCJidWZmZXI4IiwidmlldzMyIiwiVWludDMyQXJyYXkiLCJidWZmZXIiLCJpc0V2YWxTdXBwb3J0ZWQiLCJGdW5jdGlvbiIsInV0aWxfRmVhdHVyZVRlc3QiLCJpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCIsIk9mZnNjcmVlbkNhbnZhcyIsImlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkIiwiSW1hZ2VEZWNvZGVyIiwicGxhdGZvcm0iLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJpc0FuZHJvaWQiLCJpbmNsdWRlcyIsImlzTGludXgiLCJpc01hYyIsImlzV2luZG93cyIsImlzRmlyZWZveCIsImlzQ1NTUm91bmRTdXBwb3J0ZWQiLCJnbG9iYWxUaGlzIiwiQ1NTIiwic3VwcG9ydHMiLCJoZXhOdW1iZXJzIiwiQXJyYXkiLCJmcm9tIiwibiIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJVdGlsIiwibWFrZUhleENvbG9yIiwiciIsImciLCJiIiwiZG9tTWF0cml4VG9UcmFuc2Zvcm0iLCJkbSIsImEiLCJjIiwiZSIsImYiLCJzY2FsZU1pbk1heCIsIm1pbk1heCIsInRlbXAiLCJtMSIsIm0yIiwibXVsdGlwbHlCeURPTU1hdHJpeCIsIm0iLCJtZCIsImFwcGx5VHJhbnNmb3JtIiwicCIsInBvcyIsInAwIiwicDEiLCJhcHBseVRyYW5zZm9ybVRvQmV6aWVyIiwibTAiLCJtMyIsIm00IiwibTUiLCJwSSIsInBJMSIsImFwcGx5SW52ZXJzZVRyYW5zZm9ybSIsImF4aWFsQWxpZ25lZEJvdW5kaW5nQm94IiwicmVjdCIsIm91dHB1dCIsInIwIiwicjEiLCJyMiIsInIzIiwiYTAiLCJhMiIsImExIiwiYTMiLCJiMCIsImIyIiwiYjEiLCJiMyIsIm0xcjAiLCJtMXIyIiwibTJyMSIsIm0ycjMiLCJtYXgiLCJpbnZlcnNlVHJhbnNmb3JtIiwic2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUiLCJtYXRyaXgiLCJmaXJzdCIsInNlY29uZCIsInNxcnQiLCJub3JtYWxpemVSZWN0Iiwic2xpY2UiLCJpbnRlcnNlY3QiLCJyZWN0MSIsInJlY3QyIiwieExvdyIsInhIaWdoIiwieUxvdyIsInlIaWdoIiwicG9pbnRCb3VuZGluZ0JveCIsIngiLCJ5IiwicmVjdEJvdW5kaW5nQm94IiwieDAiLCJ5MCIsIngxIiwieTEiLCJnZXRFeHRyZW11bU9uQ3VydmUiLCJ4MiIsIngzIiwieTIiLCJ5MyIsInQiLCJtdCIsInR0IiwidHR0IiwiZ2V0RXh0cmVtdW0iLCJhYnMiLCJkZWx0YSIsInNxcnREZWx0YSIsImJlemllckJvdW5kaW5nQm94IiwiUERGU3RyaW5nVHJhbnNsYXRlVGFibGUiLCJzdHJpbmdUb1BERlN0cmluZyIsImtlZXBFc2NhcGVTZXF1ZW5jZSIsImVuY29kaW5nIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiZmF0YWwiLCJkZWNvZGVkIiwiZGVjb2RlIiwicmVwbGFjZUFsbCIsImV4IiwiaWkiLCJjaGFyQ29kZSIsImNoYXJBdCIsImRlY29kZVVSSUNvbXBvbmVudCIsImVzY2FwZSIsInV0ZjhTdHJpbmdUb1N0cmluZyIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiaXNBcnJheUVxdWFsIiwiYXJyMSIsImFycjIiLCJnZXRNb2RpZmljYXRpb25EYXRlIiwiZGF0ZSIsIkRhdGUiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJOb3JtYWxpemVSZWdleCIsIk5vcm1hbGl6YXRpb25NYXAiLCJub3JtYWxpemVVbmljb2RlIiwiTWFwIiwiXyIsInAyIiwibm9ybWFsaXplIiwiZ2V0VXVpZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJidWYiLCJnZXRSYW5kb21WYWx1ZXMiLCJBbm5vdGF0aW9uUHJlZml4IiwiX2lzVmFsaWRFeHBsaWNpdERlc3QiLCJ2YWxpZFJlZiIsInZhbGlkTmFtZSIsImRlc3QiLCJpc0FycmF5IiwicGFnZSIsInpvb20iLCJhcmdzIiwiYXJnc0xlbiIsImFsbG93TnVsbCIsImFyZyIsIk1hdGhDbGFtcCIsInYiLCJ0b0hleFV0aWwiLCJhcnIiLCJ0b0hleCIsIm51bSIsInRvQmFzZTY0VXRpbCIsInRvQmFzZTY0IiwiYnRvYSIsImZyb21CYXNlNjRVdGlsIiwiZnJvbUJhc2U2NCIsImF0b2IiLCJQcm9taXNlIiwidHJ5IiwiZm4iLCJyZXNvbHZlIiwic3VtUHJlY2lzZSIsIm51bWJlcnMiLCJyZWR1Y2UiLCJTVkdfTlMiLCJQaXhlbHNQZXJJbmNoIiwiUERGIiwiUERGX1RPX0NTU19VTklUUyIsImZldGNoRGF0YSIsImlzVmFsaWRGZXRjaFVybCIsImRvY3VtZW50IiwiYmFzZVVSSSIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInN0YXR1c1RleHQiLCJhcnJheUJ1ZmZlciIsImJsb2IiLCJqc29uIiwidGV4dCIsInJlamVjdCIsInJlcXVlc3QiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwiRE9ORSIsInJlc3BvbnNlVGV4dCIsInNlbmQiLCJQYWdlVmlld3BvcnQiLCJ2aWV3Qm94IiwidXNlclVuaXQiLCJzY2FsZSIsInJvdGF0aW9uIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJkb250RmxpcCIsImNlbnRlclgiLCJjZW50ZXJZIiwicm90YXRlQSIsInJvdGF0ZUIiLCJyb3RhdGVDIiwicm90YXRlRCIsIm9mZnNldENhbnZhc1giLCJvZmZzZXRDYW52YXNZIiwid2lkdGgiLCJoZWlnaHQiLCJyYXdEaW1zIiwiZGltcyIsInBhZ2VXaWR0aCIsInBhZ2VIZWlnaHQiLCJwYWdlWCIsInBhZ2VZIiwiY2xvbmUiLCJjb252ZXJ0VG9WaWV3cG9ydFBvaW50IiwiY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUiLCJ0b3BMZWZ0IiwiYm90dG9tUmlnaHQiLCJjb252ZXJ0VG9QZGZQb2ludCIsIlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiIsImV4dHJhRGVsYXkiLCJpc0RhdGFTY2hlbWUiLCJ0cmltIiwic3Vic3RyaW5nIiwidG9Mb3dlckNhc2UiLCJpc1BkZkZpbGUiLCJmaWxlbmFtZSIsInRlc3QiLCJnZXRGaWxlbmFtZUZyb21VcmwiLCJsYXN0SW5kZXhPZiIsImdldFBkZkZpbGVuYW1lRnJvbVVybCIsImRlZmF1bHRGaWxlbmFtZSIsImdldFVSTCIsInVybFN0cmluZyIsIm5ld1VSTCIsImF0IiwicGRmUmVnZXgiLCJwYXRobmFtZSIsInNlYXJjaFBhcmFtcyIsInNpemUiLCJ2YWx1ZXMiLCJyZXZlcnNlIiwicmVGaWxlbmFtZSIsImhhc2hGaWxlbmFtZSIsImV4ZWMiLCJTdGF0VGltZXIiLCJ0aW1lIiwic3RhcnRlZCIsIm5vdyIsInRpbWVFbmQiLCJ0aW1lcyIsInN0YXJ0IiwiZW5kIiwib3V0QnVmIiwibG9uZ2VzdCIsInBhZEVuZCIsImNyZWF0ZSIsIm5vQ29udGV4dE1lbnUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BFdmVudCIsInN0b3BQcm9wYWdhdGlvbiIsImRlcHJlY2F0ZWQiLCJQREZEYXRlU3RyaW5nIiwicmVnZXgiLCJ0b0RhdGVPYmplY3QiLCJpbnB1dCIsIlJlZ0V4cCIsIm1hdGNoZXMiLCJ5ZWFyIiwicGFyc2VJbnQiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJ1bml2ZXJzYWxUaW1lUmVsYXRpb24iLCJvZmZzZXRIb3VyIiwib2Zmc2V0TWludXRlIiwiVVRDIiwiZ2V0WGZhUGFnZVZpZXdwb3J0IiwieGZhUGFnZSIsImF0dHJpYnV0ZXMiLCJzdHlsZSIsImdldFJHQiIsImNvbG9yIiwiY29sb3JSR0IiLCJtYXAiLCJnZXRDb2xvclZhbHVlcyIsImNvbG9ycyIsInNwYW4iLCJjcmVhdGVFbGVtZW50IiwidmlzaWJpbGl0eSIsImNvbG9yU2NoZW1lIiwiYm9keSIsImFwcGVuZCIsImNvbXB1dGVkQ29sb3IiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwic2V0IiwicmVtb3ZlIiwiZ2V0Q3VycmVudFRyYW5zZm9ybSIsImN0eCIsImdldFRyYW5zZm9ybSIsImdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlIiwiaW52ZXJ0U2VsZiIsInNldExheWVyRGltZW5zaW9ucyIsImRpdiIsInZpZXdwb3J0IiwibXVzdEZsaXAiLCJtdXN0Um90YXRlIiwidXNlUm91bmQiLCJ3IiwiaCIsIndpZHRoU3RyIiwiaGVpZ2h0U3RyIiwic2V0QXR0cmlidXRlIiwiT3V0cHV0U2NhbGUiLCJwaXhlbFJhdGlvIiwic3giLCJzeSIsInNjYWxlZCIsInN5bW1ldHJpYyIsImxpbWl0Q2FudmFzIiwibWF4UGl4ZWxzIiwibWF4RGltIiwiY2FwQXJlYUZhY3RvciIsIm1heEFyZWFTY2FsZSIsIkluZmluaXR5IiwibWF4V2lkdGhTY2FsZSIsIm1heEhlaWdodFNjYWxlIiwiY2FwUGl4ZWxzIiwibWF4U2NhbGUiLCJkZXZpY2VQaXhlbFJhdGlvIiwid2luUGl4ZWxzIiwiY2VpbCIsInNjcmVlbiIsImF2YWlsV2lkdGgiLCJhdmFpbEhlaWdodCIsIlN1cHBvcnRlZEltYWdlTWltZVR5cGVzIiwiRWRpdG9yVG9vbGJhciIsInRvb2xiYXIiLCJjb2xvclBpY2tlciIsImVkaXRvciIsImJ1dHRvbnMiLCJhbHRUZXh0IiwiY29tbWVudCIsInNpZ25hdHVyZURlc2NyaXB0aW9uQnV0dG9uIiwibDEwblJlbW92ZSIsImZyZWV6ZSIsImZyZWV0ZXh0IiwiaGlnaGxpZ2h0IiwiaW5rIiwic3RhbXAiLCJzaWduYXR1cmUiLCJyZW5kZXIiLCJlZGl0VG9vbGJhciIsImNsYXNzTGlzdCIsImFkZCIsInNpZ25hbCIsIl91aU1hbmFnZXIiLCJfc2lnbmFsIiwiQWJvcnRTaWduYWwiLCJhYm9ydGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBvaW50ZXJEb3duIiwiY2xhc3NOYW1lIiwicG9zaXRpb24iLCJ0b29sYmFyUG9zaXRpb24iLCJkaXJlY3Rpb24iLCJpbnNldElubGluZUVuZCIsInRvcCIsImZvY3VzSW4iLCJfZm9jdXNFdmVudHNBbGxvd2VkIiwiZm9jdXNPdXQiLCJhZGRMaXN0ZW5lcnNUb0VsZW1lbnQiLCJlbGVtZW50IiwiYmluZCIsImNhcHR1cmUiLCJoaWRlIiwiaGlkZURyb3Bkb3duIiwic2hvdyIsInNob3duIiwiYWRkRGVsZXRlQnV0dG9uIiwiZWRpdG9yVHlwZSIsImJ1dHRvbiIsInRhYkluZGV4IiwiZGVsZXRlIiwiZGl2aWRlciIsImFkZEFsdFRleHQiLCJhZGRDb21tZW50IiwiYWRkQ29sb3JQaWNrZXIiLCJyZW5kZXJCdXR0b24iLCJhZGRFZGl0U2lnbmF0dXJlQnV0dG9uIiwic2lnbmF0dXJlTWFuYWdlciIsInJlbmRlckVkaXRCdXR0b24iLCJhZGRCdXR0b24iLCJ0b29sIiwidXBkYXRlRWRpdFNpZ25hdHVyZUJ1dHRvbiIsImRlc2NyaXB0aW9uIiwidGl0bGUiLCJkZXN0cm95IiwiRmxvYXRpbmdUb29sYmFyIiwidWlNYW5hZ2VyIiwiaGFzQ29tbWVudE1hbmFnZXIiLCJtYWtlQnV0dG9uIiwiY29tbWVudFNlbGVjdGlvbiIsImhpZ2hsaWdodFNlbGVjdGlvbiIsImdldExhc3RQb2ludCIsImJveGVzIiwiaXNMVFIiLCJsYXN0WSIsImxhc3RYIiwiYm94IiwicGFyZW50IiwiYnV0dG9uQ2xhc3MiLCJsMTBuSWQiLCJsYWJlbEwxMG5JZCIsImNsaWNrSGFuZGxlciIsImJpbmRFdmVudHMiLCJuYW1lcyIsIklkTWFuYWdlciIsImlkIiwiSW1hZ2VNYW5hZ2VyIiwiYmFzZUlkIiwiY2FjaGUiLCJfaXNTVkdGaXR0aW5nQ2FudmFzIiwic3ZnIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsIndpbGxSZWFkRnJlcXVlbnRseSIsImltYWdlIiwiSW1hZ2UiLCJzcmMiLCJwcm9taXNlIiwidGhlbiIsImRyYXdJbWFnZSIsImdldEltYWdlRGF0YSIsImRhdGEiLCJyYXdEYXRhIiwiYml0bWFwIiwicmVmQ291bnRlciIsImlzU3ZnIiwiRmlsZSIsImZpbGUiLCJCbG9iIiwibXVzdFJlbW92ZUFzcGVjdFJhdGlvUHJvbWlzZSIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwiaW1hZ2VFbGVtZW50IiwiaW1hZ2VQcm9taXNlIiwib25sb2FkIiwic3ZnVXJsIiwicmVzdWx0Iiwib25lcnJvciIsInJlYWRBc0RhdGFVUkwiLCJjcmVhdGVJbWFnZUJpdG1hcCIsImdldEZyb21GaWxlIiwibGFzdE1vZGlmaWVkIiwiZ2V0RnJvbVVybCIsImdldEZyb21CbG9iIiwiYmxvYlByb21pc2UiLCJnZXRGcm9tSWQiLCJnZXRGcm9tQ2FudmFzIiwib2Zmc2NyZWVuIiwidHJhbnNmZXJUb0ltYWdlQml0bWFwIiwiZ2V0U3ZnVXJsIiwiZGVsZXRlSWQiLCJ0cmFuc2ZlckZyb21JbWFnZUJpdG1hcCIsImNvbnZlcnRUb0Jsb2IiLCJjbG9zZSIsImlzVmFsaWRJZCIsIkNvbW1hbmRNYW5hZ2VyIiwiY29tbWFuZHMiLCJsb2NrZWQiLCJtYXhTaXplIiwiY21kIiwidW5kbyIsInBvc3QiLCJtdXN0RXhlYyIsIk5hTiIsIm92ZXJ3cml0ZUlmU2FtZVR5cGUiLCJrZWVwVW5kbyIsIm5leHQiLCJzcGxpY2UiLCJyZWRvIiwiaGFzU29tZXRoaW5nVG9VbmRvIiwiaGFzU29tZXRoaW5nVG9SZWRvIiwiY2xlYW5UeXBlIiwiS2V5Ym9hcmRNYW5hZ2VyIiwiY2FsbGJhY2tzIiwiYWxsS2V5cyIsIlNldCIsImNhbGxiYWNrIiwiaXNNYWNLZXkiLCJzZXJpYWxpemUiLCJldmVudCIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJzZWxmIiwiaGFzIiwiYnViYmxlcyIsImNoZWNrZXIiLCJDb2xvck1hbmFnZXIiLCJfY29sb3JzTWFwcGluZyIsIl9jb2xvcnMiLCJjb252ZXJ0IiwicmdiIiwibWF0Y2hNZWRpYSIsIlJHQiIsImV2ZXJ5IiwiZ2V0SGV4Q29kZSIsIkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJhYm9ydENvbnRyb2xsZXIiLCJhY3RpdmVFZGl0b3IiLCJhbGxFZGl0YWJsZUFubm90YXRpb25zIiwiYWxsRWRpdG9ycyIsImFsbExheWVycyIsImFsdFRleHRNYW5hZ2VyIiwiYW5ub3RhdGlvblN0b3JhZ2UiLCJjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucyIsImNvbW1hbmRNYW5hZ2VyIiwiY29tbWVudE1hbmFnZXIiLCJjb3B5UGFzdGVBQyIsImN1cnJlbnREcmF3aW5nU2Vzc2lvbiIsImN1cnJlbnRQYWdlSW5kZXgiLCJkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzIiwiZHJhZ2dpbmdFZGl0b3JzIiwiZWRpdG9yVHlwZXMiLCJlZGl0b3JzVG9SZXNjYWxlIiwiZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24iLCJlbmFibGVVcGRhdGVkQWRkSW1hZ2UiLCJlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlIiwiZmlsdGVyRmFjdG9yeSIsImZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCIsImZvY3VzTWFuYWdlckFDIiwiaGlnaGxpZ2h0Q29sb3JzIiwiaGlnaGxpZ2h0V2hlblNoaWZ0VXAiLCJmbG9hdGluZ1Rvb2xiYXIiLCJpZE1hbmFnZXIiLCJpc0VuYWJsZWQiLCJpc1BvaW50ZXJEb3duIiwiaXNXYWl0aW5nIiwia2V5Ym9hcmRNYW5hZ2VyQUMiLCJsYXN0QWN0aXZlRWxlbWVudCIsIm1haW5IaWdobGlnaHRDb2xvclBpY2tlciIsIm1pc3NpbmdDYW52YXNlcyIsIm1sTWFuYWdlciIsIm1vZGUiLCJzZWxlY3RlZEVkaXRvcnMiLCJzZWxlY3RlZFRleHROb2RlIiwicGFnZUNvbG9ycyIsInNob3dBbGxTdGF0ZXMiLCJwZGZEb2N1bWVudCIsInByZXZpb3VzU3RhdGVzIiwidHJhbnNsYXRpb24iLCJ0cmFuc2xhdGlvblRpbWVvdXRJZCIsImNvbnRhaW5lciIsInZpZXdlciIsInZpZXdlckFsZXJ0IiwidXBkYXRlTW9kZUNhcGFiaWxpdHkiLCJUUkFOU0xBVEVfU01BTEwiLCJUUkFOU0xBVEVfQklHIiwiX2tleWJvYXJkTWFuYWdlciIsInByb3RvIiwiYXJyb3dDaGVja2VyIiwiY29udGFpbnMiLCJhY3RpdmVFbGVtZW50IiwidGFnTmFtZSIsImhhc1NvbWV0aGluZ1RvQ29udHJvbCIsInRleHRJbnB1dENoZWNrZXIiLCJfc2VsZiIsInRhcmdldCIsImVsIiwiSFRNTElucHV0RWxlbWVudCIsInNtYWxsIiwiYmlnIiwic2VsZWN0QWxsIiwiYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkIiwiSFRNTEJ1dHRvbkVsZW1lbnQiLCJpc0VudGVySGFuZGxlZCIsInVuc2VsZWN0QWxsIiwidHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzIiwiZXZlbnRCdXMiLCJlZGl0b3JVbmRvQmFyIiwic3VwcG9ydHNQaW5jaFRvWm9vbSIsIkFib3J0Q29udHJvbGxlciIsIl9lZGl0b3JVbmRvQmFyIiwiaXNFZGl0aW5nIiwiaXNFbXB0eSIsImhhc1NlbGVjdGVkRWRpdG9yIiwiaGFzU2VsZWN0ZWRUZXh0IiwiX2V2ZW50QnVzIiwiX29uIiwib25FZGl0aW5nQWN0aW9uIiwib25QYWdlQ2hhbmdpbmciLCJvblNjYWxlQ2hhbmdpbmciLCJvblJvdGF0aW9uQ2hhbmdpbmciLCJvblNldFByZWZlcmVuY2UiLCJldnQiLCJ1cGRhdGVQYXJhbXMiLCJhZGRTZWxlY3Rpb25MaXN0ZW5lciIsImFkZERyYWdBbmREcm9wTGlzdGVuZXJzIiwiYWRkS2V5Ym9hcmRNYW5hZ2VyIiwidmlld1BhcmFtZXRlcnMiLCJyZWFsU2NhbGUiLCJpc1NoaWZ0S2V5RG93biIsIl9zdXBwb3J0c1BpbmNoVG9ab29tIiwiYWJvcnQiLCJsYXllciIsImNsZWFyIiwiY2xlYXJUaW1lb3V0IiwiY29tYmluZWRTaWduYWwiLCJhYyIsImFueSIsInVzZU5ld0FsdFRleHRGbG93IiwidXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSIsImhjbUZpbHRlciIsImFkZEhDTUZpbHRlciIsImZvcmVncm91bmQiLCJiYWNrZ3JvdW5kIiwiX2hpZ2hsaWdodENvbG9ycyIsInBhaXIiLCJ0b1VwcGVyQ2FzZSIsImhhc0hDTSIsImlzTmFtZUZvckhDTSIsImVuZHNXaXRoIiwicmVwbGFjZSIsImhpZ2hsaWdodENvbG9yTmFtZXMiLCJnZXROb25IQ01Db2xvciIsImNvbG9yTmFtZSIsImdldE5vbkhDTUNvbG9yTmFtZSIsInNldEN1cnJlbnREcmF3aW5nU2Vzc2lvbiIsImRpc2FibGVVc2VyU2VsZWN0Iiwic2V0TWFpbkhpZ2hsaWdodENvbG9yUGlja2VyIiwiZWRpdEFsdFRleHQiLCJmaXJzdFRpbWUiLCJlZGl0Q29tbWVudCIsImdldFNpZ25hdHVyZSIsInN3aXRjaFRvTW9kZSIsIm9uIiwib25jZSIsImRpc3BhdGNoIiwic291cmNlIiwic2V0UHJlZmVyZW5jZSIsInBhZ2VOdW1iZXIiLCJmb2N1c01haW5Db250YWluZXIiLCJmb2N1cyIsImZpbmRQYXJlbnQiLCJsYXllclgiLCJsYXllclkiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b2dnbGUiLCJhZGRTaG91bGRSZXNjYWxlIiwicmVtb3ZlU2hvdWxkUmVzY2FsZSIsImNvbW1pdE9yUmVtb3ZlIiwicGFnZXNSb3RhdGlvbiIsImdldEFuY2hvckVsZW1lbnRGb3JTZWxlY3Rpb24iLCJhbmNob3JOb2RlIiwibm9kZVR5cGUiLCJOb2RlIiwiVEVYVF9OT0RFIiwicGFyZW50RWxlbWVudCIsImdldExheWVyRm9yVGV4dExheWVyIiwidGV4dExheWVyIiwiY3VycmVudExheWVyIiwiaGFzVGV4dExheWVyIiwibWV0aG9kT2ZDcmVhdGlvbiIsInNlbGVjdGlvbiIsImdldFNlbGVjdGlvbiIsImlzQ29sbGFwc2VkIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNOb2RlIiwiZm9jdXNPZmZzZXQiLCJhbmNob3JFbGVtZW50IiwiY2xvc2VzdCIsImdldFNlbGVjdGlvbkJveGVzIiwiZW1wdHkiLCJpc05vbmVNb2RlIiwiY3JlYXRlQW5kQWRkTmV3RWRpdG9yIiwic2hvd0FsbEVkaXRvcnMiLCJkaXNwbGF5RmxvYXRpbmdUb29sYmFyIiwiYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSIsInNldFZhbHVlIiwiYTExeUFsZXJ0IiwibWVzc2FnZUlkIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlbW92ZUF0dHJpYnV0ZSIsInNlbGVjdGlvbkNoYW5nZSIsImRpc3BhdGNoVXBkYXRlU3RhdGVzIiwiYWN0aXZlTGF5ZXIiLCJ0b2dnbGVEcmF3aW5nIiwicG9pbnRlcnVwIiwib25TZWxlY3RFbmQiLCJhZGRGb2N1c01hbmFnZXIiLCJibHVyIiwicmVtb3ZlRm9jdXNNYW5hZ2VyIiwiaGFzU2VsZWN0aW9uIiwibGFzdEVkaXRvciIsImtleWRvd24iLCJrZXl1cCIsInJlbW92ZUtleWJvYXJkTWFuYWdlciIsImFkZENvcHlQYXN0ZUxpc3RlbmVycyIsImNvcHkiLCJjdXQiLCJwYXN0ZSIsInJlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycyIsImRyYWdPdmVyIiwiZHJvcCIsImFkZEVkaXRMaXN0ZW5lcnMiLCJyZW1vdmVFZGl0TGlzdGVuZXJzIiwiZGF0YVRyYW5zZmVyIiwiaXRlbXMiLCJpc0hhbmRsaW5nTWltZUZvclBhc3RpbmciLCJkcm9wRWZmZWN0IiwiaXRlbSIsImVkaXRvcnMiLCJzZXJpYWxpemVkIiwiY2xpcGJvYXJkRGF0YSIsInNldERhdGEiLCJnZXREYXRhIiwibmV3RWRpdG9ycyIsImRlc2VyaWFsaXplZEVkaXRvciIsImRlc2VyaWFsaXplIiwiYWRkRWRpdG9yVG9MYXllciIsInNlbGVjdEVkaXRvcnMiLCJhZGRDb21tYW5kcyIsImlzRWRpdG9ySGFuZGxpbmdLZXlib2FyZCIsImhhc0NoYW5nZWQiLCJlbnRyaWVzIiwic29tZSIsImFzc2lnbiIsImRpc3BhdGNoVXBkYXRlVUkiLCJzZXRFZGl0aW5nU3RhdGUiLCJyZWdpc3RlckVkaXRvclR5cGVzIiwidHlwZXMiLCJkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlIiwiZ2V0SWQiLCJnZXRMYXllciIsInBhZ2VJbmRleCIsImFkZExheWVyIiwiZW5hYmxlIiwiZGlzYWJsZSIsInJlbW92ZUxheWVyIiwidXBkYXRlTW9kZSIsImVkaXRJZCIsImlzRnJvbUtleWJvYXJkIiwibXVzdEVudGVySW5FZGl0TW9kZSIsIndpdGhSZXNvbHZlcnMiLCJoaWRlU2lkZWJhciIsImRpc2FibGVBbGwiLCJsb2FkU2lnbmF0dXJlcyIsImdldEFubm90YXRpb25zQnlUeXBlIiwiZWRpdG9yQ2xhc3MiLCJfZWRpdG9yVHlwZSIsInNob3dTaWRlYmFyIiwiZW5hYmxlQWxsIiwiYW5ub3RhdGlvbkVsZW1lbnRJZCIsInNldFNlbGVjdGVkIiwiZW50ZXJJbkVkaXRNb2RlIiwidW5zZWxlY3QiLCJjYW5DcmVhdGVOZXdFbXB0eUVkaXRvciIsImFkZE5ld0VkaXRvciIsInVwZGF0ZVRvb2xiYXIiLCJhY3Rpb24iLCJ1cGRhdGVEZWZhdWx0UGFyYW1zIiwidmlzaWJsZSIsInVwZGF0ZUJ1dHRvbiIsInN0YXRlIiwiZW5hYmxlV2FpdGluZyIsIm11c3RXYWl0IiwiZGlzYWJsZUNsaWNrIiwiZW5hYmxlQ2xpY2siLCJwcm9taXNlcyIsImFsbCIsImdldEVkaXRvcnMiLCJnZXRFZGl0b3IiLCJhZGRFZGl0b3IiLCJyZW1vdmVFZGl0b3IiLCJzZXRUaW1lb3V0IiwiYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwiYWRkQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbiIsImRlbGV0ZWQiLCJpc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudCIsInJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudCIsInJlbW92ZUNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24iLCJhZGRPclJlYnVpbGQiLCJzZXRBY3RpdmVFZGl0b3IiLCJwcm9wZXJ0aWVzVG9VcGRhdGUiLCJsYXN0U2VsZWN0ZWRFZGl0b3IiLCJlZCIsInVwZGF0ZVVJIiwidXBkYXRlVUlGb3JEZWZhdWx0UHJvcGVydGllcyIsInRvZ2dsZVNlbGVjdGVkIiwic2VsZWN0IiwiaXNTZWxlY3RlZCIsImZpcnN0U2VsZWN0ZWRFZGl0b3IiLCJwYXJhbXMiLCJjbGVhblVuZG9TdGFjayIsImRyYXdpbmdFZGl0b3IiLCJlbmREcmF3aW5nU2Vzc2lvbiIsImNvbW1pdCIsIm5vQ29tbWl0IiwidG90YWxYIiwidG90YWxZIiwiVElNRV9UT19XQUlUIiwidHJhbnNsYXRlSW5QYWdlIiwidHJhbnNsYXRpb25Eb25lIiwic2V0VXBEcmFnU2Vzc2lvbiIsInNhdmVkWCIsInNhdmVkWSIsInNhdmVkUGFnZUluZGV4IiwibmV3WCIsIm5ld1kiLCJuZXdQYWdlSW5kZXgiLCJlbmREcmFnU2Vzc2lvbiIsIm11c3RCZUFkZGVkSW5VbmRvU3RhY2siLCJtb3ZlIiwiX3NldFBhcmVudEFuZFBvc2l0aW9uIiwiZHJhZ1NlbGVjdGVkRWRpdG9ycyIsInR4IiwidHkiLCJkcmFnIiwicmVidWlsZCIsImNoYW5nZVBhcmVudCIsImdldEFjdGl2ZSIsInNob3VsZEdldEtleWJvYXJkRXZlbnRzIiwiaXNBY3RpdmUiLCJnZXRNb2RlIiwiaW1hZ2VNYW5hZ2VyIiwicmFuZ2VDb3VudCIsImdldFJhbmdlQXQiLCJjb21tb25BbmNlc3RvckNvbnRhaW5lciIsInBhcmVudFdpZHRoIiwicGFyZW50SGVpZ2h0Iiwicm90YXRvciIsImdldEF0dHJpYnV0ZSIsInJhbmdlIiwiY29sbGFwc2VkIiwiZ2V0Q2xpZW50UmVjdHMiLCJyZW5kZXJBbm5vdGF0aW9uRWxlbWVudCIsImFubm90YXRpb24iLCJlZGl0b3JJZCIsImdldFJhd1ZhbHVlIiwiaGFzQmVlbk1vZGlmaWVkIiwic2V0TWlzc2luZ0NhbnZhcyIsImFubm90YXRpb25JZCIsInNldENhbnZhcyIsImFkZE1pc3NpbmdDYW52YXMiLCJBbHRUZXh0IiwiYWx0VGV4dERlY29yYXRpdmUiLCJhbHRUZXh0QnV0dG9uIiwiYWx0VGV4dEJ1dHRvbkxhYmVsIiwiYWx0VGV4dFRvb2x0aXAiLCJhbHRUZXh0VG9vbHRpcFRpbWVvdXQiLCJhbHRUZXh0V2FzRnJvbUtleUJvYXJkIiwiYmFkZ2UiLCJndWVzc2VkVGV4dCIsInRleHRXaXRoRGlzY2xhaW1lciIsImwxMG5OZXdCdXR0b24iLCJfbDEwbiIsImFkZGVkIiwicmV2aWV3IiwiaW5pdGlhbGl6ZSIsImwxMG4iLCJsYWJlbCIsIm9uQ2xpY2siLCJfcmVwb3J0VGVsZW1ldHJ5Iiwic2V0U3RhdGUiLCJmaW5pc2giLCJmb2N1c1Zpc2libGUiLCJoYXNEYXRhIiwic2V0R3Vlc3NlZFRleHQiLCJnZW5lcmF0ZWRBbHRUZXh0IiwidG9nZ2xlQWx0VGV4dEJhZGdlIiwiaXNGb3JDb3B5aW5nIiwiZGVjb3JhdGl2ZSIsImNhbmNlbCIsImVuYWJsZWQiLCJkaXNhYmxlZCIsInRvb2x0aXAiLCJERUxBWV9UT19TSE9XX1RPT0xUSVAiLCJ0ZXh0Q29udGVudCIsInBhcmVudE5vZGUiLCJnZXRFbGVtZW50Rm9yQWx0VGV4dCIsIkNvbW1lbnQiLCJjb21tZW50QnV0dG9uIiwiY29tbWVudFdhc0Zyb21LZXlCb2FyZCIsImluaXRpYWxUZXh0IiwiZWRpdCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImdldENsaWVudERpbWVuc2lvbnMiLCJpc0RlbGV0ZWQiLCJoYXNCZWVuRWRpdGVkIiwic2V0SW5pdGlhbFRleHQiLCJUb3VjaE1hbmFnZXIiLCJpc1BpbmNoaW5nIiwiaXNQaW5jaGluZ1N0b3BwZWQiLCJpc1BpbmNoaW5nRGlzYWJsZWQiLCJvblBpbmNoU3RhcnQiLCJvblBpbmNoaW5nIiwib25QaW5jaEVuZCIsInBvaW50ZXJEb3duQUMiLCJ0b3VjaEluZm8iLCJ0b3VjaE1hbmFnZXJBQyIsInRvdWNoTW92ZUFDIiwib25Ub3VjaFN0YXJ0IiwicGFzc2l2ZSIsIk1JTl9UT1VDSF9ESVNUQU5DRV9UT19QSU5DSCIsInRvdWNoZXMiLCJvcHRzIiwiY2FuY2VsUG9pbnRlckRvd24iLCJwb2ludGVyVHlwZSIsIm9wdCIsIm9uVG91Y2hNb3ZlIiwib25Ub3VjaEVuZCIsInRvdWNoMCIsInRvdWNoMSIsImlkZW50aWZpZXIiLCJ0b3VjaDBYIiwic2NyZWVuWCIsInRvdWNoMFkiLCJzY3JlZW5ZIiwidG91Y2gxWCIsInRvdWNoMVkiLCJzY3JlZW4wWCIsInNjcmVlbjBZIiwic2NyZWVuMVgiLCJzY3JlZW4xWSIsInBUb3VjaDBYIiwicFRvdWNoMFkiLCJwVG91Y2gxWCIsInBUb3VjaDFZIiwicHJldkdhcFgiLCJwcmV2R2FwWSIsImN1cnJHYXBYIiwiY3VyckdhcFkiLCJkaXN0YW5jZSIsImh5cG90IiwicERpc3RhbmNlIiwib3JpZ2luIiwiQW5ub3RhdGlvbkVkaXRvciIsImFjY2Vzc2liaWxpdHlEYXRhIiwiYWxsUmVzaXplckRpdnMiLCJkcmFnUG9pbnRlcklkIiwiZHJhZ1BvaW50ZXJUeXBlIiwia2VlcEFzcGVjdFJhdGlvIiwicmVzaXplcnNEaXYiLCJsYXN0UG9pbnRlckNvb3JkcyIsInNhdmVkRGltZW5zaW9ucyIsImZvY3VzQUMiLCJmb2N1c2VkUmVzaXplck5hbWUiLCJoYXNCZWVuQ2xpY2tlZCIsImluaXRpYWxSZWN0IiwiaXNJbkVkaXRNb2RlIiwiaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkIiwibW92ZUluRE9NVGltZW91dCIsInByZXZEcmFnWCIsInByZXZEcmFnWSIsInRlbGVtZXRyeVRpbWVvdXRzIiwidG91Y2hNYW5hZ2VyIiwiX2wxMG5SZXNpemVyIiwiaXNEcmFnZ2FibGUiLCJ6SW5kZXgiLCJfYm9yZGVyTGluZVdpZHRoIiwiX2NvbG9yTWFuYWdlciIsIl96SW5kZXgiLCJfdGVsZW1ldHJ5VGltZW91dCIsIl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyIiwicmVzaXplIiwiX3Jlc2l6ZVdpdGhLZXlib2FyZCIsIl9zdG9wUmVzaXppbmdXaXRoS2V5Ym9hcmQiLCJwYXJhbWV0ZXJzIiwiX2lzQ29weSIsIl9lZGl0VG9vbGJhciIsIl9pbml0aWFsT3B0aW9ucyIsIl9pbml0aWFsRGF0YSIsIl9pc1Zpc2libGUiLCJfd2lsbEtlZXBBc3BlY3RSYXRpbyIsImlzQ2VudGVyZWQiLCJfc3RydWN0VHJlZVBhcmVudElkIiwicGFnZVJvdGF0aW9uIiwicGFnZURpbWVuc2lvbnMiLCJwYWdlVHJhbnNsYXRpb24iLCJwYXJlbnREaW1lbnNpb25zIiwiaXNBdHRhY2hlZFRvRE9NIiwiZ2V0UHJvdG90eXBlT2YiLCJfdHlwZSIsImlzRHJhd2VyIiwiX2RlZmF1bHRMaW5lQ29sb3IiLCJkZWxldGVBbm5vdGF0aW9uRWxlbWVudCIsImZha2VFZGl0b3IiLCJGYWtlRWRpdG9yIiwiZ2V0TmV4dElkIiwidG9wTWlkZGxlIiwidG9wUmlnaHQiLCJtaWRkbGVSaWdodCIsImJvdHRvbU1pZGRsZSIsImJvdHRvbUxlZnQiLCJtaWRkbGVMZWZ0IiwiZG9jdW1lbnRFbGVtZW50IiwicGFyc2VGbG9hdCIsImdldFByb3BlcnR5VmFsdWUiLCJfdmFsdWUiLCJtaW1lIiwiX2lzRHJhZ2dhYmxlIiwiY2VudGVyIiwicGFyZW50Um90YXRpb24iLCJmaXhBbmRTZXRQb3NpdGlvbiIsInNldEluQmFja2dyb3VuZCIsInNldEluRm9yZWdyb3VuZCIsInNldFBhcmVudCIsInN0b3BSZXNpemluZyIsImZvY3VzaW4iLCJmb2N1c291dCIsInJlbGF0ZWRUYXJnZXQiLCJpc011bHRpcGxlU2VsZWN0aW9uIiwic2V0QXQiLCJzY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbiIsIl9tb3ZlQWZ0ZXJQYXN0ZSIsImJhc2VYIiwiYmFzZVkiLCJfb25UcmFuc2xhdGVkIiwidHJhbnNsYXRlIiwiX29uVHJhbnNsYXRpbmciLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwiZmluZE5ld1BhcmVudCIsImZsb29yIiwiYngiLCJieSIsImdldEJhc2VUcmFuc2xhdGlvbiIsInRvRml4ZWQiLCJfaGFzQmVlbk1vdmVkIiwiX2hhc0JlZW5SZXNpemVkIiwiX211c3RGaXhQb3NpdGlvbiIsIm1vdmVJbkRPTSIsInJvdGF0ZVBvaW50IiwiYW5nbGUiLCJwYWdlVHJhbnNsYXRpb25Ub1NjcmVlbiIsImdldFJvdGF0aW9uTWF0cml4IiwicGFyZW50U2NhbGUiLCJzZXREaW1zIiwiZml4RGltcyIsIndpZHRoUGVyY2VudCIsImhlaWdodFBlcmNlbnQiLCJnZXRJbml0aWFsVHJhbnNsYXRpb24iLCJjcmVhdGVSZXNpemVycyIsImNsYXNzZXMiLCJyZXNpemVyUG9pbnRlcmRvd24iLCJwcmVwZW5kIiwic2F2ZWREcmFnZ2FibGUiLCJ0b2dnbGVQb2ludGVyRXZlbnRzIiwicmVzaXplclBvaW50ZXJtb3ZlIiwic2F2ZWRXaWR0aCIsInNhdmVkSGVpZ2h0Iiwic2F2ZWRQYXJlbnRDdXJzb3IiLCJjdXJzb3IiLCJzYXZlZEN1cnNvciIsInBvaW50ZXJVcENhbGxiYWNrIiwiYWRkUmVzaXplVG9VbmRvU3RhY2siLCJfb25SZXNpemVkIiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJfcm91bmQiLCJyb3VuZCIsIm1pbldpZHRoIiwiTUlOX1NJWkUiLCJtaW5IZWlnaHQiLCJyb3RhdGlvbk1hdHJpeCIsInRyYW5zZiIsImludlJvdGF0aW9uTWF0cml4IiwiaW52VHJhbnNmIiwiZ2V0UG9pbnQiLCJnZXRPcHBvc2l0ZSIsImlzRGlhZ29uYWwiLCJpc0hvcml6b250YWwiLCJwb2ludCIsIm9wcG9zaXRlUG9pbnQiLCJ0cmFuc2ZPcHBvc2l0ZVBvaW50Iiwib3Bwb3NpdGVYIiwib3Bwb3NpdGVZIiwicmF0aW9YIiwicmF0aW9ZIiwiZGVsdGFYIiwiZGVsdGFZIiwiZnJvbUtleWJvYXJkIiwibGFzdFNjcmVlblgiLCJsYXN0U2NyZWVuWSIsIm9sZERpYWciLCJfb25SZXNpemluZyIsImFsdFRleHRGaW5pc2giLCJ0b29sYmFyQnV0dG9ucyIsImFkZEVkaXRUb29sYmFyIiwiYWRkQ29tbWVudEJ1dHRvbiIsInJlbW92ZUVkaXRUb29sYmFyIiwiYWRkQ29udGFpbmVyIiwiZWRpdFRvb2xiYXJEaXYiLCJiZWZvcmUiLCJjcmVhdGVBbHRUZXh0IiwiYWx0VGV4dERhdGEiLCJndWVzc2VkQWx0VGV4dCIsInNldEd1ZXNzZWRBbHRUZXh0Iiwic2VyaWFsaXplQWx0VGV4dCIsImhhc0FsdFRleHQiLCJoYXNBbHRUZXh0RGF0YSIsImNvbW1lbnRDb2xvciIsInNldENvbW1lbnREYXRhIiwiaGFzRWRpdGVkQ29tbWVudCIsIkRFRkFVTFRfUE9QVVBfV0lEVEgiLCJERUZBVUxUX1BPUFVQX0hFSUdIVCIsInRyWSIsImJsWCIsImJsWSIsInRyWCIsInBvcHVwIiwiY29udGVudHMiLCJkZWZhdWx0TDEwbklkIiwiYWRkRm9jdXNMaXN0ZW5lcnMiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsImlzUmVzaXphYmxlIiwidG91Y2hQaW5jaFN0YXJ0Q2FsbGJhY2siLCJ0b3VjaFBpbmNoQ2FsbGJhY2siLCJ0b3VjaFBpbmNoRW5kQ2FsbGJhY2siLCJfb3JpZ2luIiwicHJldkRpc3RhbmNlIiwic2xvd0Rvd25GYWN0b3IiLCJmYWN0b3IiLCJ0cmFuc2ZDZW50ZXJQb2ludCIsIm5ld1RyYW5zZkNlbnRlclBvaW50IiwicG9pbnRlcmRvd24iLCJzZWxlY3RPblBvaW50ZXJFdmVudCIsImhhc0RyYWdnaW5nU3RhcnRlZCIsImNhbmNlbERyYWciLCJfb25TdG9wRHJhZ2dpbmciLCJjbGllbnRYIiwiY2xpZW50WSIsInBvaW50ZXJJZCIsIl9vblN0YXJ0RHJhZ2dpbmciLCJpc1ByaW1hcnkiLCJtb3ZlRWRpdG9ySW5ET00iLCJnZXRSZWN0Iiwic2hpZnRYIiwic2hpZnRZIiwiZ2V0UmVjdEluQ3VycmVudENvb3JkcyIsImdldFBERlJlY3QiLCJvbmNlQWRkZWQiLCJlbmFibGVFZGl0TW9kZSIsImRpc2FibGVFZGl0TW9kZSIsIm5lZWRzVG9CZVJlYnVpbHQiLCJpc09uU2NyZWVuIiwiaW5uZXJIZWlnaHQiLCJpbm5lcldpZHRoIiwicm90YXRlIiwiX2FuZ2xlIiwic2VyaWFsaXplRGVsZXRlZCIsInBvcHVwUmVmIiwiY29udGV4dCIsImlzQ29weSIsInRpbWVvdXQiLCJtYWtlUmVzaXphYmxlIiwiY2hpbGRyZW4iLCJib3VuZFJlc2l6ZXJLZXlkb3duIiwicmVzaXplcktleWRvd24iLCJib3VuZFJlc2l6ZXJCbHVyIiwicmVzaXplckJsdXIiLCJyZXNpemVyRm9jdXMiLCJmaXJzdFBvc2l0aW9uIiwibmV4dEZpcnN0UG9zaXRpb24iLCJmaXJzdENoaWxkIiwibGFzdENoaWxkIiwiY2hpbGQiLCJzZXRSZXNpemVyVGFiSW5kZXgiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJwcmV2ZW50U2Nyb2xsIiwiZGlzYWJsZUVkaXRpbmciLCJlbmFibGVFZGl0aW5nIiwiY2FuQ2hhbmdlQ29udGVudCIsImRibGNsaWNrIiwiY29udGVudERpdiIsInNldEFzcGVjdFJhdGlvIiwiYXNwZWN0UmF0aW8iLCJ0ZWxlbWV0cnlJbml0aWFsRGF0YSIsInRlbGVtZXRyeUZpbmFsRGF0YSIsImNvbnRlbnQiLCJxdWVyeVNlbGVjdG9yIiwibm9kZU5hbWUiLCJyZXNldEFubm90YXRpb25FbGVtZW50IiwiU0VFRCIsIk1BU0tfSElHSCIsIk1BU0tfTE9XIiwiTXVybXVySGFzaDNfNjQiLCJzZWVkIiwiaDEiLCJoMiIsInVwZGF0ZSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnl0ZUxlbmd0aCIsImJsb2NrQ291bnRzIiwidGFpbExlbmd0aCIsImRhdGFVaW50MzIiLCJrMSIsImsyIiwiQzEiLCJDMiIsIkMxX0xPVyIsIkMyX0xPVyIsImhleGRpZ2VzdCIsIlNlcmlhbGl6YWJsZUVtcHR5IiwidHJhbnNmZXIiLCJBbm5vdGF0aW9uU3RvcmFnZSIsIm1vZGlmaWVkIiwibW9kaWZpZWRJZHMiLCJzdG9yYWdlIiwib25TZXRNb2RpZmllZCIsIm9uUmVzZXRNb2RpZmllZCIsIm9uQW5ub3RhdGlvbkVkaXRvciIsImdldFZhbHVlIiwiZGVmYXVsdFZhbHVlIiwicmVzZXRNb2RpZmllZCIsImVudHJ5IiwidmFsIiwic2V0TW9kaWZpZWQiLCJwcmludCIsIlByaW50QW5ub3RhdGlvblN0b3JhZ2UiLCJzZXJpYWxpemFibGUiLCJoYXNCaXRtYXAiLCJlZGl0b3JTdGF0cyIsInN0YXRzIiwidHlwZVRvRWRpdG9yIiwiY291bnRlcnMiLCJjb3VudCIsImNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEiLCJyZXNldE1vZGlmaWVkSWRzIiwiaWRzIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJGb250TG9hZGVyIiwic3lzdGVtRm9udHMiLCJvd25lckRvY3VtZW50Iiwic3R5bGVFbGVtZW50IiwiX2RvY3VtZW50IiwibmF0aXZlRm9udEZhY2VzIiwibG9hZGluZ1JlcXVlc3RzIiwibG9hZFRlc3RGb250SWQiLCJhZGROYXRpdmVGb250RmFjZSIsIm5hdGl2ZUZvbnRGYWNlIiwiZm9udHMiLCJyZW1vdmVOYXRpdmVGb250RmFjZSIsImluc2VydFJ1bGUiLCJydWxlIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzdHlsZVNoZWV0Iiwic2hlZXQiLCJjc3NSdWxlcyIsImxvYWRTeXN0ZW1Gb250Iiwic3lzdGVtRm9udEluZm8iLCJkaXNhYmxlRm9udEZhY2UiLCJfaW5zcGVjdEZvbnQiLCJsb2FkZWROYW1lIiwiaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCIsImZvbnRGYWNlIiwiRm9udEZhY2UiLCJsb2FkIiwiYmFzZUZvbnROYW1lIiwiZm9udCIsImF0dGFjaGVkIiwibWlzc2luZ0ZpbGUiLCJjcmVhdGVOYXRpdmVGb250RmFjZSIsImxvYWRlZCIsImZhbWlseSIsImNyZWF0ZUZvbnRGYWNlUnVsZSIsImlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkIiwiX3F1ZXVlTG9hZGluZ0NhbGxiYWNrIiwiX3ByZXBhcmVGb250TG9hZEV2ZW50IiwiaGFzRm9udHMiLCJjb21wbGV0ZVJlcXVlc3QiLCJkb25lIiwib3RoZXJSZXF1ZXN0Iiwic2hpZnQiLCJjb21wbGV0ZSIsIl9sb2FkVGVzdEZvbnQiLCJ0ZXN0Rm9udCIsImludDMyIiwib2Zmc2V0Iiwic3BsaWNlU3RyaW5nIiwicyIsImluc2VydCIsImNodW5rMSIsImNodW5rMiIsImNhbGxlZCIsImlzRm9udFJlYWR5IiwiZmlsbFRleHQiLCJpbWFnZURhdGEiLCJDT01NRU5UX09GRlNFVCIsIkNGRl9DSEVDS1NVTV9PRkZTRVQiLCJYWFhYX1ZBTFVFIiwiY2hlY2tzdW0iLCJmb250RmFtaWx5IiwiRm9udEZhY2VPYmplY3QiLCJ0cmFuc2xhdGVkRGF0YSIsImluc3BlY3RGb250IiwiY29tcGlsZWRHbHlwaHMiLCJjc3NGb250SW5mbyIsImNzcyIsIndlaWdodCIsImZvbnRXZWlnaHQiLCJpdGFsaWNBbmdsZSIsIm1pbWV0eXBlIiwiZ2V0UGF0aEdlbmVyYXRvciIsIm9ianMiLCJjaGFyYWN0ZXIiLCJvYmpJZCIsImNtZHMiLCJwYXRoIiwiUGF0aDJEIiwiZm9udEV4dHJhUHJvcGVydGllcyIsImdldFVybFByb3AiLCJsb2NhdGlvbiIsImdldERhdGFQcm9wIiwiQnVmZmVyIiwiaXNOYU4iLCJnZXRGYWN0b3J5VXJsUHJvcCIsImlzUmVmUHJveHkiLCJnZW4iLCJpc05hbWVQcm94eSIsImlzVmFsaWRFeHBsaWNpdERlc3QiLCJMb29wYmFja1BvcnQiLCJsaXN0ZW5lcnMiLCJkZWZlcnJlZCIsInBvc3RNZXNzYWdlIiwibGlzdGVuZXIiLCJybUFib3J0Iiwib25BYm9ydCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0ZXJtaW5hdGUiLCJDYWxsYmFja0tpbmQiLCJEQVRBIiwiRVJST1IiLCJTdHJlYW1LaW5kIiwiQ0FOQ0VMIiwiQ0FOQ0VMX0NPTVBMRVRFIiwiQ0xPU0UiLCJFTlFVRVVFIiwiUFVMTCIsIlBVTExfQ09NUExFVEUiLCJTVEFSVF9DT01QTEVURSIsIm9uRm4iLCJ3cmFwUmVhc29uIiwiTWVzc2FnZUhhbmRsZXIiLCJtZXNzYWdlQUMiLCJzb3VyY2VOYW1lIiwidGFyZ2V0TmFtZSIsImNvbU9iaiIsImNhbGxiYWNrSWQiLCJzdHJlYW1JZCIsInN0cmVhbVNpbmtzIiwic3RyZWFtQ29udHJvbGxlcnMiLCJjYWxsYmFja0NhcGFiaWxpdGllcyIsImFjdGlvbkhhbmRsZXIiLCJvbk1lc3NhZ2UiLCJzdHJlYW0iLCJwcm9jZXNzU3RyZWFtTWVzc2FnZSIsImNhcGFiaWxpdHkiLCJyZWFzb24iLCJjcmVhdGVTdHJlYW1TaW5rIiwiYWN0aW9uTmFtZSIsImhhbmRsZXIiLCJhaCIsInRyYW5zZmVycyIsInNlbmRXaXRoUHJvbWlzZSIsInNlbmRXaXRoU3RyZWFtIiwicXVldWVpbmdTdHJhdGVneSIsIlJlYWRhYmxlU3RyZWFtIiwiY29udHJvbGxlciIsInN0YXJ0Q2FwYWJpbGl0eSIsInN0YXJ0Q2FsbCIsInB1bGxDYWxsIiwiY2FuY2VsQ2FsbCIsImlzQ2xvc2VkIiwiZGVzaXJlZFNpemUiLCJwdWxsIiwicHVsbENhcGFiaWxpdHkiLCJjYW5jZWxDYXBhYmlsaXR5Iiwic3RyZWFtU2luayIsImVucXVldWUiLCJpc0NhbmNlbGxlZCIsImxhc3REZXNpcmVkU2l6ZSIsInNpbmtDYXBhYmlsaXR5IiwicmVhZHkiLCJlcnJvciIsIm9uUHVsbCIsIm9uQ2FuY2VsIiwic3VjY2VzcyIsInN0cmVhbUNvbnRyb2xsZXIiLCJkZWxldGVTdHJlYW1Db250cm9sbGVyIiwiZGF0YVJlYXNvbiIsImFsbFNldHRsZWQiLCJCYXNlQ2FudmFzRmFjdG9yeSIsImVuYWJsZUhXQSIsIl9jcmVhdGVDYW52YXMiLCJyZXNldCIsImNhbnZhc0FuZENvbnRleHQiLCJET01DYW52YXNGYWN0b3J5IiwiQmFzZUNNYXBSZWFkZXJGYWN0b3J5IiwiaXNDb21wcmVzc2VkIiwiX2ZldGNoIiwiY01hcERhdGEiLCJjYXRjaCIsIkRPTUNNYXBSZWFkZXJGYWN0b3J5IiwiQmFzZUZpbHRlckZhY3RvcnkiLCJhZGRGaWx0ZXIiLCJtYXBzIiwiZmdDb2xvciIsImJnQ29sb3IiLCJhZGRBbHBoYUZpbHRlciIsImFkZEx1bWlub3NpdHlGaWx0ZXIiLCJhZGRIaWdobGlnaHRIQ01GaWx0ZXIiLCJmaWx0ZXJOYW1lIiwibmV3RmdDb2xvciIsIm5ld0JnQ29sb3IiLCJrZWVwSENNIiwiRE9NRmlsdGVyRmFjdG9yeSIsIl9jYWNoZSIsIl9kZWZzIiwiZG9jSWQiLCJfaGNtQ2FjaGUiLCJoY21DYWNoZSIsImRlZnMiLCJjb250YWluIiwiY3JlYXRlRWxlbWVudE5TIiwiY3JlYXRlVGFibGVzIiwibWFwUiIsInRhYmxlIiwibWFwRyIsIm1hcEIiLCJidWZmZXJSIiwiYnVmZmVyRyIsImJ1ZmZlckIiLCJjcmVhdGVVcmwiLCJ0YWJsZVIiLCJ0YWJsZUciLCJ0YWJsZUIiLCJmaWx0ZXIiLCJjcmVhdGVGaWx0ZXIiLCJhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24iLCJmZ1JHQiIsImJnUkdCIiwiYWRkR3JheUNvbnZlcnNpb24iLCJnZXRTdGVwcyIsInRhYmxlQSIsImFkZFRyYW5zZmVyTWFwQWxwaGFDb252ZXJzaW9uIiwiYWRkTHVtaW5vc2l0eUNvbnZlcnNpb24iLCJmZ0dyYXkiLCJiZ0dyYXkiLCJuZXdGZ1JHQiIsIm5ld0JnUkdCIiwiZmciLCJiZyIsInN0ZXAiLCJuZXdTdGFydCIsIm5ld1N0ZXAiLCJwcmV2IiwiayIsImoiLCJmZUNvbG9yTWF0cml4IiwiYXBwZW5kRmVGdW5jIiwiZmVDb21wb25lbnRUcmFuc2ZlciIsImZ1bmMiLCJmZUZ1bmMiLCJyVGFibGUiLCJnVGFibGUiLCJiVGFibGUiLCJhVGFibGUiLCJCYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsIkJhc2VXYXNtRmFjdG9yeSIsIkRPTVdhc21GYWN0b3J5Iiwibm9kZV91dGlsc19mZXRjaERhdGEiLCJmcyIsImdldEJ1aWx0aW5Nb2R1bGUiLCJyZWFkRmlsZSIsIk5vZGVGaWx0ZXJGYWN0b3J5IiwiTm9kZUNhbnZhc0ZhY3RvcnkiLCJyZXF1aXJlIiwiY3JlYXRlUmVxdWlyZSIsImNyZWF0ZUNhbnZhcyIsIk5vZGVDTWFwUmVhZGVyRmFjdG9yeSIsIk5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsIk5vZGVXYXNtRmFjdG9yeSIsIkZPUkNFRF9ERVBFTkRFTkNZX0xBQkVMIiwiQ2FudmFzRGVwZW5kZW5jeVRyYWNrZXIiLCJzaW1wbGUiLCJpbmNyZW1lbnRhbCIsIm5hbWVkRGVwZW5kZW5jaWVzIiwic2F2ZXNTdGFjayIsIm1hcmtlZENvbnRlbnRTdGFjayIsImJhc2VUcmFuc2Zvcm1TdGFjayIsImNsaXBCb3giLCJwZW5kaW5nQkJveCIsInBlbmRpbmdCQm94SWR4IiwicGVuZGluZ0RlcGVuZGVuY2llcyIsIm9wZXJhdGlvbnMiLCJmb250QkJveFRydXN0d29ydGh5IiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJfX3Byb3RvX18iLCJzYW1lTGluZVRleHQiLCJGbG9hdDY0QXJyYXkiLCJvcElkeCIsInByZXZpb3VzIiwibGFzdFBhaXIiLCJwb3AiLCJyZWNvcmRPcGVuTWFya2VyIiwiaWR4IiwiZ2V0T3Blbk1hcmtlciIsInJlY29yZENsb3NlTWFya2VyIiwicHVzaEJhc2VUcmFuc2Zvcm0iLCJwb3BCYXNlVHJhbnNmb3JtIiwicmVjb3JkU2ltcGxlRGF0YSIsInJlY29yZEluY3JlbWVudGFsRGF0YSIsInJlc2V0SW5jcmVtZW50YWxEYXRhIiwicmVjb3JkTmFtZWREYXRhIiwicmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeSIsImluaGVyaXRTaW1wbGVEYXRhQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMiLCJpbmhlcml0UGVuZGluZ0RlcGVuZGVuY2llc0FzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzIiwiZGVwIiwicmVzZXRCQm94IiwiaGFzUGVuZGluZ0JCb3giLCJyZWNvcmRDbGlwQm94IiwibWluWCIsIm1heFgiLCJtaW5ZIiwibWF4WSIsImludGVyc2VjdGlvbiIsInJlY29yZEJCb3giLCJiYm94IiwicmVjb3JkQ2hhcmFjdGVyQkJveCIsImdldE1lYXN1cmUiLCJmb250QkJveCIsImlzQkJveFRydXN0d29ydGh5IiwiY29tcHV0ZWRCQm94IiwiZm9udE1hdHJpeCIsInJlY29yZEZ1bGxQYWdlQkJveCIsIm1lYXN1cmUiLCJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCJhY3R1YWxCb3VuZGluZ0JveFJpZ2h0IiwiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCJhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQiLCJnZXRTaW1wbGVJbmRleCIsImRlcGVuZGVuY3lOYW1lIiwicmVjb3JkRGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jeU5hbWVzIiwiZm9yRWFjaCIsImNvcHlEZXBlbmRlbmNpZXNGcm9tSW5jcmVtZW50YWxPcGVyYXRpb24iLCJkZXBJZHgiLCJkZXBlbmRlbmNpZXMiLCJyZWNvcmROYW1lZERlcGVuZGVuY3kiLCJyZWNvcmRPcGVyYXRpb24iLCJwcmVzZXJ2ZUJib3giLCJwYWlycyIsImNvbmNhdCIsImJib3hUb0NsaXBCb3hEcm9wT3BlcmF0aW9uIiwiX3Rha2VQZW5kaW5nRGVwZW5kZW5jaWVzIiwiX2V4dHJhY3RPcGVyYXRpb24iLCJvcGVyYXRpb24iLCJfcHVzaFBlbmRpbmdEZXBlbmRlbmNpZXMiLCJ0YWtlIiwic29ydCIsIkNhbnZhc05lc3RlZERlcGVuZGVuY3lUcmFja2VyIiwiZGVwZW5kZW5jeVRyYWNrZXIiLCJuZXN0aW5nTGV2ZWwiLCJvdXRlckRlcGVuZGVuY2llcyIsInNhdmVzTGV2ZWwiLCJyZWNvcmROZXN0ZWREZXBlbmRlbmNpZXMiLCJEZXBlbmRlbmNpZXMiLCJpbWFnZVhPYmplY3QiLCJ0cmFuc2Zvcm1BbmRGaWxsIiwiUGF0aFR5cGUiLCJTSEFESU5HIiwiYXBwbHlCb3VuZGluZ0JveCIsInJlZ2lvbiIsIkJhc2VTaGFkaW5nUGF0dGVybiIsImlzTW9kaWZ5aW5nQ3VycmVudFRyYW5zZm9ybSIsImdldFBhdHRlcm4iLCJSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuIiwiSVIiLCJfYmJveCIsIl9jb2xvclN0b3BzIiwiX3AwIiwiX3AxIiwiX3IwIiwiX3IxIiwiX2NyZWF0ZUdyYWRpZW50IiwiZ3JhZCIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJjb2xvclN0b3AiLCJhZGRDb2xvclN0b3AiLCJvd25lciIsImludmVyc2UiLCJwYXRoVHlwZSIsInBhdHRlcm4iLCJvd25lckJCb3giLCJjdXJyZW50IiwiZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCIsInRtcENhbnZhcyIsImNhY2hlZENhbnZhc2VzIiwiZ2V0Q2FudmFzIiwidG1wQ3R4IiwiY2xlYXJSZWN0IiwiYmVnaW5QYXRoIiwiYmFzZVRyYW5zZm9ybSIsImZpbGxTdHlsZSIsImNyZWF0ZVBhdHRlcm4iLCJkb21NYXRyaXgiLCJET01NYXRyaXgiLCJzZXRUcmFuc2Zvcm0iLCJkcmF3VHJpYW5nbGUiLCJwMyIsImMxIiwiYzIiLCJjMyIsImNvb3JkcyIsInJvd1NpemUiLCJ0bXAiLCJzY2FsZVgiLCJzY2FsZVkiLCJjMXIiLCJjMWciLCJjMWIiLCJjMnIiLCJjMmciLCJjMmIiLCJjM3IiLCJjM2ciLCJjM2IiLCJ4YSIsImNhciIsImNhZyIsImNhYiIsInhiIiwiY2JyIiwiY2JnIiwiY2JiIiwieDFfIiwieDJfIiwiZHJhd0ZpZ3VyZSIsImZpZ3VyZSIsInBzIiwiY3MiLCJ2ZXJ0aWNlc1BlclJvdyIsInJvd3MiLCJjb2xzIiwicSIsIk1lc2hTaGFkaW5nUGF0dGVybiIsIl9jb29yZHMiLCJfZmlndXJlcyIsIl9ib3VuZHMiLCJfYmFja2dyb3VuZCIsIl9jcmVhdGVNZXNoQ2FudmFzIiwiY29tYmluZWRTY2FsZSIsImJhY2tncm91bmRDb2xvciIsIkVYUEVDVEVEX1NDQUxFIiwiTUFYX1BBVFRFUk5fU0laRSIsIkJPUkRFUl9TSVpFIiwiYm91bmRzV2lkdGgiLCJib3VuZHNIZWlnaHQiLCJwYWRkZWRXaWR0aCIsInBhZGRlZEhlaWdodCIsImNyZWF0ZUltYWdlRGF0YSIsInB1dEltYWdlRGF0YSIsIkZsb2F0MzJBcnJheSIsIm1hdHJpeFNjYWxlWCIsIm1hdHJpeFNjYWxlWSIsInRlbXBvcmFyeVBhdHRlcm5DYW52YXMiLCJEdW1teVNoYWRpbmdQYXR0ZXJuIiwiZ2V0U2hhZGluZ1BhdHRlcm4iLCJQYWludFR5cGUiLCJDT0xPUkVEIiwiVU5DT0xPUkVEIiwiVGlsaW5nUGF0dGVybiIsImNhbnZhc0dyYXBoaWNzRmFjdG9yeSIsIm9wZXJhdG9yTGlzdCIsInhzdGVwIiwieXN0ZXAiLCJwYWludFR5cGUiLCJ0aWxpbmdUeXBlIiwiY3JlYXRlUGF0dGVybkNhbnZhcyIsImNvbWJpbmVkU2NhbGVYIiwiY29tYmluZWRTY2FsZVkiLCJyZWRyYXdIb3Jpem9udGFsbHkiLCJyZWRyYXdWZXJ0aWNhbGx5IiwieFNjYWxlZFN0ZXAiLCJ5U2NhbGVkU3RlcCIsInhTY2FsZWRXaWR0aCIsInlTY2FsZWRIZWlnaHQiLCJkaW14IiwiZ2V0U2l6ZUFuZFNjYWxlIiwiZGlteSIsImdyYXBoaWNzIiwiY3JlYXRlQ2FudmFzR3JhcGhpY3MiLCJncm91cExldmVsIiwic2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0IiwiY2xpcEJib3giLCJleGVjdXRlT3BlcmF0b3JMaXN0IiwiZW5kRHJhd2luZyIsImRpbXgyIiwiZGlteTIiLCJ4U2l6ZSIsInlTaXplIiwidG1wQ2FudmFzMiIsInRtcEN0eDIiLCJqaiIsInJlYWxPdXRwdXRTaXplIiwiYmJveFdpZHRoIiwiYmJveEhlaWdodCIsInN0cm9rZVN0eWxlIiwiZmlsbENvbG9yIiwic3Ryb2tlQ29sb3IiLCJjb252ZXJ0VG9SR0JBIiwia2luZCIsIkltYWdlS2luZCIsImNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBIiwiY29udmVydFJHQlRvUkdCQSIsInNyY1BvcyIsIm5vbkJsYWNrQ29sb3IiLCJpbnZlcnNlRGVjb2RlIiwiYmxhY2siLCJ6ZXJvTWFwcGluZyIsIm9uZU1hcHBpbmciLCJ3aWR0aEluU291cmNlIiwid2lkdGhSZW1haW5kZXIiLCJzcmNMZW5ndGgiLCJkZXN0UG9zIiwiZWxlbSIsImxlbiIsImxlbjMyIiwic3JjMzIiLCJGZWF0dXJlVGVzdCIsInMxIiwiczIiLCJzMyIsImdyYXlUb1JHQkEiLCJNSU5fRk9OVF9TSVpFIiwiTUFYX0ZPTlRfU0laRSIsIkVYRUNVVElPTl9USU1FIiwiRVhFQ1VUSU9OX1NURVBTIiwiRlVMTF9DSFVOS19IRUlHSFQiLCJTQ0FMRV9NQVRSSVgiLCJYWSIsIk1JTl9NQVhfSU5JVCIsIm1pcnJvckNvbnRleHRPcGVyYXRpb25zIiwiZGVzdEN0eCIsIl9yZW1vdmVNaXJyb3JpbmciLCJfX29yaWdpbmFsU2F2ZSIsIl9fb3JpZ2luYWxSZXN0b3JlIiwiX19vcmlnaW5hbFJvdGF0ZSIsIl9fb3JpZ2luYWxTY2FsZSIsIl9fb3JpZ2luYWxUcmFuc2xhdGUiLCJfX29yaWdpbmFsVHJhbnNmb3JtIiwiX19vcmlnaW5hbFNldFRyYW5zZm9ybSIsIl9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSIsInJlc2V0VHJhbnNmb3JtIiwiX19vcmlnaW5hbENsaXAiLCJfX29yaWdpbmFsTW92ZVRvIiwiX19vcmlnaW5hbExpbmVUbyIsIl9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvIiwiYmV6aWVyQ3VydmVUbyIsIl9fb3JpZ2luYWxSZWN0IiwiX19vcmlnaW5hbENsb3NlUGF0aCIsIl9fb3JpZ2luYWxCZWdpblBhdGgiLCJjcDF4IiwiY3AxeSIsImNwMngiLCJjcDJ5IiwiQ2FjaGVkQ2FudmFzZXMiLCJjYW52YXNGYWN0b3J5IiwiY2FudmFzRW50cnkiLCJkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMiLCJzcmNJbWciLCJzcmNYIiwic3JjWSIsInNyY1ciLCJzcmNIIiwiZGVzdFgiLCJkZXN0WSIsImRlc3RXIiwiZGVzdEgiLCJ0bFgiLCJyVGxYIiwidGxZIiwiclRsWSIsImJyWCIsInJXaWR0aCIsImJyWSIsInJIZWlnaHQiLCJzaWduIiwiQ2FudmFzRXh0cmFTdGF0ZSIsInByZUluaXQiLCJhbHBoYUlzU2hhcGUiLCJmb250U2l6ZSIsImZvbnRTaXplU2NhbGUiLCJ0ZXh0TWF0cml4IiwidGV4dE1hdHJpeFNjYWxlIiwibGVhZGluZyIsImxpbmVYIiwibGluZVkiLCJjaGFyU3BhY2luZyIsIndvcmRTcGFjaW5nIiwidGV4dEhTY2FsZSIsInRleHRSZW5kZXJpbmdNb2RlIiwidGV4dFJpc2UiLCJwYXR0ZXJuRmlsbCIsInBhdHRlcm5TdHJva2UiLCJmaWxsQWxwaGEiLCJzdHJva2VBbHBoYSIsImxpbmVXaWR0aCIsImFjdGl2ZVNNYXNrIiwidHJhbnNmZXJNYXBzIiwiZ2V0UGF0aEJvdW5kaW5nQm94IiwieFN0cm9rZVBhZCIsInlTdHJva2VQYWQiLCJ1cGRhdGVDbGlwRnJvbVBhdGgiLCJzdGFydE5ld1BhdGhBbmRDbGlwQm94IiwiaXNFbXB0eUNsaXAiLCJwdXRCaW5hcnlJbWFnZURhdGEiLCJpbWdEYXRhIiwiSW1hZ2VEYXRhIiwicGFydGlhbENodW5rSGVpZ2h0IiwiZnVsbENodW5rcyIsInRvdGFsQ2h1bmtzIiwiY2h1bmtJbWdEYXRhIiwidGhpc0NodW5rSGVpZ2h0IiwiZWxlbXNJblRoaXNDaHVuayIsImRlc3QzMiIsImRlc3QzMkRhdGFMZW5ndGgiLCJmdWxsU3JjRGlmZiIsIndoaXRlIiwic3JjRGlmZiIsImtFbmQiLCJrRW5kVW5yb2xsZWQiLCJtYXNrIiwic3JjQnl0ZSIsInB1dEJpbmFyeUltYWdlTWFzayIsImNvcHlDdHhTdGF0ZSIsInNvdXJjZUN0eCIsInByb3BlcnRpZXMiLCJwcm9wZXJ0eSIsInNldExpbmVEYXNoIiwiZ2V0TGluZURhc2giLCJsaW5lRGFzaE9mZnNldCIsInJlc2V0Q3R4VG9EZWZhdWx0IiwiZmlsbFJ1bGUiLCJnbG9iYWxBbHBoYSIsImxpbmVDYXAiLCJsaW5lSm9pbiIsIm1pdGVyTGltaXQiLCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24iLCJnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJpbnRlcnBvbGF0ZSIsImFjdHVhbFNjYWxlIiwiZnJvdW5kIiwiTElORV9DQVBfU1RZTEVTIiwiTElORV9KT0lOX1NUWUxFUyIsIk5PUk1BTF9DTElQIiwiRU9fQ0xJUCIsIkNhbnZhc0dyYXBoaWNzIiwiY2FudmFzQ3R4IiwiY29tbW9uT2JqcyIsIm9wdGlvbmFsQ29udGVudENvbmZpZyIsImFubm90YXRpb25DYW52YXNNYXAiLCJzdGF0ZVN0YWNrIiwicGVuZGluZ0NsaXAiLCJwZW5kaW5nRU9GaWxsIiwieG9ianMiLCJncm91cFN0YWNrIiwic21hc2tTdGFjayIsInNtYXNrQ291bnRlciIsInRlbXBTTWFzayIsInN1c3BlbmRlZEN0eCIsImNvbnRlbnRWaXNpYmxlIiwiY2FjaGVkUGF0dGVybnMiLCJ2aWV3cG9ydFNjYWxlIiwib3V0cHV0U2NhbGVYIiwib3V0cHV0U2NhbGVZIiwiX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmciLCJfY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCIsIl9jYWNoZWRCaXRtYXBzTWFwIiwiZ2V0T2JqZWN0IiwiZmFsbGJhY2siLCJiZWdpbkRyYXdpbmciLCJ0cmFuc3BhcmVuY3kiLCJzYXZlZEZpbGxTdHlsZSIsImZpbGxSZWN0IiwidHJhbnNwYXJlbnRDYW52YXMiLCJjb21wb3NpdGVDdHgiLCJleGVjdXRpb25TdGFydElkeCIsImNvbnRpbnVlQ2FsbGJhY2siLCJzdGVwcGVyIiwiZmlsdGVyZWRPcGVyYXRpb25JbmRleGVzIiwiYXJnc0FycmF5IiwiZm5BcnJheSIsImFyZ3NBcnJheUxlbiIsImNodW5rT3BlcmF0aW9ucyIsImVuZFRpbWUiLCJzdGVwcyIsImZuSWQiLCJmbkFyZ3MiLCJuZXh0QnJlYWtQb2ludCIsImJyZWFrSXQiLCJkZXBPYmpJZCIsIm9ianNQb29sIiwicmVzdG9yZUluaXRpYWxTdGF0ZSIsImluU01hc2tNb2RlIiwiSFRNTENhbnZhc0VsZW1lbnQiLCJkcmF3RmlsdGVyIiwiaGNtRmlsdGVySWQiLCJzYXZlZEZpbHRlciIsIl9zY2FsZUltYWdlIiwiaW1nIiwiZGlzcGxheVdpZHRoIiwiZGlzcGxheUhlaWdodCIsIndpZHRoU2NhbGUiLCJoZWlnaHRTY2FsZSIsInBhaW50V2lkdGgiLCJwYWludEhlaWdodCIsInRtcENhbnZhc0lkIiwiX2NyZWF0ZU1hc2tDYW52YXMiLCJpc1BhdHRlcm5GaWxsIiwiY3VycmVudFRyYW5zZm9ybSIsImNhY2hlS2V5IiwibWFza0NhbnZhcyIsIm1haW5LZXkiLCJjYWNoZWRJbWFnZSIsIm1hc2tUb0NhbnZhcyIsImRyYXduV2lkdGgiLCJkcmF3bkhlaWdodCIsImZpbGxDYW52YXMiLCJmaWxsQ3R4IiwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwibGltaXQiLCJkYXNoQXJyYXkiLCJkYXNoUGhhc2UiLCJpbnRlbnQiLCJmbGF0bmVzcyIsInN0YXRlcyIsImNoZWNrU01hc2tTdGF0ZSIsImJlZ2luU01hc2tNb2RlIiwiZW5kU01hc2tNb2RlIiwiY2FjaGVJZCIsInNjcmF0Y2hDYW52YXMiLCJjb21wb3NlIiwiZGlydHlCb3giLCJzbWFzayIsImNvbXBvc2VTTWFzayIsImxheWVyQ3R4IiwibGF5ZXJCb3giLCJsYXllck9mZnNldFgiLCJsYXllck9mZnNldFkiLCJsYXllcldpZHRoIiwibGF5ZXJIZWlnaHQiLCJnZW5lcmljQ29tcG9zZVNNYXNrIiwic3VidHlwZSIsImJhY2tkcm9wIiwidHJhbnNmZXJNYXAiLCJtYXNrQ3R4IiwibWFza09mZnNldFgiLCJtYXNrT2Zmc2V0WSIsIm1hc2tYIiwibWFza1kiLCJvbGQiLCJvcCIsIm91dGVyRXh0cmFTaXplIiwicGF0aDJkIiwiX3BhdGhTdGFydElkeCIsImNvbnN1bWVQYXRoIiwibmV3UGF0aCIsImFkZFBhdGgiLCJtdWx0aXBseVNlbGYiLCJyZXNjYWxlQW5kU3Ryb2tlIiwibmVlZFJlc3RvcmUiLCJwYXRocyIsInBlbmRpbmdUZXh0UGF0aHMiLCJwcmVNdWx0aXBseVNlbGYiLCJzcGFjaW5nIiwiZm9udFJlZk5hbWUiLCJmb250T2JqIiwiZm9udERpcmVjdGlvbiIsImlzVHlwZTNGb250IiwidHlwZWZhY2UiLCJmYWxsYmFja05hbWUiLCJib2xkIiwiaXRhbGljIiwiYnJvd3NlckZvbnRTaXplIiwicmlzZSIsImdldFNjYWxlZFBhdGgiLCJwYWludENoYXIiLCJwYXR0ZXJuRmlsbFRyYW5zZm9ybSIsInBhdHRlcm5TdHJva2VUcmFuc2Zvcm0iLCJmaWxsU3Ryb2tlTW9kZSIsImlzQWRkVG9QYXRoU2V0Iiwic2NhbGVkUGF0aCIsImludlBhdHRlcm5UcmFuc2Zvcm0iLCJtZWFzdXJlVGV4dCIsInN0cm9rZVRleHQiLCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCIsImdseXBocyIsInNob3dUeXBlM1RleHQiLCJnbHlwaHNMZW5ndGgiLCJ2ZXJ0aWNhbCIsInNwYWNpbmdEaXIiLCJkZWZhdWx0Vk1ldHJpY3MiLCJ3aWR0aEFkdmFuY2VTY2FsZSIsInNpbXBsZUZpbGxUZXh0IiwiZ2V0U2luZ2xlUGl4ZWxXaWR0aCIsImlzSW52YWxpZFBERmpzRm9udCIsImNoYXJzIiwiZ2x5cGgiLCJ1bmljb2RlIiwiam9pbmVkQ2hhcnMiLCJyZXN0b3JlTmVlZGVkIiwiaXNTcGFjZSIsImZvbnRDaGFyIiwiYWNjZW50Iiwic2NhbGVkWCIsInNjYWxlZFkiLCJ2bWV0cmljIiwidngiLCJ2eSIsInJlbWVhc3VyZSIsIm1lYXN1cmVkV2lkdGgiLCJjaGFyYWN0ZXJTY2FsZVgiLCJpc0luRm9udCIsInNjYWxlZEFjY2VudFgiLCJzY2FsZWRBY2NlbnRZIiwiY2hhcldpZHRoIiwiaXNUZXh0SW52aXNpYmxlIiwic3BhY2luZ0xlbmd0aCIsImNoYXJQcm9jT3BlcmF0b3JMaXN0Iiwib3BlcmF0b3JMaXN0SWQiLCJ4V2lkdGgiLCJ5V2lkdGgiLCJsbHgiLCJsbHkiLCJ1cngiLCJ1cnkiLCJnZXRDb2xvck5fUGF0dGVybiIsIl9nZXRQYXR0ZXJuIiwiaW52IiwiZ3JvdXAiLCJjdXJyZW50Q3R4IiwiaXNvbGF0ZWQiLCJrbm9ja291dCIsImJvdW5kcyIsImNhbnZhc0JvdW5kcyIsImdyb3VwQ3R4Iiwic3RhcnRUcmFuc2Zvcm1JbnZlcnNlIiwiY3VycmVudE10eCIsImhhc093bkNhbnZhcyIsImFubm90YXRpb25DYW52YXMiLCJzYXZlZEN0eCIsInNrZXdYIiwic2tld1kiLCJwb3NpdGlvbnMiLCJ0cmFucyIsImltYWdlcyIsImFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXMiLCJhcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwIiwiaW1nVG9QYWludCIsIkhUTUxFbGVtZW50IiwidGFnIiwiaXNWaXNpYmxlIiwiaXNDb250ZW50VmlzaWJsZSIsImFic0RldCIsIm5vcm1YIiwibm9ybVkiLCJnZXRTY2FsZUZvclN0cm9raW5nIiwic2NhbGVkTGluZVdpZHRoIiwic2NhbGVkWExpbmVXaWR0aCIsInNjYWxlZFlMaW5lV2lkdGgiLCJiYXNlQXJlYSIsInNhdmVSZXN0b3JlIiwiZGFzaGVzIiwiR2xvYmFsV29ya2VyT3B0aW9ucyIsInBvcnQiLCJ3b3JrZXJQb3J0IiwiV29ya2VyIiwid29ya2VyU3JjIiwiTWV0YWRhdGEiLCJwYXJzZWREYXRhIiwiZ2V0UmF3IiwiSU5URVJOQUwiLCJPcHRpb25hbENvbnRlbnRHcm91cCIsImlzRGlzcGxheSIsImlzUHJpbnQiLCJ1c2VyU2V0IiwicmVuZGVyaW5nSW50ZW50IiwidXNhZ2UiLCJyYkdyb3VwcyIsInZpZXciLCJ2aWV3U3RhdGUiLCJwcmludFN0YXRlIiwiX3NldFZpc2libGUiLCJpbnRlcm5hbCIsIk9wdGlvbmFsQ29udGVudENvbmZpZyIsImNhY2hlZEdldEhhc2giLCJncm91cHMiLCJpbml0aWFsSGFzaCIsIm9yZGVyIiwiY3JlYXRvciIsImJhc2VTdGF0ZSIsIm9mZiIsImdldEhhc2giLCJldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uIiwiYXJyYXkiLCJvcGVyYXRvciIsImV4cHJlc3Npb24iLCJwb2xpY3kiLCJzZXRWaXNpYmlsaXR5IiwicHJlc2VydmVSQiIsInJiR3JvdXAiLCJvdGhlcklkIiwic2V0T0NHU3RhdGUiLCJoYXNJbml0aWFsVmlzaWJpbGl0eSIsImdldE9yZGVyIiwiZ2V0R3JvdXAiLCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtIiwicGRmRGF0YVJhbmdlVHJhbnNwb3J0IiwiZGlzYWJsZVJhbmdlIiwiZGlzYWJsZVN0cmVhbSIsImluaXRpYWxEYXRhIiwicHJvZ3Jlc3NpdmVEb25lIiwiY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUiLCJfcXVldWVkQ2h1bmtzIiwiX3Byb2dyZXNzaXZlRG9uZSIsIl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSIsIl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQiLCJfaXNTdHJlYW1pbmdTdXBwb3J0ZWQiLCJfaXNSYW5nZVN1cHBvcnRlZCIsIl9jb250ZW50TGVuZ3RoIiwiX2Z1bGxSZXF1ZXN0UmVhZGVyIiwiX3JhbmdlUmVhZGVycyIsImFkZFJhbmdlTGlzdGVuZXIiLCJiZWdpbiIsIl9vblJlY2VpdmVEYXRhIiwiYWRkUHJvZ3Jlc3NMaXN0ZW5lciIsInRvdGFsIiwiX29uUHJvZ3Jlc3MiLCJhZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lciIsImFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyIiwiX29uUHJvZ3Jlc3NpdmVEb25lIiwidHJhbnNwb3J0UmVhZHkiLCJfZW5xdWV1ZSIsImZvdW5kIiwicmFuZ2VSZWFkZXIiLCJfYmVnaW4iLCJfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoIiwiX2xvYWRlZCIsIm9uUHJvZ3Jlc3MiLCJfcmVtb3ZlUmFuZ2VSZWFkZXIiLCJyZWFkZXIiLCJpbmRleE9mIiwiZ2V0RnVsbFJlYWRlciIsInF1ZXVlZENodW5rcyIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIiLCJnZXRSYW5nZVJlYWRlciIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlciIsInJlcXVlc3REYXRhUmFuZ2UiLCJjYW5jZWxBbGxSZXF1ZXN0cyIsIl9zdHJlYW0iLCJfZG9uZSIsIl9maWxlbmFtZSIsIl9yZXF1ZXN0cyIsIl9oZWFkZXJzUmVhZHkiLCJyZXF1ZXN0Q2FwYWJpbGl0eSIsImhlYWRlcnNSZWFkeSIsImlzUmFuZ2VTdXBwb3J0ZWQiLCJpc1N0cmVhbWluZ1N1cHBvcnRlZCIsImNvbnRlbnRMZW5ndGgiLCJyZWFkIiwiX2VuZCIsIl9xdWV1ZWRDaHVuayIsInJlcXVlc3RzQ2FwYWJpbGl0eSIsImdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlciIsImNvbnRlbnREaXNwb3NpdGlvbiIsIm5lZWRzRW5jb2RpbmdGaXh1cCIsInRvUGFyYW1SZWdFeHAiLCJyZmMyNjE2dW5xdW90ZSIsInJmYzU5ODdkZWNvZGUiLCJyZmMyMDQ3ZGVjb2RlIiwiZml4dXBFbmNvZGluZyIsInJmYzIyMzFnZXRwYXJhbSIsImF0dHJpYnV0ZVBhdHRlcm4iLCJmbGFncyIsInRleHRkZWNvZGUiLCJjb250ZW50RGlzcG9zaXRpb25TdHIiLCJpdGVyIiwicXVvdCIsInBhcnQiLCJwYXJ0cyIsInF1b3RpbmRleCIsImV4dHZhbHVlIiwiZW5jb2RpbmdlbmQiLCJsYW5ndmFsdWUiLCJjaGFyc2V0IiwiaGV4IiwiY3JlYXRlSGVhZGVycyIsImlzSHR0cCIsImh0dHBIZWFkZXJzIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJnZXRSZXNwb25zZU9yaWdpbiIsInZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzIiwicmVzcG9uc2VIZWFkZXJzIiwicmFuZ2VDaHVua1NpemUiLCJyZXR1cm5WYWx1ZXMiLCJhbGxvd1JhbmdlUmVxdWVzdHMiLCJzdWdnZXN0ZWRMZW5ndGgiLCJjb250ZW50RW5jb2RpbmciLCJleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyIiwiY3JlYXRlUmVzcG9uc2VFcnJvciIsInZhbGlkYXRlUmVzcG9uc2VTdGF0dXMiLCJjcmVhdGVGZXRjaE9wdGlvbnMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJtZXRob2QiLCJjcmVkZW50aWFscyIsInJlZGlyZWN0IiwiZ2V0QXJyYXlCdWZmZXIiLCJQREZGZXRjaFN0cmVhbSIsIl9yZXNwb25zZU9yaWdpbiIsIl9yYW5nZVJlcXVlc3RSZWFkZXJzIiwiUERGRmV0Y2hTdHJlYW1SZWFkZXIiLCJQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyIiwiX3JlYWRlciIsIl93aXRoQ3JlZGVudGlhbHMiLCJfaGVhZGVyc0NhcGFiaWxpdHkiLCJfZGlzYWJsZVJhbmdlIiwiX3JhbmdlQ2h1bmtTaXplIiwiX2Fib3J0Q29udHJvbGxlciIsImdldFJlYWRlciIsIl9yZWFkQ2FwYWJpbGl0eSIsInJlc3BvbnNlT3JpZ2luIiwiT0tfUkVTUE9OU0UiLCJQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UiLCJuZXR3b3JrX2dldEFycmF5QnVmZmVyIiwieGhyIiwiTmV0d29ya01hbmFnZXIiLCJjdXJyWGhySWQiLCJwZW5kaW5nUmVxdWVzdHMiLCJ4aHJJZCIsInBlbmRpbmdSZXF1ZXN0Iiwic2V0UmVxdWVzdEhlYWRlciIsImV4cGVjdGVkU3RhdHVzIiwib25FcnJvciIsIm9uU3RhdGVDaGFuZ2UiLCJvbnByb2dyZXNzIiwib25IZWFkZXJzUmVjZWl2ZWQiLCJvbkRvbmUiLCJ4aHJTdGF0dXMiLCJva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0IiwicmFuZ2VIZWFkZXIiLCJnZXRSZXNwb25zZUhlYWRlciIsImdldFJlcXVlc3RYaHIiLCJpc1BlbmRpbmdSZXF1ZXN0IiwiYWJvcnRSZXF1ZXN0IiwiUERGTmV0d29ya1N0cmVhbSIsIl9zb3VyY2UiLCJfbWFuYWdlciIsIl9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZCIsIlBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlciIsIlBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIiLCJvbkNsb3NlZCIsIm1hbmFnZXIiLCJfdXJsIiwiX2Z1bGxSZXF1ZXN0SWQiLCJfb25IZWFkZXJzUmVjZWl2ZWQiLCJfb25Eb25lIiwiX29uRXJyb3IiLCJfY2FjaGVkQ2h1bmtzIiwiX3N0b3JlZEVycm9yIiwiZnVsbFJlcXVlc3RYaHJJZCIsImZ1bGxSZXF1ZXN0WGhyIiwicmVzcG9uc2VVUkwiLCJyYXdSZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJ0cmltU3RhcnQiLCJsZW5ndGhDb21wdXRhYmxlIiwiX3JlcXVlc3RJZCIsIl9jbG9zZSIsInVybFJlZ2V4IiwicGFyc2VVcmxPclBhdGgiLCJzb3VyY2VVcmwiLCJwYXRoVG9GaWxlVVJMIiwiUERGTm9kZVN0cmVhbSIsIlBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIiLCJQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlciIsIl9yZWFkYWJsZVN0cmVhbSIsImxzdGF0Iiwic3RhdCIsIl9zZXRSZWFkYWJsZVN0cmVhbSIsImNyZWF0ZVJlYWRTdHJlYW0iLCJfZXJyb3IiLCJyZWFkYWJsZVN0cmVhbSIsIklOSVRJQUxfREFUQSIsIlBERk9iamVjdHMiLCJlbnN1cmVPYmoiLCJNQVhfVEVYVF9ESVZTX1RPX1JFTkRFUiIsIkRFRkFVTFRfRk9OVF9TSVpFIiwiVGV4dExheWVyIiwiZGlzYWJsZVByb2Nlc3NJdGVtcyIsImZvbnRJbnNwZWN0b3JFbmFibGVkIiwibGFuZyIsImxheW91dFRleHRQYXJhbXMiLCJyb290Q29udGFpbmVyIiwic3R5bGVDYWNoZSIsInRleHRDb250ZW50SXRlbXNTdHIiLCJ0ZXh0Q29udGVudFNvdXJjZSIsInRleHREaXZzIiwidGV4dERpdlByb3BlcnRpZXMiLCJhc2NlbnRDYWNoZSIsImNhbnZhc0NvbnRleHRzIiwiY2FudmFzQ3R4Rm9udHMiLCJXZWFrTWFwIiwibWluRm9udFNpemUiLCJwZW5kaW5nVGV4dExheWVycyIsIkZvbnRJbnNwZWN0b3IiLCJlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkIiwiZmluYWxseSIsImZvbnRGYW1pbHlNYXAiLCJwdW1wIiwic3R5bGVzIiwicHJvY2Vzc0l0ZW1zIiwib25CZWZvcmUiLCJnZXRDdHgiLCJsYXlvdXQiLCJhYm9ydEV4IiwiYXBwZW5kVGV4dCIsImdlb20iLCJ0ZXh0RGl2IiwiaGFzVGV4dCIsImhhc0VPTCIsImF0YW4yIiwiZm9udE5hbWUiLCJmb250U3Vic3RpdHV0aW9uIiwiZm9udEhlaWdodCIsImZvbnRBc2NlbnQiLCJnZXRBc2NlbnQiLCJzaW4iLCJjb3MiLCJzY2FsZUZhY3RvclN0ciIsImRpdlN0eWxlIiwiZGlyIiwiZGF0YXNldCIsImZvbnRTdWJzdGl0dXRpb25Mb2FkZWROYW1lIiwic2hvdWxkU2NhbGVUZXh0IiwiYWJzU2NhbGVYIiwiYWJzU2NhbGVZIiwiYnIiLCJlbnN1cmVDdHhGb250IiwiY2xlYW51cCIsImFscGhhIiwiY2FjaGVkIiwib3BhY2l0eSIsImxpbmVIZWlnaHQiLCJjYWNoZWRBc2NlbnQiLCJtZXRyaWNzIiwiYXNjZW50IiwiZm9udEJvdW5kaW5nQm94QXNjZW50IiwiZGVzY2VudCIsImZvbnRCb3VuZGluZ0JveERlc2NlbnQiLCJyYXRpbyIsIlhmYVRleHQiLCJ4ZmEiLCJ3YWxrIiwibm9kZSIsInNob3VsZEJ1aWxkVGV4dCIsIlJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVCIsImdldERvY3VtZW50IiwidGFzayIsIlBERkRvY3VtZW50TG9hZGluZ1Rhc2siLCJwYXNzd29yZCIsInJhbmdlVHJhbnNwb3J0IiwiUERGRGF0YVJhbmdlVHJhbnNwb3J0Iiwid29ya2VyIiwiUERGV29ya2VyIiwiZG9jQmFzZVVybCIsImNNYXBVcmwiLCJjTWFwUGFja2VkIiwiQ01hcFJlYWRlckZhY3RvcnkiLCJpY2NVcmwiLCJzdGFuZGFyZEZvbnREYXRhVXJsIiwiU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJ3YXNtVXJsIiwiV2FzbUZhY3RvcnkiLCJpZ25vcmVFcnJvcnMiLCJzdG9wQXRFcnJvcnMiLCJtYXhJbWFnZVNpemUiLCJjaHJvbWUiLCJjYW52YXNNYXhBcmVhSW5CeXRlcyIsImVuYWJsZVhmYSIsImRpc2FibGVBdXRvRmV0Y2giLCJwZGZCdWciLCJDYW52YXNGYWN0b3J5IiwiRmlsdGVyRmFjdG9yeSIsInVzZVdhc20iLCJ1c2VTeXN0ZW1Gb250cyIsInVzZVdvcmtlckZldGNoIiwidHJhbnNwb3J0RmFjdG9yeSIsImNNYXBSZWFkZXJGYWN0b3J5Iiwic3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJ3YXNtRmFjdG9yeSIsIl93b3JrZXIiLCJkb2NQYXJhbXMiLCJhcGlWZXJzaW9uIiwiZXZhbHVhdG9yT3B0aW9ucyIsInRyYW5zcG9ydFBhcmFtcyIsImxvYWRpbmdQYXJhbXMiLCJkZXN0cm95ZWQiLCJ3b3JrZXJJZFByb21pc2UiLCJtZXNzYWdlSGFuZGxlciIsIm5ldHdvcmtTdHJlYW0iLCJOZXR3b3JrU3RyZWFtIiwid29ya2VySWQiLCJ0cmFuc3BvcnQiLCJXb3JrZXJUcmFuc3BvcnQiLCJfdHJhbnNwb3J0IiwiX2NhcGFiaWxpdHkiLCJfcGVuZGluZ0Rlc3Ryb3kiLCJvblBhc3N3b3JkIiwicHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzIiwicHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzIiwicHJvZ3Jlc3NMaXN0ZW5lcnMiLCJyYW5nZUxpc3RlbmVycyIsIm9uRGF0YVJhbmdlIiwib25EYXRhUHJvZ3Jlc3MiLCJvbkRhdGFQcm9ncmVzc2l2ZVJlYWQiLCJvbkRhdGFQcm9ncmVzc2l2ZURvbmUiLCJQREZEb2N1bWVudFByb3h5IiwicGRmSW5mbyIsIl9wZGZJbmZvIiwibnVtUGFnZXMiLCJmaW5nZXJwcmludHMiLCJpc1B1cmVYZmEiLCJfaHRtbEZvclhmYSIsImFsbFhmYUh0bWwiLCJnZXRQYWdlIiwiZ2V0UGFnZUluZGV4IiwicmVmIiwiZ2V0RGVzdGluYXRpb25zIiwiZ2V0RGVzdGluYXRpb24iLCJnZXRQYWdlTGFiZWxzIiwiZ2V0UGFnZUxheW91dCIsImdldFBhZ2VNb2RlIiwiZ2V0Vmlld2VyUHJlZmVyZW5jZXMiLCJnZXRPcGVuQWN0aW9uIiwiZ2V0QXR0YWNobWVudHMiLCJwYWdlSW5kZXhlc1RvU2tpcCIsImdldEpTQWN0aW9ucyIsImdldERvY0pTQWN0aW9ucyIsImdldE91dGxpbmUiLCJnZXRPcHRpb25hbENvbnRlbnRDb25maWciLCJnZXRSZW5kZXJpbmdJbnRlbnQiLCJnZXRQZXJtaXNzaW9ucyIsImdldE1ldGFkYXRhIiwiZ2V0TWFya0luZm8iLCJzYXZlRG9jdW1lbnQiLCJnZXREb3dubG9hZEluZm8iLCJkb3dubG9hZEluZm9DYXBhYmlsaXR5Iiwia2VlcExvYWRlZEZvbnRzIiwic3RhcnRDbGVhbnVwIiwibG9hZGluZ1Rhc2siLCJjYWNoZWRQYWdlTnVtYmVyIiwiZ2V0RmllbGRPYmplY3RzIiwiaGFzSlNBY3Rpb25zIiwiZ2V0Q2FsY3VsYXRpb25PcmRlcklkcyIsIlBERlBhZ2VQcm94eSIsInBlbmRpbmdDbGVhbnVwIiwicGFnZUluZm8iLCJfcGFnZUluZGV4IiwiX3BhZ2VJbmZvIiwiX3N0YXRzIiwiX3BkZkJ1ZyIsIl9pbnRlbnRTdGF0ZXMiLCJyZWNvcmRlZEdyb3VwcyIsImdldFZpZXdwb3J0IiwiZ2V0QW5ub3RhdGlvbnMiLCJnZXRQYWdlSlNBY3Rpb25zIiwiZ2V0WGZhIiwiY2FudmFzQ29udGV4dCIsImFubm90YXRpb25Nb2RlIiwib3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSIsInByaW50QW5ub3RhdGlvblN0b3JhZ2UiLCJyZWNvcmRPcGVyYXRpb25zIiwiaW50ZW50QXJncyIsImludGVudFN0YXRlIiwic3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCIsImludGVudFByaW50IiwiZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSIsImxhc3RDaHVuayIsInNlcGFyYXRlQW5ub3RzIiwiX3B1bXBPcGVyYXRvckxpc3QiLCJzaG91bGRSZWNvcmRPcGVyYXRpb25zIiwiU3RlcHBlck1hbmFnZXIiLCJyZW5kZXJUYXNrcyIsImludGVybmFsUmVuZGVyVGFzayIsImdmeCIsInNldE9wZXJhdG9yR3JvdXBzIiwidHJ5Q2xlYW51cCIsIl9hYm9ydE9wZXJhdG9yTGlzdCIsIlN0YXRzIiwiSW50ZXJuYWxSZW5kZXJUYXNrIiwidXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVuZGVyVGFzayIsImluaXRpYWxpemVHcmFwaGljcyIsIm9wZXJhdG9yTGlzdENoYW5nZWQiLCJnZXRPcGVyYXRvckxpc3QiLCJvcExpc3RSZWFkQ2FwYWJpbGl0eSIsIm9wTGlzdFRhc2siLCJzdHJlYW1UZXh0Q29udGVudCIsImluY2x1ZGVNYXJrZWRDb250ZW50IiwiZGlzYWJsZU5vcm1hbGl6YXRpb24iLCJURVhUX0NPTlRFTlRfQ0hVTktfU0laRSIsImhpZ2hXYXRlck1hcmsiLCJnZXRUZXh0Q29udGVudCIsImdldFN0cnVjdFRyZWUiLCJfZGVzdHJveSIsIndhaXRPbiIsImZvcmNlIiwiY29tcGxldGVkIiwicmVzZXRTdGF0cyIsIl9zdGFydFJlbmRlclBhZ2UiLCJfcmVuZGVyUGFnZUNodW5rIiwib3BlcmF0b3JMaXN0Q2h1bmsiLCJhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSIsInN0cmVhbVJlYWRlciIsImRlbGF5IiwiY3VyQ2FjaGVLZXkiLCJjdXJJbnRlbnRTdGF0ZSIsIndlYldvcmtlciIsImZha2VXb3JrZXJJZCIsImlzV29ya2VyRGlzYWJsZWQiLCJ3b3JrZXJQb3J0cyIsIl9pc1NhbWVPcmlnaW4iLCJvdGhlclVybCIsImJhc2UiLCJvdGhlciIsIl9jcmVhdGVDRE5XcmFwcGVyIiwid3JhcHBlciIsImNyZWF0ZU9iamVjdFVSTCIsImZyb21Qb3J0IiwiaW5pdGlhbGl6ZUZyb21Qb3J0IiwibWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyIiwic2V0dXBGYWtlV29ya2VyIiwidGVybWluYXRlRWFybHkiLCJzZW5kVGVzdCIsInRlc3RPYmoiLCJfc2V0dXBGYWtlV29ya2VyR2xvYmFsIiwiV29ya2VyTWVzc2FnZUhhbmRsZXIiLCJ3b3JrZXJIYW5kbGVyIiwic2V0dXAiLCJjYWNoZWRQb3J0IiwicGRmanNXb3JrZXIiLCJsb2FkZXIiLCJtZXRob2RQcm9taXNlcyIsInBhZ2VDYWNoZSIsInBhZ2VQcm9taXNlcyIsInBhZ2VSZWZDYWNoZSIsInBhc3N3b3JkQ2FwYWJpbGl0eSIsImZhY3RvcnkiLCJmb250TG9hZGVyIiwiX3BhcmFtcyIsImRlc3Ryb3lDYXBhYmlsaXR5IiwiX25ldHdvcmtTdHJlYW0iLCJfZnVsbFJlYWRlciIsIl9sYXN0UHJvZ3Jlc3MiLCJzZXR1cE1lc3NhZ2VIYW5kbGVyIiwiY2FjaGVTaW1wbGVNZXRob2QiLCJjYWNoZWRQcm9taXNlIiwiaXNPcExpc3QiLCJtb2RpZmllZElkc0hhc2giLCJjYWNoZUtleUJ1ZiIsInRlcm1pbmF0ZWQiLCJzaW5rIiwicmVhZHlSZWFzb24iLCJfbnVtUGFnZXMiLCJodG1sRm9yWGZhIiwidXBkYXRlUGFzc3dvcmQiLCJlcnIiLCJleHBvcnRlZERhdGEiLCJleHBvcnRlZEVycm9yIiwiZm9udEFkZGVkIiwiaW1hZ2VSZWYiLCJwYWdlUHJveHkiLCJkYXRhTGVuIiwicmVmU3RyIiwicmVzdWx0cyIsIm1ldGFkYXRhIiwiY2xlYW51cFN1Y2Nlc3NmdWwiLCJSZW5kZXJUYXNrIiwib25Db250aW51ZSIsImZvcm0iLCJyQUYiLCJjYW52YXNJblVzZSIsIldlYWtTZXQiLCJvcGVyYXRvckxpc3RJZHgiLCJydW5uaW5nIiwiZ3JhcGhpY3NSZWFkeUNhbGxiYWNrIiwiZ3JhcGhpY3NSZWFkeSIsIl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxsZWQiLCJfY2FuY2VsQm91bmQiLCJfY29udGludWVCb3VuZCIsIl9jb250aW51ZSIsIl9zY2hlZHVsZU5leHRCb3VuZCIsIl9zY2hlZHVsZU5leHQiLCJfbmV4dEJvdW5kIiwiX25leHQiLCJfY2FudmFzIiwiX2NhbnZhc0NvbnRleHQiLCJfZW5hYmxlSFdBIiwiX2RlcGVuZGVuY3lUcmFja2VyIiwiX2ZpbHRlcmVkT3BlcmF0aW9uSW5kZXhlcyIsImluaXQiLCJnZXROZXh0QnJlYWtQb2ludCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwidXBkYXRlT3BlcmF0b3JMaXN0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidmVyc2lvbiIsImJ1aWxkIiwiQ29sb3JQaWNrZXIiLCJidXR0b25Td2F0Y2giLCJkZWZhdWx0Q29sb3IiLCJkcm9wZG93biIsImRyb3Bkb3duV2FzRnJvbUtleWJvYXJkIiwiaXNNYWluQ29sb3JQaWNrZXIiLCJvcGVuRHJvcGRvd25BQyIsImwxMG5Db2xvciIsIl9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmQiLCJfY29sb3JTZWxlY3RGcm9tS2V5Ym9hcmQiLCJfbW92ZVRvTmV4dCIsIl9tb3ZlVG9QcmV2aW91cyIsIl9tb3ZlVG9CZWdpbm5pbmciLCJfbW92ZVRvRW5kIiwiYmx1ZSIsImdyZWVuIiwicGluayIsInJlZCIsInllbGxvdyIsImFyaWFIYXNQb3B1cCIsImFyaWFDb250cm9scyIsIm9wZW5Ecm9wZG93biIsImtleURvd24iLCJzd2F0Y2giLCJhcmlhSGlkZGVuIiwicmVuZGVyTWFpbkRyb3Bkb3duIiwiZ2V0RHJvcGRvd25Sb290IiwiYXJpYU9yaWVudGF0aW9uIiwiYXJpYUxhYmVsbGVkQnkiLCJyb2xlIiwiYXJpYU11bHRpU2VsZWN0YWJsZSIsImFyaWFTZWxlY3RlZCIsImNvbG9yU2VsZWN0IiwidXBkYXRlQ29sb3IiLCJpc0Ryb3Bkb3duVmlzaWJsZSIsIm5leHRTaWJsaW5nIiwicHJldmlvdXNTaWJsaW5nIiwiZGV0YWlsIiwiYXJpYUV4cGFuZGVkIiwicm9vdCIsIkJhc2ljQ29sb3JQaWNrZXIiLCJjb2xvclR5cGUiLCJjb2xvclZhbHVlIiwibWFrZUNvbG9yQ29tcCIsInNjYWxlQW5kQ2xhbXAiLCJDb2xvckNvbnZlcnRlcnMiLCJDTVlLX0ciLCJHX0NNWUsiLCJHX1JHQiIsIkdfcmdiIiwiR19IVE1MIiwiRyIsIlJHQl9HIiwiUkdCX3JnYiIsIlJHQl9IVE1MIiwiVF9IVE1MIiwiVF9yZ2IiLCJDTVlLX1JHQiIsIkNNWUtfcmdiIiwiQ01ZS19IVE1MIiwiY29tcG9uZW50cyIsIlJHQl9DTVlLIiwiRGF0ZUZvcm1hdHMiLCJUaW1lRm9ybWF0cyIsIkJhc2VTVkdGYWN0b3J5Iiwic2tpcERpbWVuc2lvbnMiLCJfY3JlYXRlU1ZHIiwiRE9NU1ZHRmFjdG9yeSIsIlhmYUxheWVyIiwic2V0dXBTdG9yYWdlIiwiaHRtbCIsInN0b3JlZERhdGEiLCJ4ZmFPbiIsInhmYU9mZiIsImNoZWNrZWQiLCJvcHRpb24iLCJzZWxlY3RlZCIsInNlbGVjdGVkSW5kZXgiLCJzZXRBdHRyaWJ1dGVzIiwibGlua1NlcnZpY2UiLCJpc0hUTUxBbmNob3JFbGVtZW50IiwiSFRNTEFuY2hvckVsZW1lbnQiLCJhZGRMaW5rQXR0cmlidXRlcyIsIm5ld1dpbmRvdyIsImRhdGFJZCIsInhmYUh0bWwiLCJyb290SHRtbCIsImlzTm90Rm9yUmljaFRleHQiLCJyb290RGl2IiwiY3JlYXRlVGV4dE5vZGUiLCJzdGFjayIsImNoaWxkSHRtbCIsInhtbG5zIiwicXVlcnlTZWxlY3RvckFsbCIsImhpZGRlbiIsImFubm90YXRpb25fbGF5ZXJfREVGQVVMVF9GT05UX1NJWkUiLCJHZXRFbGVtZW50c0J5TmFtZVNldCIsIlRJTUVaT05FX09GRlNFVCIsImdldFRpbWV6b25lT2Zmc2V0IiwiQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5IiwiYW5ub3RhdGlvblR5cGUiLCJMaW5rQW5ub3RhdGlvbkVsZW1lbnQiLCJUZXh0QW5ub3RhdGlvbkVsZW1lbnQiLCJmaWVsZFR5cGUiLCJUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJyYWRpb0J1dHRvbiIsIlJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJjaGVja0JveCIsIkNoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIlNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50IiwiV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJQb3B1cEFubm90YXRpb25FbGVtZW50IiwiRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCIsIkxpbmVBbm5vdGF0aW9uRWxlbWVudCIsIlNxdWFyZUFubm90YXRpb25FbGVtZW50IiwiQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQiLCJQb2x5bGluZUFubm90YXRpb25FbGVtZW50IiwiQ2FyZXRBbm5vdGF0aW9uRWxlbWVudCIsIklua0Fubm90YXRpb25FbGVtZW50IiwiUG9seWdvbkFubm90YXRpb25FbGVtZW50IiwiSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQiLCJVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCIsIlNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQiLCJTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCIsIlN0YW1wQW5ub3RhdGlvbkVsZW1lbnQiLCJGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50IiwiQW5ub3RhdGlvbkVsZW1lbnQiLCJ1cGRhdGVzIiwiaGFzQm9yZGVyIiwicG9wdXBFbGVtZW50IiwiaXNSZW5kZXJhYmxlIiwiaWdub3JlQm9yZGVyIiwiY3JlYXRlUXVhZHJpbGF0ZXJhbHMiLCJkb3dubG9hZE1hbmFnZXIiLCJpbWFnZVJlc291cmNlc1BhdGgiLCJyZW5kZXJGb3JtcyIsInN2Z0ZhY3RvcnkiLCJlbmFibGVDb21tZW50IiwiZW5hYmxlU2NyaXB0aW5nIiwiX2ZpZWxkT2JqZWN0cyIsImZpZWxkT2JqZWN0cyIsIl9jcmVhdGVDb250YWluZXIiLCJfY3JlYXRlUXVhZHJpbGF0ZXJhbHMiLCJfaGFzUG9wdXBEYXRhIiwiY29udGVudHNPYmoiLCJyaWNoVGV4dCIsIl9pc0VkaXRhYmxlIiwiaXNFZGl0YWJsZSIsImhhc1BvcHVwRGF0YSIsImhhc0NvbW1lbnRCdXR0b24iLCJoYXNQb3B1cEVsZW1lbnQiLCJjb21tZW50QnV0dG9uUG9zaXRpb24iLCJxdWFkUG9pbnRzIiwiY29tbWVudEJ1dHRvbkNvbG9yIiwib3Bwb3NpdGVPcGFjaXR5IiwiY2hhbmdlTGlnaHRuZXNzIiwibCIsIm5ld0wiLCJfbm9ybWFsaXplUG9pbnQiLCJ1cGRhdGVFZGl0ZWQiLCJuZXdQb3B1cCIsInNldFJlY3RFZGl0ZWQiLCJfY3JlYXRlUG9wdXAiLCJyZXNldEVkaXRlZCIsImN1cnJlbnRSZWN0Iiwic2V0Um90YXRpb24iLCJhbHRlcm5hdGl2ZVRleHQiLCJub1JvdGF0ZSIsImJvcmRlclN0eWxlIiwiYm9yZGVyV2lkdGgiLCJob3Jpem9udGFsUmFkaXVzIiwiaG9yaXpvbnRhbENvcm5lclJhZGl1cyIsInZlcnRpY2FsUmFkaXVzIiwidmVydGljYWxDb3JuZXJSYWRpdXMiLCJyYWRpdXMiLCJib3JkZXJSYWRpdXMiLCJib3JkZXJCb3R0b21TdHlsZSIsImJvcmRlckNvbG9yIiwiX2NvbW1vbkFjdGlvbnMiLCJzZXRDb2xvciIsImpzTmFtZSIsInN0eWxlTmFtZSIsImNvbG9yQXJyYXkiLCJkaXNwbGF5Iiwibm9WaWV3Iiwibm9QcmludCIsInVzZXJOYW1lIiwicmVhZG9ubHkiLCJyZXF1aXJlZCIsIl9zZXRSZXF1aXJlZCIsInRleHRDb2xvciIsIl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3giLCJhY3Rpb25zIiwianNFdmVudCIsImNvbW1vbkFjdGlvbnMiLCJfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMiLCJldmVudFByb3h5IiwicmVjdEJsWCIsInJlY3RCbFkiLCJyZWN0VHJYIiwicmVjdFRyWSIsInN2Z0J1ZmZlciIsImNsaXBQYXRoIiwicmVjdFdpZHRoIiwicmVjdEhlaWdodCIsImJhY2tncm91bmRJbWFnZSIsInBvcHVwRGF0YSIsIm1vZGlmaWNhdGlvbkRhdGUiLCJ0aXRsZU9iaiIsInBhcmVudFJlY3QiLCJlbGVtZW50cyIsIl9nZXRFbGVtZW50c0J5TmFtZSIsInNraXBJZCIsImZpZWxkcyIsImZpZWxkT2JqIiwiZXhwb3J0VmFsdWVzIiwiZXhwb3J0VmFsdWUiLCJkb21FbGVtZW50IiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJtYXliZVNob3ciLCJmb3JjZUhpZGUiLCJnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwIiwiYWRkSGlnaGxpZ2h0QXJlYSIsInRyaWdnZXJzIiwiX2VkaXRPbkRvdWJsZUNsaWNrIiwiYW5ub3RhdGlvbkVkaXRvclR5cGUiLCJpc1Rvb2x0aXBPbmx5IiwibGluayIsImlzQm91bmQiLCJfYmluZE5hbWVkQWN0aW9uIiwib3ZlcmxhaWRUZXh0IiwiYXR0YWNobWVudCIsImJpbmRBdHRhY2htZW50IiwiYXR0YWNobWVudERlc3QiLCJiaW5kU2V0T0NHU3RhdGUiLCJfYmluZExpbmsiLCJBY3Rpb24iLCJfYmluZEpTQWN0aW9uIiwicmVzZXRGb3JtIiwiX2JpbmRSZXNldEZvcm1BY3Rpb24iLCJzZXRJbnRlcm5hbExpbmsiLCJkZXN0aW5hdGlvbiIsImdldERlc3RpbmF0aW9uSGFzaCIsIm9uY2xpY2siLCJnb1RvRGVzdGluYXRpb24iLCJnZXRBbmNob3JVcmwiLCJleGVjdXRlTmFtZWRBY3Rpb24iLCJvcGVuT3JEb3dubG9hZERhdGEiLCJleGVjdXRlU2V0T0NHU3RhdGUiLCJvdGhlckNsaWNrQWN0aW9uIiwicmVzZXRGb3JtRmllbGRzIiwicmVmcyIsInJlc2V0Rm9ybVJlZnMiLCJpbmNsdWRlIiwiYWxsRmllbGRzIiwiZmllbGRJZHMiLCJmaWVsZE5hbWUiLCJmaWVsZCIsImFsbElkcyIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsInNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyIsIl9nZXRLZXlNb2RpZmllciIsIl9zZXRFdmVudExpc3RlbmVyIiwiZWxlbWVudERhdGEiLCJiYXNlTmFtZSIsImV2ZW50TmFtZSIsInZhbHVlR2V0dGVyIiwibW9kaWZpZXIiLCJmb2N1c2VkIiwiX3NldEV2ZW50TGlzdGVuZXJzIiwiZ2V0dGVyIiwiQmx1ciIsIkZvY3VzIiwiX3NldEJhY2tncm91bmRDb2xvciIsIl9zZXRUZXh0U3R5bGUiLCJURVhUX0FMSUdOTUVOVCIsImZvbnRDb2xvciIsImRlZmF1bHRBcHBlYXJhbmNlRGF0YSIsImNvbXB1dGVkRm9udFNpemUiLCJyb3VuZFRvT25lRGVjaW1hbCIsIm11bHRpTGluZSIsIm51bWJlck9mTGluZXMiLCJ0ZXh0QWxpZ25tZW50IiwidGV4dEFsaWduIiwiaXNSZXF1aXJlZCIsImhhc0FwcGVhcmFuY2UiLCJmaWVsZFZhbHVlIiwic2V0UHJvcGVydHlPblNpYmxpbmdzIiwia2V5SW5TdG9yYWdlIiwibWF4TGVuIiwiY2hhckxpbWl0IiwiZmllbGRGb3JtYXR0ZWRWYWx1ZXMiLCJmb3JtYXR0ZWRWYWx1ZSIsImNvbWIiLCJ1c2VyVmFsdWUiLCJsYXN0Q29tbWl0dGVkVmFsdWUiLCJjb21taXRLZXkiLCJkb05vdFNjcm9sbCIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsInJlYWRPbmx5IiwiZGF0ZXRpbWVGb3JtYXQiLCJkYXRldGltZVR5cGUiLCJ0aW1lU3RlcCIsImhhc0RhdGVPclRpbWUiLCJtYXhMZW5ndGgiLCJkZWZhdWx0RmllbGRWYWx1ZSIsImJsdXJMaXN0ZW5lciIsInNjcm9sbExlZnQiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwidG9JU09TdHJpbmciLCJzZWxSYW5nZSIsInNldFNlbGVjdGlvblJhbmdlIiwid2lsbENvbW1pdCIsInNlbFN0YXJ0Iiwic2VsZWN0aW9uU3RhcnQiLCJzZWxFbmQiLCJzZWxlY3Rpb25FbmQiLCJfYmx1ckxpc3RlbmVyIiwidmFsdWVPZiIsIktleXN0cm9rZSIsImlucHV0VHlwZSIsImNoYW5nZSIsImZpZWxkV2lkdGgiLCJjb21iV2lkdGgiLCJsZXR0ZXJTcGFjaW5nIiwidmVydGljYWxBbGlnbiIsImNoZWNrYm94IiwiY3VyQ2hlY2tlZCIsImJ1dHRvblZhbHVlIiwicmFkaW8iLCJwZGZCdXR0b25WYWx1ZSIsImxpbmtFbGVtZW50Iiwic2VsZWN0RWxlbWVudCIsImFkZEFuRW1wdHlFbnRyeSIsImNvbWJvIiwibXVsdGlTZWxlY3QiLCJtdWx0aXBsZSIsIm9wdGlvbkVsZW1lbnQiLCJkaXNwbGF5VmFsdWUiLCJyZW1vdmVFbXB0eUVudHJ5Iiwibm9uZU9wdGlvbkVsZW1lbnQiLCJpc0V4cG9ydCIsInNlbGVjdGVkVmFsdWVzIiwiZ2V0SXRlbXMiLCJtdWx0aXBsZVNlbGVjdGlvbiIsImluZGV4IiwiZmluZEluZGV4Iiwic2VsZWN0Q2hpbGQiLCJpbmRpY2VzIiwiZWRpdGFibGUiLCJjaGFuZ2VFeCIsIlBvcHVwRWxlbWVudCIsImNyZWF0aW9uRGF0ZSIsImVsZW1lbnRJZHMiLCJib3VuZEtleURvd24iLCJib3VuZEhpZGUiLCJib3VuZFNob3ciLCJib3VuZFRvZ2dsZSIsImRhdGVPYmoiLCJwaW5uZWQiLCJwb3B1cEFib3J0Q29udHJvbGxlciIsIndhc1Zpc2libGUiLCJ0cmlnZ2VyIiwiZmxhdE1hcCIsImFkZEV2ZW50TGlzdGVuZXJzIiwicmVuZGVyQ29tbWVudEJ1dHRvbiIsInNldENvbW1lbnRCdXR0b25Qb3NpdGlvbiIsImZpbmQiLCJwYXJlbnRDb250YWluZXIiLCJhZnRlciIsImJhc2VDb2xvciIsIm91dGxpbmVDb2xvciIsImhlYWRlciIsImRhdGVUaW1lIiwiX2Zvcm1hdENvbnRlbnRzIiwibWFrZVBvcHVwQ29udGVudCIsInBvcHVwTGluZXMiLCJwb3B1cENvbnRlbnQiLCJsaW5lQXR0cmlidXRlcyIsImxpbmUiLCJsaW5lcyIsInNldFBvc2l0aW9uIiwidXNlUGFyZW50UmVjdCIsIm5vcm1hbGl6ZWRSZWN0IiwiSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OIiwicG9wdXBMZWZ0IiwicG9wdXBUb3AiLCJ0ZXh0UG9zaXRpb24iLCJsaW5lU3BhbiIsImxpbmVDb29yZGluYXRlcyIsInNxdWFyZSIsImNpcmNsZSIsInBvbHlsaW5lIiwiY29udGFpbmVyQ2xhc3NOYW1lIiwic3ZnRWxlbWVudE5hbWUiLCJ2ZXJ0aWNlcyIsInBvaW50cyIsInBvbHlsaW5lc0dyb3VwRWxlbWVudCIsInBvbHlsaW5lcyIsIml0IiwiaW5rTGlzdHMiLCJ0aGlja25lc3MiLCJpbmtMaXN0IiwibWFyayIsInVuZGVybGluZSIsInN0cmlrZW91dCIsImRvd25sb2FkIiwiQW5ub3RhdGlvbkxheWVyIiwiYWNjZXNzaWJpbGl0eU1hbmFnZXIiLCJlZGl0YWJsZUFubm90YXRpb25zIiwic3RydWN0VHJlZUxheWVyIiwiYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciIsIl9hbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIiwiaGFzRWRpdGFibGVBbm5vdGF0aW9ucyIsImFwcGVuZEVsZW1lbnQiLCJwb3B1cEVsZW1lbnRzIiwiY29udGVudEVsZW1lbnQiLCJhcmlhQXR0cmlidXRlcyIsImdldEFyaWFBdHRyaWJ1dGVzIiwibW92ZUVsZW1lbnRJbkRPTSIsImFubm90YXRpb25zIiwicG9wdXBUb0VsZW1lbnRzIiwiZWxlbWVudFBhcmFtcyIsIm5vSFRNTCIsImlzUG9wdXBBbm5vdGF0aW9uIiwicmVuZGVyZWQiLCJzZXRBbm5vdGF0aW9uQ2FudmFzTWFwIiwiYWRkTGlua0Fubm90YXRpb25zIiwiX2RlZmF1bHRCb3JkZXJTdHlsZSIsInJlcGxhY2VXaXRoIiwiZWRpdGFibGVBbm5vdGF0aW9uIiwiX2hhc05vQ2FudmFzIiwiZ2V0RWRpdGFibGVBbm5vdGF0aW9ucyIsImdldEVkaXRhYmxlQW5ub3RhdGlvbiIsInJhd1dpZHRoIiwiRU9MX1BBVFRFUk4iLCJGcmVlVGV4dEVkaXRvciIsImVkaXRvckRpdklkIiwiZWRpdE1vZGVBQyIsIl9mcmVlVGV4dERlZmF1bHRDb250ZW50IiwiX2ludGVybmFsUGFkZGluZyIsIl9kZWZhdWx0Q29sb3IiLCJfZGVmYXVsdEZvbnRTaXplIiwiX3RyYW5zbGF0ZUVtcHR5IiwiX2NvbG9yUGlja2VyIiwidXBkYXRlRm9udFNpemUiLCJzZXRGb250c2l6ZSIsImVkaXRvckRpdiIsInNldEVkaXRvckRpbWVuc2lvbnMiLCJzYXZlZEZvbnRzaXplIiwiY29sIiwic2F2ZWRDb2xvciIsIm92ZXJsYXlEaXYiLCJjb250ZW50RWRpdGFibGUiLCJlZGl0b3JEaXZLZXlkb3duIiwiZWRpdG9yRGl2Rm9jdXMiLCJlZGl0b3JEaXZCbHVyIiwiZWRpdG9yRGl2SW5wdXQiLCJlZGl0b3JEaXZQYXN0ZSIsImlubmVyVGV4dCIsImV4dHJhY3RUZXh0IiwicHJldkNoaWxkIiwiY2hpbGROb2RlcyIsImdldE5vZGVDb250ZW50Iiwic2F2ZWREaXNwbGF5Iiwic2F2ZWRWaXNpYmlsaXR5Iiwic2F2ZWRUZXh0IiwibmV3VGV4dCIsInRyaW1FbmQiLCJzZXRUZXh0Iiwic2V0Q29udGVudCIsInBvc1giLCJwb3NZIiwibm9kZVZhbHVlIiwiZGVzZXJpYWxpemVDb250ZW50IiwiZGVsZXRlRnJvbURvY3VtZW50IiwiaW5zZXJ0Tm9kZSIsImNvbGxhcHNlVG9TdGFydCIsInN0YXJ0Q29udGFpbmVyIiwic3RhcnRPZmZzZXQiLCJidWZmZXJCZWZvcmUiLCJidWZmZXJBZnRlciIsIm5ld1JhbmdlIiwiUmFuZ2UiLCJiZWZvcmVMZW5ndGgiLCJzZXRTdGFydCIsInNldEVuZCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwicmVwbGFjZUNoaWxkcmVuIiwic2VyaWFsaXplQ29udGVudCIsInBhZGRpbmciLCJzdHJ1Y3RUcmVlUGFyZW50SWQiLCJoYXNFbGVtZW50Q2hhbmdlZCIsIk91dGxpbmUiLCJQUkVDSVNJT04iLCJ0b1NWR1BhdGgiLCJfcm90YXRpb24iLCJfcmVzY2FsZSIsIl9yZXNjYWxlQW5kU3dhcCIsIl90cmFuc2xhdGUiLCJzdmdSb3VuZCIsIl9ub3JtYWxpemVQYWdlUG9pbnQiLCJjcmVhdGVCZXppZXJQb2ludHMiLCJGcmVlRHJhd091dGxpbmVyIiwiaW5uZXJNYXJnaW4iLCJsYXN0IiwibWluX2Rpc3QiLCJzY2FsZUZhY3RvciIsIk1JTl9ESVNUIiwiTUlOX0RJRkYiLCJNSU4iLCJnZXRMYXN0Q29vcmRzIiwibGFzdFRvcCIsImxhc3RCb3R0b20iLCJkaWZmWCIsImRpZmZZIiwiZGlmZkQiLCJuWCIsIm5ZIiwidGhYIiwidGhZIiwidG9TVkdQYXRoVHdvUG9pbnRzIiwidG9TVkdQYXRoRW5kIiwidG9TVkdQYXRoU3RhcnQiLCJsYXN0VG9wWCIsImxhc3RUb3BZIiwibGFzdEJvdHRvbVgiLCJsYXN0Qm90dG9tWSIsIm5ld0ZyZWVEcmF3T3V0bGluZSIsIm91dGxpbmUiLCJGcmVlRHJhd091dGxpbmUiLCJnZXRPdXRsaW5lcyIsImdldE91dGxpbmVUd29Qb2ludHMiLCJOIiwiZ2V0T3V0bGluZUVuZCIsImdldE91dGxpbmVTdGFydCIsImxhc3RQb2ludCIsImNvbXB1dGVNaW5NYXgiLCJsYXN0UG9pbnRYIiwibGFzdFBvaW50WSIsImx0ckNhbGxiYWNrIiwibmV3T3V0bGluZXIiLCJnZXROZXdPdXRsaW5lIiwib3V0bGluZXIiLCJIaWdobGlnaHRPdXRsaW5lciIsInZlcnRpY2FsRWRnZXMiLCJpbnRlcnZhbHMiLCJOVU1CRVJfT0ZfRElHSVRTIiwiRVBTSUxPTiIsInNoaWZ0ZWRNaW5YIiwic2hpZnRlZE1pblkiLCJsYXN0RWRnZSIsImVkZ2UiLCJvdXRsaW5lVmVydGljYWxFZGdlcyIsImJyZWFrRWRnZSIsImVkZ2VzIiwiYWxsRWRnZXMiLCJlZGdlMSIsImVkZ2UyIiwib3V0bGluZXMiLCJIaWdobGlnaHRPdXRsaW5lIiwiYmluYXJ5U2VhcmNoIiwibWlkZGxlIiwieTQiLCJwb2x5Z29uIiwicHJldlgiLCJwcmV2WSIsImNsYXNzTmFtZXNGb3JPdXRsaW5pbmciLCJGcmVlSGlnaGxpZ2h0T3V0bGluZXIiLCJGcmVlSGlnaGxpZ2h0T3V0bGluZSIsIkhpZ2hsaWdodEVkaXRvciIsImNsaXBQYXRoSWQiLCJmb2N1c091dGxpbmVzIiwiaGlnaGxpZ2h0RGl2IiwiaGlnaGxpZ2h0T3V0bGluZXMiLCJpc0ZyZWVIaWdobGlnaHQiLCJvdXRsaW5lSWQiLCJfZGVmYXVsdE9wYWNpdHkiLCJfZGVmYXVsdFRoaWNrbmVzcyIsIl9mcmVlSGlnaGxpZ2h0SWQiLCJfZnJlZUhpZ2hsaWdodCIsIl9mcmVlSGlnaGxpZ2h0Q2xpcElkIiwiX21vdmVDYXJldCIsImhpZ2hsaWdodElkIiwiY3JlYXRlRnJlZU91dGxpbmVzIiwiYWRkVG9EcmF3TGF5ZXIiLCJjcmVhdGVPdXRsaW5lcyIsIm51bWJlck9mQ29sb3JzIiwib3V0bGluZXJGb3JPdXRsaW5lIiwiZXh0cmFUaGlja25lc3MiLCJkcmF3TGF5ZXIiLCJmaW5hbGl6ZURyYXciLCJkcmF3T3V0bGluZSIsInJvb3RDbGFzcyIsImhpZ2hsaWdodE91dGxpbmUiLCJmcmVlIiwidXBkYXRlUHJvcGVydGllcyIsInJvdGF0ZUJib3giLCJ1cGRhdGVUaGlja25lc3MiLCJzZXRDb2xvckFuZE9wYWNpdHkiLCJvcGEiLCJzYXZlZE9wYWNpdHkiLCJzYXZlZFRoaWNrbmVzcyIsInNldFRoaWNrbmVzcyIsInRoIiwiY2hhbmdlVGhpY2tuZXNzIiwiZ2V0Um90YXRpb24iLCJhZGRVbmRvYWJsZUVkaXRvciIsImNsZWFuRHJhd0xheWVyIiwibXVzdEJlU2VsZWN0ZWQiLCJkcmF3IiwicG9pbnRlcm92ZXIiLCJob3ZlcmVkIiwicG9pbnRlcmxlYXZlIiwic2V0Q2FyZXQiLCJzZXJpYWxpemVCb3hlcyIsInNlcmlhbGl6ZU91dGxpbmVzIiwic3RhcnRIaWdobGlnaHRpbmciLCJlbmRIaWdobGlnaHQiLCJoaWdobGlnaHRNb3ZlIiwiRHJhd2luZ09wdGlvbnMiLCJzdmdQcm9wZXJ0aWVzIiwidXBkYXRlUHJvcGVydHkiLCJ1cGRhdGVTVkdQcm9wZXJ0eSIsInRvU1ZHUHJvcGVydGllcyIsInVwZGF0ZUFsbCIsIkRyYXdpbmdFZGl0b3IiLCJkcmF3T3V0bGluZXMiLCJtdXN0QmVDb21taXR0ZWQiLCJfY3VycmVudERyYXdJZCIsIl9jdXJyZW50UGFyZW50IiwiY3VycmVudERyYXciLCJjdXJyZW50RHJhd2luZ0FDIiwiY3VycmVudERyYXdpbmdPcHRpb25zIiwiY3VycmVudFBvaW50ZXJJZCIsImN1cnJlbnRQb2ludGVyVHlwZSIsImN1cnJlbnRQb2ludGVySWRzIiwiY3VycmVudE1vdmVUaW1lc3RhbXAiLCJfSU5ORVJfTUFSR0lOIiwiX2RyYXdJZCIsIl9hZGRPdXRsaW5lcyIsImNyZWF0ZURyYXdPdXRsaW5lcyIsImRyYXdJZCIsImRyYXdpbmdPcHRpb25zIiwiX2RyYXdpbmdPcHRpb25zIiwiZGVmYXVsdFByb3BlcnRpZXMiLCJjcmVhdGVEcmF3aW5nIiwidXBkYXRlQmJveCIsIl9tZXJnZVNWR1Byb3BlcnRpZXMiLCJkZWZhdWx0U1ZHUHJvcGVydGllcyIsInAxS2V5cyIsImdldERlZmF1bHREcmF3aW5nT3B0aW9ucyIsIl9vcHRpb25zIiwidHlwZXNNYXAiLCJzdXBwb3J0TXVsdGlwbGVEcmF3aW5ncyIsInByb3BlcnR5TmFtZSIsIl9kZWZhdWx0RHJhd2luZ09wdGlvbnMiLCJfdXBkYXRlUHJvcGVydHkiLCJzYXZlZFZhbHVlIiwic2V0dGVyIiwiZ2V0UGF0aFJlc2l6aW5nU1ZHUHJvcGVydGllcyIsImNvbnZlcnRUb0RyYXdTcGFjZSIsInJvdGF0ZUJveCIsImdldFBhdGhSZXNpemVkU1ZHUHJvcGVydGllcyIsIl94IiwiX3kiLCJnZXRQYXRoVHJhbnNsYXRlZFNWR1Byb3BlcnRpZXMiLCJtb3ZpbmciLCJ1cGRhdGVQYXJlbnQiLCJjb252ZXJ0VG9QYXJlbnRTcGFjZSIsInBXIiwicEgiLCJ1cGRhdGVSb3RhdGlvbiIsInVwZGF0ZVBhcmVudERpbWVuc2lvbnMiLCJvblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZyIsImRyYXdEaXYiLCJjcmVhdGVEcmF3ZXJJbnN0YW5jZSIsIl9wYXJlbnRXaWR0aCIsIl9wYXJlbnRIZWlnaHQiLCJzdGFydERyYXdpbmciLCJfaXNMVFIiLCJfZW5kRHJhdyIsImlzQ2FuY2VsbGFibGUiLCJyZW1vdmVMYXN0RWxlbWVudCIsIl9kcmF3TW92ZSIsInRpbWVTdGFtcCIsInN0YXJ0TmV3IiwiX2NsZWFudXAiLCJsYXN0RWxlbWVudCIsImdldExhc3RFbGVtZW50Iiwic2V0TGFzdEVsZW1lbnQiLCJpc0Fib3J0ZWQiLCJjcmVhdGVEcmF3aW5nT3B0aW9ucyIsIl9kYXRhIiwiZGVzZXJpYWxpemVEcmF3IiwiX3BhZ2VYIiwiX3BhZ2VZIiwiX3BhZ2VXaWR0aCIsIl9wYWdlSGVpZ2h0IiwiX2lubmVyV2lkdGgiLCJzZXJpYWxpemVEcmF3IiwiSW5rRHJhd091dGxpbmVyIiwibGFzdFNWR1BhdGgiLCJsYXN0SW5kZXgiLCJJbmtEcmF3T3V0bGluZSIsIm5vcm1hbGl6ZVBvaW50IiwiZmlyc3RYIiwiZmlyc3RZIiwic2Vjb25kWCIsInNlY29uZFkiLCJjMXgiLCJjMXkiLCJjMngiLCJjMnkiLCJjdXJyZW50Um90YXRpb24iLCJjb21wdXRlQmJveCIsInNlcmlhbGl6ZWRMaW5lcyIsInNlcmlhbGl6ZWRQb2ludHMiLCJnZXRCQm94V2l0aE5vTWFyZ2luIiwicmVzY2FsZUZuIiwibmV3TGluZXMiLCJnZXRNYXJnaW5Db21wb25lbnRzIiwibWFyZ2luIiwibWFyZ2luWCIsIm1hcmdpblkiLCJvbGRNYXJnaW5YIiwib2xkTWFyZ2luWSIsIm5ld01hcmdpblgiLCJuZXdNYXJnaW5ZIiwiZGlmZk1hcmdpblgiLCJkaWZmTWFyZ2luWSIsInJvdGF0aW9uVHJhbnNmb3JtIiwiczF4IiwiczF5IiwiczJ4IiwiczJ5IiwibmV3UGFyZW50V2lkdGgiLCJuZXdQYXJlbnRIZWlnaHQiLCJJbmtEcmF3aW5nT3B0aW9ucyIsInZpZXdlclBhcmFtZXRlcnMiLCJfdmlld1BhcmFtZXRlcnMiLCJJbmtFZGl0b3IiLCJDb250b3VyRHJhd091dGxpbmUiLCJCQVNFX0hFQURFUl9MRU5HVEgiLCJQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIiLCJTaWduYXR1cmVFeHRyYWN0b3IiLCJQQVJBTUVURVJTIiwic2lnbWFTRmFjdG9yIiwic2lnbWFSIiwia2VybmVsU2l6ZSIsIm5laWdoYm9ySW5kZXhUb0lkIiwiaTAiLCJqMCIsIm5laWdoYm9ySWRUb0luZGV4IiwiSW50MzJBcnJheSIsImNsb2Nrd2lzZU5vblplcm8iLCJrayIsInNoaWZ0SSIsInNoaWZ0SiIsImNvdW50ZXJDbG9ja3dpc2VOb25aZXJvIiwiZmluZENvbnRvdXJzIiwidGhyZXNob2xkIiwibmJkIiwibG5iZCIsImNvbnRvdXJzIiwiaWoiLCJwaXgiLCJpMiIsImoyIiwiaXNIb2xlIiwiY29udG91ciIsImNvbnRvdXIwIiwiaTEiLCJqMSIsImkzIiwiajMiLCJpNCIsImo0IiwiaWozIiwiZG91Z2xhc1BldWNrZXJIZWxwZXIiLCJheCIsImF5IiwiYWJ4IiwiYWJ5IiwiZGlzdCIsIm5hYngiLCJuYWJ5IiwiYWEiLCJpbnZTIiwicGhpIiwiYXRhbiIsImNvc1BoaSIsInNpblBoaSIsInRtYXgiLCJwb2x5IiwicGFydGlhbFBoaSIsImRtYXgiLCJkb3VnbGFzUGV1Y2tlciIsImJpbGF0ZXJhbEZpbHRlciIsInNpZ21hUyIsImtlcm5lbCIsInNpZ21hUzIiLCJoYWxmU2l6ZSIsImV4cCIsInJhbmdlVmFsdWVzIiwic2lnbWFSMiIsIm91dCIsImhpc3RvZ3JhbSIsInN1bSIsIm5vcm0iLCJuZWlnaGJvdXIiLCJnZXRIaXN0b2dyYW0iLCJ0b1VpbnQ4IiwiVWludDhDbGFtcGVkQXJyYXkiLCJndWVzc1RocmVzaG9sZCIsIk0iLCJMIiwic3BvcyIsImdldEdyYXlQaXhlbHMiLCJvcmlnaW5hbEJpdG1hcCIsInByZXZXaWR0aCIsInByZXZIZWlnaHQiLCJsb2cyIiwiaXN0ZXBzIiwiZ3JheUltYWdlIiwidWludDhCdWYiLCJleHRyYWN0Q29udG91cnNGcm9tVGV4dCIsImZvbnRTdHlsZSIsIlNDQUxFIiwiY29udG91ckxpc3QiLCJwcm9jZXNzRHJhd25MaW5lcyIsImN1cnZlcyIsIm11c3RTbW9vdGgiLCJhcmVDb250b3VycyIsImxpbmVzQW5kUG9pbnRzIiwieFNjYWxlIiwieVNjYWxlIiwibmV3Q3VydmVzIiwicmVkdWNlZFBvaW50cyIsIm5ld1BvaW50cyIsImNvbXByZXNzU2lnbmF0dXJlIiwibWluRGlmZiIsIm1heERpZmYiLCJvdXRsaW5lc0xlbmd0aCIsImR4IiwiYnVmZmVyVHlwZSIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJoZWFkZXJMZW5ndGgiLCJCWVRFU19QRVJfRUxFTUVOVCIsIkNvbXByZXNzaW9uU3RyZWFtIiwid3JpdGVyIiwiZ2V0V3JpdGVyIiwid3JpdGUiLCJCdWZmZXJDdG9yIiwiZGlmZnMiLCJSZXNwb25zZSIsInJlYWRhYmxlIiwiZGVjb21wcmVzc1NpZ25hdHVyZSIsInNpZ25hdHVyZURhdGEiLCJEZWNvbXByZXNzaW9uU3RyZWFtIiwibnVtYmVyT2ZEcmF3aW5ncyIsImRpZmZzT2Zmc2V0IiwiU2lnbmF0dXJlT3B0aW9ucyIsIkRyYXduU2lnbmF0dXJlT3B0aW9ucyIsIlNpZ25hdHVyZUVkaXRvciIsImlzRXh0cmFjdGVkIiwic2lnbmF0dXJlVVVJRCIsIl9kZWZhdWx0RHJhd25TaWduYXR1cmVPcHRpb25zIiwiaGFzRGVzY3JpcHRpb24iLCJoYXNEZXNjcmlwdGlvblN0YXRzIiwiaGFzTm9BbHRUZXh0IiwidXVpZCIsImhlaWdodEluUGFnZSIsImFkZFNpZ25hdHVyZSIsInNldFV1aWQiLCJnZXRTaWduYXR1cmVQcmV2aWV3Iiwib3V0bGluZURhdGEiLCJoYXNCZWVuU2F2ZWQiLCJnZXRGcm9tSW1hZ2UiLCJnZXRGcm9tVGV4dCIsImZvbnRJbmZvIiwiZ2V0RHJhd25TaWduYXR1cmUiLCJpc1NpZ25hdHVyZSIsImFsdCIsIlN0YW1wRWRpdG9yIiwiYml0bWFwSWQiLCJiaXRtYXBQcm9taXNlIiwiYml0bWFwVXJsIiwiYml0bWFwRmlsZSIsImJpdG1hcEZpbGVOYW1lIiwibWlzc2luZ0NhbnZhcyIsInJlc2l6ZVRpbWVvdXRJZCIsImhhc0JlZW5BZGRlZEluVW5kb1N0YWNrIiwicGFzdGVFZGl0b3IiLCJnZXRBc0ZpbGUiLCJoYXNBbHRUZXh0U3RhdHMiLCJnZXRCaXRtYXBGZXRjaGVkIiwiZnJvbUlkIiwiZ2V0Qml0bWFwRG9uZSIsImFsdF90ZXh0X21vZGFsIiwiYWx0X3RleHRfdHlwZSIsIm1sR3Vlc3NBbHRUZXh0IiwidXBkYXRlQWx0VGV4dERhdGEiLCJpc0VuYWJsZWRGb3IiLCJjb3B5Q2FudmFzIiwiZ3Vlc3MiLCJjaGFubmVscyIsImdldEJpdG1hcCIsImFjY2VwdCIsImZpbGVzIiwiY2xpY2siLCJkcmF3Qml0bWFwIiwiTUFYX1JBVElPIiwibWF4RGF0YURpbWVuc2lvbiIsIm1heFByZXZpZXdEaW1lbnNpb24iLCJiaXRtYXBXaWR0aCIsImJpdG1hcEhlaWdodCIsIm91dHB1dFNjYWxlIiwic2NhbGVkV2lkdGgiLCJzY2FsZWRIZWlnaHQiLCJzY2FsZUJpdG1hcCIsImJveERpbSIsImJveERpbVdpZHRoIiwiYm94RGltSGVpZ2h0IiwicGF0dGVybkN0eCIsImRhdGFXaWR0aCIsImRhdGFIZWlnaHQiLCJvZmZzY3JlZW5DdHgiLCJzZXJpYWxpemVCaXRtYXAiLCJ0b1VybCIsInRvRGF0YVVSTCIsInN0cnVjdFBhcmVudCIsIl9zdHJ1Y3RUcmVlIiwiY2hhbmdlcyIsImlzU2FtZSIsImlzU2FtZUFsdFRleHQiLCJzdGFtcHMiLCJhcmVhIiwicHJldkRhdGEiLCJpc1NhbWVQYWdlSW5kZXgiLCJBbm5vdGF0aW9uRWRpdG9yTGF5ZXIiLCJhbGxvd0NsaWNrIiwiYW5ub3RhdGlvbkxheWVyIiwiY2xpY2tBQyIsImVkaXRvckZvY3VzVGltZW91dElkIiwiaGFkUG9pbnRlckRvd24iLCJpc0Rpc2FibGluZyIsImlzRW5hYmxpbmciLCJkcmF3aW5nQUMiLCJmb2N1c2VkRWxlbWVudCIsInRleHRTZWxlY3Rpb25BQyIsInRleHRMYXllckRibENsaWNrQUMiLCJsYXN0UG9pbnRlckRvd25UaW1lc3RhbXAiLCJfaW5pdGlhbGl6ZWQiLCJpc0ludmlzaWJsZSIsImRpc2FibGVUZXh0U2VsZWN0aW9uIiwidG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyIsImVuYWJsZVRleHRTZWxlY3Rpb24iLCJhbm5vdGF0aW9uRWxlbWVudElkcyIsImVkaXRhYmxlcyIsIkRCTF9DTElDS19USFJFU0hPTEQiLCJlbGVtZW50c0Zyb21Qb2ludCIsImNoYW5nZWRBbm5vdGF0aW9ucyIsInJlc2V0QW5ub3RhdGlvbnMiLCJjdXJyZW50QWN0aXZlIiwidGV4dExheWVyUG9pbnRlckRvd24iLCJhdHRhY2giLCJkZXRhY2giLCJyZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIiLCJjdXJyZW50RWRpdG9yVHlwZSIsImNyZWF0ZU5ld0VkaXRvciIsImdldENlbnRlclBvaW50IiwiY3VycmVudE1vZGUiLCJzdGFydERyYXdpbmdTZXNzaW9uIiwicGF1c2UiLCJvbGRSb3RhdGlvbiIsIkRyYXdMYXllciIsIm1hcHBpbmciLCJ0b1VwZGF0ZSIsIl9zdmdGYWN0b3J5Iiwic2V0Qm94IiwiY3JlYXRlU1ZHIiwiY3JlYXRlQ2xpcFBhdGgiLCJwYXRoSWQiLCJjbGlwUGF0aFVzZSIsImlzUGF0aFVwZGF0YWJsZSIsImhhc0NsaXAiLCJ1c2UiLCJtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMiLCJtYXNrSWQiLCJ1c2UxIiwidXNlMiIsImNsb25lTm9kZSIsImVsZW1lbnRPcklkIiwicGF0aEVsZW1lbnQiLCJfcGRmanNUZXN0aW5nVXRpbHMiLCJwZGZqc0xpYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pdfjs-dist/build/pdf.mjs\n");

/***/ })

};
;